; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25547.0 

	TITLE	f:\users\krzysztof\documents\szko?a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_06JGCGFIEG@polish?$AA@			; `string'
PUBLIC	??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@		; `string'
PUBLIC	??_C@_05PDJBBECF@pause?$AA@			; `string'
PUBLIC	??_C@_0DM@FGCBIOFJ@Jak?$LJ?5opcje?5chcesz?5obstawic?5?$DP?5?$CIzg@ ; `string'
PUBLIC	??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@		; `string'
PUBLIC	??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@	; `string'
PUBLIC	??_C@_0BC@GOMOHEMO@r?5?9?5czerwone?$CIred?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BC@LKBFHLDI@b?5?9?5czarne?$CIblack?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@ ; `string'
PUBLIC	??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@	; `string'
PUBLIC	??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@ ; `string'
PUBLIC	??_C@_0CJ@KMEGGBFA@w1?0?5w2?0?5?4?4?4?0?5w12?5?9?5wiersz?5trzech@ ; `string'
PUBLIC	??_C@_0CP@FOKBNGLG@0?5?9?536?5?9?5pojedyncze?5pole?5o?5odpow@ ; `string'
PUBLIC	??_C@_01JBBJJEPG@p?$AA@				; `string'
PUBLIC	??_C@_01EFFIKLCJ@n?$AA@				; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_01OJONOECF@b?$AA@				; `string'
PUBLIC	??_C@_01JEJKBAGA@g?$AA@				; `string'
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	??_C@_02ICGBAFJO@k1?$AA@			; `string'
PUBLIC	??_C@_02KJEMFGFN@k2?$AA@			; `string'
PUBLIC	??_C@_02LAFHGHBM@k3?$AA@			; `string'
PUBLIC	??_C@_02JHFNFPIK@w1?$AA@			; `string'
PUBLIC	??_C@_02LMHAAMEJ@w2?$AA@			; `string'
PUBLIC	??_C@_02KFGLDNAI@w3?$AA@			; `string'
PUBLIC	??_C@_02OKCKKLMP@w4?$AA@			; `string'
PUBLIC	??_C@_02PDDBJKIO@w5?$AA@			; `string'
PUBLIC	??_C@_02NIBMMJEN@w6?$AA@			; `string'
PUBLIC	??_C@_02MBAHPIAM@w7?$AA@			; `string'
PUBLIC	??_C@_02EGJPOEMD@w8?$AA@			; `string'
PUBLIC	??_C@_02FPIENFIC@w9?$AA@			; `string'
PUBLIC	??_C@_03NCLMABJC@w10?$AA@			; `string'
PUBLIC	??_C@_03MLKHDAND@w11?$AA@			; `string'
PUBLIC	??_C@_03OAIKGDBA@w12?$AA@			; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_01FDFGLJHB@2?$AA@				; `string'
PUBLIC	??_C@_01EKENIIDA@3?$AA@				; `string'
PUBLIC	??_C@_01FAMBOPH@4?$AA@				; `string'
PUBLIC	??_C@_01BMBHCPLG@5?$AA@				; `string'
PUBLIC	??_C@_01DHDKHMHF@6?$AA@				; `string'
PUBLIC	??_C@_01COCBENDE@7?$AA@				; `string'
PUBLIC	??_C@_01KJLJFBPL@8?$AA@				; `string'
PUBLIC	??_C@_01LAKCGALK@9?$AA@				; `string'
PUBLIC	??_C@_02PKFBJPLJ@10?$AA@			; `string'
PUBLIC	??_C@_02ODEKKOPI@11?$AA@			; `string'
PUBLIC	??_C@_02MIGHPNDL@12?$AA@			; `string'
PUBLIC	??_C@_02NBHMMMHK@13?$AA@			; `string'
PUBLIC	??_C@_02JODNFKLN@14?$AA@			; `string'
PUBLIC	??_C@_02IHCGGLPM@15?$AA@			; `string'
PUBLIC	??_C@_02KMALDIDP@16?$AA@			; `string'
PUBLIC	??_C@_02LFBAAJHO@17?$AA@			; `string'
PUBLIC	??_C@_02DCIIBFLB@18?$AA@			; `string'
PUBLIC	??_C@_02CLJDCEPA@19?$AA@			; `string'
PUBLIC	??_C@_02PIBHCBOA@20?$AA@			; `string'
PUBLIC	??_C@_02OBAMBAKB@21?$AA@			; `string'
PUBLIC	??_C@_02MKCBEDGC@22?$AA@			; `string'
PUBLIC	??_C@_02NDDKHCCD@23?$AA@			; `string'
PUBLIC	??_C@_02JMHLOEOE@24?$AA@			; `string'
PUBLIC	??_C@_02IFGANFKF@25?$AA@			; `string'
PUBLIC	??_C@_02KOENIGGG@26?$AA@			; `string'
PUBLIC	??_C@_02LHFGLHCH@27?$AA@			; `string'
PUBLIC	??_C@_02DAMOKLOI@28?$AA@			; `string'
PUBLIC	??_C@_02CJNFJKKJ@29?$AA@			; `string'
PUBLIC	??_C@_02PJNFELNH@30?$AA@			; `string'
PUBLIC	??_C@_02OAMOHKJG@31?$AA@			; `string'
PUBLIC	??_C@_02MLODCJFF@32?$AA@			; `string'
PUBLIC	??_C@_02NCPIBIBE@33?$AA@			; `string'
PUBLIC	??_C@_02JNLJIOND@34?$AA@			; `string'
PUBLIC	??_C@_02IEKCLPJC@35?$AA@			; `string'
PUBLIC	??_C@_02KPIPOMFB@36?$AA@			; `string'
PUBLIC	??_C@_0CF@BGACGNBA@$?0?5jak?$LJ?5kwot?j?5chcesz?5obstawi?f?5wy@ ; `string'
PUBLIC	??_C@_05OMMBNPEF@Masz?5?$AA@			; `string'
PUBLIC	??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@ ; `string'
PUBLIC	??_C@_01PBGHHLMH@?$AH?$AA@			; `string'
PUBLIC	??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@ ; `string'
PUBLIC	??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@ ; `string'
PUBLIC	??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@ ; `string'
PUBLIC	??_C@_02MGHEPNFN@?$AI?$AI?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@	; `string'
PUBLIC	??_C@_02KHOJGJKF@?4?5?$AA@			; `string'
PUBLIC	??_C@_02DEPNMBPN@$?4?$AA@			; `string'
PUBLIC	??_C@_0CB@MBIMKPJH@Obstawiles?5poprawnie?0?5wygrywasz?5@ ; `string'
PUBLIC	??_C@_0EF@FAPGEAPP@Obstawiles?5niepoprawnie?5lecz?5uda@ ; `string'
PUBLIC	??_C@_0CF@EMPIFKEH@Obstawiles?5niepoprawnie?0?5przegra@ ; `string'
PUBLIC	??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@ ; `string'
PUBLIC	??_C@_0DB@MONJHHJM@$?0?5czy?5chcesz?5grac?5dalej?$CI?8t?8?5?9?5t@ ; `string'
PUBLIC	??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@	; `string'
PUBLIC	??_C@_01PFHFFBPC@t?$AA@				; `string'
PUBLIC	??_C@_03PFPKAEFD@tak?$AA@			; `string'
PUBLIC	??_C@_03FFMIKLGN@Tak?$AA@			; `string'
PUBLIC	??_C@_03PIABMJCP@TAK?$AA@			; `string'
PUBLIC	??_C@_03FKMOMPJO@nie?$AA@			; `string'
PUBLIC	??_C@_03PKPMGAKA@Nie?$AA@			; `string'
PUBLIC	??_C@_03FHDFACOC@NIE?$AA@			; `string'
PUBLIC	??_C@_04IBLEHOMF@?4wav?$AA@			; `string'
PUBLIC	??_C@_05PNHGCFLK@p?4wav?$AA@			; `string'
PUBLIC	??_C@_05MEKKEGFB@n?4wav?$AA@			; `string'
PUBLIC	??_C@_05LALOIELB@r?4wav?$AA@			; `string'
PUBLIC	??_C@_05LDGIIGCK@b?4wav?$AA@			; `string'
PUBLIC	??_C@_05ODKFBHJJ@g?4wav?$AA@			; `string'
PUBLIC	??_C@_05GFDBGFDH@d?4wav?$AA@			; `string'
PUBLIC	??_C@_01DICPFPGM@k?$AA@				; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@	; `string'
PUBLIC	??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@ ; `string'
PUBLIC	??_C@_09LFKNBKJA@Posiadasz?$AA@			; `string'
PUBLIC	??_C@_0L@DAFLKCID@Wylosowano?$AA@		; `string'
PUBLIC	??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@		; `string'
PUBLIC	??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@	; `string'
PUBLIC	??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@		; `string'
PUBLIC	??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@	; `string'
PUBLIC	??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@	; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@ ; `string'
PUBLIC	??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@	; `string'
PUBLIC	??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@ ; `string'
PUBLIC	??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ ; `string'
PUBLIC	??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@ ; `string'
PUBLIC	??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@ ; `string'
PUBLIC	??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@ ; `string'
PUBLIC	??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@ ; `string'
PUBLIC	??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@ ; `string'
PUBLIC	??_C@_05CMOJBPHN@G?$LDos?1?$AA@			; `string'
PUBLIC	??_C@_05KFCKMKOB@Jacek?$AA@			; `string'
PUBLIC	??_C@_03FPCJKMNP@Ewa?$AA@			; `string'
PUBLIC	??_C@_04CDICBAGM@Maja?$AA@			; `string'
PUBLIC	??_C@_03JIHJHPIE@Jan?$AA@			; `string'
PUBLIC	??_C@_06DKNIKMFF@Jacek2?$AA@			; `string'
PUBLIC	??_C@_04PLEDLCJI@Ewa2?$AA@			; `string'
PUBLIC	??_C@_05KJFHPLBC@Maja2?$AA@			; `string'
PUBLIC	??_C@_04HDNGKDH@Jan2?$AA@			; `string'
PUBLIC	??_C@_05NKPCGME@Agata?$AA@			; `string'
PUBLIC	??_C@_01IDAFKMJL@_?$AA@				; `string'
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_04JLFAMLOH@G?$LDos?$AA@			; `string'
PUBLIC	??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ ; `string'
PUBLIC	??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@ ; `string'
PUBLIC	??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@ ; `string'
PUBLIC	??_C@_0M@COFBHHKL@setting?4txt?$AA@		; `string'
PUBLIC	??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@ ; `string'
PUBLIC	??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ ; `string'
PUBLIC	??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@ ; `string'
PUBLIC	??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@ ; `string'
PUBLIC	??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@ ; `string'
PUBLIC	??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@ ; `string'
PUBLIC	??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@	; `string'
PUBLIC	??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@	; `string'
PUBLIC	??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@ ; `string'
PUBLIC	??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@ ; `string'
PUBLIC	??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@	; `string'
PUBLIC	??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@ ; `string'
PUBLIC	??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@ ; `string'
PUBLIC	??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@ ; `string'
PUBLIC	??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@ ; `string'
PUBLIC	??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@ ; `string'
PUBLIC	??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@ ; `string'
PUBLIC	??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@ ; `string'
PUBLIC	??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@ ; `string'
PUBLIC	??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@ ; `string'
PUBLIC	??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@ ; `string'
PUBLIC	??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@ ; `string'
PUBLIC	??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@ ; `string'
PUBLIC	??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@ ; `string'
PUBLIC	??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ ; `string'
PUBLIC	??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ ; `string'
PUBLIC	??_C@_01EPMOAMKG@$?$AA@				; `string'
PUBLIC	??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@		; `string'
PUBLIC	??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@		; `string'
PUBLIC	??_C@_07KIPBKJCE@win?4wav?$AA@			; `string'
PUBLIC	??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@ ; `string'
PUBLIC	??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@		; `string'
PUBLIC	??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@ ; `string'
PUBLIC	??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@ ; `string'
PUBLIC	??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@ ; `string'
PUBLIC	??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@ ; `string'
PUBLIC	??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@		; `string'
PUBLIC	??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@	; `string'
PUBLIC	??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@	; `string'
PUBLIC	??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@ ; `string'
PUBLIC	??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@		; `string'
PUBLIC	??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@ ; `string'
PUBLIC	??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ ; `string'
PUBLIC	??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@ ; `string'
PUBLIC	??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@ ; `string'
PUBLIC	??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@	; `string'
PUBLIC	??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@	; `string'
PUBLIC	??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@	; `string'
PUBLIC	??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@	; `string'
PUBLIC	??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@	; `string'
PUBLIC	??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@ ; `string'
PUBLIC	??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	?czy_kontynuowaæ_grê@@3FA			; czy_kontynuowaæ_grê
PUBLIC	??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA	; iloœæ_max_dodatkowych_obrotów_ruletki
PUBLIC	?iloœæ_minimalna_obrotów_ruletki@@3FA		; iloœæ_minimalna_obrotów_ruletki
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	?efekty_dŸwiêkowe@@3FA				; efekty_dŸwiêkowe
PUBLIC	?kwota_pocz¹tkowa@@3HA				; kwota_pocz¹tkowa
PUBLIC	?g³os_szybkoœæ_odczytu_numeru@@3FA		; g³os_szybkoœæ_odczytu_numeru
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?stan_dŸwiêków@@3FA				; stan_dŸwiêków
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	?czas_przeskoku_kulki_wolny@@3FA		; czas_przeskoku_kulki_wolny
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	?styl_liczenia_wygranej@@3FA			; styl_liczenia_wygranej
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?czas_przeskoku_kulki_szybki@@3FA		; czas_przeskoku_kulki_szybki
PUBLIC	?g³os_odczytu_numeru@@3FA			; g³os_odczytu_numeru
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	?EfektyKompletne@@3_NA				; EfektyKompletne
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Czas@@3U_SYSTEMTIME@@A				; Czas
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?G³osyKompletne@@3_NA				; G³osyKompletne
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	?czas_przerwy_dzwiêku@@3FA			; czas_przerwy_dzwiêku
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?is@?$ctype@D@std@@QBE_NFD@Z:PROC
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?eof@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	__imp_?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC
EXTRN	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync
EXTRN	__imp_?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
EXTRN	__imp_?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC
EXTRN	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow
EXTRN	__imp_?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC
EXTRN	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:PROC
EXTRN	__imp___get_stream_buffer_pointers:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp___fseeki64:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp__GetSystemTime@4:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__fsetpos:PROC
EXTRN	__imp____std_terminate:PROC
EXTRN	__imp__ungetc:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp__memchr:PROC
EXTRN	__imp__setvbuf:PROC
EXTRN	__imp__fgetpos:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp___lock_file:PROC
EXTRN	__imp___unlock_file:PROC
EXTRN	__imp__SetConsoleCursorInfo@8:PROC
EXTRN	__imp___access:PROC
EXTRN	__imp__system:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__PlaySoundA@12:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp__fgetc:PROC
EXTRN	_atexit:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp__URLDownloadToFileA@20:PROC
EXTRN	__imp__remove:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Random_device@std@@YAIXZ:PROC
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_BADOFF@std@@3_JB:QWORD
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp__fclose:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp__fflush:PROC
EXTRN	__imp__GetConsoleCursorInfo@8:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp__GetStdHandle@4:PROC
EXTRN	__imp__SetConsoleTextAttribute@8:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp__fputc:PROC
EXTRN	__imp__setlocale:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp____CxxFrameHandler3:PROC
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
?Czas@@3U_SYSTEMTIME@@A DB 010H DUP (?)			; Czas
_BSS	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	078H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	078H
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	070H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	070H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	058H
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	068H
?Ruletka_ko³o@@3QBHB DD 00H				; Ruletka_ko³o
	DD	020H
	DD	0fH
	DD	013H
	DD	04H
	DD	015H
	DD	02H
	DD	019H
	DD	011H
	DD	022H
	DD	06H
	DD	01bH
	DD	0dH
	DD	024H
	DD	0bH
	DD	01eH
	DD	08H
	DD	017H
	DD	0aH
	DD	05H
	DD	018H
	DD	010H
	DD	021H
	DD	01H
	DD	014H
	DD	0eH
	DD	01fH
	DD	09H
	DD	016H
	DD	012H
	DD	01dH
	DD	07H
	DD	01cH
	DD	0cH
	DD	023H
	DD	03H
	DD	01aH
	ORG $+4
?Ruletka_plansza_kolor_col@@3QBHB DD 02H		; Ruletka_plansza_kolor_col
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
?Ruletka_plansza_kolor@@3QBDB DB 067H			; Ruletka_plansza_kolor
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
?czy_kontynuowaæ_grê@@3FA DW 01H			; czy_kontynuowaæ_grê
?EfektyKompletne@@3_NA DB 01H				; EfektyKompletne
?G³osyKompletne@@3_NA DB 01H				; G³osyKompletne
?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA DW 03H	; iloœæ_max_dodatkowych_obrotów_ruletki
	ORG $+2
?iloœæ_minimalna_obrotów_ruletki@@3FA DW 02H		; iloœæ_minimalna_obrotów_ruletki
	ORG $+2
?efekty_dŸwiêkowe@@3FA DW 01H				; efekty_dŸwiêkowe
	ORG $+2
?kwota_pocz¹tkowa@@3HA DD 03e8H				; kwota_pocz¹tkowa
?g³os_szybkoœæ_odczytu_numeru@@3FA DW 04H		; g³os_szybkoœæ_odczytu_numeru
	ORG $+2
?stan_dŸwiêków@@3FA DW 01H				; stan_dŸwiêków
	ORG $+2
?czas_przeskoku_kulki_wolny@@3FA DW 04bH		; czas_przeskoku_kulki_wolny
	ORG $+2
?styl_liczenia_wygranej@@3FA DW 01H			; styl_liczenia_wygranej
	ORG $+2
?czas_przeskoku_kulki_szybki@@3FA DW 032H		; czas_przeskoku_kulki_szybki
	ORG $+2
?g³os_odczytu_numeru@@3FA DW 01H			; g³os_odczytu_numeru
	ORG $+2
?czas_przerwy_dzwiêku@@3FA DW 01f4H			; czas_przerwy_dzwiêku
_DATA	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$alloc'
	DB	'ator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@
CONST	SEGMENT
??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@ DB 'efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@
CONST	SEGMENT
??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@ DB 'g', 0b3H, 'o'
	DB	's_szybko', 09cH, 0e6H, '_odczytu_numeru', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@
CONST	SEGMENT
??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@ DB 'g', 0b3H, 'os_odczytu_n'
	DB	'umeru', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@
CONST	SEGMENT
??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@ DB 'czy_kontynuowa', 0e6H, '_'
	DB	'gr', 0eaH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@
CONST	SEGMENT
??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@ DB 'stan_d', 09fH, 'wi', 0eaH, 'k'
	DB	0f3H, 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@
CONST	SEGMENT
??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@ DB 'kwota_pocz', 0b9H, 'tkowa'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@
CONST	SEGMENT
??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@ DB 'styl_liczenia_wygranej'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@
CONST	SEGMENT
??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@ DB 'czas_przeskoku_kul'
	DB	'ki_wolny', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@
CONST	SEGMENT
??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@ DB 'czas_przeskoku_ku'
	DB	'lki_szybki', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
CONST	SEGMENT
??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ DB 'ilo', 09cH, 0e6H
	DB	'_max_dodatkowych_obrot', 0f3H, 'w_ruletki', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@
CONST	SEGMENT
??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@ DB 'ilo', 09cH
	DB	0e6H, '_minimalna_obrot', 0f3H, 'w_ruletki', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
CONST	SEGMENT
??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@ DB ' Wylosowano ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@
CONST	SEGMENT
??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@ DB 'Kulka w gr'
	DB	'ze, zaczekaj na wylosowanie numeru...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
CONST	SEGMENT
??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@ DB ' Obstawiono zaklad ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@
CONST	SEGMENT
??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@ DB 'Obstawiono zak', 0b3H
	DB	'ad ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
CONST	SEGMENT
??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@ DB 'Obstawiono za ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@
CONST	SEGMENT
??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@ DB 'Gratuluje zwi'
	DB	0eaH, 'kszy', 0b3H, 'e', 09cH, ' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@
CONST	SEGMENT
??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@ DB ' krotnie '
	DB	'sw', 0f3H, 'j zas', 0f3H, 'b finansowy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@
CONST	SEGMENT
??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@ DB 'Grat'
	DB	'uluje zwi', 0eaH, 'kszy', 0b3H, 'e', 09cH, ' sw', 0f3H, 'j za'
	DB	's', 0f3H, 'b finansowy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
CONST	SEGMENT
??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@ DB 'Ko', 0f1H, 'cz'
	DB	'ysz gr', 0eaH, ' z wynikiem ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
CONST	SEGMENT
??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@ DB ' Przegrales ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
CONST	SEGMENT
??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@ DB ' Dostajesz '
	DB	'polowe zak', 0b3H, 'adu ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KIPBKJCE@win?4wav?$AA@
CONST	SEGMENT
??_C@_07KIPBKJCE@win?4wav?$AA@ DB 'win.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
CONST	SEGMENT
??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@ DB ' Posiadasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
CONST	SEGMENT
??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@ DB ' Wygrywasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EPMOAMKG@$?$AA@
CONST	SEGMENT
??_C@_01EPMOAMKG@$?$AA@ DB '$', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
CONST	SEGMENT
??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ DB 'N'
	DB	'ie mo', 0bfH, 'esz mie', 0e6H, ' wy', 0b3H, 0b9H, 'czonych d', 09fH
	DB	'wi', 0eaH, 'k', 0f3H, 'w i w', 0b3H, 0b9H, 'czon', 0b9H, ' mo'
	DB	'w', 0eaH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
CONST	SEGMENT
??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ DB 'N'
	DB	'ie mo', 0bfH, 'esz mie', 0e6H, ' wy', 0b3H, 0b9H, 'czonych d', 09fH
	DB	'wi', 0eaH, 'k', 0f3H, 'w i w', 0b3H, 0b9H, 'czonych efekt', 0f3H
	DB	'w d', 09fH, 'wi', 0eaH, 'kowych', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@
CONST	SEGMENT
??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@ DB 'Opcja efe'
	DB	'kty d', 09fH, 'wi', 0eaH, 'kowe przyjmuje warto', 09cH, 'ci 0'
	DB	' lub 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@
CONST	SEGMENT
??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@ DB 'Opcja'
	DB	' szybko', 09cH, 0e6H, ' g', 0b3H, 'osu odczytu przyjmuje wart'
	DB	'o', 09cH, 'ci w przedziale [1;5]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@
CONST	SEGMENT
??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@ DB 'Opcja g', 0b3H
	DB	'os odczytu numeru przyjmuje warto', 09cH, 'ci w przedziale [0'
	DB	';10]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@
CONST	SEGMENT
??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@ DB 'Opcja kontynu'
	DB	'owania gry przyjmuje warto', 09cH, 'ci tylko 0 lub 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@
CONST	SEGMENT
??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@ DB 'Stan '
	DB	'd', 09fH, 'wi', 0eaH, 'k', 0f3H, 'w przyjmuje warto', 09cH, 'c'
	DB	'i tylko 0 lub 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@
CONST	SEGMENT
??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@ DB 'Kwot'
	DB	'a pocz', 0b9H, 'tkowa nie mo', 0bfH, 'e by', 0e6H, ' mniejsza'
	DB	' od zera', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@
CONST	SEGMENT
??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@ DB 'Czas'
	DB	' przerwy d', 09fH, 'wi', 0eaH, 'ku nie mo', 0bfH, 'e by', 0e6H
	DB	' mniejszy od zera', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@
CONST	SEGMENT
??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@ DB 'Styl liczeia '
	DB	'wygranej przyjmuje warto', 09cH, 'ci tylko 0 lub 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@
CONST	SEGMENT
??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@ DB 'Jedna z dek'
	DB	'laracji w sprawie obrot', 0f3H, 'w ruletki musi by', 0e6H, ' '
	DB	'wi', 0eaH, 'ksza od zera', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@
CONST	SEGMENT
??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@ DB 'Ilo', 09cH
	DB	0e6H, ' max obrot', 0f3H, 'w ruletki nie mo', 0bfH, 'e by', 0e6H
	DB	' mniejsza od 0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@
CONST	SEGMENT
??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@ DB 'Ilo', 09cH
	DB	0e6H, ' minimalna obrot', 0f3H, 'w ruletki nie mo', 0bfH, 'e b'
	DB	'y', 0e6H, ' mniejsza od 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
CONST	SEGMENT
??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@ DB 'Ustawiam do'
	DB	'my', 09cH, 'lne ustawienie', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@
CONST	SEGMENT
??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@ DB 'Warto', 09cH
	DB	0e6H, ' wolnego czasu przeskoku kulki musi by', 0e6H, ' ni', 0bfH
	DB	'sza ni', 0bfH, ' warto', 09cH, 0e6H, ' szybkiego czasu przesk'
	DB	'oku kulki', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@
CONST	SEGMENT
??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@ DB 'efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@
CONST	SEGMENT
??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@ DB 'g', 0b3H
	DB	'os_szybko', 09cH, 0e6H, '_odczytu_numeru 4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@
CONST	SEGMENT
??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@ DB 'g', 0b3H, 'os_odczyt'
	DB	'u_numeru 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@
CONST	SEGMENT
??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@ DB 'czy_kontynuowa', 0e6H
	DB	'_gr', 0eaH, ' 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@
CONST	SEGMENT
??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@ DB 'stan_d', 09fH, 'wi', 0eaH
	DB	'k', 0f3H, 'w 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@
CONST	SEGMENT
??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@ DB 'kwota_pocz', 0b9H, 't'
	DB	'kowa 1000', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@
CONST	SEGMENT
??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@ DB 'styl_liczenia_wygra'
	DB	'nej 1', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@
CONST	SEGMENT
??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@ DB 'czas_przerwy_dzwi', 0eaH
	DB	'ku 500', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@
CONST	SEGMENT
??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@ DB 'czas_przeskoku'
	DB	'_kulki_wolny 75', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@
CONST	SEGMENT
??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@ DB 'czas_przeskok'
	DB	'u_kulki_szybki 50', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
CONST	SEGMENT
??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ DB 'ilo', 09cH, 0e6H
	DB	'_max_dodatkowych_obrot', 0f3H, 'w_ruletki 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@
CONST	SEGMENT
??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@ DB 'ilo', 09cH
	DB	0e6H, '_minimalna_obrot', 0f3H, 'w_ruletki 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COFBHHKL@setting?4txt?$AA@
CONST	SEGMENT
??_C@_0M@COFBHHKL@setting?4txt?$AA@ DB 'setting.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@
CONST	SEGMENT
??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@ DB 'Pobr'
	DB	'ano brakuj', 0b9H, 'ce pliki g', 0b3H, 'os', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
CONST	SEGMENT
??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@ DB 'Brak p'
	DB	'lik', 0f3H, 'w dla g', 0b3H, 'osu oraz nie mo', 0bfH, 'na pob'
	DB	'ra', 0e6H, ' danych, wy', 0b3H, 0b9H, 'czono odczytywanie wyn'
	DB	'iku', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
CONST	SEGMENT
??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ DB 'Rozpoczynam'
	DB	' pobieranie brakuj', 0b9H, 'cych plik', 0f3H, 'w g', 0b3H, 'o'
	DB	's', 0f3H, 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLFAMLOH@G?$LDos?$AA@
CONST	SEGMENT
??_C@_04JLFAMLOH@G?$LDos?$AA@ DB 'G', 0b3H, 'os', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/G%C5%82os/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IDAFKMJL@_?$AA@
CONST	SEGMENT
??_C@_01IDAFKMJL@_?$AA@ DB '_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NKPCGME@Agata?$AA@
CONST	SEGMENT
??_C@_05NKPCGME@Agata?$AA@ DB 'Agata', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDNGKDH@Jan2?$AA@
CONST	SEGMENT
??_C@_04HDNGKDH@Jan2?$AA@ DB 'Jan2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KJFHPLBC@Maja2?$AA@
CONST	SEGMENT
??_C@_05KJFHPLBC@Maja2?$AA@ DB 'Maja2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PLEDLCJI@Ewa2?$AA@
CONST	SEGMENT
??_C@_04PLEDLCJI@Ewa2?$AA@ DB 'Ewa2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKNIKMFF@Jacek2?$AA@
CONST	SEGMENT
??_C@_06DKNIKMFF@Jacek2?$AA@ DB 'Jacek2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JIHJHPIE@Jan?$AA@
CONST	SEGMENT
??_C@_03JIHJHPIE@Jan?$AA@ DB 'Jan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CDICBAGM@Maja?$AA@
CONST	SEGMENT
??_C@_04CDICBAGM@Maja?$AA@ DB 'Maja', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FPCJKMNP@Ewa?$AA@
CONST	SEGMENT
??_C@_03FPCJKMNP@Ewa?$AA@ DB 'Ewa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFCKMKOB@Jacek?$AA@
CONST	SEGMENT
??_C@_05KFCKMKOB@Jacek?$AA@ DB 'Jacek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
CONST	SEGMENT
??_C@_05CMOJBPHN@G?$LDos?1?$AA@ DB 'G', 0b3H, 'os/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@
CONST	SEGMENT
??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@ DB 'Pobran'
	DB	'o brakuj', 0b9H, 'ce pliki efekt', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/zwielokrotnenie.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
CONST	SEGMENT
??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/zwielokrotnenie.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/wygrana2.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
CONST	SEGMENT
??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/wygrana2.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/wygrana1.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
CONST	SEGMENT
??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/wygrana1.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
CONST	SEGMENT
??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@ DB 'Brak p'
	DB	'lik', 0f3H, 'w dla efekt', 0f3H, 'w d', 09fH, 'wi', 0eaH, 'ko'
	DB	'wych oraz nie mo', 0bfH, 'na pobra', 0e6H, ' danych, wy', 0b3H
	DB	0b9H, 'czono efekty d', 09fH, 'wi', 0eaH, 'kowe muzyczne, w', 0b3H
	DB	0b9H, 'czono efekty systemowe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/bankrut.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
CONST	SEGMENT
??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ DB 'Rozpoczynam'
	DB	' pobieranie brakuj', 0b9H, 'cych plik', 0f3H, 'w efekt', 0f3H
	DB	'w', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
CONST	SEGMENT
??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/bankrut.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
CONST	SEGMENT
??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@ DB 'Efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@
CONST	SEGMENT
??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@ DB 'Nowa gra rozpoc'
	DB	'zeta dnia ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@
CONST	SEGMENT
??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@ DB 'Gra rozpoczeta dnia ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
CONST	SEGMENT
??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@ DB ' o godzinie ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@
CONST	SEGMENT
??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@ DB 'Gra rozpoczeta dnia', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@
CONST	SEGMENT
??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@ DB 'Obstawiono za', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
CONST	SEGMENT
??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@ DB 'Obstawiono zaklad', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
CONST	SEGMENT
??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@ DB ' Wylosowano', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DAFLKCID@Wylosowano?$AA@
CONST	SEGMENT
??_C@_0L@DAFLKCID@Wylosowano?$AA@ DB 'Wylosowano', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LFKNBKJA@Posiadasz?$AA@
CONST	SEGMENT
??_C@_09LFKNBKJA@Posiadasz?$AA@ DB 'Posiadasz', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@
CONST	SEGMENT
??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@ DB 'Uruch'
	DB	'omiono ponownie gr', 0eaH, ' z wy', 0b3H, 0b9H, 'czon', 0b9H, ' '
	DB	'opcj', 0b9H, ' kontynuowania', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
CONST	SEGMENT
??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@ DB 'log_aktualny.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DICPFPGM@k?$AA@
CONST	SEGMENT
??_C@_01DICPFPGM@k?$AA@ DB 'k', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFDBGFDH@d?4wav?$AA@
CONST	SEGMENT
??_C@_05GFDBGFDH@d?4wav?$AA@ DB 'd.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ODKFBHJJ@g?4wav?$AA@
CONST	SEGMENT
??_C@_05ODKFBHJJ@g?4wav?$AA@ DB 'g.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LDGIIGCK@b?4wav?$AA@
CONST	SEGMENT
??_C@_05LDGIIGCK@b?4wav?$AA@ DB 'b.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LALOIELB@r?4wav?$AA@
CONST	SEGMENT
??_C@_05LALOIELB@r?4wav?$AA@ DB 'r.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEKKEGFB@n?4wav?$AA@
CONST	SEGMENT
??_C@_05MEKKEGFB@n?4wav?$AA@ DB 'n.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PNHGCFLK@p?4wav?$AA@
CONST	SEGMENT
??_C@_05PNHGCFLK@p?4wav?$AA@ DB 'p.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBLEHOMF@?4wav?$AA@
CONST	SEGMENT
??_C@_04IBLEHOMF@?4wav?$AA@ DB '.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FHDFACOC@NIE?$AA@
CONST	SEGMENT
??_C@_03FHDFACOC@NIE?$AA@ DB 'NIE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PKPMGAKA@Nie?$AA@
CONST	SEGMENT
??_C@_03PKPMGAKA@Nie?$AA@ DB 'Nie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKMOMPJO@nie?$AA@
CONST	SEGMENT
??_C@_03FKMOMPJO@nie?$AA@ DB 'nie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PIABMJCP@TAK?$AA@
CONST	SEGMENT
??_C@_03PIABMJCP@TAK?$AA@ DB 'TAK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFMIKLGN@Tak?$AA@
CONST	SEGMENT
??_C@_03FFMIKLGN@Tak?$AA@ DB 'Tak', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFPKAEFD@tak?$AA@
CONST	SEGMENT
??_C@_03PFPKAEFD@tak?$AA@ DB 'tak', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PFHFFBPC@t?$AA@
CONST	SEGMENT
??_C@_01PFHFFBPC@t?$AA@ DB 't', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@
CONST	SEGMENT
??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@ DB 'Na koncie masz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MONJHHJM@$?0?5czy?5chcesz?5grac?5dalej?$CI?8t?8?5?9?5t@
CONST	SEGMENT
??_C@_0DB@MONJHHJM@$?0?5czy?5chcesz?5grac?5dalej?$CI?8t?8?5?9?5t@ DB '$, '
	DB	'czy chcesz grac dalej(''t'' - tak, ''n'' - nie) ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@
CONST	SEGMENT
??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@ DB 'Nie m'
	DB	'o', 0bfH, 'esz kontynuowa', 0e6H, ', przegra', 0b3H, 'e', 09cH
	DB	' wszystko', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EMPIFKEH@Obstawiles?5niepoprawnie?0?5przegra@
CONST	SEGMENT
??_C@_0CF@EMPIFKEH@Obstawiles?5niepoprawnie?0?5przegra@ DB 'Obstawiles ni'
	DB	'epoprawnie, przegra', 0b3H, 'e', 09cH, ' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@FAPGEAPP@Obstawiles?5niepoprawnie?5lecz?5uda@
CONST	SEGMENT
??_C@_0EF@FAPGEAPP@Obstawiles?5niepoprawnie?5lecz?5uda@ DB 'Obstawiles ni'
	DB	'epoprawnie lecz uda', 0b3H, 'o Ci si', 0eaH, ', dostajesz po', 0b3H
	DB	'ow', 0eaH, ' zak', 0b3H, 'adu ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MBIMKPJH@Obstawiles?5poprawnie?0?5wygrywasz?5@
CONST	SEGMENT
??_C@_0CB@MBIMKPJH@Obstawiles?5poprawnie?0?5wygrywasz?5@ DB 'Obstawiles p'
	DB	'oprawnie, wygrywasz ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DEPNMBPN@$?4?$AA@
CONST	SEGMENT
??_C@_02DEPNMBPN@$?4?$AA@ DB '$.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KHOJGJKF@?4?5?$AA@
CONST	SEGMENT
??_C@_02KHOJGJKF@?4?5?$AA@ DB '. ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
CONST	SEGMENT
??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@ DB 'Wylosowano numer ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
CONST	SEGMENT
??_C@_02MGHEPNFN@?$AI?$AI?$AA@ DB 08H, 08H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@
CONST	SEGMENT
??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@ DB 'Ni'
	DB	'e mo', 0bfH, 'esz obstawi', 0e6H, ' ujemn', 0b9H, ' kwot', 0b9H
	DB	' zak', 0b3H, 'adu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@
CONST	SEGMENT
??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@ DB 'Nie masz tyle pie'
	DB	'ni', 0eaH, 'dzy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@
CONST	SEGMENT
??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@ DB 'Nie mo', 0bfH
	DB	'esz obstawi', 0e6H, ' zerowego zak', 0b3H, 'adu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01PBGHHLMH@?$AH?$AA@
CONST	SEGMENT
??_C@_01PBGHHLMH@?$AH?$AA@ DB 07H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@
CONST	SEGMENT
??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@ DB 'Wpro'
	DB	'wadzi', 0b3H, 'e', 0e6H, ' nieprawid', 0b3H, 'ow', 0b9H, ' wa'
	DB	'rto', 09cH, 0e6H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OMMBNPEF@Masz?5?$AA@
CONST	SEGMENT
??_C@_05OMMBNPEF@Masz?5?$AA@ DB 'Masz ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BGACGNBA@$?0?5jak?$LJ?5kwot?j?5chcesz?5obstawi?f?5wy@
CONST	SEGMENT
??_C@_0CF@BGACGNBA@$?0?5jak?$LJ?5kwot?j?5chcesz?5obstawi?f?5wy@ DB '$, ja'
	DB	'k', 0b9H, ' kwot', 0eaH, ' chcesz obstawi', 0e6H, ' wynik?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPIPOMFB@36?$AA@
CONST	SEGMENT
??_C@_02KPIPOMFB@36?$AA@ DB '36', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IEKCLPJC@35?$AA@
CONST	SEGMENT
??_C@_02IEKCLPJC@35?$AA@ DB '35', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JNLJIOND@34?$AA@
CONST	SEGMENT
??_C@_02JNLJIOND@34?$AA@ DB '34', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NCPIBIBE@33?$AA@
CONST	SEGMENT
??_C@_02NCPIBIBE@33?$AA@ DB '33', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MLODCJFF@32?$AA@
CONST	SEGMENT
??_C@_02MLODCJFF@32?$AA@ DB '32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OAMOHKJG@31?$AA@
CONST	SEGMENT
??_C@_02OAMOHKJG@31?$AA@ DB '31', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PJNFELNH@30?$AA@
CONST	SEGMENT
??_C@_02PJNFELNH@30?$AA@ DB '30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CJNFJKKJ@29?$AA@
CONST	SEGMENT
??_C@_02CJNFJKKJ@29?$AA@ DB '29', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DAMOKLOI@28?$AA@
CONST	SEGMENT
??_C@_02DAMOKLOI@28?$AA@ DB '28', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LHFGLHCH@27?$AA@
CONST	SEGMENT
??_C@_02LHFGLHCH@27?$AA@ DB '27', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KOENIGGG@26?$AA@
CONST	SEGMENT
??_C@_02KOENIGGG@26?$AA@ DB '26', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IFGANFKF@25?$AA@
CONST	SEGMENT
??_C@_02IFGANFKF@25?$AA@ DB '25', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMHLOEOE@24?$AA@
CONST	SEGMENT
??_C@_02JMHLOEOE@24?$AA@ DB '24', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NDDKHCCD@23?$AA@
CONST	SEGMENT
??_C@_02NDDKHCCD@23?$AA@ DB '23', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MKCBEDGC@22?$AA@
CONST	SEGMENT
??_C@_02MKCBEDGC@22?$AA@ DB '22', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OBAMBAKB@21?$AA@
CONST	SEGMENT
??_C@_02OBAMBAKB@21?$AA@ DB '21', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PIBHCBOA@20?$AA@
CONST	SEGMENT
??_C@_02PIBHCBOA@20?$AA@ DB '20', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLJDCEPA@19?$AA@
CONST	SEGMENT
??_C@_02CLJDCEPA@19?$AA@ DB '19', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCIIBFLB@18?$AA@
CONST	SEGMENT
??_C@_02DCIIBFLB@18?$AA@ DB '18', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFBAAJHO@17?$AA@
CONST	SEGMENT
??_C@_02LFBAAJHO@17?$AA@ DB '17', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KMALDIDP@16?$AA@
CONST	SEGMENT
??_C@_02KMALDIDP@16?$AA@ DB '16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IHCGGLPM@15?$AA@
CONST	SEGMENT
??_C@_02IHCGGLPM@15?$AA@ DB '15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JODNFKLN@14?$AA@
CONST	SEGMENT
??_C@_02JODNFKLN@14?$AA@ DB '14', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NBHMMMHK@13?$AA@
CONST	SEGMENT
??_C@_02NBHMMMHK@13?$AA@ DB '13', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MIGHPNDL@12?$AA@
CONST	SEGMENT
??_C@_02MIGHPNDL@12?$AA@ DB '12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ODEKKOPI@11?$AA@
CONST	SEGMENT
??_C@_02ODEKKOPI@11?$AA@ DB '11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PKFBJPLJ@10?$AA@
CONST	SEGMENT
??_C@_02PKFBJPLJ@10?$AA@ DB '10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LAKCGALK@9?$AA@
CONST	SEGMENT
??_C@_01LAKCGALK@9?$AA@ DB '9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8?$AA@
CONST	SEGMENT
??_C@_01KJLJFBPL@8?$AA@ DB '8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01COCBENDE@7?$AA@
CONST	SEGMENT
??_C@_01COCBENDE@7?$AA@ DB '7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DHDKHMHF@6?$AA@
CONST	SEGMENT
??_C@_01DHDKHMHF@6?$AA@ DB '6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BMBHCPLG@5?$AA@
CONST	SEGMENT
??_C@_01BMBHCPLG@5?$AA@ DB '5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FAMBOPH@4?$AA@
CONST	SEGMENT
??_C@_01FAMBOPH@4?$AA@ DB '4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EKENIIDA@3?$AA@
CONST	SEGMENT
??_C@_01EKENIIDA@3?$AA@ DB '3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FDFGLJHB@2?$AA@
CONST	SEGMENT
??_C@_01FDFGLJHB@2?$AA@ DB '2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OAIKGDBA@w12?$AA@
CONST	SEGMENT
??_C@_03OAIKGDBA@w12?$AA@ DB 'w12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MLKHDAND@w11?$AA@
CONST	SEGMENT
??_C@_03MLKHDAND@w11?$AA@ DB 'w11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NCLMABJC@w10?$AA@
CONST	SEGMENT
??_C@_03NCLMABJC@w10?$AA@ DB 'w10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FPIENFIC@w9?$AA@
CONST	SEGMENT
??_C@_02FPIENFIC@w9?$AA@ DB 'w9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGJPOEMD@w8?$AA@
CONST	SEGMENT
??_C@_02EGJPOEMD@w8?$AA@ DB 'w8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MBAHPIAM@w7?$AA@
CONST	SEGMENT
??_C@_02MBAHPIAM@w7?$AA@ DB 'w7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NIBMMJEN@w6?$AA@
CONST	SEGMENT
??_C@_02NIBMMJEN@w6?$AA@ DB 'w6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDDBJKIO@w5?$AA@
CONST	SEGMENT
??_C@_02PDDBJKIO@w5?$AA@ DB 'w5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OKCKKLMP@w4?$AA@
CONST	SEGMENT
??_C@_02OKCKKLMP@w4?$AA@ DB 'w4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KFGLDNAI@w3?$AA@
CONST	SEGMENT
??_C@_02KFGLDNAI@w3?$AA@ DB 'w3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMHAAMEJ@w2?$AA@
CONST	SEGMENT
??_C@_02LMHAAMEJ@w2?$AA@ DB 'w2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JHFNFPIK@w1?$AA@
CONST	SEGMENT
??_C@_02JHFNFPIK@w1?$AA@ DB 'w1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LAFHGHBM@k3?$AA@
CONST	SEGMENT
??_C@_02LAFHGHBM@k3?$AA@ DB 'k3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KJEMFGFN@k2?$AA@
CONST	SEGMENT
??_C@_02KJEMFGFN@k2?$AA@ DB 'k2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ICGBAFJO@k1?$AA@
CONST	SEGMENT
??_C@_02ICGBAFJO@k1?$AA@ DB 'k1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JEJKBAGA@g?$AA@
CONST	SEGMENT
??_C@_01JEJKBAGA@g?$AA@ DB 'g', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OJONOECF@b?$AA@
CONST	SEGMENT
??_C@_01OJONOECF@b?$AA@ DB 'b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n?$AA@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n?$AA@ DB 'n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p?$AA@
CONST	SEGMENT
??_C@_01JBBJJEPG@p?$AA@ DB 'p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FOKBNGLG@0?5?9?536?5?9?5pojedyncze?5pole?5o?5odpow@
CONST	SEGMENT
??_C@_0CP@FOKBNGLG@0?5?9?536?5?9?5pojedyncze?5pole?5o?5odpow@ DB '0 - 36 '
	DB	'- pojedyncze pole o odpowiednim numerze', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KMEGGBFA@w1?0?5w2?0?5?4?4?4?0?5w12?5?9?5wiersz?5trzech@
CONST	SEGMENT
??_C@_0CJ@KMEGGBFA@w1?0?5w2?0?5?4?4?4?0?5w12?5?9?5wiersz?5trzech@ DB 'w1,'
	DB	' w2, ..., w12 - wiersz trzech numer', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@
CONST	SEGMENT
??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@ DB 'k1, k'
	DB	'2, k3 - kolumna 1, kolumna 2, kolumna 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@
CONST	SEGMENT
??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@ DB 'd - dolna po', 0b3H, 'o'
	DB	'wa', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@
CONST	SEGMENT
??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@ DB 'g - g', 0f3H, 'rna p'
	DB	'o', 0b3H, 'owa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LKBFHLDI@b?5?9?5czarne?$CIblack?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@LKBFHLDI@b?5?9?5czarne?$CIblack?$CJ?$AA@ DB 'b - czarne(black)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GOMOHEMO@r?5?9?5czerwone?$CIred?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@GOMOHEMO@r?5?9?5czerwone?$CIred?$CJ?$AA@ DB 'r - czerwone(red)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@
CONST	SEGMENT
??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@ DB 'n - nieparzyste', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@
CONST	SEGMENT
??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@ DB 'p - parzyste', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@FGCBIOFJ@Jak?$LJ?5opcje?5chcesz?5obstawic?5?$DP?5?$CIzg@
CONST	SEGMENT
??_C@_0DM@FGCBIOFJ@Jak?$LJ?5opcje?5chcesz?5obstawic?5?$DP?5?$CIzg@ DB 'Ja'
	DB	'k', 0b9H, ' opcje chcesz obstawic ? (zgodnie z poni', 0bfH, 's'
	DB	'zym opisem) :', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause?$AA@
CONST	SEGMENT
??_C@_05PDJBBECF@pause?$AA@ DB 'pause', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@
CONST	SEGMENT
??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@ DB 'log_og', 0f3H, 'lny.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGCGFIEG@polish?$AA@
CONST	SEGMENT
??_C@_06JGCGFIEG@polish?$AA@ DB 'polish', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ; std::uniform_int<int>::_Adjust
PUBLIC	?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAII@Z		; std::uniform_int<int>::_Adjust
PUBLIC	??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QAE@AAVrandom_device@1@@Z ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>
PUBLIC	??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEII@Z ; std::_Rng_from_urng<unsigned int,std::random_device>::operator()
PUBLIC	?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEIXZ ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z ; std::_Traits_equal<std::char_traits<char> >
PUBLIC	??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@ABEHAAVrandom_device@1@HH@Z ; std::uniform_int<int>::_Eval<std::random_device>
PUBLIC	??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
PUBLIC	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
PUBLIC	??$_Refancy@PAD$0A@@std@@YAPADPAD@Z		; std::_Refancy<char *,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$size@D$0BN@@std@@YAIAAY0BN@$$CBD@Z		; std::size<char,29>
PUBLIC	??$size@D$0BE@@std@@YAIAAY0BE@$$CBD@Z		; std::size<char,20>
PUBLIC	??$size@D$0O@@std@@YAIAAY0O@$$CBD@Z		; std::size<char,14>
PUBLIC	??$size@D$0BB@@std@@YAIAAY0BB@$$CBD@Z		; std::size<char,17>
PUBLIC	??$size@D$0BH@@std@@YAIAAY0BH@$$CBD@Z		; std::size<char,23>
PUBLIC	??$size@D$0BL@@std@@YAIAAY0BL@$$CBD@Z		; std::size<char,27>
PUBLIC	??$size@D$0BM@@std@@YAIAAY0BM@$$CBD@Z		; std::size<char,28>
PUBLIC	??$size@D$0CG@@std@@YAIAAY0CG@$$CBD@Z		; std::size<char,38>
PUBLIC	??$size@D$0CA@@std@@YAIAAY0CA@$$CBD@Z		; std::size<char,32>
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?RVrandom_device@std@@@?$uniform_int@H@std@@QBEHAAVrandom_device@1@@Z ; std::uniform_int<int>::operator()<std::random_device>
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z	; std::uniform_int<int>::param_type::_Init
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
PUBLIC	??0param_type@?$uniform_int@H@std@@QAE@HH@Z	; std::uniform_int<int>::param_type::param_type
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ	; std::fpos<_Mbstatet>::seekpos
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
PUBLIC	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
PUBLIC	?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
PUBLIC	?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
PUBLIC	?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
PUBLIC	??0?$uniform_int@H@std@@QAE@HH@Z		; std::uniform_int<int>::uniform_int<int>
PUBLIC	?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ; std::pointer_traits<char *>::pointer_to
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_fstream<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::close
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
PUBLIC	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
PUBLIC	??0?$uniform_int_distribution@H@std@@QAE@HH@Z	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
PUBLIC	?Ustaw_ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ustaw_ustawienia
PUBLIC	?Pêtla_g³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; Pêtla_g³ówna
PUBLIC	?Koniec_gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z ; Koniec_gry
PUBLIC	?Og³oœ_wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ; Og³oœ_wynik
PUBLIC	?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?SprawdŸ_ustawienia@@YAXXZ			; SprawdŸ_ustawienia
PUBLIC	?SprawdŸ_Pliki@@YAXXZ				; SprawdŸ_Pliki
PUBLIC	?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Wczytaj_z_pliku
PUBLIC	?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
PUBLIC	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Odczytaj_liczbê
PUBLIC	?Wylosuj@@YAHABH0@Z				; Wylosuj
PUBLIC	?Show_Cursor@@YAXXZ				; Show_Cursor
PUBLIC	?Hide_Cursor@@YAXXZ				; Hide_Cursor
PUBLIC	?Change_Col@@YAXABH@Z				; Change_Col
PUBLIC	?Czy_Kontynuowaæ@@YA_NABH@Z			; Czy_Kontynuowaæ
PUBLIC	?SprawdŸ_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; SprawdŸ_Zak³ad
PUBLIC	?Zakrêæ_Ruletk¹@@YAHXZ				; Zakrêæ_Ruletk¹
PUBLIC	?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z		; Wczytaj_Kwotê_Zak³adu
PUBLIC	?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Obstaw
PUBLIC	?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	_main
PUBLIC	??Rrandom_device@std@@QAEIXZ			; std::random_device::operator()
PUBLIC	?entropy@random_device@std@@QAENXZ		; std::random_device::entropy
PUBLIC	?max@random_device@std@@SAIXZ			; std::random_device::max
PUBLIC	?min@random_device@std@@SAIXZ			; std::random_device::min
PUBLIC	??0random_device@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::random_device::random_device
PUBLIC	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z		; std::_Ungetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?eq@?$char_traits@D@std@@SA_NABD0@Z		; std::char_traits<char>::eq
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAPADQADID@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?find@?$char_traits@D@std@@SAPBDQBDIABD@Z	; std::char_traits<char>::find
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	?compare@?$char_traits@D@std@@SAHQBD0I@Z	; std::char_traits<char>::compare
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
PUBLIC	__real@4040000000000000
PUBLIC	__real@4042800000000000
EXTRN	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___std_terminate:PROC
EXTRN	__dtoui3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
CRT$XCU	SEGMENT
?G³os$initializer$@@3P6AXXZA DD FLAT:??__EG³os@@YAXXZ	; G³os$initializer$
CRT$XCU	ENDS
;	COMDAT __real@4042800000000000
CONST	SEGMENT
__real@4042800000000000 DQ 04042800000000000r	; 37
CONST	ENDS
;	COMDAT __real@4040000000000000
CONST	SEGMENT
__real@4040000000000000 DQ 04040000000000000r	; 32
	ORG $+2
?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; G³os
	DB	19 DUP(00H)
	DD	0fH
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$5
	DD	01H
	DD	FLAT:__unwindfunclet$_main$6
	DD	02H
	DD	FLAT:__unwindfunclet$_main$8
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
	DD	04H
	DD	FLAT:__unwindfunclet$_main$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Zakrêæ_Ruletk¹@@YAHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Zakrêæ_Ruletk¹@@YAHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Zakrêæ_Ruletk¹@@YAHXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Zakrêæ_Ruletk¹@@YAHXZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Czy_Kontynuowaæ@@YA_NABH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Czy_Kontynuowaæ@@YA_NABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Czy_Kontynuowaæ@@YA_NABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Czy_Kontynuowaæ@@YA_NABH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Wylosuj@@YAHABH0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Wylosuj@@YAHABH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Wylosuj@@YAHABH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Wylosuj@@YAHABH0@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Wylosuj@@YAHABH0@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$19
	DD	00H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$20
	DD	01H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	04H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$10
	DD	06H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$11
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$167
	DD	08H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$168
	DD	09H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$170
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$13
	DD	0bH
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$14
	DD	0cH
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$15
	DD	0dH
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SprawdŸ_Pliki@@YAXXZ DD 019930522H
	DD	03aH
	DD	FLAT:__unwindtable$?SprawdŸ_Pliki@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?SprawdŸ_Pliki@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$5
	DD	02H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$6
	DD	03H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$7
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$10
	DD	05H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$11
	DD	06H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$12
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$15
	DD	08H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$16
	DD	09H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$17
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$20
	DD	0bH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$21
	DD	0cH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$22
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$25
	DD	0eH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$26
	DD	0fH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$27
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$30
	DD	011H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$31
	DD	012H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$32
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$34
	DD	014H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$35
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$37
	DD	016H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$38
	DD	017H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$39
	DD	018H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$40
	DD	019H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$41
	DD	01aH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$42
	DD	01bH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$43
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$304
	DD	01dH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$305
	DD	01eH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$307
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$45
	DD	020H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$46
	DD	021H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$47
	DD	022H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$48
	DD	020H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$50
	DD	024H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$51
	DD	025H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$52
	DD	026H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$53
	DD	027H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$54
	DD	028H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$55
	DD	029H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$56
	DD	02aH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$57
	DD	02bH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$58
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$756
	DD	02dH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$757
	DD	02eH
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$759
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$60
	DD	030H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$61
	DD	031H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$62
	DD	030H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$64
	DD	033H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$65
	DD	034H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$66
	DD	035H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$67
	DD	036H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$68
	DD	037H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$69
	DD	038H
	DD	FLAT:__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$70
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SprawdŸ_ustawienia@@YAXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?SprawdŸ_ustawienia@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SprawdŸ_ustawienia@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$0
	DD	03H
	DD	FLAT:__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$11
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$35
__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$35 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$30
__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$30 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$10
__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$dead$ = ecx

; 535  :             return _time64(_Time);

  00000	6a 00		 push	 0
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00008	83 c4 04	 add	 esp, 4

; 536  :         }

  0000b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
;	COMDAT _memcpy_s
_TEXT	SEGMENT
__Source$ = 8						; size = 4
__SourceSize$dead$ = 12					; size = 4
_memcpy_s PROC						; COMDAT
; __Destination$ = ecx
; __DestinationSize$dead$ = edx

; 41   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   :         if (_SourceSize == 0)
; 43   :         {
; 44   :             return 0;
; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  00003	85 c9		 test	 ecx, ecx
  00005	74 12		 je	 SHORT $LN10@memcpy_s

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00007	8b 45 08	 mov	 eax, DWORD PTR __Source$[ebp]
  0000a	85 c0		 test	 eax, eax
  0000c	74 08		 je	 SHORT $LN5@memcpy_s

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;
; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

  0000e	8a 00		 mov	 al, BYTE PTR [eax]
  00010	88 01		 mov	 BYTE PTR [ecx], al

; 60   :         return 0;

  00012	33 c0		 xor	 eax, eax

; 61   :     }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  00016	c6 01 00	 mov	 BYTE PTR [ecx], 0
$LN10@memcpy_s:

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0001f	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  0002b	b8 16 00 00 00	 mov	 eax, 22			; 00000016H

; 61   :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_memcpy_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 60   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 61   :         _Data._What = _Message;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  0000f	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0
  00014	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 62   :     }

  00017	8b c1		 mov	 eax, ecx
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_copy
  00024	83 c4 08	 add	 esp, 8

; 68   :     }

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00010	59		 pop	 ecx

; 85   :     }

  00011	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 90   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 83   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 84   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00016	83 c4 04	 add	 esp, 4
  00019	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001d	74 0b		 je	 SHORT $LN6@scalar
  0001f	6a 0c		 push	 12			; 0000000cH
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN6@scalar:
  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 683  : 		return (INT_MAX);

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 684  : 		}

  00005	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Size$dead$ = ecx
; __Where$ = edx

; 92   :         (void)_Size;
; 93   :         return _Where;

  00000	8b c2		 mov	 eax, edx

; 94   :     }

  00002	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHQBD0I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?compare@?$char_traits@D@std@@SAHQBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 474  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  00007	83 ee 04	 sub	 esi, 4
  0000a	72 15		 jb	 SHORT $LN5@compare
  0000c	0f 1f 40 00	 npad	 4
$LL6@compare:
  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	3b 02		 cmp	 eax, DWORD PTR [edx]
  00014	75 10		 jne	 SHORT $LN4@compare
  00016	83 c1 04	 add	 ecx, 4
  00019	83 c2 04	 add	 edx, 4
  0001c	83 ee 04	 sub	 esi, 4
  0001f	73 ef		 jae	 SHORT $LL6@compare
$LN5@compare:
  00021	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00024	74 35		 je	 SHORT $LN3@compare
$LN4@compare:
  00026	8a 01		 mov	 al, BYTE PTR [ecx]
  00028	3a 02		 cmp	 al, BYTE PTR [edx]
  0002a	75 27		 jne	 SHORT $LN7@compare
  0002c	83 fe fd	 cmp	 esi, -3			; fffffffdH
  0002f	74 2a		 je	 SHORT $LN3@compare
  00031	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00034	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  00037	75 1a		 jne	 SHORT $LN7@compare
  00039	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0003c	74 1d		 je	 SHORT $LN3@compare
  0003e	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00041	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  00044	75 0d		 jne	 SHORT $LN7@compare
  00046	83 fe ff	 cmp	 esi, -1
  00049	74 10		 je	 SHORT $LN3@compare
  0004b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0004e	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00051	74 08		 je	 SHORT $LN3@compare
$LN7@compare:
  00053	1b c0		 sbb	 eax, eax
  00055	83 c8 01	 or	 eax, 1

; 476  : 		}

  00058	5e		 pop	 esi
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN3@compare:

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0005b	33 c0		 xor	 eax, eax

; 476  : 		}

  0005d	5e		 pop	 esi
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHQBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT
; __First$ = ecx

; 480  : 		return (_CSTD strlen(_First));

  00000	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL3@length:
  00003	8a 01		 mov	 al, BYTE PTR [ecx]
  00005	41		 inc	 ecx
  00006	84 c0		 test	 al, al
  00008	75 f9		 jne	 SHORT $LL3@length
  0000a	2b ca		 sub	 ecx, edx
  0000c	8b c1		 mov	 eax, ecx

; 481  : 		}

  0000e	c3		 ret	 0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 485  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00003	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00006	52		 push	 edx
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memcpy
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 487  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?find@?$char_traits@D@std@@SAPBDQBDIABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?find@?$char_traits@D@std@@SAPBDQBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT
; __First$ = ecx
; __Count$ = edx

; 499  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	52		 push	 edx
  00007	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 501  : 		}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?find@?$char_traits@D@std@@SAPBDQBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 505  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00003	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00006	52		 push	 edx
  00007	51		 push	 ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 507  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADQADID@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?assign@?$char_traits@D@std@@SAPADQADID@Z PROC		; std::char_traits<char>::assign, COMDAT
; __First$ = ecx
; __Count$ = edx

; 511  : 		{	// assign _Count * _Ch to [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00003	0f be 45 08	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00007	52		 push	 edx
  00008	50		 push	 eax
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 _memset
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 513  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPADQADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 517  : 		_Left = _Right;

  00000	8a 02		 mov	 al, BYTE PTR [edx]
  00002	88 01		 mov	 BYTE PTR [ecx], al

; 518  : 		}

  00004	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT
?eq@?$char_traits@D@std@@SA_NABD0@Z PROC		; std::char_traits<char>::eq, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 522  : 		return (_Left == _Right);

  00000	8a 01		 mov	 al, BYTE PTR [ecx]
  00002	3a 02		 cmp	 al, BYTE PTR [edx]
  00004	0f 94 c0	 sete	 al

; 523  : 		}

  00007	c3		 ret	 0
?eq@?$char_traits@D@std@@SA_NABD0@Z ENDP		; std::char_traits<char>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT
; __Meta$ = ecx

; 532  : 		return ((_Elem)_Meta);

  00000	8a 01		 mov	 al, BYTE PTR [ecx]

; 533  : 		}

  00002	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT
; __Ch$ = ecx

; 537  : 		return ((unsigned char)_Ch);

  00000	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 538  : 		}

  00003	c3		 ret	 0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 542  : 		return (_Left == _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 02		 cmp	 eax, DWORD PTR [edx]
  00004	0f 94 c0	 sete	 al

; 543  : 		}

  00007	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT
; __Meta$ = ecx

; 547  : 		return (_Meta != eof() ? _Meta : !eof());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	33 c9		 xor	 ecx, ecx
  00004	83 f8 ff	 cmp	 eax, -1
  00007	0f 44 c1	 cmove	 eax, ecx

; 548  : 		}

  0000a	c3		 ret	 0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 552  : 		return (EOF);

  00000	83 c8 ff	 or	 eax, -1

; 553  : 		}

  00003	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 65   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$dead$ = ecx

; 76   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Try_aligned_allocation$dead$ = 8			; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT
; __Count$ = ecx
; __Sz$dead$ = edx

; 50   : 	void *_Ptr = 0;
; 51   : 
; 52   : 	if (_Count == 0)

  00000	85 c9		 test	 ecx, ecx
  00002	75 03		 jne	 SHORT $LN2@Allocate

; 53   : 		{
; 54   : 		return (_Ptr);

  00004	33 c0		 xor	 eax, eax

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);
; 96   : 	}

  00006	c3		 ret	 0
$LN2@Allocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00007	32 c0		 xor	 al, al
  00009	74 06		 je	 SHORT $LN3@Allocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 22		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00019	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  0001c	3b c1		 cmp	 eax, ecx
  0001e	77 06		 ja	 SHORT $LN5@Allocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  00020	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN5@Allocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0002f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00032	83 e1 e0	 and	 ecx, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00035	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  00038	8b c1		 mov	 eax, ecx

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);
; 96   : 	}

  0003a	c3		 ret	 0
$LN4@Allocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	83 c4 04	 add	 esp, 4

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);
; 96   : 	}

  00044	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Sz$dead$ = 8						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT
; __Ptr$ = ecx
; __Count$ = edx

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)
; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00000	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00006	72 1a		 jb	 SHORT $LN4@Deallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00008	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0000b	75 1d		 jne	 SHORT $_Invalid_parameter$15

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0000d	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00010	3b c1		 cmp	 eax, ecx
  00012	73 16		 jae	 SHORT $_Invalid_parameter$15

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00014	2b c8		 sub	 ecx, eax
  00016	83 f9 04	 cmp	 ecx, 4
  00019	72 0f		 jb	 SHORT $_Invalid_parameter$15

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  0001b	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0001e	77 0a		 ja	 SHORT $_Invalid_parameter$15

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00020	8b c8		 mov	 ecx, eax
$LN4@Deallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	59		 pop	 ecx

; 156  : 	}

  00029	c3		 ret	 0
$_Invalid_parameter$15:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT
; __Len$ = ecx

; 1162 : 	return (_Len);

  00000	8b c1		 mov	 eax, ecx

; 1163 : 	}

  00002	c3		 ret	 0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_typeinfo.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 127  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 128  :     }

  00003	8b c1		 mov	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h

; 59   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 60   :     {
; 61   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_typeinfo.h

; 127  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@

; 128  :     }

  00017	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 83   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 84   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00016	83 c4 04	 add	 esp, 4
  00019	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001d	74 0b		 je	 SHORT $LN9@scalar
  0001f	6a 0c		 push	 12			; 0000000cH
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN9@scalar:
  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00010	59		 pop	 ecx
  00011	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 403  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1locale@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 404  : 		if (_Ptr != 0)

  00022	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00025	85 c9		 test	 ecx, ecx
  00027	74 11		 je	 SHORT $LN4@locale

; 405  : 			delete _Ptr->_Decref();

  00029	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002b	ff 50 08	 call	 DWORD PTR [eax+8]
  0002e	85 c0		 test	 eax, eax
  00030	74 08		 je	 SHORT $LN4@locale
  00032	8b 10		 mov	 edx, DWORD PTR [eax]
  00034	8b c8		 mov	 ecx, eax
  00036	6a 01		 push	 1
  00038	ff 12		 call	 DWORD PTR [edx]
$LN4@locale:

; 406  : 		}

  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1locale@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1locale@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 430  : 		{	// look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __Id$[ebp]
  0000a	3b 71 0c	 cmp	 esi, DWORD PTR [ecx+12]
  0000d	73 0c		 jae	 SHORT $LN6@Getfacet
  0000f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00012	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00015	85 c0		 test	 eax, eax
  00017	75 22		 jne	 SHORT $LN3@Getfacet
  00019	eb 02		 jmp	 SHORT $LN10@Getfacet
$LN6@Getfacet:

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0001b	33 c0		 xor	 eax, eax
$LN10@Getfacet:

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0001d	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00021	74 18		 je	 SHORT $LN3@Getfacet

; 434  : 			return (_Facptr);	// found facet or not transparent
; 435  : 		else
; 436  : 			{	// look in current locale
; 437  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 438  : 			return (_Id < _Ptr0->_Facetcount

  00029	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  0002c	73 0b		 jae	 SHORT $LN8@Getfacet
  0002e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00031	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 439  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 440  : 				: 0);	// no entry in current locale
; 441  : 			}
; 442  : 		}

  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN8@Getfacet:

; 438  : 			return (_Id < _Ptr0->_Facetcount

  00039	33 c0		 xor	 eax, eax
$LN3@Getfacet:

; 439  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 440  : 				: 0);	// no entry in current locale
; 441  : 			}
; 442  : 		}

  0003b	5e		 pop	 esi
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT
; __Byte$ = ecx
; __File$ = edx

; 47   : 	{	// get a char element from a C stream

  00000	56		 push	 esi

; 48   : 	int _Meta;
; 49   : 	if ((_Meta = fgetc(_File)) == EOF)

  00001	52		 push	 edx
  00002	8b f1		 mov	 esi, ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  0000a	83 c4 04	 add	 esp, 4
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	75 04		 jne	 SHORT $LN2@Fgetc

; 50   : 		return (false);

  00012	32 c0		 xor	 al, al

; 55   : 		}
; 56   : 	}

  00014	5e		 pop	 esi
  00015	c3		 ret	 0
$LN2@Fgetc:

; 51   : 	else
; 52   : 		{	// got one, convert to char
; 53   : 		_Byte = (char)_Meta;

  00016	88 06		 mov	 BYTE PTR [esi], al

; 54   : 		return (true);

  00018	b0 01		 mov	 al, 1

; 55   : 		}
; 56   : 	}

  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT
; __Byte$ = cl
; __File$ = edx

; 93   : 	return (fputc(_Byte, _File) != EOF);

  00000	52		 push	 edx
  00001	0f be c1	 movsx	 eax, cl
  00004	50		 push	 eax
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputc
  0000b	83 c4 08	 add	 esp, 8
  0000e	83 f8 ff	 cmp	 eax, -1
  00011	0f 95 c0	 setne	 al

; 94   : 	}

  00014	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT
; __Byte$ = ecx
; __File$ = edx

; 117  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  00000	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00003	52		 push	 edx
  00004	50		 push	 eax
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ungetc
  0000b	83 c4 08	 add	 esp, 8
  0000e	83 f8 ff	 cmp	 eax, -1
  00011	0f 95 c0	 setne	 al

; 118  : 	}

  00014	c3		 ret	 0
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0random_device@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0random_device@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::random_device::random_device, COMDAT
; _this$ = ecx

; 6420 : 	explicit random_device(const string& = "")

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 6442 : 		return (_Random_device());

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ

; 6421 : 		{	// construct
; 6422 : 		(*this)();	// force early failure if bad engine
; 6423 : 		}

  00009	8b c6		 mov	 eax, esi
  0000b	5e		 pop	 esi
  0000c	c2 04 00	 ret	 4
??0random_device@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::random_device::random_device
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?min@random_device@std@@SAIXZ
_TEXT	SEGMENT
?min@random_device@std@@SAIXZ PROC			; std::random_device::min, COMDAT

; 6427 : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 6428 : 		}

  00002	c3		 ret	 0
?min@random_device@std@@SAIXZ ENDP			; std::random_device::min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?max@random_device@std@@SAIXZ
_TEXT	SEGMENT
?max@random_device@std@@SAIXZ PROC			; std::random_device::max, COMDAT

; 6432 : 		return ((result_type)-1);

  00000	83 c8 ff	 or	 eax, -1

; 6433 : 		}

  00003	c3		 ret	 0
?max@random_device@std@@SAIXZ ENDP			; std::random_device::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?entropy@random_device@std@@QAENXZ
_TEXT	SEGMENT
?entropy@random_device@std@@QAENXZ PROC			; std::random_device::entropy, COMDAT
; _this$dead$ = ecx

; 6437 : 		return (32.0);

  00000	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4040000000000000

; 6438 : 		}

  00008	c3		 ret	 0
?entropy@random_device@std@@QAENXZ ENDP			; std::random_device::entropy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??Rrandom_device@std@@QAEIXZ
_TEXT	SEGMENT
??Rrandom_device@std@@QAEIXZ PROC			; std::random_device::operator(), COMDAT
; _this$dead$ = ecx

; 6442 : 		return (_Random_device());

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?_Random_device@std@@YAIXZ
??Rrandom_device@std@@QAEIXZ ENDP			; std::random_device::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ??__EG³os@@YAXXZ
text$di	SEGMENT
??__EG³os@@YAXXZ PROC					; `dynamic initializer for 'G³os'', COMDAT

; 69   : string G³os;

  00000	68 00 00 00 00	 push	 OFFSET ??__FG³os@@YAXXZ	; `dynamic atexit destructor for 'G³os''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__EG³os@@YAXXZ ENDP					; `dynamic initializer for 'G³os''
text$di	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??__FG³os@@YAXXZ
text$yd	SEGMENT
??__FG³os@@YAXXZ PROC					; `dynamic atexit destructor for 'G³os'', COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3707 : 		this->_Orphan_all();

  00000	e8 00 00 00 00	 call	 ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00005	a1 14 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  0000a	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  0000d	72 31		 jb	 SHORT $LN30@dynamic
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00015	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00016	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001b	72 1a		 jb	 SHORT $LN33@dynamic

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0001d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00020	75 3e		 jne	 SHORT $_Invalid_parameter$52

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00022	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00025	3b c1		 cmp	 eax, ecx
  00027	73 37		 jae	 SHORT $_Invalid_parameter$52

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00029	2b c8		 sub	 ecx, eax
  0002b	83 f9 04	 cmp	 ecx, 4
  0002e	72 30		 jb	 SHORT $_Invalid_parameter$52

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00030	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00033	77 2b		 ja	 SHORT $_Invalid_parameter$52

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00035	8b c8		 mov	 ecx, eax
$LN33@dynamic:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003d	83 c4 04	 add	 esp, 4
$LN30@dynamic:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00040	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0004a	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00054	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2247 : 		}

  0005b	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
$_Invalid_parameter$52:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00060	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
??__FG³os@@YAXXZ ENDP					; `dynamic atexit destructor for 'G³os''
text$yd	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_wylosowana_liczba$ = -432				; size = 4
_this$ = -428						; size = 4
_kwota_zak³adu$ = -428					; size = 4
$T1 = -424						; size = 4
_iloœæ_pieniêdzy$ = -424				; size = 4
_co_kontynuowaæ$ = -417					; size = 1
_log_ogólny$ = -416					; size = 176
_log$ = -240						; size = 192
_typ_zak³adu$ = -48					; size = 24
_hCCI$10 = -24						; size = 8
_wygrana$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_main
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a4 01 00
	00		 sub	 esp, 420		; 000001a4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 74   : 	//Inicjowanie funkcji
; 75   : 	setlocale(LC_ALL, "polish"); // W celu polskich liter w konsoli

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_06JGCGFIEG@polish?$AA@
  00031	6a 00		 push	 0
  00033	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setlocale
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00043	6a 00		 push	 0
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 76   : 	srand((unsigned int)time(nullptr)); //Zainicjowanie generatorza LCG (Liniowy Generator Kongruentny) dla ma³o wa¿nych liczb

  0004b	50		 push	 eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand
  00052	83 c4 10	 add	 esp, 16			; 00000010H

; 351  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00055	6a f5		 push	 -11			; fffffff5H
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  0005d	8b f0		 mov	 esi, eax

; 352  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 353  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0005f	8d 45 e8	 lea	 eax, DWORD PTR _hCCI$10[ebp]
  00062	50		 push	 eax
  00063	56		 push	 esi
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 354  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoœæ widocznoœci kursorsora tekstego w konsoli jest ró¿na od prawdy

  0006a	83 7d ec 01	 cmp	 DWORD PTR _hCCI$10[ebp+4], 1
  0006e	74 12		 je	 SHORT $LN12@main

; 355  : 	{
; 356  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoœci kursora na widoczny
; 357  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoœci kursora zgodnie z poprzedni¹ zmienn¹

  00070	8d 45 e8	 lea	 eax, DWORD PTR _hCCI$10[ebp]
  00073	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _hCCI$10[ebp+4], 1
  0007a	50		 push	 eax
  0007b	56		 push	 esi
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8
$LN12@main:

; 77   : 	Show_Cursor(); //Pokazanie kursora tekstowego w konsoli
; 78   : 
; 79   : 	SprawdŸ_ustawienia(); //Wczytanie ustawieñ z pliku

  00082	e8 00 00 00 00	 call	 ?SprawdŸ_ustawienia@@YAXXZ ; SprawdŸ_ustawienia

; 80   : 	SprawdŸ_Pliki(); //Wczytanie plików audio

  00087	e8 00 00 00 00	 call	 ?SprawdŸ_Pliki@@YAXXZ	; SprawdŸ_Pliki
  0008c	68 b0 00 00 00	 push	 176			; 000000b0H
  00091	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _log_ogólny$[ebp]
  00097	6a 00		 push	 0
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _memset

; 83   : 	ofstream log_ogólny; //Utworzenie typu do celu zapisu do pliku

  0009f	83 c4 08	 add	 esp, 8
  000a2	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  000a8	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000ad	51		 push	 ecx
  000ae	6a 0a		 push	 10			; 0000000aH
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@
  000b5	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+4]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 83   : 	ofstream log_ogólny; //Utworzenie typu do celu zapisu do pliku

  000bb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000c2	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  000c7	85 c0		 test	 eax, eax

; 1139 : 			_Myios::setstate(ios_base::failbit);

  000c9	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  000cf	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _log_ogólny$[ebp]
  000d5	6a 00		 push	 0
  000d7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000da	75 0c		 jne	 SHORT $LN18@main
  000dc	6a 02		 push	 2
  000de	03 c8		 add	 ecx, eax
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1140 : 		else

  000e6	eb 0a		 jmp	 SHORT $LN19@main
$LN18@main:

; 1141 : 			_Myios::clear();	// added with C++11

  000e8	6a 00		 push	 0
  000ea	03 c8		 add	 ecx, eax
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN19@main:
  000f2	68 c0 00 00 00	 push	 192			; 000000c0H
  000f7	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp]
  000fd	6a 00		 push	 0
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _memset
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1196 : 		{	// construct unopened

  00108	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00112	8d 4d 88	 lea	 ecx, DWORD PTR _log$[ebp+120]
  00115	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+16], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00125	6a 00		 push	 0
  00127	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp+24]
  0012d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00131	50		 push	 eax
  00132	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp]
  00138	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T1[ebp], 1

; 1142 : 		}
; 1143 : 
; 1144 : 	void open(const string& _Str,
; 1145 : 		ios_base::openmode _Mode = ios_base::out,
; 1146 : 		int _Prot = (int)ios_base::_Openprot)
; 1147 : 		{	// open a C stream with specified mode
; 1148 : 		open(_Str.c_str(), _Mode, _Prot);
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1152 : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 1153 : 		{	// open a C stream with specified mode (old style)
; 1154 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1155 : 		}
; 1156 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1157 : 
; 1158 : 	void close()
; 1159 : 		{	// close the C stream
; 1160 : 		if (_Filebuffer.close() == 0)
; 1161 : 			_Myios::setstate(ios_base::failbit);
; 1162 : 		}
; 1163 : 
; 1164 : private:
; 1165 : 	_Myfb _Filebuffer;	// the file buffer
; 1166 : 	};
; 1167 : 
; 1168 : 	// basic_ofstream TEMPLATE OPERATORS
; 1169 : template<class _Elem,
; 1170 : 	class _Traits> inline
; 1171 : 	void swap(basic_ofstream<_Elem, _Traits>& _Left,
; 1172 : 		basic_ofstream<_Elem, _Traits>& _Right)
; 1173 : 	{	// swap _Left and _Right basic_ofstreams
; 1174 : 	_Left.swap(_Right);
; 1175 : 	}
; 1176 : 
; 1177 : 		// TEMPLATE CLASS basic_fstream
; 1178 : template<class _Elem,
; 1179 : 	class _Traits>
; 1180 : 	class basic_fstream
; 1181 : 		: public basic_iostream<_Elem, _Traits>
; 1182 : 	{	// input/output stream associated with a C stream
; 1183 : public:
; 1184 : 	typedef basic_fstream<_Elem, _Traits> _Myt;
; 1185 : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 1186 : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 1187 : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 1188 : 	typedef _Elem char_type;
; 1189 : 	typedef _Traits traits_type;
; 1190 : 	typedef typename _Traits::int_type int_type;
; 1191 : 	typedef typename _Traits::pos_type pos_type;
; 1192 : 	typedef typename _Traits::off_type off_type;
; 1193 : 
; 1194 : 	basic_fstream()
; 1195 : 		: _Mybase(&_Filebuffer)

  00142	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00148	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 1196 : 		{	// construct unopened

  0014f	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
  00155	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00158	c7 84 05 10 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _log$[ebp+eax], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00163	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
  00169	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016c	8d 41 88	 lea	 eax, DWORD PTR [ecx-120]
  0016f	89 84 0d 0c ff
	ff ff		 mov	 DWORD PTR _log$[ebp+ecx-4], eax
  00176	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp+24]

; 155  : 		: _Mysb()

  0017c	8b c8		 mov	 ecx, eax

; 1196 : 		{	// construct unopened

  0017e	89 85 54 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 155  : 		: _Mysb()

  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0018a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  0018e	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+24]

; 156  : 		{	// construct from pointer to C stream

  00194	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+24], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 625  : 		_Closef = _Which == _Openfl;

  0019e	c6 85 70 ff ff
	ff 00		 mov	 BYTE PTR _log$[ebp+96], 0

; 626  : 		_Wrotesome = false;

  001a5	c6 85 65 ff ff
	ff 00		 mov	 BYTE PTR _log$[ebp+85], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;
; 652  : 		_State = _Stinit;

  001b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  001b7	89 85 68 ff ff
	ff		 mov	 DWORD PTR _log$[ebp+88], eax
  001bd	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  001c2	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+100], 0
  001cc	89 85 6c ff ff
	ff		 mov	 DWORD PTR _log$[ebp+92], eax

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  001d2	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+80], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 86   : 	int iloœæ_pieniêdzy = kwota_pocz¹tkowa, kwota_zak³adu, wylosowana_liczba, wygrana; //Zmienne do których wczytuje siê wartoœci liczbowe pobrane od u¿ytkownika takie jak kwota zak³adu a przechowuje iloœæ posiadanych pieniêdzy a tak¿e przechowuje wyniki funkcji losowania liczby z ruletki i kwote wygran¹ z zak³adu

  001dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?kwota_pocz¹tkowa@@3HA ; kwota_pocz¹tkowa
  001e1	89 85 58 fe ff
	ff		 mov	 DWORD PTR _iloœæ_pieniêdzy$[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  001e7	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001ee	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  001f5	c6 45 d0 00	 mov	 BYTE PTR _typ_zak³adu$[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 90   : 	Wczytaj_z_pliku(log_ogólny, log, co_kontynuowaæ, iloœæ_pieniêdzy, kwota_zak³adu, wylosowana_liczba, typ_zak³adu); //Wczytanie stanu gry z pliku

  001f9	8d 45 d0	 lea	 eax, DWORD PTR _typ_zak³adu$[ebp]
  001fc	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00200	50		 push	 eax
  00201	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00207	50		 push	 eax
  00208	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _kwota_zak³adu$[ebp]
  0020e	50		 push	 eax
  0020f	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  00215	50		 push	 eax
  00216	8d 85 5f fe ff
	ff		 lea	 eax, DWORD PTR _co_kontynuowaæ$[ebp]
  0021c	50		 push	 eax
  0021d	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR _log$[ebp]
  00223	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  00229	e8 00 00 00 00	 call	 ?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Wczytaj_z_pliku
  0022e	83 c4 14	 add	 esp, 20			; 00000014H
$LL4@main:

; 91   : 
; 92   : 	do
; 93   : 	{
; 94   : 		Pêtla_g³ówna(wygrana, kwota_zak³adu, iloœæ_pieniêdzy, log_ogólny, log, co_kontynuowaæ, typ_zak³adu, wylosowana_liczba); //Funkcja obs³uguj¹ca wszystkie elementy gry

  00231	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00237	50		 push	 eax
  00238	8d 45 d0	 lea	 eax, DWORD PTR _typ_zak³adu$[ebp]
  0023b	50		 push	 eax
  0023c	8d 85 5f fe ff
	ff		 lea	 eax, DWORD PTR _co_kontynuowaæ$[ebp]
  00242	50		 push	 eax
  00243	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp]
  00249	50		 push	 eax
  0024a	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _log_ogólny$[ebp]
  00250	50		 push	 eax
  00251	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  00257	50		 push	 eax
  00258	8d 95 54 fe ff
	ff		 lea	 edx, DWORD PTR _kwota_zak³adu$[ebp]
  0025e	8d 4d ec	 lea	 ecx, DWORD PTR _wygrana$[ebp]
  00261	e8 00 00 00 00	 call	 ?Pêtla_g³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; Pêtla_g³ówna
  00266	83 c4 18	 add	 esp, 24			; 00000018H

; 95   : 		co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  00269	c6 85 5f fe ff
	ff 6e		 mov	 BYTE PTR _co_kontynuowaæ$[ebp], 110 ; 0000006eH

; 96   : 	} while (Czy_Kontynuowaæ(iloœæ_pieniêdzy)); //Pêtla dza³aj¹ca do czasu wartoœci fa³sz zwróconej przez funkcjê Czy_kontynuowaæ

  00270	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  00276	e8 00 00 00 00	 call	 ?Czy_Kontynuowaæ@@YA_NABH@Z ; Czy_Kontynuowaæ
  0027b	84 c0		 test	 al, al
  0027d	75 b2		 jne	 SHORT $LL4@main

; 97   : 
; 98   : 	Koniec_gry(log_ogólny, log, iloœæ_pieniêdzy); //Zakoñczenie gry i wskazanie wyniku

  0027f	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  00285	50		 push	 eax
  00286	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR _log$[ebp]
  0028c	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  00292	e8 00 00 00 00	 call	 ?Koniec_gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z ; Koniec_gry

; 100  : 	system("pause"); //Wywo³anie funkcji wymagaj¹cej do zamkniêcia naciœniêcie dowolnego klawisza

  00297	68 00 00 00 00	 push	 OFFSET ??_C@_05PDJBBECF@pause?$AA@
  0029c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__system
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002a2	8b 45 e4	 mov	 eax, DWORD PTR _typ_zak³adu$[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 100  : 	system("pause"); //Wywo³anie funkcji wymagaj¹cej do zamkniêcia naciœniêcie dowolnego klawisza

  002a5	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002a8	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  002ab	72 3e		 jb	 SHORT $LN87@main
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  002ad	8b 4d d0	 mov	 ecx, DWORD PTR _typ_zak³adu$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002b0	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  002b1	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  002b6	72 2a		 jb	 SHORT $LN90@main

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  002b8	f6 c1 1f	 test	 cl, 31			; 0000001fH
  002bb	0f 85 e9 00 00
	00		 jne	 $_Invalid_parameter$125

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002c1	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  002c4	3b c1		 cmp	 eax, ecx
  002c6	0f 83 de 00 00
	00		 jae	 $_Invalid_parameter$125

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  002cc	2b c8		 sub	 ecx, eax
  002ce	83 f9 04	 cmp	 ecx, 4
  002d1	0f 82 d3 00 00
	00		 jb	 $_Invalid_parameter$125

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  002d7	83 f9 23	 cmp	 ecx, 35			; 00000023H
  002da	0f 87 ca 00 00
	00		 ja	 $_Invalid_parameter$125

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  002e0	8b c8		 mov	 ecx, eax
$LN90@main:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  002e2	51		 push	 ecx
  002e3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002e8	83 c4 04	 add	 esp, 4
$LN87@main:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1342 : 		{	// destroy the object

  002eb	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  002f1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  002f8	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  002ff	c6 45 d0 00	 mov	 BYTE PTR _typ_zak³adu$[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1342 : 		{	// destroy the object

  00303	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00306	c7 84 05 10 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _log$[ebp+eax], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00311	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
  00317	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0031a	8d 41 88	 lea	 eax, DWORD PTR [ecx-120]
  0031d	89 84 0d 0c ff
	ff ff		 mov	 DWORD PTR _log$[ebp+ecx-4], eax

; 1343 : 		}

  00324	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+24]
  0032a	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0032f	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+32]
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0033b	8d 4d 88	 lea	 ecx, DWORD PTR _log$[ebp+120]
  0033e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ

; 1121 : 		{	// destroy the object

  00344	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _log_ogólny$[ebp]
  0034a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0034d	c7 84 05 60 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _log_ogólny$[ebp+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00358	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _log_ogólny$[ebp]
  0035e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00361	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00364	89 84 0d 5c fe
	ff ff		 mov	 DWORD PTR _log_ogólny$[ebp+ecx-4], eax

; 1122 : 		}

  0036b	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+4]
  00371	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00376	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+8]
  0037c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00382	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+104]
  00388	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 102  : 	return 0; //Zwrócenie wartoœæ 0, czyli porogram zakoñczy³ siê bez b³êdu

  0038e	33 c0		 xor	 eax, eax

; 103  : }

  00390	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00393	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0039a	59		 pop	 ecx
  0039b	5e		 pop	 esi
  0039c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039f	33 cd		 xor	 ecx, ebp
  003a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a6	8b e5		 mov	 esp, ebp
  003a8	5d		 pop	 ebp
  003a9	c3		 ret	 0
$_Invalid_parameter$125:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  003aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN124@main:
$LN123@main:
  003b0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
  00000	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$_main$5:
  0000b	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00011	83 e0 01	 and	 eax, 1
  00014	0f 84 10 00 00
	00		 je	 $LN28@main
  0001a	83 a5 58 fe ff
	ff fe		 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00021	8d 4d 88	 lea	 ecx, DWORD PTR _log$[ebp+120]
  00024	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN28@main:
  0002a	c3		 ret	 0
__unwindfunclet$_main$6:
  0002b	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+32]
  00031	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$_main$8:
  00037	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$_main$1:
  00043	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp]
  00049	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$_main$2:
  0004e	8d 4d d0	 lea	 ecx, DWORD PTR _typ_zak³adu$[ebp]
  00051	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$_main:
  00056	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0005d	8b 8a 54 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-428]
  00063	33 c8		 xor	 ecx, eax
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0006d	33 c8		 xor	 ecx, eax
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_main
  00079	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 1121 : 		{	// destroy the object

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8d 71 68	 lea	 esi, DWORD PTR [ecx+104]

; 1122 : 		}

  00006	8d 4e 9c	 lea	 ecx, DWORD PTR [esi-100]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  0001d	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0002f	8b ce		 mov	 ecx, esi
  00031	5e		 pop	 esi
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	68 b0 00 00 00	 push	 176			; 000000b0H
  00005	6a 00		 push	 0
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memset
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00010	c2 04 00	 ret	 4
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 1342 : 		{	// destroy the object

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8d 71 78	 lea	 esi, DWORD PTR [ecx+120]

; 1343 : 		}

  00006	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 88 00
	00 00 00	 mov	 DWORD PTR [eax+esi-120], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 88	 mov	 eax, DWORD PTR [esi-120]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 88	 lea	 eax, DWORD PTR [edx-120]
  0001d	89 44 32 84	 mov	 DWORD PTR [edx+esi-124], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0002f	8b ce		 mov	 ecx, esi
  00031	5e		 pop	 esi
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	68 c0 00 00 00	 push	 192			; 000000c0H
  00005	6a 00		 push	 0
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memset
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00010	c2 04 00	 ret	 4
?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = -20					; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Obstaw, COMDAT
; ___$ReturnUdt$ = ecx

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR ___$ReturnUdt$[ebp], esi
  0002b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 182  : 	return zaklad_typ; //Zwracam typ zak³adu podany przez u¿ytkownika

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
$LL4@Obstaw:

; 107  : 	string zaklad_typ; //Deklaracja zmiennej typu string przechowywuj¹cej typ zak³adu
; 108  : 
; 109  : 	do { //Pêtla do aby wykona³a siê conajmniej raz
; 110  : 		cout << "Jak¹ opcje chcesz obstawic ? (zgodnie z poni¿szym opisem) :" << endl; //Zadanie pytania u¿ytkownikowi

  00051	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00056	51		 push	 ecx
  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0005d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DM@FGCBIOFJ@Jak?$LJ?5opcje?5chcesz?5obstawic?5?$DP?5?$CIzg@
  00062	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00067	83 c4 04	 add	 esp, 4
  0006a	8b c8		 mov	 ecx, eax
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 111  : 		cout << "p - parzyste" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  00072	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00077	51		 push	 ecx
  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0007e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@
  00083	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00088	83 c4 04	 add	 esp, 4
  0008b	8b c8		 mov	 ecx, eax
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 112  : 		cout << "n - nieparzyste" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  00093	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00098	51		 push	 ecx
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0009f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@
  000a4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000a9	83 c4 04	 add	 esp, 4
  000ac	8b c8		 mov	 ecx, eax
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 113  : 		cout << "r - czerwone(red)" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  000b4	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000b9	51		 push	 ecx
  000ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000c0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@GOMOHEMO@r?5?9?5czerwone?$CIred?$CJ?$AA@
  000c5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000ca	83 c4 04	 add	 esp, 4
  000cd	8b c8		 mov	 ecx, eax
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 114  : 		cout << "b - czarne(black)" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  000d5	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000da	51		 push	 ecx
  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000e1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@LKBFHLDI@b?5?9?5czarne?$CIblack?$CJ?$AA@
  000e6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000eb	83 c4 04	 add	 esp, 4
  000ee	8b c8		 mov	 ecx, eax
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 115  : 		cout << "g - górna po³owa" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  000f6	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000fb	51		 push	 ecx
  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00102	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@
  00107	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0010c	83 c4 04	 add	 esp, 4
  0010f	8b c8		 mov	 ecx, eax
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 116  : 		cout << "d - dolna po³owa" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  00117	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0011c	51		 push	 ecx
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00123	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@
  00128	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0012d	83 c4 04	 add	 esp, 4
  00130	8b c8		 mov	 ecx, eax
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 117  : 		cout << "k1, k2, k3 - kolumna 1, kolumna 2, kolumna 3" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  00138	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0013d	51		 push	 ecx
  0013e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00144	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@
  00149	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0014e	83 c4 04	 add	 esp, 4
  00151	8b c8		 mov	 ecx, eax
  00153	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 118  : 		cout << "w1, w2, ..., w12 - wiersz trzech numerów" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  00159	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0015e	51		 push	 ecx
  0015f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00165	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CJ@KMEGGBFA@w1?0?5w2?0?5?4?4?4?0?5w12?5?9?5wiersz?5trzech@
  0016a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0016f	83 c4 04	 add	 esp, 4
  00172	8b c8		 mov	 ecx, eax
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 119  : 		cout << "0 - 36 - pojedyncze pole o odpowiednim numerze" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  0017a	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0017f	51		 push	 ecx
  00180	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00186	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CP@FOKBNGLG@0?5?9?536?5?9?5pojedyncze?5pole?5o?5odpow@
  0018b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00190	83 c4 04	 add	 esp, 4
  00193	8b c8		 mov	 ecx, eax
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  0019b	8b d6		 mov	 edx, esi
  0019d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  001a3	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  001a8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JBBJJEPG@p?$AA@
  001ad	8b ce		 mov	 ecx, esi
  001af	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  001b4	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  001b6	0f 85 58 04 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  001bc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EFFIKLCJ@n?$AA@
  001c1	8b ce		 mov	 ecx, esi
  001c3	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  001c8	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  001ca	0f 85 44 04 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  001d0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01KDCPPGHE@r?$AA@
  001d5	8b ce		 mov	 ecx, esi
  001d7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  001dc	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  001de	0f 85 30 04 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  001e4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01OJONOECF@b?$AA@
  001e9	8b ce		 mov	 ecx, esi
  001eb	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  001f0	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  001f2	0f 85 1c 04 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  001f8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JEJKBAGA@g?$AA@
  001fd	8b ce		 mov	 ecx, esi
  001ff	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00204	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00206	0f 85 08 04 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  0020c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LPLHEDKD@d?$AA@
  00211	8b ce		 mov	 ecx, esi
  00213	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00218	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0021a	0f 85 f4 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00220	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02ICGBAFJO@k1?$AA@
  00225	8b ce		 mov	 ecx, esi
  00227	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0022c	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0022e	0f 85 e0 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00234	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KJEMFGFN@k2?$AA@
  00239	8b ce		 mov	 ecx, esi
  0023b	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00240	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00242	0f 85 cc 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00248	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02LAFHGHBM@k3?$AA@
  0024d	8b ce		 mov	 ecx, esi
  0024f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00254	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00256	0f 85 b8 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  0025c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02JHFNFPIK@w1?$AA@
  00261	8b ce		 mov	 ecx, esi
  00263	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00268	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0026a	0f 85 a4 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00270	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02LMHAAMEJ@w2?$AA@
  00275	8b ce		 mov	 ecx, esi
  00277	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0027c	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0027e	0f 85 90 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00284	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KFGLDNAI@w3?$AA@
  00289	8b ce		 mov	 ecx, esi
  0028b	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00290	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00292	0f 85 7c 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00298	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02OKCKKLMP@w4?$AA@
  0029d	8b ce		 mov	 ecx, esi
  0029f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  002a4	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  002a6	0f 85 68 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  002ac	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02PDDBJKIO@w5?$AA@
  002b1	8b ce		 mov	 ecx, esi
  002b3	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  002b8	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  002ba	0f 85 54 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  002c0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02NIBMMJEN@w6?$AA@
  002c5	8b ce		 mov	 ecx, esi
  002c7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  002cc	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  002ce	0f 85 40 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  002d4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MBAHPIAM@w7?$AA@
  002d9	8b ce		 mov	 ecx, esi
  002db	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  002e0	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  002e2	0f 85 2c 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  002e8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02EGJPOEMD@w8?$AA@
  002ed	8b ce		 mov	 ecx, esi
  002ef	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  002f4	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  002f6	0f 85 18 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  002fc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02FPIENFIC@w9?$AA@
  00301	8b ce		 mov	 ecx, esi
  00303	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00308	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0030a	0f 85 04 03 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00310	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_03NCLMABJC@w10?$AA@
  00315	8b ce		 mov	 ecx, esi
  00317	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0031c	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0031e	0f 85 f0 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00324	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_03MLKHDAND@w11?$AA@
  00329	8b ce		 mov	 ecx, esi
  0032b	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00330	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00332	0f 85 dc 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00338	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_03OAIKGDBA@w12?$AA@
  0033d	8b ce		 mov	 ecx, esi
  0033f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00344	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00346	0f 85 c8 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  0034c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00351	8b ce		 mov	 ecx, esi
  00353	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00358	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0035a	0f 85 b4 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00360	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01HIHLOKLC@1?$AA@
  00365	8b ce		 mov	 ecx, esi
  00367	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0036c	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0036e	0f 85 a0 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00374	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01FDFGLJHB@2?$AA@
  00379	8b ce		 mov	 ecx, esi
  0037b	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00380	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00382	0f 85 8c 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00388	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EKENIIDA@3?$AA@
  0038d	8b ce		 mov	 ecx, esi
  0038f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00394	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00396	0f 85 78 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  0039c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01FAMBOPH@4?$AA@
  003a1	8b ce		 mov	 ecx, esi
  003a3	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  003a8	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  003aa	0f 85 64 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  003b0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01BMBHCPLG@5?$AA@
  003b5	8b ce		 mov	 ecx, esi
  003b7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  003bc	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  003be	0f 85 50 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  003c4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01DHDKHMHF@6?$AA@
  003c9	8b ce		 mov	 ecx, esi
  003cb	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  003d0	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  003d2	0f 85 3c 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  003d8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01COCBENDE@7?$AA@
  003dd	8b ce		 mov	 ecx, esi
  003df	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  003e4	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  003e6	0f 85 28 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  003ec	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01KJLJFBPL@8?$AA@
  003f1	8b ce		 mov	 ecx, esi
  003f3	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  003f8	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  003fa	0f 85 14 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00400	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LAKCGALK@9?$AA@
  00405	8b ce		 mov	 ecx, esi
  00407	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0040c	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0040e	0f 85 00 02 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00414	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02PKFBJPLJ@10?$AA@
  00419	8b ce		 mov	 ecx, esi
  0041b	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00420	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00422	0f 85 ec 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00428	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02ODEKKOPI@11?$AA@
  0042d	8b ce		 mov	 ecx, esi
  0042f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00434	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00436	0f 85 d8 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  0043c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MIGHPNDL@12?$AA@
  00441	8b ce		 mov	 ecx, esi
  00443	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00448	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0044a	0f 85 c4 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00450	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02NBHMMMHK@13?$AA@
  00455	8b ce		 mov	 ecx, esi
  00457	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0045c	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0045e	0f 85 b0 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00464	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02JODNFKLN@14?$AA@
  00469	8b ce		 mov	 ecx, esi
  0046b	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00470	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00472	0f 85 9c 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00478	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02IHCGGLPM@15?$AA@
  0047d	8b ce		 mov	 ecx, esi
  0047f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00484	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00486	0f 85 88 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  0048c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KMALDIDP@16?$AA@
  00491	8b ce		 mov	 ecx, esi
  00493	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00498	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0049a	0f 85 74 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  004a0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02LFBAAJHO@17?$AA@
  004a5	8b ce		 mov	 ecx, esi
  004a7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  004ac	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  004ae	0f 85 60 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  004b4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02DCIIBFLB@18?$AA@
  004b9	8b ce		 mov	 ecx, esi
  004bb	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  004c0	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  004c2	0f 85 4c 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  004c8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02CLJDCEPA@19?$AA@
  004cd	8b ce		 mov	 ecx, esi
  004cf	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  004d4	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  004d6	0f 85 38 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  004dc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02PIBHCBOA@20?$AA@
  004e1	8b ce		 mov	 ecx, esi
  004e3	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  004e8	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  004ea	0f 85 24 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  004f0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02OBAMBAKB@21?$AA@
  004f5	8b ce		 mov	 ecx, esi
  004f7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  004fc	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  004fe	0f 85 10 01 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00504	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MKCBEDGC@22?$AA@
  00509	8b ce		 mov	 ecx, esi
  0050b	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00510	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00512	0f 85 fc 00 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00518	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02NDDKHCCD@23?$AA@
  0051d	8b ce		 mov	 ecx, esi
  0051f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00524	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00526	0f 85 e8 00 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  0052c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02JMHLOEOE@24?$AA@
  00531	8b ce		 mov	 ecx, esi
  00533	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00538	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0053a	0f 85 d4 00 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00540	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02IFGANFKF@25?$AA@
  00545	8b ce		 mov	 ecx, esi
  00547	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0054c	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0054e	0f 85 c0 00 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00554	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KOENIGGG@26?$AA@
  00559	8b ce		 mov	 ecx, esi
  0055b	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00560	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00562	0f 85 ac 00 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00568	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02LHFGLHCH@27?$AA@
  0056d	8b ce		 mov	 ecx, esi
  0056f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00574	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  00576	0f 85 98 00 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  0057c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02DAMOKLOI@28?$AA@
  00581	8b ce		 mov	 ecx, esi
  00583	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00588	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0058a	0f 85 84 00 00
	00		 jne	 $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00590	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02CJNFJKKJ@29?$AA@
  00595	8b ce		 mov	 ecx, esi
  00597	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0059c	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0059e	75 74		 jne	 SHORT $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  005a0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02PJNFELNH@30?$AA@
  005a5	8b ce		 mov	 ecx, esi
  005a7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  005ac	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  005ae	75 64		 jne	 SHORT $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  005b0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02OAMOHKJG@31?$AA@
  005b5	8b ce		 mov	 ecx, esi
  005b7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  005bc	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  005be	75 54		 jne	 SHORT $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  005c0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MLODCJFF@32?$AA@
  005c5	8b ce		 mov	 ecx, esi
  005c7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  005cc	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  005ce	75 44		 jne	 SHORT $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  005d0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02NCPIBIBE@33?$AA@
  005d5	8b ce		 mov	 ecx, esi
  005d7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  005dc	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  005de	75 34		 jne	 SHORT $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  005e0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02JNLJIOND@34?$AA@
  005e5	8b ce		 mov	 ecx, esi
  005e7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  005ec	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  005ee	75 24		 jne	 SHORT $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  005f0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02IEKCLPJC@35?$AA@
  005f5	8b ce		 mov	 ecx, esi
  005f7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  005fc	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  005fe	75 14		 jne	 SHORT $LN5@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00600	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KPIPOMFB@36?$AA@
  00605	8b ce		 mov	 ecx, esi
  00607	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0060c	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 178  : 		zaklad_typ != "35" && //Sprawdzanie czy wprowadzono zak³ad na liczbê 35

  0060e	0f 84 3d fa ff
	ff		 je	 $LL4@Obstaw
$LN5@Obstaw:

; 182  : 	return zaklad_typ; //Zwracam typ zak³adu podany przez u¿ytkownika

  00614	8b c6		 mov	 eax, esi

; 183  : }

  00616	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00619	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00620	59		 pop	 ecx
  00621	5e		 pop	 esi
  00622	8b e5		 mov	 esp, ebp
  00624	5d		 pop	 ebp
  00625	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@Obstaw
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@Obstaw:
  00018	c3		 ret	 0
__ehhandler$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Obstaw
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z
_TEXT	SEGMENT
_iloœæ_pieniêdzy$GSCopy$1$ = -48			; size = 4
_kwota_zak³adu$GSCopy$1$ = -44				; size = 4
_kwota_zak³adu_s$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z PROC		; Wczytaj_Kwotê_Zak³adu, COMDAT
; _kwota_zak³adu$ = ecx
; _iloœæ_pieniêdzy$ = edx

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b da		 mov	 ebx, edx
  0002d	89 5d d0	 mov	 DWORD PTR _iloœæ_pieniêdzy$GSCopy$1$[ebp], ebx
  00030	8b f1		 mov	 esi, ecx
  00032	89 75 d4	 mov	 DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00035	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _kwota_zak³adu_s$[ebp+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _kwota_zak³adu_s$[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00043	c6 45 d8 00	 mov	 BYTE PTR _kwota_zak³adu_s$[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 187  : 	string kwota_zak³adu_s; //Deklaracja zmiennej typu string do wczytywania kwoty aby zabezpieczyæ siê przed b³êdem wpisania do zmiennej liczbowej litery

  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004e	66 90		 npad	 2
$LL2@Wczytaj_Kw:

; 188  : 
; 189  : 	while (true) //Rozpoczêcie pêtli nieskoñczonej
; 190  : 	{
; 191  : 		cout << "Masz " << iloœæ_pieniêdzy << "$, jak¹ kwotê chcesz obstawiæ wynik?" << endl; //Podanie akualnego stanu konta i zadanie pytania o kwotê zak³adu

  00050	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00055	51		 push	 ecx
  00056	ff 33		 push	 DWORD PTR [ebx]
  00058	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05OMMBNPEF@Masz?5?$AA@
  0005d	51		 push	 ecx
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00064	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00069	83 c4 04	 add	 esp, 4
  0006c	8b c8		 mov	 ecx, eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00074	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CF@BGACGNBA@$?0?5jak?$LJ?5kwot?j?5chcesz?5obstawi?f?5wy@
  00079	8b c8		 mov	 ecx, eax
  0007b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00080	83 c4 04	 add	 esp, 4
  00083	8b c8		 mov	 ecx, eax
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  00091	8d 55 d8	 lea	 edx, DWORD PTR _kwota_zak³adu_s$[ebp]
  00094	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00099	83 7d ec 10	 cmp	 DWORD PTR _kwota_zak³adu_s$[ebp+20], 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0009d	8d 45 d8	 lea	 eax, DWORD PTR _kwota_zak³adu_s$[ebp]

; 1607 : 		if (_Large_string_engaged())

  000a0	0f 43 45 d8	 cmovae	 eax, DWORD PTR _kwota_zak³adu_s$[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 193  : 		kwota_zak³adu = atoi(kwota_zak³adu_s.c_str()); //Zmiana stringaa na inta i wpisanie do zmiennej kwota_zak³adu

  000a4	50		 push	 eax
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  000ab	83 c4 04	 add	 esp, 4
  000ae	89 06		 mov	 DWORD PTR [esi], eax

; 194  : 		if (kwota_zak³adu > 0 && kwota_zak³adu <= iloœæ_pieniêdzy) //Sprawdzenie czy kwota zak³¹du jest wiêksza od zeri i mniejsza lub równa dostêpnej gotówce

  000b0	85 c0		 test	 eax, eax
  000b2	7e 0a		 jle	 SHORT $LN154@Wczytaj_Kw
  000b4	3b 03		 cmp	 eax, DWORD PTR [ebx]
  000b6	0f 8e d8 00 00
	00		 jle	 $LN141@Wczytaj_Kw

; 195  : 			break; //Je¿eli tak to zatrzymuje pêtle
; 196  : 		else //W przeciwym wypadku
; 197  : 			if (kwota_zak³adu == 0) //Je¿eli wynikiem zamiany na liczbê jest zero (wynikiem zamiany jest zero kiedy tekst to zero lub kiedy jest b³¹d zamiany) to

  000bc	85 c0		 test	 eax, eax
$LN154@Wczytaj_Kw:
  000be	75 7d		 jne	 SHORT $LN9@Wczytaj_Kw

; 198  : 			{
; 199  : 				bool czy_zero = true; //Utworzenie zmiennej informuj¹cej czy znaleziono zero w tekœcie i przypisanie jej wartoœci true
; 200  : 				for (unsigned short i = 0; i < (unsigned short)kwota_zak³adu_s.size(); ++i) //Rozpoczêcie pêtli numerowanej przez zmienn¹ i przez wszystkie znaki wczytanego tekst

  000c0	66 8b 75 e8	 mov	 si, WORD PTR _kwota_zak³adu_s$[ebp+16]
  000c4	33 c9		 xor	 ecx, ecx
  000c6	33 c0		 xor	 eax, eax
  000c8	66 3b ce	 cmp	 cx, si
  000cb	73 21		 jae	 SHORT $LN147@Wczytaj_Kw
  000cd	8b 7d ec	 mov	 edi, DWORD PTR _kwota_zak³adu_s$[ebp+20]
  000d0	8b 5d d8	 mov	 ebx, DWORD PTR _kwota_zak³adu_s$[ebp]
$LL6@Wczytaj_Kw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000d3	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 201  : 					if (kwota_zak³adu_s[i] != '0') //Je¿eli znak na i-tej pozycji

  000d6	0f b7 c8	 movzx	 ecx, ax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  000d9	8d 55 d8	 lea	 edx, DWORD PTR _kwota_zak³adu_s$[ebp]

; 1596 : 		if (_Large_string_engaged())

  000dc	0f 43 d3	 cmovae	 edx, ebx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 201  : 					if (kwota_zak³adu_s[i] != '0') //Je¿eli znak na i-tej pozycji

  000df	80 3c 11 30	 cmp	 BYTE PTR [ecx+edx], 48	; 00000030H
  000e3	75 2f		 jne	 SHORT $LN140@Wczytaj_Kw

; 198  : 			{
; 199  : 				bool czy_zero = true; //Utworzenie zmiennej informuj¹cej czy znaleziono zero w tekœcie i przypisanie jej wartoœci true
; 200  : 				for (unsigned short i = 0; i < (unsigned short)kwota_zak³adu_s.size(); ++i) //Rozpoczêcie pêtli numerowanej przez zmienn¹ i przez wszystkie znaki wczytanego tekst

  000e5	40		 inc	 eax
  000e6	66 3b c6	 cmp	 ax, si
  000e9	72 e8		 jb	 SHORT $LL6@Wczytaj_Kw

; 194  : 		if (kwota_zak³adu > 0 && kwota_zak³adu <= iloœæ_pieniêdzy) //Sprawdzenie czy kwota zak³¹du jest wiêksza od zeri i mniejsza lub równa dostêpnej gotówce

  000eb	8b 5d d0	 mov	 ebx, DWORD PTR _iloœæ_pieniêdzy$GSCopy$1$[ebp]
$LN147@Wczytaj_Kw:

; 209  : 				{
; 210  : 					cout << "Nie mo¿esz obstawiæ zerowego zak³adu" << endl; //Poinformowanie u¿ytkownika, ¿e nie mo¿e obstawiæ zerowego zak³adu

  000ee	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000f3	51		 push	 ecx
  000f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000fa	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@
  000ff	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00104	83 c4 04	 add	 esp, 4
  00107	8b c8		 mov	 ecx, eax
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 211  : 					if (stan_dŸwiêków) cout << "\a"; //Wywo³anie pikniêcia w g³oœniku

  0010f	8b 75 d4	 mov	 esi, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]

; 212  : 				}
; 213  : 			}

  00112	eb 5d		 jmp	 SHORT $LN155@Wczytaj_Kw
$LN140@Wczytaj_Kw:

; 202  : 					{
; 203  : 						cout << "Wprowadzi³eæ nieprawid³ow¹ wartoœæ" << endl; //Poinformowanie u¿ytkownika, ¿e nie mo¿e obstawiæ tekstowego

  00114	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00119	51		 push	 ecx
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00120	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@
  00125	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0012a	83 c4 04	 add	 esp, 4
  0012d	8b c8		 mov	 ecx, eax
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 204  : 						if (stan_dŸwiêków) cout << "\a"; //Wywo³anie pikniêcia w g³oœniku

  00135	8b 5d d0	 mov	 ebx, DWORD PTR _iloœæ_pieniêdzy$GSCopy$1$[ebp]
  00138	8b 75 d4	 mov	 esi, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]

; 205  : 						czy_zero = false; //Zmiana wartoœci zmiennej czy znaleziono zero w tekœcie na false
; 206  : 						break; //Zatrzymanie pêtli
; 207  : 					}
; 208  : 				if (czy_zero) //Sprawdzenie czy znaleziono same zera w tekœcie, je¿eli tak to

  0013b	eb 34		 jmp	 SHORT $LN155@Wczytaj_Kw
$LN9@Wczytaj_Kw:

; 214  : 			else if (kwota_zak³adu > iloœæ_pieniêdzy) //Je¿eli u¿ytkownik chce obstawiæ za wiêcej ni¿ ma, to

  0013d	3b 03		 cmp	 eax, DWORD PTR [ebx]
  0013f	7e 07		 jle	 SHORT $LN15@Wczytaj_Kw

; 215  : 			{
; 216  : 				cout << "Nie masz tyle pieniêdzy" << endl; //Poinformowanie go o tym

  00141	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@

; 217  : 				if (stan_dŸwiêków) cout << "\a"; //Wywo³anie pikniêcia w g³oœniku
; 218  : 			}

  00146	eb 0d		 jmp	 SHORT $LN156@Wczytaj_Kw
$LN15@Wczytaj_Kw:

; 219  : 			else if (kwota_zak³adu < 0) //Je¿eli u¿ytkownik chce obstawiæ za ujemn¹ kwotê, to

  00148	85 c0		 test	 eax, eax
  0014a	0f 89 00 ff ff
	ff		 jns	 $LL2@Wczytaj_Kw

; 220  : 			{
; 221  : 				cout << "Nie mo¿esz obstawiæ ujemn¹ kwot¹ zak³adu" << endl; //Poinformowanie go o tym

  00150	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@
$LN156@Wczytaj_Kw:
  00155	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0015a	51		 push	 ecx
  0015b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00161	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00166	83 c4 04	 add	 esp, 4
  00169	8b c8		 mov	 ecx, eax
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN155@Wczytaj_Kw:

; 222  : 				if (stan_dŸwiêków) cout << "\a"; //Wywo³anie pikniêcia w g³oœniku

  00171	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?stan_dŸwiêków@@3FA, 0 ; stan_dŸwiêków
  00179	0f 84 d1 fe ff
	ff		 je	 $LL2@Wczytaj_Kw
  0017f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00185	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01PBGHHLMH@?$AH?$AA@
  0018a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 223  : 			}
; 224  : 	}

  0018f	e9 bc fe ff ff	 jmp	 $LL2@Wczytaj_Kw
$LN141@Wczytaj_Kw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00194	8b 45 ec	 mov	 eax, DWORD PTR _kwota_zak³adu_s$[ebp+20]
  00197	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  0019a	72 2e		 jb	 SHORT $LN117@Wczytaj_Kw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0019c	8b 4d d8	 mov	 ecx, DWORD PTR _kwota_zak³adu_s$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0019f	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  001a0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001a5	72 1a		 jb	 SHORT $LN120@Wczytaj_Kw

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  001a7	f6 c1 1f	 test	 cl, 31			; 0000001fH
  001aa	75 3a		 jne	 SHORT $_Invalid_parameter$158

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001ac	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  001af	3b c1		 cmp	 eax, ecx
  001b1	73 33		 jae	 SHORT $_Invalid_parameter$158

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001b3	2b c8		 sub	 ecx, eax
  001b5	83 f9 04	 cmp	 ecx, 4
  001b8	72 2c		 jb	 SHORT $_Invalid_parameter$158

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  001ba	83 f9 23	 cmp	 ecx, 35			; 00000023H
  001bd	77 27		 ja	 SHORT $_Invalid_parameter$158

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  001bf	8b c8		 mov	 ecx, eax
$LN120@Wczytaj_Kw:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  001c1	51		 push	 ecx
  001c2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001c7	83 c4 04	 add	 esp, 4
$LN117@Wczytaj_Kw:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 225  : }

  001ca	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001cd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d4	59		 pop	 ecx
  001d5	5f		 pop	 edi
  001d6	5e		 pop	 esi
  001d7	5b		 pop	 ebx
  001d8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001db	33 cd		 xor	 ecx, ebp
  001dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	c3		 ret	 0
$_Invalid_parameter$158:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN157@Wczytaj_Kw:
$LN151@Wczytaj_Kw:
  001ec	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _kwota_zak³adu_s$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z ENDP		; Wczytaj_Kwotê_Zak³adu
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Zakrêæ_Ruletk¹@@YAHXZ
_TEXT	SEGMENT
$T13 = -64						; size = 24
_czas_przeskoku_kulki_wolny_przyspieszenie$1$ = -40	; size = 8
_czas_przeskoku_kulki_szybki_opóŸnienie$1$ = -40	; size = 8
_distribution$25 = -32					; size = 8
_wylosowana_pozycja$1$ = -28				; size = 4
_iloœæ_zakrêceñ$1$ = -28				; size = 4
tv931 = -24						; size = 8
_hCCI$26 = -24						; size = 8
_hCCI$27 = -24						; size = 8
_i$1$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Zakrêæ_Ruletk¹@@YAHXZ PROC				; Zakrêæ_Ruletk¹, COMDAT

; 228  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Zakrêæ_Ruletk¹@@YAHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 229  : 	int iloœæ_zakrêceñ = rand() % (iloœæ_max_dodatkowych_obrotów_ruletki + 1) + iloœæ_minimalna_obrotów_ruletki; //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ pseudolosow¹ (o niskiej pseoudolosowoœci) iloœæ obrotów ruletk¹ ((od 0 do max dodatkowych obrotów ruletki) + minimalna iloœæ obrotów ruletki) zanim nastêpi finalny obrót

  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00031	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA ; iloœæ_max_dodatkowych_obrotów_ruletki
  00038	41		 inc	 ecx
  00039	99		 cdq
  0003a	f7 f9		 idiv	 ecx
  0003c	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA ; iloœæ_minimalna_obrotów_ruletki

; 230  : 	double czas_przeskoku_kulki_szybki_opóŸnienie = czas_przeskoku_kulki_szybki / (iloœæ_zakrêceñ * 37.0); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoœæ na kole ruletki powinna byæ szybciej pokazana

  00043	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?czas_przeskoku_kulki_szybki@@3FA ; czas_przeskoku_kulki_szybki
  0004a	03 ca		 add	 ecx, edx

; 342  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  0004c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetStdHandle@4
  00052	6a f5		 push	 -11			; fffffff5H

; 229  : 	int iloœæ_zakrêceñ = rand() % (iloœæ_max_dodatkowych_obrotów_ruletki + 1) + iloœæ_minimalna_obrotów_ruletki; //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ pseudolosow¹ (o niskiej pseoudolosowoœci) iloœæ obrotów ruletk¹ ((od 0 do max dodatkowych obrotów ruletki) + minimalna iloœæ obrotów ruletki) zanim nastêpi finalny obrót

  00054	89 4d e4	 mov	 DWORD PTR _iloœæ_zakrêceñ$1$[ebp], ecx
  00057	66 0f 6e c1	 movd	 xmm0, ecx

; 230  : 	double czas_przeskoku_kulki_szybki_opóŸnienie = czas_przeskoku_kulki_szybki / (iloœæ_zakrêceñ * 37.0); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoœæ na kole ruletki powinna byæ szybciej pokazana

  0005b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0005f	66 0f 6e c8	 movd	 xmm1, eax
  00063	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4042800000000000
  0006b	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0006f	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00073	f2 0f 11 4d d8	 movsd	 QWORD PTR _czas_przeskoku_kulki_szybki_opóŸnienie$1$[ebp], xmm1

; 342  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00078	ff d7		 call	 edi
  0007a	8b f0		 mov	 esi, eax

; 343  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 344  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0007c	8d 45 e8	 lea	 eax, DWORD PTR _hCCI$27[ebp]
  0007f	50		 push	 eax
  00080	56		 push	 esi
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 345  : 	hCCI.bVisible = FALSE; //Zmiena widocznoœci kursora na niewidoczny
; 346  : 	SetConsoleCursorInfo(hConsoleOut, &hCCI); //Ustawienie widocznoœci kursora zgodnie z poprzedni¹ zmienn¹

  00087	8d 45 e8	 lea	 eax, DWORD PTR _hCCI$27[ebp]
  0008a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _hCCI$27[ebp+4], 0
  00091	50		 push	 eax
  00092	56		 push	 esi
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8

; 229  : 	int iloœæ_zakrêceñ = rand() % (iloœæ_max_dodatkowych_obrotów_ruletki + 1) + iloœæ_minimalna_obrotów_ruletki; //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ pseudolosow¹ (o niskiej pseoudolosowoœci) iloœæ obrotów ruletk¹ ((od 0 do max dodatkowych obrotów ruletki) + minimalna iloœæ obrotów ruletki) zanim nastêpi finalny obrót

  00099	33 db		 xor	 ebx, ebx

; 231  : 	Hide_Cursor(); //Ukrycie kursora tekstowego w konsoli
; 232  : 	for (int i = 0; i < iloœæ_zakrêceñ; ++i) //Wykonanie iloœæ_zakrêceñ obrotów ruletk¹

  0009b	39 5d e4	 cmp	 DWORD PTR _iloœæ_zakrêceñ$1$[ebp], ebx
  0009e	0f 8e bd 00 00
	00		 jle	 $LL3@Zakr?
$LL4@Zakr?:
  000a4	66 0f 6e c3	 movd	 xmm0, ebx

; 233  : 		for (int ii = 0; ii < 37; ++ii) //Przejœcie przez wszystkie pozycje ruletki

  000a8	33 ff		 xor	 edi, edi
  000aa	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000ae	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4042800000000000
  000b6	f2 0f 11 45 e8	 movsd	 QWORD PTR tv931[ebp], xmm0
  000bb	0f 1f 44 00 00	 npad	 5
$LL7@Zakr?:

; 234  : 		{
; 235  : 			Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[ii]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  000c0	8b 34 bd 00 00
	00 00		 mov	 esi, DWORD PTR ?Ruletka_ko³o@@3QBHB[edi*4]

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  000c7	6a f5		 push	 -11			; fffffff5H
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  000cf	0f b7 0c b5 00
	00 00 00	 movzx	 ecx, WORD PTR ?Ruletka_plansza_kolor_col@@3QBHB[esi*4]
  000d7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetConsoleTextAttribute@8
  000dd	51		 push	 ecx
  000de	50		 push	 eax
  000df	ff d6		 call	 esi

; 236  : 			cout << Ruletka_ko³o[ii]; //Wypisanie numeru na kole ruletki na którym znajduje siê pêtla

  000e1	ff 34 bd 00 00
	00 00		 push	 DWORD PTR ?Ruletka_ko³o@@3QBHB[edi*4]
  000e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000f4	66 0f 6e c7	 movd	 xmm0, edi

; 237  : 			Sleep((DWORD)(czas_przeskoku_kulki_szybki_opóŸnienie*((double)i*37.0 + (double)ii))); //Przestój który zwiêksza siê co zmianê pozycji pêtli

  000f8	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000fc	f2 0f 58 45 e8	 addsd	 xmm0, QWORD PTR tv931[ebp]
  00101	f2 0f 59 45 d8	 mulsd	 xmm0, QWORD PTR _czas_przeskoku_kulki_szybki_opóŸnienie$1$[ebp]
  00106	e8 00 00 00 00	 call	 __dtoui3
  0010b	50		 push	 eax
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00112	6a f5		 push	 -11			; fffffff5H
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0011a	6a 07		 push	 7
  0011c	50		 push	 eax
  0011d	ff d6		 call	 esi

; 238  : 			Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 239  : 			cout << "\b\b" << "  " << "\b\b"; //Cofniêcie kursora tekstowego do lewej strony konsoli aby zape³niæ podem spacjami czyli niewidocznym znakiem wiersza konsoli aby widaæ przejœcie pomiêdzy liczbami na ruletce

  0011f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00125	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  0012a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0012f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
  00134	8b c8		 mov	 ecx, eax
  00136	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0013b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  00140	8b c8		 mov	 ecx, eax
  00142	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00147	47		 inc	 edi
  00148	83 ff 25	 cmp	 edi, 37			; 00000025H
  0014b	0f 8c 6f ff ff
	ff		 jl	 $LL7@Zakr?

; 231  : 	Hide_Cursor(); //Ukrycie kursora tekstowego w konsoli
; 232  : 	for (int i = 0; i < iloœæ_zakrêceñ; ++i) //Wykonanie iloœæ_zakrêceñ obrotów ruletk¹

  00151	43		 inc	 ebx
  00152	3b 5d e4	 cmp	 ebx, DWORD PTR _iloœæ_zakrêceñ$1$[ebp]
  00155	0f 8c 49 ff ff
	ff		 jl	 $LL4@Zakr?
  0015b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetStdHandle@4
$LL3@Zakr?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00161	6a 00		 push	 0
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00168	8d 4d c0	 lea	 ecx, DWORD PTR $T13[ebp]

; 3698 : 		_My_data._Mysize = 0;

  0016b	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T13[ebp+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00172	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T13[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00179	c6 45 c0 00	 mov	 BYTE PTR $T13[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0017d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 382  : 	random_device generator; //Generator liczb losowych, który generuje niedeterministyczne liczby losowe, jeœli s¹ obs³ugiwane.

  00182	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 382  : 	random_device generator; //Generator liczb losowych, który generuje niedeterministyczne liczby losowe, jeœli s¹ obs³ugiwane.

  0018f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00196	8b 45 d4	 mov	 eax, DWORD PTR $T13[ebp+20]
  00199	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  0019c	72 3e		 jb	 SHORT $LN187@Zakr?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0019e	8b 4d c0	 mov	 ecx, DWORD PTR $T13[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001a1	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  001a2	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001a7	72 2a		 jb	 SHORT $LN190@Zakr?

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  001a9	f6 c1 1f	 test	 cl, 31			; 0000001fH
  001ac	0f 85 bc 01 00
	00		 jne	 $_Invalid_parameter$264

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001b2	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  001b5	3b c1		 cmp	 eax, ecx
  001b7	0f 83 b1 01 00
	00		 jae	 $_Invalid_parameter$264

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001bd	2b c8		 sub	 ecx, eax
  001bf	83 f9 04	 cmp	 ecx, 4
  001c2	0f 82 a6 01 00
	00		 jb	 $_Invalid_parameter$264

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  001c8	83 f9 23	 cmp	 ecx, 35			; 00000023H
  001cb	0f 87 9d 01 00
	00		 ja	 $_Invalid_parameter$264

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  001d1	8b c8		 mov	 ecx, eax
$LN190@Zakr?:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  001d3	51		 push	 ecx
  001d4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d9	83 c4 04	 add	 esp, 4
$LN187@Zakr?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 394  : 	return distribution(generator); //Zwraca wygenerowan¹ liczbê

  001dc	51		 push	 ecx
  001dd	8d 4d e0	 lea	 ecx, DWORD PTR _distribution$25[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2256 : 			_Min = _Min0;

  001e0	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _distribution$25[ebp], 0

; 2257 : 			_Max = _Max0;

  001e7	c7 45 e4 24 00
	00 00		 mov	 DWORD PTR _distribution$25[ebp+4], 36 ; 00000024H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 394  : 	return distribution(generator); //Zwraca wygenerowan¹ liczbê

  001ee	e8 00 00 00 00	 call	 ??$?RVrandom_device@std@@@?$uniform_int@H@std@@QBEHAAVrandom_device@1@@Z ; std::uniform_int<int>::operator()<std::random_device>

; 240  : 		}
; 241  : 	int wylosowana_pozycja = Wylosuj(0, 36); //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ losow¹ lub pseudolosow¹ liczbê (o wysokiej pseoudolosowoœci) pozycjê na ruletce
; 242  : 	double czas_przeskoku_kulki_wolny_przyspieszenie = (czas_przeskoku_kulki_wolny - czas_przeskoku_kulki_szybki) / (double)(wylosowana_pozycja); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoœæ na kole ruletki powinna byæ szybciej pokazana

  001f3	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?czas_przeskoku_kulki_wolny@@3FA ; czas_przeskoku_kulki_wolny
  001fa	33 f6		 xor	 esi, esi
  001fc	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?czas_przeskoku_kulki_szybki@@3FA ; czas_przeskoku_kulki_szybki
  00203	2b d1		 sub	 edx, ecx
  00205	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SetConsoleTextAttribute@8
  0020b	66 0f 6e c0	 movd	 xmm0, eax

; 394  : 	return distribution(generator); //Zwraca wygenerowan¹ liczbê

  0020f	89 45 e4	 mov	 DWORD PTR _wylosowana_pozycja$1$[ebp], eax

; 240  : 		}
; 241  : 	int wylosowana_pozycja = Wylosuj(0, 36); //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ losow¹ lub pseudolosow¹ liczbê (o wysokiej pseoudolosowoœci) pozycjê na ruletce
; 242  : 	double czas_przeskoku_kulki_wolny_przyspieszenie = (czas_przeskoku_kulki_wolny - czas_przeskoku_kulki_szybki) / (double)(wylosowana_pozycja); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoœæ na kole ruletki powinna byæ szybciej pokazana

  00212	89 75 ec	 mov	 DWORD PTR _i$1$[ebp], esi
  00215	66 0f 6e ca	 movd	 xmm1, edx
  00219	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0021d	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00221	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00225	f2 0f 11 4d d8	 movsd	 QWORD PTR _czas_przeskoku_kulki_wolny_przyspieszenie$1$[ebp], xmm1

; 243  : 	for (int i = 0; i < wylosowana_pozycja; ++i) //Przejœcie przez pozycje do pozycji o 1 mniejszej od wylosowanej pozyji na ruletce

  0022a	85 c0		 test	 eax, eax
  0022c	0f 8e 97 00 00
	00		 jle	 $LN9@Zakr?
$LL10@Zakr?:

; 244  : 	{
; 245  : 		Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[i]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  00232	8b 34 b5 00 00
	00 00		 mov	 esi, DWORD PTR ?Ruletka_ko³o@@3QBHB[esi*4]

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00239	6a f5		 push	 -11			; fffffff5H
  0023b	ff d7		 call	 edi

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0023d	0f b7 0c b5 00
	00 00 00	 movzx	 ecx, WORD PTR ?Ruletka_plansza_kolor_col@@3QBHB[esi*4]
  00245	51		 push	 ecx
  00246	50		 push	 eax
  00247	ff d3		 call	 ebx

; 246  : 		cout << Ruletka_ko³o[i]; //Wypisanie numeru na kole ruletki na którym znajduje siê pêtla

  00249	8b 75 ec	 mov	 esi, DWORD PTR _i$1$[ebp]
  0024c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00252	ff 34 b5 00 00
	00 00		 push	 DWORD PTR ?Ruletka_ko³o@@3QBHB[esi*4]
  00259	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z

; 247  : 		Sleep((DWORD)(czas_przeskoku_kulki_szybki + (czas_przeskoku_kulki_wolny_przyspieszenie*i))); //Przestój który zwiêksza siê co zmianê pozycji pêtli

  0025f	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?czas_przeskoku_kulki_szybki@@3FA ; czas_przeskoku_kulki_szybki
  00266	66 0f 6e c6	 movd	 xmm0, esi
  0026a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0026e	66 0f 6e c8	 movd	 xmm1, eax
  00272	f2 0f 59 45 d8	 mulsd	 xmm0, QWORD PTR _czas_przeskoku_kulki_wolny_przyspieszenie$1$[ebp]
  00277	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0027b	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0027f	e8 00 00 00 00	 call	 __dtoui3
  00284	50		 push	 eax
  00285	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  0028b	6a f5		 push	 -11			; fffffff5H
  0028d	ff d7		 call	 edi

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0028f	6a 07		 push	 7
  00291	50		 push	 eax
  00292	ff d3		 call	 ebx

; 248  : 		Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 249  : 		cout << "\b\b" << "  " << "\b\b"; //Cofniêcie kursora tekstowego do lewej strony konsoli aby zape³niæ podem spacjami czyli niewidocznym znakiem wiersza konsoli aby widaæ przejœcie pomiêdzy liczbami na ruletce

  00294	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0029a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  0029f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002a4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
  002a9	8b c8		 mov	 ecx, eax
  002ab	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002b0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  002b5	8b c8		 mov	 ecx, eax
  002b7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002bc	46		 inc	 esi
  002bd	89 75 ec	 mov	 DWORD PTR _i$1$[ebp], esi
  002c0	3b 75 e4	 cmp	 esi, DWORD PTR _wylosowana_pozycja$1$[ebp]
  002c3	0f 8c 69 ff ff
	ff		 jl	 $LL10@Zakr?
$LN9@Zakr?:

; 250  : 	}
; 251  : 	cout << "Wylosowano numer "; //Poinformowanie o zakoñczeniu (wyœwietlania) losowania

  002c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002cf	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
  002d4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 252  : 	Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[wylosowana_pozycja]]);//Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  002d9	8b 45 e4	 mov	 eax, DWORD PTR _wylosowana_pozycja$1$[ebp]

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  002dc	6a f5		 push	 -11			; fffffff5H

; 252  : 	Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[wylosowana_pozycja]]);//Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  002de	8b 34 85 00 00
	00 00		 mov	 esi, DWORD PTR ?Ruletka_ko³o@@3QBHB[eax*4]

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  002e5	ff d7		 call	 edi

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  002e7	0f b7 0c b5 00
	00 00 00	 movzx	 ecx, WORD PTR ?Ruletka_plansza_kolor_col@@3QBHB[esi*4]
  002ef	51		 push	 ecx
  002f0	50		 push	 eax
  002f1	ff d3		 call	 ebx

; 253  : 	cout << Ruletka_ko³o[wylosowana_pozycja]; //Wypisanie liczby na wylosowanej pozycji ruletki

  002f3	8b 75 e4	 mov	 esi, DWORD PTR _wylosowana_pozycja$1$[ebp]
  002f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002fc	ff 34 b5 00 00
	00 00		 push	 DWORD PTR ?Ruletka_ko³o@@3QBHB[esi*4]
  00303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00309	6a f5		 push	 -11			; fffffff5H
  0030b	ff d7		 call	 edi

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0030d	6a 07		 push	 7
  0030f	50		 push	 eax
  00310	ff d3		 call	 ebx

; 254  : 	Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 255  : 	cout << ". "; //Zakoñczenie tekstu kropk¹

  00312	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00318	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KHOJGJKF@?4?5?$AA@
  0031d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 351  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00322	6a f5		 push	 -11			; fffffff5H
  00324	ff d7		 call	 edi
  00326	8b f8		 mov	 edi, eax

; 352  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 353  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  00328	8d 45 e8	 lea	 eax, DWORD PTR _hCCI$26[ebp]
  0032b	50		 push	 eax
  0032c	57		 push	 edi
  0032d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 354  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoœæ widocznoœci kursorsora tekstego w konsoli jest ró¿na od prawdy

  00333	83 7d ec 01	 cmp	 DWORD PTR _hCCI$26[ebp+4], 1
  00337	74 12		 je	 SHORT $LN238@Zakr?

; 355  : 	{
; 356  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoœci kursora na widoczny
; 357  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoœci kursora zgodnie z poprzedni¹ zmienn¹

  00339	8d 45 e8	 lea	 eax, DWORD PTR _hCCI$26[ebp]
  0033c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _hCCI$26[ebp+4], 1
  00343	50		 push	 eax
  00344	57		 push	 edi
  00345	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8
$LN238@Zakr?:

; 256  : 	Show_Cursor(); //Pokazanie kursora tekstowego w konsoli
; 257  : 
; 258  : 	return Ruletka_ko³o[wylosowana_pozycja]; //Zwracam wartoœæ bêd¹c¹ na wylosowanym polu ruletki

  0034b	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR ?Ruletka_ko³o@@3QBHB[esi*4]

; 259  : }

  00352	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00355	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0035c	59		 pop	 ecx
  0035d	5f		 pop	 edi
  0035e	5e		 pop	 esi
  0035f	5b		 pop	 ebx
  00360	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00363	33 cd		 xor	 ecx, ebp
  00365	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0036a	8b e5		 mov	 esp, ebp
  0036c	5d		 pop	 ebp
  0036d	c3		 ret	 0
$_Invalid_parameter$264:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0036e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN263@Zakr?:
$LN262@Zakr?:
  00374	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Zakrêæ_Ruletk¹@@YAHXZ$1:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR $T13[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Zakrêæ_Ruletk¹@@YAHXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Zakrêæ_Ruletk¹@@YAHXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Zakrêæ_Ruletk¹@@YAHXZ ENDP				; Zakrêæ_Ruletk¹
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?SprawdŸ_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
_kwota$1$ = -4						; size = 4
_wylosowana_liczba$ = 8					; size = 4
?SprawdŸ_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; SprawdŸ_Zak³ad, COMDAT
; _kwota$ = ecx
; _typ_zak³adu$ = edx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b c1		 mov	 eax, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 45 fc	 mov	 DWORD PTR _kwota$1$[ebp], eax
  0000e	8b f2		 mov	 esi, edx

; 295  : 			if (wylosowana_liczba > 18) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest od 19 do 36, je¿eli tak to wygrana jest 1:1

  00010	8b 38		 mov	 edi, DWORD PTR [eax]
  00012	8b 45 08	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00015	8b 18		 mov	 ebx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00017	8b c6		 mov	 eax, esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 265  : 	if (wylosowana_liczba == 0) //Warunek sprawdzaj¹cy czy wylosowano 0

  00019	85 db		 test	 ebx, ebx
  0001b	0f 85 04 01 00
	00		 jne	 $LN2@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00021	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00024	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00027	72 02		 jb	 SHORT $LN75@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00029	8b 06		 mov	 eax, DWORD PTR [esi]
$LN75@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0002b	83 7e 10 01	 cmp	 DWORD PTR [esi+16], 1
  0002f	75 22		 jne	 SHORT $LN4@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00031	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00034	3c 70		 cmp	 al, 112			; 00000070H
  00036	75 04		 jne	 SHORT $LN241@SprawdŸ_Z
  00038	33 c0		 xor	 eax, eax
  0003a	eb 05		 jmp	 SHORT $LN242@SprawdŸ_Z
$LN241@SprawdŸ_Z:
  0003c	1b c0		 sbb	 eax, eax
  0003e	83 c8 01	 or	 eax, 1
$LN242@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00041	85 c0		 test	 eax, eax
  00043	75 0e		 jne	 SHORT $LN4@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 267  : 		if (typ_zak³adu == "p") wygrana /= 2; //Je¿eli typ zak³adu by³ p to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  00045	8b c7		 mov	 eax, edi
  00047	99		 cdq
  00048	2b c2		 sub	 eax, edx
  0004a	8b f8		 mov	 edi, eax
  0004c	d1 ff		 sar	 edi, 1
  0004e	e9 2c 02 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN4@SprawdŸ_Z:

; 268  : 		else if (typ_zak³adu == "n") wygrana /= 2; //Je¿eli typ zak³adu by³ p to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  00053	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EFFIKLCJ@n?$AA@
  00058	8b ce		 mov	 ecx, esi
  0005a	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0005f	84 c0		 test	 al, al
  00061	74 0e		 je	 SHORT $LN6@SprawdŸ_Z
  00063	8b c7		 mov	 eax, edi
  00065	99		 cdq
  00066	2b c2		 sub	 eax, edx
  00068	8b f8		 mov	 edi, eax
  0006a	d1 ff		 sar	 edi, 1
  0006c	e9 0e 02 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN6@SprawdŸ_Z:

; 269  : 		else if (typ_zak³adu == "r") wygrana /= 2; //Je¿eli typ zak³adu by³ r to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  00071	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0007d	84 c0		 test	 al, al
  0007f	74 0e		 je	 SHORT $LN8@SprawdŸ_Z
  00081	8b c7		 mov	 eax, edi
  00083	99		 cdq
  00084	2b c2		 sub	 eax, edx
  00086	8b f8		 mov	 edi, eax
  00088	d1 ff		 sar	 edi, 1
  0008a	e9 f0 01 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN8@SprawdŸ_Z:

; 270  : 		else if (typ_zak³adu == "b") wygrana /= 2; //Je¿eli typ zak³adu by³ b to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  0008f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01OJONOECF@b?$AA@
  00094	8b ce		 mov	 ecx, esi
  00096	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0009b	84 c0		 test	 al, al
  0009d	74 0e		 je	 SHORT $LN10@SprawdŸ_Z
  0009f	8b c7		 mov	 eax, edi
  000a1	99		 cdq
  000a2	2b c2		 sub	 eax, edx
  000a4	8b f8		 mov	 edi, eax
  000a6	d1 ff		 sar	 edi, 1
  000a8	e9 d2 01 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN10@SprawdŸ_Z:

; 271  : 		else if (typ_zak³adu == "g") wygrana /= 2; //Je¿eli typ zak³adu by³ g to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  000ad	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JEJKBAGA@g?$AA@
  000b2	8b ce		 mov	 ecx, esi
  000b4	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  000b9	84 c0		 test	 al, al
  000bb	74 0e		 je	 SHORT $LN12@SprawdŸ_Z
  000bd	8b c7		 mov	 eax, edi
  000bf	99		 cdq
  000c0	2b c2		 sub	 eax, edx
  000c2	8b f8		 mov	 edi, eax
  000c4	d1 ff		 sar	 edi, 1
  000c6	e9 b4 01 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN12@SprawdŸ_Z:

; 272  : 		else if (typ_zak³adu == "d") wygrana /= 2; //Je¿eli typ zak³adu by³ d to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  000cb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LPLHEDKD@d?$AA@
  000d0	8b ce		 mov	 ecx, esi
  000d2	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  000d7	84 c0		 test	 al, al
  000d9	74 0e		 je	 SHORT $LN14@SprawdŸ_Z
  000db	8b c7		 mov	 eax, edi
  000dd	99		 cdq
  000de	2b c2		 sub	 eax, edx
  000e0	8b f8		 mov	 edi, eax
  000e2	d1 ff		 sar	 edi, 1

; 273  : 		else if (typ_zak³adu[0] == 'k') wygrana *= 0; //Je¿eli typ zak³adu by³ k to przegra³o siê zak³ad

  000e4	e9 96 01 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN14@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  000e9	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000eb	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1607 : 		if (_Large_string_engaged())

  000ee	72 02		 jb	 SHORT $LN98@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000f0	8b 06		 mov	 eax, DWORD PTR [esi]
$LN98@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 273  : 		else if (typ_zak³adu[0] == 'k') wygrana *= 0; //Je¿eli typ zak³adu by³ k to przegra³o siê zak³ad

  000f2	80 38 6b	 cmp	 BYTE PTR [eax], 107	; 0000006bH
  000f5	0f 84 82 01 00
	00		 je	 $LN53@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  000fb	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000fd	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00100	72 02		 jb	 SHORT $LN113@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00102	8b 06		 mov	 eax, DWORD PTR [esi]
$LN113@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 274  : 		else if (typ_zak³adu[0] == 'w') wygrana *= 0; //Je¿eli typ zak³adu by³ k to przegra³o siê zak³ad

  00104	80 38 77	 cmp	 BYTE PTR [eax], 119	; 00000077H
  00107	0f 84 70 01 00
	00		 je	 $LN53@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0010d	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00110	72 02		 jb	 SHORT $LN128@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00112	8b 36		 mov	 esi, DWORD PTR [esi]
$LN128@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 275  : 		else if (typ_zak³adu[0] == '0') wygrana *= 35; //Je¿eli typ zak³adu by³ 0 to przegra³o siê zak³ad

  00114	80 3e 30	 cmp	 BYTE PTR [esi], 48	; 00000030H
  00117	0f 85 62 01 00
	00		 jne	 $LN54@SprawdŸ_Z
  0011d	6b ff 23	 imul	 edi, edi, 35

; 276  : 	}
; 277  : 	else //Je¿eli wylosowana liczba nie jest zerem to

  00120	e9 5a 01 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN2@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00125	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00129	72 02		 jb	 SHORT $LN149@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0012b	8b 06		 mov	 eax, DWORD PTR [esi]
$LN149@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0012d	83 7e 10 01	 cmp	 DWORD PTR [esi+16], 1
  00131	75 1f		 jne	 SHORT $LN21@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00133	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00136	3c 70		 cmp	 al, 112			; 00000070H
  00138	75 04		 jne	 SHORT $LN243@SprawdŸ_Z
  0013a	33 c0		 xor	 eax, eax
  0013c	eb 05		 jmp	 SHORT $LN244@SprawdŸ_Z
$LN243@SprawdŸ_Z:
  0013e	1b c0		 sbb	 eax, eax
  00140	83 c8 01	 or	 eax, 1
$LN244@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00143	85 c0		 test	 eax, eax
  00145	75 0b		 jne	 SHORT $LN21@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 280  : 			if (wylosowana_liczba % 2 == 0) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest parzysta, je¿eli tak to wygrana jest 1:1

  00147	f6 c3 01	 test	 bl, 1
  0014a	0f 45 f8	 cmovne	 edi, eax

; 281  : 			else wygrana *= 0; //Je¿eli wylosowana liczba nie jest parzysta to przegra³o siê zak³ad

  0014d	e9 2d 01 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN21@SprawdŸ_Z:

; 282  : 		else if (typ_zak³adu == "n") //Je¿eli typ zak³adu to n

  00152	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EFFIKLCJ@n?$AA@
  00157	8b ce		 mov	 ecx, esi
  00159	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0015e	84 c0		 test	 al, al
  00160	74 1a		 je	 SHORT $LN25@SprawdŸ_Z

; 283  : 			if (wylosowana_liczba % 2 == 1) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest nieparzysta, je¿eli tak to wygrana jest 1:1

  00162	81 e3 01 00 00
	80		 and	 ebx, -2147483647	; 80000001H
  00168	79 05		 jns	 SHORT $LN245@SprawdŸ_Z
  0016a	4b		 dec	 ebx
  0016b	83 cb fe	 or	 ebx, -2			; fffffffeH
  0016e	43		 inc	 ebx
$LN245@SprawdŸ_Z:
  0016f	33 c0		 xor	 eax, eax
  00171	83 fb 01	 cmp	 ebx, 1
  00174	0f 45 f8	 cmovne	 edi, eax

; 284  : 			else wygrana *= 0; //Je¿eli obstawiony numer nie jest nieparzysta to przegra³o siê zak³ad

  00177	e9 03 01 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN25@SprawdŸ_Z:

; 285  : 		else if (typ_zak³adu == "r") //Je¿eli typ zak³adu to n

  0017c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00181	8b ce		 mov	 ecx, esi
  00183	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00188	84 c0		 test	 al, al
  0018a	74 11		 je	 SHORT $LN29@SprawdŸ_Z

; 286  : 			if (Ruletka_plansza_kolor[wylosowana_liczba] == 'r') wygrana *= 1; //To sprawdzam czy wylosowana liczba jest czerwona, je¿eli tak to wygrana jest 1:1

  0018c	33 c0		 xor	 eax, eax
  0018e	80 bb 00 00 00
	00 72		 cmp	 BYTE PTR ?Ruletka_plansza_kolor@@3QBDB[ebx], 114 ; 00000072H
  00195	0f 45 f8	 cmovne	 edi, eax

; 287  : 			else wygrana *= 0; //Je¿eli wylosowana liczba nie jest czerwony to przegra³o siê zak³ad

  00198	e9 e2 00 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN29@SprawdŸ_Z:

; 288  : 		else if (typ_zak³adu == "b") //Je¿eli typ zak³adu to n

  0019d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01OJONOECF@b?$AA@
  001a2	8b ce		 mov	 ecx, esi
  001a4	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  001a9	84 c0		 test	 al, al
  001ab	74 11		 je	 SHORT $LN33@SprawdŸ_Z

; 289  : 			if (Ruletka_plansza_kolor[wylosowana_liczba] == 'b') wygrana *= 1; //To sprawdzam czy wylosowana liczba jest czarna, je¿eli tak to wygrana jest 1:1

  001ad	33 c0		 xor	 eax, eax
  001af	80 bb 00 00 00
	00 62		 cmp	 BYTE PTR ?Ruletka_plansza_kolor@@3QBDB[ebx], 98 ; 00000062H
  001b6	0f 45 f8	 cmovne	 edi, eax

; 290  : 			else wygrana *= 0; //Je¿eli wylosowana liczba nie jest czarny to przegra³o siê zak³ad

  001b9	e9 c1 00 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN33@SprawdŸ_Z:

; 291  : 		else if (typ_zak³adu == "g") //Je¿eli typ zak³adu to g

  001be	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JEJKBAGA@g?$AA@
  001c3	8b ce		 mov	 ecx, esi
  001c5	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  001ca	84 c0		 test	 al, al
  001cc	74 0d		 je	 SHORT $LN37@SprawdŸ_Z

; 292  : 			if (wylosowana_liczba < 19) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest od 1 do 18, je¿eli tak to wygrana jest 1:1

  001ce	33 c0		 xor	 eax, eax
  001d0	83 fb 13	 cmp	 ebx, 19			; 00000013H
  001d3	0f 4d f8	 cmovge	 edi, eax

; 293  : 			else wygrana *= 0; //Je¿eli wylosowana liczba nie nale¿y do przedzia³u [1,18] to przegra³o siê zak³ad

  001d6	e9 a4 00 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN37@SprawdŸ_Z:

; 294  : 		else if (typ_zak³adu == "d") //Je¿eli typ zak³adu to d

  001db	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LPLHEDKD@d?$AA@
  001e0	8b ce		 mov	 ecx, esi
  001e2	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  001e7	84 c0		 test	 al, al
  001e9	74 0d		 je	 SHORT $LN41@SprawdŸ_Z

; 295  : 			if (wylosowana_liczba > 18) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest od 19 do 36, je¿eli tak to wygrana jest 1:1

  001eb	33 c0		 xor	 eax, eax
  001ed	83 fb 12	 cmp	 ebx, 18			; 00000012H
  001f0	0f 4e f8	 cmovle	 edi, eax

; 297  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  001f3	e9 87 00 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN41@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001f8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  001fb	8b ce		 mov	 ecx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001fd	83 f8 10	 cmp	 eax, 16			; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00200	72 02		 jb	 SHORT $LN172@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00202	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN172@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 297  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  00204	80 39 6b	 cmp	 BYTE PTR [ecx], 107	; 0000006bH
  00207	75 21		 jne	 SHORT $LN45@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00209	83 f8 10	 cmp	 eax, 16			; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0020c	72 02		 jb	 SHORT $LN187@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0020e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN187@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 298  : 			if ((wylosowana_liczba - 1) % 3 == typ_zak³adu[1] - 49) wygrana *= 2; //To sprawdzam czy wylosowana liczba jest z obstawionej kolumny, je¿eli tak to wygrana jest 2:1

  00210	0f be 4e 01	 movsx	 ecx, BYTE PTR [esi+1]
  00214	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00217	99		 cdq
  00218	be 03 00 00 00	 mov	 esi, 3
  0021d	f7 fe		 idiv	 esi
  0021f	83 e9 31	 sub	 ecx, 49			; 00000031H
  00222	3b d1		 cmp	 edx, ecx
  00224	75 57		 jne	 SHORT $LN53@SprawdŸ_Z
  00226	03 ff		 add	 edi, edi

; 300  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  00228	eb 55		 jmp	 SHORT $LN54@SprawdŸ_Z
$LN45@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0022a	8b ce		 mov	 ecx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0022c	83 f8 10	 cmp	 eax, 16			; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0022f	72 02		 jb	 SHORT $LN202@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00231	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN202@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 300  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  00233	80 39 77	 cmp	 BYTE PTR [ecx], 119	; 00000077H
  00236	75 28		 jne	 SHORT $LN49@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00238	83 f8 10	 cmp	 eax, 16			; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0023b	72 02		 jb	 SHORT $LN217@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0023d	8b 36		 mov	 esi, DWORD PTR [esi]
$LN217@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 301  : 			if (((wylosowana_liczba - 1) / 3 + 1) == typ_zak³adu[1] - 48) wygrana *= 11; //To sprawdzam czy wylosowana liczba jest z obstawionego wiersza, je¿eli tak to wygrana jest 11:1

  0023f	0f be 76 01	 movsx	 esi, BYTE PTR [esi+1]
  00243	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  00246	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0024b	83 ee 31	 sub	 esi, 49			; 00000031H
  0024e	f7 e9		 imul	 ecx
  00250	8b c2		 mov	 eax, edx
  00252	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00255	03 c2		 add	 eax, edx
  00257	3b c6		 cmp	 eax, esi
  00259	75 22		 jne	 SHORT $LN53@SprawdŸ_Z
  0025b	6b ff 0b	 imul	 edi, edi, 11

; 303  : 		else if (wylosowana_liczba == atoi(typ_zak³adu.c_str())) wygrana *= 35; //Je¿eli typ zak³adu to liczba, to sprawdzam czy wylosowana liczba jest równa obstawionej liczbie, je¿eli tak to wygrana jest 35:1

  0025e	eb 1f		 jmp	 SHORT $LN54@SprawdŸ_Z
$LN49@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00260	83 f8 10	 cmp	 eax, 16			; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00263	72 02		 jb	 SHORT $LN233@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00265	8b 36		 mov	 esi, DWORD PTR [esi]
$LN233@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 303  : 		else if (wylosowana_liczba == atoi(typ_zak³adu.c_str())) wygrana *= 35; //Je¿eli typ zak³adu to liczba, to sprawdzam czy wylosowana liczba jest równa obstawionej liczbie, je¿eli tak to wygrana jest 35:1

  00267	56		 push	 esi
  00268	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0026e	8b 4d 08	 mov	 ecx, DWORD PTR _wylosowana_liczba$[ebp]
  00271	83 c4 04	 add	 esp, 4
  00274	39 01		 cmp	 DWORD PTR [ecx], eax
  00276	75 05		 jne	 SHORT $LN53@SprawdŸ_Z
  00278	6b ff 23	 imul	 edi, edi, 35
  0027b	eb 02		 jmp	 SHORT $LN54@SprawdŸ_Z
$LN53@SprawdŸ_Z:

; 304  : 		else wygrana *= 0; //Je¿eli wylosowana liczba nie jest równa obstawionej liczbie to przegra³o siê zak³ad

  0027d	33 ff		 xor	 edi, edi
$LN54@SprawdŸ_Z:

; 305  : 	}
; 306  : 
; 307  : 	if (wygrana >= kwota) cout << "Obstawiles poprawnie, wygrywasz " << wygrana << "$." << endl; //Je¿eli wygrana jest wiêksza lub równa obstawionej kwocie to informujê o tym, ¿e wygra³

  0027f	8b 4d fc	 mov	 ecx, DWORD PTR _kwota$1$[ebp]
  00282	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00287	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00289	51		 push	 ecx
  0028a	3b f9		 cmp	 edi, ecx
  0028c	7c 08		 jl	 SHORT $LN55@SprawdŸ_Z
  0028e	57		 push	 edi
  0028f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CB@MBIMKPJH@Obstawiles?5poprawnie?0?5wygrywasz?5@
  00294	eb 19		 jmp	 SHORT $LN247@SprawdŸ_Z
$LN55@SprawdŸ_Z:

; 308  : 	else if (wygrana == kwota / 2) cout << "Obstawiles niepoprawnie lecz uda³o Ci siê, dostajesz po³owê zak³adu " << wygrana << "$." << endl; //Je¿eli wygrana jest równa po³owie obstawionej kwocie to informujê o tym, ¿e przegra³ po³owe stawki

  00296	8b c1		 mov	 eax, ecx
  00298	99		 cdq
  00299	2b c2		 sub	 eax, edx
  0029b	d1 f8		 sar	 eax, 1
  0029d	3b f8		 cmp	 edi, eax
  0029f	75 08		 jne	 SHORT $LN57@SprawdŸ_Z
  002a1	57		 push	 edi
  002a2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EF@FAPGEAPP@Obstawiles?5niepoprawnie?5lecz?5uda@
  002a7	eb 06		 jmp	 SHORT $LN247@SprawdŸ_Z
$LN57@SprawdŸ_Z:

; 309  : 	else cout << "Obstawiles niepoprawnie, przegra³eœ " << kwota << "$." << endl; //Je¿eli wygrana jest równa zero to informujê o tym, ¿e przegra³

  002a9	51		 push	 ecx
  002aa	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CF@EMPIFKEH@Obstawiles?5niepoprawnie?0?5przegra@
$LN247@SprawdŸ_Z:
  002af	51		 push	 ecx
  002b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002b6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002bb	83 c4 04	 add	 esp, 4
  002be	8b c8		 mov	 ecx, eax
  002c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  002c6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02DEPNMBPN@$?4?$AA@
  002cb	8b c8		 mov	 ecx, eax
  002cd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002d2	83 c4 04	 add	 esp, 4
  002d5	8b c8		 mov	 ecx, eax
  002d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 310  : 
; 311  : 	return wygrana; //Zwracam wartoœ wygranej lub zwrotu

  002dd	8b c7		 mov	 eax, edi

; 312  : }

  002df	5f		 pop	 edi
  002e0	5e		 pop	 esi
  002e1	5b		 pop	 ebx
  002e2	8b e5		 mov	 esp, ebp
  002e4	5d		 pop	 ebp
  002e5	c3		 ret	 0
?SprawdŸ_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; SprawdŸ_Zak³ad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Czy_Kontynuowaæ@@YA_NABH@Z
_TEXT	SEGMENT
_tak_nie$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Czy_Kontynuowaæ@@YA_NABH@Z PROC			; Czy_Kontynuowaæ, COMDAT
; _iloœæ_pieniêdzy$ = ecx

; 315  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Czy_Kontynuowaæ@@YA_NABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0002d	be 0f 00 00 00	 mov	 esi, 15			; 0000000fH
  00032	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _tak_nie$[ebp+16], 0
  00039	89 75 ec	 mov	 DWORD PTR _tak_nie$[ebp+20], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0003c	c6 45 d8 00	 mov	 BYTE PTR _tak_nie$[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 316  : 	string tak_nie; //Zadeklarowanie zmiennej typu string

  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 
; 318  : 	if (iloœæ_pieniêdzy == 0) //Je¿eli posiadana iloœæ gotówki jest róna 0

  00047	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0004a	75 34		 jne	 SHORT $LL2@Czy_Kontyn

; 319  : 	{
; 320  : 		cout << "Nie mo¿esz kontynuowaæ, przegra³eœ wszystko" << endl; //Poinformowanie u¿ytkownika, ¿e jest bankrutem

  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00052	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@
  00057	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0005c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00061	8b c8		 mov	 ecx, eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00069	8b 45 d8	 mov	 eax, DWORD PTR _tak_nie$[ebp]
  0006c	32 db		 xor	 bl, bl
  0006e	e9 59 01 00 00	 jmp	 $LN13@Czy_Kontyn
  00073	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL2@Czy_Kontyn:

; 321  : 		return false; //Zwrot wartoœci false, co oznacza, ¿e kolejna runda siê nie odbêdzie
; 322  : 	}
; 323  : 
; 324  : 	while (true) //Rozpoczêcie pêtli nieskoñczonej
; 325  : 	{
; 326  : 		cout << "Na koncie masz " << iloœæ_pieniêdzy << "$, czy chcesz grac dalej('t' - tak, 'n' - nie) ?" << endl; //Pointormowanie o stanie konta i zapytanie o to czy gra dalej

  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00086	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@
  0008b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00090	ff 33		 push	 DWORD PTR [ebx]
  00092	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00097	8b c8		 mov	 ecx, eax
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0009f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@MONJHHJM@$?0?5czy?5chcesz?5grac?5dalej?$CI?8t?8?5?9?5t@
  000a4	8b c8		 mov	 ecx, eax
  000a6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000ab	8b c8		 mov	 ecx, eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  000b9	8d 55 d8	 lea	 edx, DWORD PTR _tak_nie$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000c1	8b 75 ec	 mov	 esi, DWORD PTR _tak_nie$[ebp+20]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  000c4	8d 4d d8	 lea	 ecx, DWORD PTR _tak_nie$[ebp]

; 1607 : 		if (_Large_string_engaged())

  000c7	8b 45 d8	 mov	 eax, DWORD PTR _tak_nie$[ebp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000ca	83 fe 10	 cmp	 esi, 16			; 00000010H

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000cd	8b 55 e8	 mov	 edx, DWORD PTR _tak_nie$[ebp+16]

; 1607 : 		if (_Large_string_engaged())

  000d0	0f 43 c8	 cmovae	 ecx, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000d3	83 fa 01	 cmp	 edx, 1
  000d6	75 09		 jne	 SHORT $LN65@Czy_Kontyn
  000d8	80 39 74	 cmp	 BYTE PTR [ecx], 116	; 00000074H
  000db	0f 84 c9 00 00
	00		 je	 $LN365@Czy_Kontyn
$LN65@Czy_Kontyn:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000e1	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  000e4	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1607 : 		if (_Large_string_engaged())

  000e7	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000ea	83 fa 03	 cmp	 edx, 3
  000ed	75 11		 jne	 SHORT $LN375@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000ef	66 81 3f 74 61	 cmp	 WORD PTR [edi], 24948	; 00006174H
  000f4	75 0a		 jne	 SHORT $LN375@Czy_Kontyn
  000f6	80 7f 02 6b	 cmp	 BYTE PTR [edi+2], 107	; 0000006bH
  000fa	0f 84 aa 00 00
	00		 je	 $LN365@Czy_Kontyn
$LN375@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00100	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00103	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1607 : 		if (_Large_string_engaged())

  00106	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00109	83 fa 03	 cmp	 edx, 3
  0010c	75 11		 jne	 SHORT $LN376@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0010e	66 81 3f 54 61	 cmp	 WORD PTR [edi], 24916	; 00006154H
  00113	75 0a		 jne	 SHORT $LN376@Czy_Kontyn
  00115	80 7f 02 6b	 cmp	 BYTE PTR [edi+2], 107	; 0000006bH
  00119	0f 84 8b 00 00
	00		 je	 $LN365@Czy_Kontyn
$LN376@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0011f	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00122	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1607 : 		if (_Large_string_engaged())

  00125	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00128	83 fa 03	 cmp	 edx, 3
  0012b	75 0d		 jne	 SHORT $LN377@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0012d	66 81 3f 54 41	 cmp	 WORD PTR [edi], 16724	; 00004154H
  00132	75 06		 jne	 SHORT $LN377@Czy_Kontyn
  00134	80 7f 02 4b	 cmp	 BYTE PTR [edi+2], 75	; 0000004bH
  00138	74 70		 je	 SHORT $LN365@Czy_Kontyn
$LN377@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0013a	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0013d	8d 4d d8	 lea	 ecx, DWORD PTR _tak_nie$[ebp]

; 1607 : 		if (_Large_string_engaged())

  00140	0f 43 c8	 cmovae	 ecx, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00143	83 fa 01	 cmp	 edx, 1
  00146	75 05		 jne	 SHORT $LN181@Czy_Kontyn
  00148	80 39 6e	 cmp	 BYTE PTR [ecx], 110	; 0000006eH
  0014b	74 5d		 je	 SHORT $LN365@Czy_Kontyn
$LN181@Czy_Kontyn:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0014d	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00150	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1607 : 		if (_Large_string_engaged())

  00153	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00156	83 fa 03	 cmp	 edx, 3
  00159	75 0d		 jne	 SHORT $LN378@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0015b	66 81 3f 6e 69	 cmp	 WORD PTR [edi], 26990	; 0000696eH
  00160	75 06		 jne	 SHORT $LN378@Czy_Kontyn
  00162	80 7f 02 65	 cmp	 BYTE PTR [edi+2], 101	; 00000065H
  00166	74 42		 je	 SHORT $LN365@Czy_Kontyn
$LN378@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00168	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0016b	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1607 : 		if (_Large_string_engaged())

  0016e	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00171	83 fa 03	 cmp	 edx, 3
  00174	75 0d		 jne	 SHORT $LN379@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00176	66 81 3f 4e 69	 cmp	 WORD PTR [edi], 26958	; 0000694eH
  0017b	75 06		 jne	 SHORT $LN379@Czy_Kontyn
  0017d	80 7f 02 65	 cmp	 BYTE PTR [edi+2], 101	; 00000065H
  00181	74 27		 je	 SHORT $LN365@Czy_Kontyn
$LN379@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00183	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00186	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1607 : 		if (_Large_string_engaged())

  00189	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0018c	83 fa 03	 cmp	 edx, 3
  0018f	0f 85 eb fe ff
	ff		 jne	 $LL2@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00195	66 81 3f 4e 49	 cmp	 WORD PTR [edi], 18766	; 0000494eH
  0019a	0f 85 e0 fe ff
	ff		 jne	 $LL2@Czy_Kontyn
  001a0	80 7f 02 45	 cmp	 BYTE PTR [edi+2], 69	; 00000045H
  001a4	0f 85 d6 fe ff
	ff		 jne	 $LL2@Czy_Kontyn
$LN365@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001aa	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  001ad	8d 4d d8	 lea	 ecx, DWORD PTR _tak_nie$[ebp]

; 1596 : 		if (_Large_string_engaged())

  001b0	0f 43 c8	 cmovae	 ecx, eax
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 329  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoœæ true

  001b3	80 39 74	 cmp	 BYTE PTR [ecx], 116	; 00000074H
  001b6	74 12		 je	 SHORT $LN9@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001b8	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  001bb	8d 4d d8	 lea	 ecx, DWORD PTR _tak_nie$[ebp]

; 1596 : 		if (_Large_string_engaged())

  001be	0f 43 c8	 cmovae	 ecx, eax
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 329  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoœæ true

  001c1	80 39 54	 cmp	 BYTE PTR [ecx], 84	; 00000054H
  001c4	74 04		 je	 SHORT $LN9@Czy_Kontyn

; 330  : 			else return false; //W przeciwym wypadku zwracam wartoœæ false

  001c6	32 db		 xor	 bl, bl
  001c8	eb 02		 jmp	 SHORT $LN13@Czy_Kontyn
$LN9@Czy_Kontyn:

; 329  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoœæ true

  001ca	b3 01		 mov	 bl, 1
$LN13@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001cc	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  001cf	72 2f		 jb	 SHORT $LN331@Czy_Kontyn

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001d1	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  001d4	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001da	72 1b		 jb	 SHORT $LN334@Czy_Kontyn

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  001dc	f6 45 d8 1f	 test	 BYTE PTR _tak_nie$[ebp], 31 ; 0000001fH
  001e0	75 3c		 jne	 SHORT $_Invalid_parameter$385

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001e2	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  001e5	3b c8		 cmp	 ecx, eax
  001e7	73 35		 jae	 SHORT $_Invalid_parameter$385

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001e9	2b c1		 sub	 eax, ecx
  001eb	83 f8 04	 cmp	 eax, 4
  001ee	72 2e		 jb	 SHORT $_Invalid_parameter$385

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  001f0	83 f8 23	 cmp	 eax, 35			; 00000023H
  001f3	77 29		 ja	 SHORT $_Invalid_parameter$385

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  001f5	8b c1		 mov	 eax, ecx
$LN334@Czy_Kontyn:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001fd	83 c4 04	 add	 esp, 4
$LN331@Czy_Kontyn:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 330  : 			else return false; //W przeciwym wypadku zwracam wartoœæ false

  00200	8a c3		 mov	 al, bl

; 332  : }

  00202	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00205	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0020c	59		 pop	 ecx
  0020d	5f		 pop	 edi
  0020e	5e		 pop	 esi
  0020f	5b		 pop	 ebx
  00210	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00213	33 cd		 xor	 ecx, ebp
  00215	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021a	8b e5		 mov	 esp, ebp
  0021c	5d		 pop	 ebp
  0021d	c3		 ret	 0
$_Invalid_parameter$385:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0021e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN384@Czy_Kontyn:
$LN383@Czy_Kontyn:
  00224	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Czy_Kontynuowaæ@@YA_NABH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _tak_nie$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Czy_Kontynuowaæ@@YA_NABH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Czy_Kontynuowaæ@@YA_NABH@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Czy_Kontynuowaæ@@YA_NABH@Z ENDP			; Czy_Kontynuowaæ
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Change_Col@@YAXABH@Z
_TEXT	SEGMENT
?Change_Col@@YAXABH@Z PROC				; Change_Col, COMDAT
; _num_of_col$ = ecx

; 335  : {

  00000	56		 push	 esi

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00001	6a f5		 push	 -11			; fffffff5H
  00003	8b f1		 mov	 esi, ecx
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0000b	0f b7 0e	 movzx	 ecx, WORD PTR [esi]
  0000e	51		 push	 ecx
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleTextAttribute@8
  00016	5e		 pop	 esi

; 338  : }

  00017	c3		 ret	 0
?Change_Col@@YAXABH@Z ENDP				; Change_Col
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Hide_Cursor@@YAXXZ
_TEXT	SEGMENT
_hCCI$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
?Hide_Cursor@@YAXXZ PROC				; Hide_Cursor, COMDAT

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 342  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00011	6a f5		 push	 -11			; fffffff5H
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  00019	8b f0		 mov	 esi, eax

; 343  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 344  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0001b	8d 45 f4	 lea	 eax, DWORD PTR _hCCI$[ebp]
  0001e	50		 push	 eax
  0001f	56		 push	 esi
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 345  : 	hCCI.bVisible = FALSE; //Zmiena widocznoœci kursora na niewidoczny
; 346  : 	SetConsoleCursorInfo(hConsoleOut, &hCCI); //Ustawienie widocznoœci kursora zgodnie z poprzedni¹ zmienn¹

  00026	8d 45 f4	 lea	 eax, DWORD PTR _hCCI$[ebp]
  00029	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hCCI$[ebp+4], 0
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8

; 347  : }

  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	5e		 pop	 esi
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?Hide_Cursor@@YAXXZ ENDP				; Hide_Cursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Show_Cursor@@YAXXZ
_TEXT	SEGMENT
_hCCI$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
?Show_Cursor@@YAXXZ PROC				; Show_Cursor, COMDAT

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 351  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00011	6a f5		 push	 -11			; fffffff5H
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  00019	8b f0		 mov	 esi, eax

; 352  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 353  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0001b	8d 45 f4	 lea	 eax, DWORD PTR _hCCI$[ebp]
  0001e	50		 push	 eax
  0001f	56		 push	 esi
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 354  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoœæ widocznoœci kursorsora tekstego w konsoli jest ró¿na od prawdy

  00026	83 7d f8 01	 cmp	 DWORD PTR _hCCI$[ebp+4], 1
  0002a	74 12		 je	 SHORT $LN2@Show_Curso

; 355  : 	{
; 356  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoœci kursora na widoczny
; 357  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoœci kursora zgodnie z poprzedni¹ zmienn¹

  0002c	8d 45 f4	 lea	 eax, DWORD PTR _hCCI$[ebp]
  0002f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _hCCI$[ebp+4], 1
  00036	50		 push	 eax
  00037	56		 push	 esi
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8
$LN2@Show_Curso:

; 358  : 	}
; 359  : }

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00041	33 cd		 xor	 ecx, ebp
  00043	5e		 pop	 esi
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?Show_Cursor@@YAXXZ ENDP				; Show_Cursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wylosuj@@YAHABH0@Z
_TEXT	SEGMENT
$T10 = -44						; size = 24
$T1 = -44						; size = 24
_distribution$ = -20					; size = 8
_distribution$20 = -20					; size = 8
_od_liczby$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Wylosuj@@YAHABH0@Z PROC				; Wylosuj, COMDAT
; _od_liczby$ = ecx
; _do_liczby$ = edx

; 362  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Wylosuj@@YAHABH0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b da		 mov	 ebx, edx
  0002a	8b c1		 mov	 eax, ecx
  0002c	89 45 f0	 mov	 DWORD PTR _od_liczby$1$[ebp], eax

; 363  : 	if (od_liczby > do_liczby) //Je¿eli od jest wiêksze ni¿ do to

  0002f	8b 38		 mov	 edi, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00031	8d 4d d4	 lea	 ecx, DWORD PTR $T1[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 363  : 	if (od_liczby > do_liczby) //Je¿eli od jest wiêksze ni¿ do to

  00034	8b 33		 mov	 esi, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00036	6a 00		 push	 0
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@

; 3698 : 		_My_data._Mysize = 0;

  0003d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00044	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T1[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0004b	c6 45 d4 00	 mov	 BYTE PTR $T1[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0004f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 363  : 	if (od_liczby > do_liczby) //Je¿eli od jest wiêksze ni¿ do to

  00054	3b fe		 cmp	 edi, esi
  00056	7e 58		 jle	 SHORT $LN2@Wylosuj

; 367  : 		random_device generator; //Generator liczb losowych, który generuje niedeterministyczne liczby losowe, jeœli s¹ obs³ugiwane.

  00058	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 367  : 		random_device generator; //Generator liczb losowych, który generuje niedeterministyczne liczby losowe, jeœli s¹ obs³ugiwane.

  00065	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0006c	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp+20]
  0006f	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  00072	72 2e		 jb	 SHORT $LN68@Wylosuj
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00074	8b 4d d4	 mov	 ecx, DWORD PTR $T1[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00077	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00078	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007d	72 1a		 jb	 SHORT $LN71@Wylosuj

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0007f	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00082	75 26		 jne	 SHORT $_Invalid_parameter$223

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00084	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00087	3b c1		 cmp	 eax, ecx
  00089	73 1f		 jae	 SHORT $_Invalid_parameter$223

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0008b	2b c8		 sub	 ecx, eax
  0008d	83 f9 04	 cmp	 ecx, 4
  00090	72 18		 jb	 SHORT $_Invalid_parameter$223

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00092	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00095	77 13		 ja	 SHORT $_Invalid_parameter$223

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00097	8b c8		 mov	 ecx, eax
$LN71@Wylosuj:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009f	83 c4 04	 add	 esp, 4
$LN68@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2256 : 			_Min = _Min0;

  000a2	89 75 ec	 mov	 DWORD PTR _distribution$20[ebp], esi

; 2257 : 			_Max = _Max0;

  000a5	89 7d f0	 mov	 DWORD PTR _distribution$20[ebp+4], edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 379  : 		return distribution(generator); //Zwraca wygenerowan¹ liczbê z uwzglêdnieniem przedzia³u

  000a8	eb 5d		 jmp	 SHORT $LN221@Wylosuj
$_Invalid_parameter$223:
$_Invalid_parameter$224:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN222@Wylosuj:
$LN2@Wylosuj:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 382  : 	random_device generator; //Generator liczb losowych, który generuje niedeterministyczne liczby losowe, jeœli s¹ obs³ugiwane.

  000b0	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 382  : 	random_device generator; //Generator liczb losowych, który generuje niedeterministyczne liczby losowe, jeœli s¹ obs³ugiwane.

  000bd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000c4	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp+20]
  000c7	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  000ca	72 2e		 jb	 SHORT $LN170@Wylosuj
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  000cc	8b 4d d4	 mov	 ecx, DWORD PTR $T10[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000cf	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000d0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000d5	72 1a		 jb	 SHORT $LN173@Wylosuj

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000d7	f6 c1 1f	 test	 cl, 31			; 0000001fH
  000da	75 ce		 jne	 SHORT $_Invalid_parameter$223

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000dc	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000df	3b c1		 cmp	 eax, ecx
  000e1	73 c7		 jae	 SHORT $_Invalid_parameter$223

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000e3	2b c8		 sub	 ecx, eax
  000e5	83 f9 04	 cmp	 ecx, 4
  000e8	72 c0		 jb	 SHORT $_Invalid_parameter$223

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  000ea	83 f9 23	 cmp	 ecx, 35			; 00000023H
  000ed	77 bb		 ja	 SHORT $_Invalid_parameter$223

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000ef	8b c8		 mov	 ecx, eax
$LN173@Wylosuj:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  000f1	51		 push	 ecx
  000f2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f7	83 c4 04	 add	 esp, 4
$LN170@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2256 : 			_Min = _Min0;

  000fa	8b 45 f0	 mov	 eax, DWORD PTR _od_liczby$1$[ebp]
  000fd	8b 00		 mov	 eax, DWORD PTR [eax]
  000ff	89 45 ec	 mov	 DWORD PTR _distribution$[ebp], eax

; 2257 : 			_Max = _Max0;

  00102	8b 03		 mov	 eax, DWORD PTR [ebx]
  00104	89 45 f0	 mov	 DWORD PTR _distribution$[ebp+4], eax
$LN221@Wylosuj:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 394  : 	return distribution(generator); //Zwraca wygenerowan¹ liczbê

  00107	51		 push	 ecx
  00108	8d 4d ec	 lea	 ecx, DWORD PTR _distribution$[ebp]
  0010b	e8 00 00 00 00	 call	 ??$?RVrandom_device@std@@@?$uniform_int@H@std@@QBEHAAVrandom_device@1@@Z ; std::uniform_int<int>::operator()<std::random_device>

; 395  : }

  00110	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00113	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011a	59		 pop	 ecx
  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN220@Wylosuj:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Wylosuj@@YAHABH0@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T1[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wylosuj@@YAHABH0@Z$1:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR $T10[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Wylosuj@@YAHABH0@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Wylosuj@@YAHABH0@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Wylosuj@@YAHABH0@Z ENDP				; Wylosuj
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T84 = -480						; size = 24
$T73 = -480						; size = 24
$T19 = -480						; size = 24
$T81 = -456						; size = 24
$T55 = -456						; size = 24
$T4 = -456						; size = 24
_this$ = -432						; size = 4
_this$ = -432						; size = 4
$T82 = -428						; size = 24
$T44 = -428						; size = 24
$T34 = -428						; size = 24
$T29 = -428						; size = 24
$T24 = -428						; size = 24
$T83 = -404						; size = 24
$T65 = -404						; size = 24
$T11 = -404						; size = 24
_wylosowana_liczba$GSCopy$1$ = -380			; size = 4
$T59 = -380						; size = 1
_numers$90 = -376					; size = 176
_numers$ = -200						; size = 176
__Ch$ = -24						; size = 1
$T1 = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Odczytaj_liczbê, COMDAT
; _wylosowana_liczba$ = ecx
; _typ_zak³adu$ = edx

; 397  : void Odczytaj_liczbê(const int & wylosowana_liczba, const string & typ_zak³adu) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 ec d0 01 00
	00		 sub	 esp, 464		; 000001d0H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	56		 push	 esi
  00036	57		 push	 edi
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	8b f2		 mov	 esi, edx
  00043	8b f9		 mov	 edi, ecx
  00045	89 bd 84 fe ff
	ff		 mov	 DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp], edi
  0004b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 398  : 	if ((g³os_odczytu_numeru == 0) || (!G³osyKompletne)) return; //Je¿eli ustawienia wy³¹czaj¹ g³os lub brak plików g³osu to wyjdŸ z funkcji

  00052	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?g³os_odczytu_numeru@@3FA, 0 ; g³os_odczytu_numeru
  0005a	0f 84 7e 05 00
	00		 je	 $LN3@Odczytaj_l
  00060	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  00067	0f 84 71 05 00
	00		 je	 $LN3@Odczytaj_l
  0006d	68 b0 00 00 00	 push	 176			; 000000b0H
  00072	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _numers$[ebp]
  00078	6a 00		 push	 0
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _memset
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 593  : 		{	// construct empty character buffer

  00083	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0008d	8d 4d a0	 lea	 ecx, DWORD PTR _numers$[ebp+104]
  00090	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  000a0	6a 00		 push	 0
  000a2	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _numers$[ebp+24]
  000a8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000af	50		 push	 eax
  000b0	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp]
  000b6	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	typedef typename allocator_traits<allocator_type>::pointer _Ptrty;
; 350  : 
; 351  : 	enum
; 352  : 		{	// constant for minimum buffer size
; 353  : 		_MINSIZE = 32};
; 354  : 
; 355  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 356  : 		{	// convert open mode to stream state bits
; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);
; 367  : 		}
; 368  : 
; 369  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 370  : 	_Strstate _Mystate;	// the stream state
; 371  : 	allocator_type _Al;	// the allocator object
; 372  : 	};
; 373  : 
; 374  : 	// basic_stringbuf TEMPLATE OPERATORS
; 375  : template<class _Elem,
; 376  : 	class _Traits,
; 377  : 	class _Alloc> inline
; 378  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 379  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 380  : 	{	// swap _Left and _Right basic_stringbufs
; 381  : 	_Left.swap(_Right);
; 382  : 	}
; 383  : 
; 384  : 		// TEMPLATE CLASS basic_istringstream
; 385  : template<class _Elem,
; 386  : 	class _Traits,
; 387  : 	class _Alloc>
; 388  : 	class basic_istringstream
; 389  : 		: public basic_istream<_Elem, _Traits>
; 390  : 	{	// input stream associated with a character array
; 391  : public:
; 392  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 393  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 394  : 	typedef _Alloc allocator_type;
; 395  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 396  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 397  : 
; 398  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 399  : 		: _Mybase(&_Stringbuffer),
; 400  : 			_Stringbuffer(_Mode | ios_base::in)
; 401  : 		{	// construct empty readable character buffer
; 402  : 		}
; 403  : 
; 404  : 	explicit basic_istringstream(const _Mystr& _Str,
; 405  : 		ios_base::openmode _Mode = ios_base::in)
; 406  : 		: _Mybase(&_Stringbuffer),
; 407  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 408  : 		{	// construct readable character buffer from NTCS
; 409  : 		}
; 410  : 
; 411  : 	basic_istringstream(_Myt&& _Right)
; 412  : 		: _Mybase(&_Stringbuffer)
; 413  : 		{	// construct by moving _Right
; 414  : 		_Assign_rv(_STD move(_Right));
; 415  : 		}
; 416  : 
; 417  : 	_Myt& operator=(_Myt&& _Right)
; 418  : 		{	// move from _Right
; 419  : 		_Assign_rv(_STD move(_Right));
; 420  : 		return (*this);
; 421  : 		}
; 422  : 
; 423  : 	void _Assign_rv(_Myt&& _Right)
; 424  : 		{	// assign by moving _Right
; 425  : 		if (this != _STD addressof(_Right))
; 426  : 			{	// different, worth moving
; 427  : 			_Stringbuffer.str(_Mystr());
; 428  : 			this->swap(_Right);
; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 	void swap(_Myt& _Right)
; 433  : 		{	// swap with _Right
; 434  : 		if (this != _STD addressof(_Right))
; 435  : 			{	// different, swap base and buffer
; 436  : 			_Mybase::swap(_Right);
; 437  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 438  : 			}
; 439  : 		}
; 440  : 
; 441  : 	basic_istringstream(const _Myt&) = delete;
; 442  : 	_Myt& operator=(const _Myt&) = delete;
; 443  : 
; 444  : 	virtual ~basic_istringstream() _NOEXCEPT
; 445  : 		{	// destroy the object
; 446  : 		}
; 447  : 
; 448  : 	_Mysb *rdbuf() const
; 449  : 		{	// return pointer to file buffer
; 450  : 		return ((_Mysb *)&_Stringbuffer);
; 451  : 		}
; 452  : 
; 453  : 	_Mystr str() const
; 454  : 		{	// return string copy of character array
; 455  : 		return (_Stringbuffer.str());
; 456  : 		}
; 457  : 
; 458  : 	void str(const _Mystr& _Newstr)
; 459  : 		{	// replace character array from string
; 460  : 		_Stringbuffer.str(_Newstr);
; 461  : 		}
; 462  : 
; 463  : private:
; 464  : 	_Mysb _Stringbuffer;	// the string buffer
; 465  : 	};
; 466  : 
; 467  : 	// basic_istringstream TEMPLATE OPERATORS
; 468  : template<class _Elem,
; 469  : 	class _Traits,
; 470  : 	class _Alloc> inline
; 471  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 472  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 473  : 	{	// swap _Left and _Right basic_istringstreams
; 474  : 	_Left.swap(_Right);
; 475  : 	}
; 476  : 
; 477  : 		// TEMPLATE CLASS basic_ostringstream
; 478  : template<class _Elem,
; 479  : 	class _Traits,
; 480  : 	class _Alloc>
; 481  : 	class basic_ostringstream
; 482  : 		: public basic_ostream<_Elem, _Traits>
; 483  : 	{	// output stream associated with a character array
; 484  : public:
; 485  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 486  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 487  : 	typedef _Alloc allocator_type;
; 488  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 489  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 490  : 
; 491  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 492  : 		: _Mybase(&_Stringbuffer),
; 493  : 			_Stringbuffer(_Mode | ios_base::out)
; 494  : 		{	// construct empty writable character buffer
; 495  : 		}
; 496  : 
; 497  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 498  : 		ios_base::openmode _Mode = ios_base::out)
; 499  : 		: _Mybase(&_Stringbuffer),
; 500  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 501  : 		{	// construct writable character buffer from NTCS
; 502  : 		}
; 503  : 
; 504  : 	basic_ostringstream(_Myt&& _Right)
; 505  : 		: _Mybase(&_Stringbuffer)
; 506  : 		{	// construct by moving _Right
; 507  : 		_Assign_rv(_STD move(_Right));
; 508  : 		}
; 509  : 
; 510  : 	_Myt& operator=(_Myt&& _Right)
; 511  : 		{	// move from _Right
; 512  : 		_Assign_rv(_STD move(_Right));
; 513  : 		return (*this);
; 514  : 		}
; 515  : 
; 516  : 	void _Assign_rv(_Myt&& _Right)
; 517  : 		{	// assign by moving _Right
; 518  : 		if (this != _STD addressof(_Right))
; 519  : 			{	// different, worth moving
; 520  : 			_Stringbuffer.str(_Mystr());
; 521  : 			this->swap(_Right);
; 522  : 			}
; 523  : 		}
; 524  : 
; 525  : 	void swap(_Myt& _Right)
; 526  : 		{	// swap with _Right
; 527  : 		if (this != _STD addressof(_Right))
; 528  : 			{	// different, swap base and buffer
; 529  : 			_Mybase::swap(_Right);
; 530  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 531  : 			}
; 532  : 		}
; 533  : 
; 534  : 	basic_ostringstream(const _Myt&) = delete;
; 535  : 	_Myt& operator=(const _Myt&) = delete;
; 536  : 
; 537  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 538  : 		{	// destroy the object
; 539  : 		}
; 540  : 
; 541  : 	_Mysb *rdbuf() const
; 542  : 		{	// return pointer to buffer
; 543  : 		return ((_Mysb *)&_Stringbuffer);
; 544  : 		}
; 545  : 
; 546  : 	_Mystr str() const
; 547  : 		{	// return string copy of character array
; 548  : 		return (_Stringbuffer.str());
; 549  : 		}
; 550  : 
; 551  : 	void str(const _Mystr& _Newstr)
; 552  : 		{	// replace character array from string
; 553  : 		_Stringbuffer.str(_Newstr);
; 554  : 		}
; 555  : 
; 556  : private:
; 557  : 	_Mysb _Stringbuffer;	// the string buffer
; 558  : 	};
; 559  : 
; 560  : 	// basic_ostringstream TEMPLATE OPERATORS
; 561  : template<class _Elem,
; 562  : 	class _Traits,
; 563  : 	class _Alloc> inline
; 564  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 565  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 566  : 	{	// swap _Left and _Right basic_ostringstreams
; 567  : 	_Left.swap(_Right);
; 568  : 	}
; 569  : 
; 570  : 		// TEMPLATE CLASS basic_stringstream
; 571  : template<class _Elem,
; 572  : 	class _Traits,
; 573  : 	class _Alloc>
; 574  : 	class basic_stringstream
; 575  : 		: public basic_iostream<_Elem, _Traits>
; 576  : 	{	// input/output stream associated with a character array
; 577  : public:
; 578  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 579  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 580  : 	typedef _Elem char_type;
; 581  : 	typedef _Traits traits_type;
; 582  : 	typedef _Alloc allocator_type;
; 583  : 	typedef typename _Traits::int_type int_type;
; 584  : 	typedef typename _Traits::pos_type pos_type;
; 585  : 	typedef typename _Traits::off_type off_type;
; 586  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 587  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 588  : 
; 589  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 590  : 		ios_base::in | ios_base::out)
; 591  : 		: _Mybase(&_Stringbuffer),

  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  000c3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 593  : 		{	// construct empty character buffer

  000ca	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  000d0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d3	c7 84 05 38 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  000de	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  000e4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e7	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  000ea	89 84 0d 34 ff
	ff ff		 mov	 DWORD PTR _numers$[ebp+ecx-4], eax
  000f1	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _numers$[ebp+24]

; 30   : 		{	// construct empty character buffer from mode

  000f7	8b c8		 mov	 ecx, eax

; 592  : 			_Stringbuffer(_Mode)

  000f9	89 85 50 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00105	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

  0010f	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _numers$[ebp+80], 0

; 312  : 		_Mystate = _State;

  00116	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _numers$[ebp+84], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 400  : 	stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  0011d	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 401  : 	numers << wylosowana_liczba; //Wpisanie to typu wylosowanej liczby

  00124	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+16]
  0012a	ff 37		 push	 DWORD PTR [edi]
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 647  : 		return (_Stringbuffer.str());

  00132	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00138	50		 push	 eax
  00139	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+24]
  0013f	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3830 : 	return (_STD move(_Right.insert(0, _Left)));

  00144	68 00 00 00 00	 push	 OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00149	51		 push	 ecx
  0014a	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 402  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  00150	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3830 : 	return (_STD move(_Right.insert(0, _Left)));

  00154	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1576 : 		_Mysize(0),

  00159	c7 85 7c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+16], 0

; 1577 : 		_Myres(0)

  00163	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0016d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00170	0f 11 85 6c fe
	ff ff		 movups	 XMMWORD PTR $T11[ebp], xmm0
  00177	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0017c	66 0f d6 85 7c
	fe ff ff	 movq	 QWORD PTR $T11[ebp+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00184	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0018b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00192	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 402  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  00195	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  0019a	8d 95 6c fe ff
	ff		 lea	 edx, DWORD PTR $T11[ebp]
  001a0	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  001a4	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  001aa	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  001af	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001b2	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  001b6	72 02		 jb	 SHORT $LN483@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  001b8	8b 00		 mov	 eax, DWORD PTR [eax]
$LN483@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 402  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  001ba	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PlaySoundA@12
  001c0	6a 00		 push	 0
  001c2	6a 00		 push	 0
  001c4	50		 push	 eax
  001c5	ff d7		 call	 edi
  001c7	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  001cd	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001d2	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  001d8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001dd	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001e3	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  001e7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 403  : 	if (wylosowana_liczba != 0)

  001ec	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  001f2	8b 01		 mov	 eax, DWORD PTR [ecx]
  001f4	85 c0		 test	 eax, eax
  001f6	0f 84 9b 03 00
	00		 je	 $LN9@Odczytaj_l

; 404  : 		if (typ_zak³adu == "p" || typ_zak³adu == "n") //Je¿eli typ zak³adu to p lub n

  001fc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JBBJJEPG@p?$AA@
  00201	8b ce		 mov	 ecx, esi
  00203	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00208	84 c0		 test	 al, al
  0020a	0f 85 47 03 00
	00		 jne	 $LN7@Odczytaj_l
  00210	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EFFIKLCJ@n?$AA@
  00215	8b ce		 mov	 ecx, esi
  00217	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0021c	84 c0		 test	 al, al
  0021e	0f 85 33 03 00
	00		 jne	 $LN7@Odczytaj_l

; 409  : 		else if (typ_zak³adu == "r" || typ_zak³adu == "b") //Je¿eli typ zak³adu to r lub b

  00224	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00229	8b ce		 mov	 ecx, esi
  0022b	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00230	84 c0		 test	 al, al
  00232	0f 85 fa 02 00
	00		 jne	 $LN12@Odczytaj_l
  00238	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01OJONOECF@b?$AA@
  0023d	8b ce		 mov	 ecx, esi
  0023f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00244	84 c0		 test	 al, al
  00246	0f 85 e6 02 00
	00		 jne	 $LN12@Odczytaj_l

; 414  : 		else if (typ_zak³adu == "g" || typ_zak³adu == "d") //Je¿eli typ zak³adu to g lub d

  0024c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JEJKBAGA@g?$AA@
  00251	8b ce		 mov	 ecx, esi
  00253	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00258	84 c0		 test	 al, al
  0025a	0f 85 b3 02 00
	00		 jne	 $LN17@Odczytaj_l
  00260	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LPLHEDKD@d?$AA@
  00265	8b ce		 mov	 ecx, esi
  00267	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0026c	84 c0		 test	 al, al
  0026e	0f 85 9f 02 00
	00		 jne	 $LN17@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00274	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00277	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00279	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0027c	72 02		 jb	 SHORT $LN594@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0027e	8b 06		 mov	 eax, DWORD PTR [esi]
$LN594@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 419  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  00280	80 38 6b	 cmp	 BYTE PTR [eax], 107	; 0000006bH
  00283	0f 85 f3 00 00
	00		 jne	 $LN20@Odczytaj_l

; 420  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  00289	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  0028e	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]
  00294	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00299	83 c4 04	 add	 esp, 4
  0029c	8b f0		 mov	 esi, eax
  0029e	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  002a2	b9 03 00 00 00	 mov	 ecx, 3
  002a7	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  002ad	8b 00		 mov	 eax, DWORD PTR [eax]
  002af	48		 dec	 eax
  002b0	99		 cdq
  002b1	f7 f9		 idiv	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  002b3	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 420  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  002b6	80 c2 31	 add	 dl, 49			; 00000031H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3895 : 	_Left.push_back(_Right);

  002b9	88 55 e8	 mov	 BYTE PTR __Ch$[ebp], dl

; 2992 : 		if (_Old_size < _My_data._Myres)

  002bc	3b 4e 14	 cmp	 ecx, DWORD PTR [esi+20]
  002bf	73 1a		 jae	 SHORT $LN605@Odczytaj_l

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002c1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2994 : 			_My_data._Mysize = _Old_size + 1;

  002c5	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  002c8	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  002cb	8b c6		 mov	 eax, esi

; 1596 : 		if (_Large_string_engaged())

  002cd	72 02		 jb	 SHORT $LN614@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002cf	8b 06		 mov	 eax, DWORD PTR [esi]
$LN614@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  002d1	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  002d4	c6 44 08 01 00	 mov	 BYTE PTR [eax+ecx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2998 : 			return;

  002d9	eb 18		 jmp	 SHORT $LN604@Odczytaj_l
$LN605@Odczytaj_l:

; 2999 : 			}
; 3000 : 
; 3001 : 		_Reallocate_grow_by(1,

  002db	ff 75 e8	 push	 DWORD PTR __Ch$[ebp]
  002de	c6 85 84 fe ff
	ff 00		 mov	 BYTE PTR $T59[ebp], 0
  002e5	ff b5 84 fe ff
	ff		 push	 DWORD PTR $T59[ebp]
  002eb	51		 push	 ecx
  002ec	8b ce		 mov	 ecx, esi
  002ee	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN604@Odczytaj_l:

; 1576 : 		_Mysize(0),

  002f3	c7 85 7c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T65[ebp+16], 0

; 1577 : 		_Myres(0)

  002fd	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T65[ebp+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00307	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  0030a	0f 11 85 6c fe
	ff ff		 movups	 XMMWORD PTR $T65[ebp], xmm0
  00311	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  00316	66 0f d6 85 7c
	fe ff ff	 movq	 QWORD PTR $T65[ebp+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  0031e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00325	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0032c	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 420  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  0032f	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  00334	8d 95 6c fe ff
	ff		 lea	 edx, DWORD PTR $T65[ebp]
  0033a	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0033e	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T73[ebp]
  00344	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00349	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0034c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00350	72 02		 jb	 SHORT $LN697@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00352	8b 00		 mov	 eax, DWORD PTR [eax]
$LN697@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 420  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  00354	6a 00		 push	 0
  00356	6a 00		 push	 0
  00358	50		 push	 eax
  00359	ff d7		 call	 edi
  0035b	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T73[ebp]
  00361	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00366	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T65[ebp]
  0036c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00371	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]

; 421  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  00377	e9 16 02 00 00	 jmp	 $LN1107@Odczytaj_l
$LN20@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0037c	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0037f	72 02		 jb	 SHORT $LN712@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00381	8b 36		 mov	 esi, DWORD PTR [esi]
$LN712@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 421  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  00383	80 3e 77	 cmp	 BYTE PTR [esi], 119	; 00000077H
  00386	0f 85 0b 02 00
	00		 jne	 $LN9@Odczytaj_l
  0038c	68 b0 00 00 00	 push	 176			; 000000b0H
  00391	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _numers$90[ebp]
  00397	6a 00		 push	 0
  00399	50		 push	 eax
  0039a	e8 00 00 00 00	 call	 _memset
  0039f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 593  : 		{	// construct empty character buffer

  003a2	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$90[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  003ac	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$90[ebp+104]
  003b2	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$90[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  003bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  003c2	6a 00		 push	 0
  003c4	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _numers$90[ebp+24]
  003ca	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  003ce	50		 push	 eax
  003cf	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$90[ebp]
  003d5	c7 45 e8 2b 00
	00 00		 mov	 DWORD PTR $T1[ebp], 43	; 0000002bH

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	typedef typename allocator_traits<allocator_type>::pointer _Ptrty;
; 350  : 
; 351  : 	enum
; 352  : 		{	// constant for minimum buffer size
; 353  : 		_MINSIZE = 32};
; 354  : 
; 355  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 356  : 		{	// convert open mode to stream state bits
; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);
; 367  : 		}
; 368  : 
; 369  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 370  : 	_Strstate _Mystate;	// the stream state
; 371  : 	allocator_type _Al;	// the allocator object
; 372  : 	};
; 373  : 
; 374  : 	// basic_stringbuf TEMPLATE OPERATORS
; 375  : template<class _Elem,
; 376  : 	class _Traits,
; 377  : 	class _Alloc> inline
; 378  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 379  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 380  : 	{	// swap _Left and _Right basic_stringbufs
; 381  : 	_Left.swap(_Right);
; 382  : 	}
; 383  : 
; 384  : 		// TEMPLATE CLASS basic_istringstream
; 385  : template<class _Elem,
; 386  : 	class _Traits,
; 387  : 	class _Alloc>
; 388  : 	class basic_istringstream
; 389  : 		: public basic_istream<_Elem, _Traits>
; 390  : 	{	// input stream associated with a character array
; 391  : public:
; 392  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 393  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 394  : 	typedef _Alloc allocator_type;
; 395  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 396  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 397  : 
; 398  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 399  : 		: _Mybase(&_Stringbuffer),
; 400  : 			_Stringbuffer(_Mode | ios_base::in)
; 401  : 		{	// construct empty readable character buffer
; 402  : 		}
; 403  : 
; 404  : 	explicit basic_istringstream(const _Mystr& _Str,
; 405  : 		ios_base::openmode _Mode = ios_base::in)
; 406  : 		: _Mybase(&_Stringbuffer),
; 407  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 408  : 		{	// construct readable character buffer from NTCS
; 409  : 		}
; 410  : 
; 411  : 	basic_istringstream(_Myt&& _Right)
; 412  : 		: _Mybase(&_Stringbuffer)
; 413  : 		{	// construct by moving _Right
; 414  : 		_Assign_rv(_STD move(_Right));
; 415  : 		}
; 416  : 
; 417  : 	_Myt& operator=(_Myt&& _Right)
; 418  : 		{	// move from _Right
; 419  : 		_Assign_rv(_STD move(_Right));
; 420  : 		return (*this);
; 421  : 		}
; 422  : 
; 423  : 	void _Assign_rv(_Myt&& _Right)
; 424  : 		{	// assign by moving _Right
; 425  : 		if (this != _STD addressof(_Right))
; 426  : 			{	// different, worth moving
; 427  : 			_Stringbuffer.str(_Mystr());
; 428  : 			this->swap(_Right);
; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 	void swap(_Myt& _Right)
; 433  : 		{	// swap with _Right
; 434  : 		if (this != _STD addressof(_Right))
; 435  : 			{	// different, swap base and buffer
; 436  : 			_Mybase::swap(_Right);
; 437  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 438  : 			}
; 439  : 		}
; 440  : 
; 441  : 	basic_istringstream(const _Myt&) = delete;
; 442  : 	_Myt& operator=(const _Myt&) = delete;
; 443  : 
; 444  : 	virtual ~basic_istringstream() _NOEXCEPT
; 445  : 		{	// destroy the object
; 446  : 		}
; 447  : 
; 448  : 	_Mysb *rdbuf() const
; 449  : 		{	// return pointer to file buffer
; 450  : 		return ((_Mysb *)&_Stringbuffer);
; 451  : 		}
; 452  : 
; 453  : 	_Mystr str() const
; 454  : 		{	// return string copy of character array
; 455  : 		return (_Stringbuffer.str());
; 456  : 		}
; 457  : 
; 458  : 	void str(const _Mystr& _Newstr)
; 459  : 		{	// replace character array from string
; 460  : 		_Stringbuffer.str(_Newstr);
; 461  : 		}
; 462  : 
; 463  : private:
; 464  : 	_Mysb _Stringbuffer;	// the string buffer
; 465  : 	};
; 466  : 
; 467  : 	// basic_istringstream TEMPLATE OPERATORS
; 468  : template<class _Elem,
; 469  : 	class _Traits,
; 470  : 	class _Alloc> inline
; 471  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 472  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 473  : 	{	// swap _Left and _Right basic_istringstreams
; 474  : 	_Left.swap(_Right);
; 475  : 	}
; 476  : 
; 477  : 		// TEMPLATE CLASS basic_ostringstream
; 478  : template<class _Elem,
; 479  : 	class _Traits,
; 480  : 	class _Alloc>
; 481  : 	class basic_ostringstream
; 482  : 		: public basic_ostream<_Elem, _Traits>
; 483  : 	{	// output stream associated with a character array
; 484  : public:
; 485  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 486  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 487  : 	typedef _Alloc allocator_type;
; 488  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 489  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 490  : 
; 491  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 492  : 		: _Mybase(&_Stringbuffer),
; 493  : 			_Stringbuffer(_Mode | ios_base::out)
; 494  : 		{	// construct empty writable character buffer
; 495  : 		}
; 496  : 
; 497  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 498  : 		ios_base::openmode _Mode = ios_base::out)
; 499  : 		: _Mybase(&_Stringbuffer),
; 500  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 501  : 		{	// construct writable character buffer from NTCS
; 502  : 		}
; 503  : 
; 504  : 	basic_ostringstream(_Myt&& _Right)
; 505  : 		: _Mybase(&_Stringbuffer)
; 506  : 		{	// construct by moving _Right
; 507  : 		_Assign_rv(_STD move(_Right));
; 508  : 		}
; 509  : 
; 510  : 	_Myt& operator=(_Myt&& _Right)
; 511  : 		{	// move from _Right
; 512  : 		_Assign_rv(_STD move(_Right));
; 513  : 		return (*this);
; 514  : 		}
; 515  : 
; 516  : 	void _Assign_rv(_Myt&& _Right)
; 517  : 		{	// assign by moving _Right
; 518  : 		if (this != _STD addressof(_Right))
; 519  : 			{	// different, worth moving
; 520  : 			_Stringbuffer.str(_Mystr());
; 521  : 			this->swap(_Right);
; 522  : 			}
; 523  : 		}
; 524  : 
; 525  : 	void swap(_Myt& _Right)
; 526  : 		{	// swap with _Right
; 527  : 		if (this != _STD addressof(_Right))
; 528  : 			{	// different, swap base and buffer
; 529  : 			_Mybase::swap(_Right);
; 530  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 531  : 			}
; 532  : 		}
; 533  : 
; 534  : 	basic_ostringstream(const _Myt&) = delete;
; 535  : 	_Myt& operator=(const _Myt&) = delete;
; 536  : 
; 537  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 538  : 		{	// destroy the object
; 539  : 		}
; 540  : 
; 541  : 	_Mysb *rdbuf() const
; 542  : 		{	// return pointer to buffer
; 543  : 		return ((_Mysb *)&_Stringbuffer);
; 544  : 		}
; 545  : 
; 546  : 	_Mystr str() const
; 547  : 		{	// return string copy of character array
; 548  : 		return (_Stringbuffer.str());
; 549  : 		}
; 550  : 
; 551  : 	void str(const _Mystr& _Newstr)
; 552  : 		{	// replace character array from string
; 553  : 		_Stringbuffer.str(_Newstr);
; 554  : 		}
; 555  : 
; 556  : private:
; 557  : 	_Mysb _Stringbuffer;	// the string buffer
; 558  : 	};
; 559  : 
; 560  : 	// basic_ostringstream TEMPLATE OPERATORS
; 561  : template<class _Elem,
; 562  : 	class _Traits,
; 563  : 	class _Alloc> inline
; 564  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 565  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 566  : 	{	// swap _Left and _Right basic_ostringstreams
; 567  : 	_Left.swap(_Right);
; 568  : 	}
; 569  : 
; 570  : 		// TEMPLATE CLASS basic_stringstream
; 571  : template<class _Elem,
; 572  : 	class _Traits,
; 573  : 	class _Alloc>
; 574  : 	class basic_stringstream
; 575  : 		: public basic_iostream<_Elem, _Traits>
; 576  : 	{	// input/output stream associated with a character array
; 577  : public:
; 578  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 579  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 580  : 	typedef _Elem char_type;
; 581  : 	typedef _Traits traits_type;
; 582  : 	typedef _Alloc allocator_type;
; 583  : 	typedef typename _Traits::int_type int_type;
; 584  : 	typedef typename _Traits::pos_type pos_type;
; 585  : 	typedef typename _Traits::off_type off_type;
; 586  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 587  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 588  : 
; 589  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 590  : 		ios_base::in | ios_base::out)
; 591  : 		: _Mybase(&_Stringbuffer),

  003dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  003e2	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9

; 593  : 		{	// construct empty character buffer

  003e9	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _numers$90[ebp]
  003ef	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003f2	c7 84 05 88 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$90[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  003fd	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _numers$90[ebp]
  00403	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00406	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00409	89 84 0d 84 fe
	ff ff		 mov	 DWORD PTR _numers$90[ebp+ecx-4], eax
  00410	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _numers$90[ebp+24]

; 30   : 		{	// construct empty character buffer from mode

  00416	8b c8		 mov	 ecx, eax

; 592  : 			_Stringbuffer(_Mode)

  00418	89 85 50 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

  0041e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00424	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$90[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

  0042e	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$90[ebp+80], 0

; 312  : 		_Mystate = _State;

  00438	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$90[ebp+84], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 423  : 			stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  00442	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH

; 424  : 			numers << ((wylosowana_liczba - 1) / 3 + 1); //Wpisanie do typu obliczonego wiersza wylosowanej liczby

  00446	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  0044c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0044e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00453	49		 dec	 ecx
  00454	f7 e9		 imul	 ecx
  00456	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$90[ebp+16]
  0045c	8b c2		 mov	 eax, edx
  0045e	42		 inc	 edx
  0045f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00462	03 c2		 add	 eax, edx
  00464	50		 push	 eax
  00465	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 647  : 		return (_Stringbuffer.str());

  0046b	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR $T81[ebp]
  00471	50		 push	 eax
  00472	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$90[ebp+24]
  00478	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 425  : 			PlaySound((G³os + "w" + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiego wiersza jest wylosowana liczba

  0047d	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  00482	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T82[ebp]
  00488	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  0048c	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00491	83 c4 04	 add	 esp, 4
  00494	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T81[ebp]
  0049a	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  0049e	51		 push	 ecx
  0049f	8b d0		 mov	 edx, eax
  004a1	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T83[ebp]
  004a7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  004ac	83 c4 04	 add	 esp, 4
  004af	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  004b4	8b d0		 mov	 edx, eax
  004b6	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  004ba	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T84[ebp]
  004c0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  004c5	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004c8	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  004cc	72 02		 jb	 SHORT $LN1094@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  004ce	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1094@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 425  : 			PlaySound((G³os + "w" + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiego wiersza jest wylosowana liczba

  004d0	6a 00		 push	 0
  004d2	6a 00		 push	 0
  004d4	50		 push	 eax
  004d5	ff d7		 call	 edi
  004d7	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T84[ebp]
  004dd	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  004e2	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T83[ebp]
  004e8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  004ed	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T82[ebp]
  004f3	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  004f8	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T81[ebp]
  004fe	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 426  : 		}

  00503	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$90[ebp]
  00509	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  0050e	e9 84 00 00 00	 jmp	 $LN9@Odczytaj_l
$LN17@Odczytaj_l:

; 415  : 			if (wylosowana_liczba < 19) //Je¿eli wylosowa liczba jest mniejsza ni¿ 19

  00513	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  00519	83 39 13	 cmp	 DWORD PTR [ecx], 19	; 00000013H

; 416  : 				PlaySound((G³os + "g.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest z górnej po³ówki

  0051c	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  00522	7d 07		 jge	 SHORT $LN18@Odczytaj_l
  00524	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@

; 417  : 			else

  00529	eb 4a		 jmp	 SHORT $LN1110@Odczytaj_l
$LN18@Odczytaj_l:

; 418  : 				PlaySound((G³os + "d.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana liczba jest z dolnej po³ówki

  0052b	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@

; 419  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  00530	eb 43		 jmp	 SHORT $LN1110@Odczytaj_l
$LN12@Odczytaj_l:

; 410  : 			if (Ruletka_plansza_kolor[wylosowana_liczba] == 'r') //Je¿eli kolor wylosowanej liczby to czerwony

  00532	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  00538	8b 01		 mov	 eax, DWORD PTR [ecx]

; 411  : 				PlaySound((G³os + "r.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest koloru czerwonego

  0053a	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T34[ebp]
  00540	80 b8 00 00 00
	00 72		 cmp	 BYTE PTR ?Ruletka_plansza_kolor@@3QBDB[eax], 114 ; 00000072H
  00547	75 07		 jne	 SHORT $LN13@Odczytaj_l
  00549	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@

; 412  : 			else

  0054e	eb 25		 jmp	 SHORT $LN1110@Odczytaj_l
$LN13@Odczytaj_l:

; 413  : 				PlaySound((G³os + "b.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e liczba jest koloru czarnego

  00550	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  00555	eb 1e		 jmp	 SHORT $LN1110@Odczytaj_l
$LN7@Odczytaj_l:

; 405  : 			if (wylosowana_liczba % 2 == 0) //Je¿eli wylosowana liczba modulo 2 jest 0 to

  00557	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  0055d	8b 01		 mov	 eax, DWORD PTR [ecx]

; 406  : 				PlaySound((G³os + "p.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana licza jest parzysta

  0055f	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  00565	a8 01		 test	 al, 1
  00567	75 07		 jne	 SHORT $LN8@Odczytaj_l
  00569	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@

; 407  : 			else

  0056e	eb 05		 jmp	 SHORT $LN1110@Odczytaj_l
$LN8@Odczytaj_l:

; 408  : 				PlaySound((G³os + "n.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana licza jest nieparzysta

  00570	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
$LN1110@Odczytaj_l:
  00575	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0057a	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0057d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00581	72 02		 jb	 SHORT $LN515@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00583	8b 00		 mov	 eax, DWORD PTR [eax]
$LN515@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 408  : 				PlaySound((G³os + "n.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana licza jest nieparzysta

  00585	6a 00		 push	 0
  00587	6a 00		 push	 0
  00589	50		 push	 eax
  0058a	ff d7		 call	 edi
  0058c	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
$LN1107@Odczytaj_l:
  00592	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN9@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 637  : 		{	// destroy the object

  00597	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  0059d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  005a0	c7 84 05 38 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  005ab	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  005b1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005b4	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  005b7	89 84 0d 34 ff
	ff ff		 mov	 DWORD PTR _numers$[ebp+ecx-4], eax

; 638  : 		}

  005be	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+24]
  005c4	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  005c9	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+32]
  005cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  005d5	8d 4d a0	 lea	 ecx, DWORD PTR _numers$[ebp+104]
  005d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN3@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 427  : }

  005de	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005e1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005e8	59		 pop	 ecx
  005e9	5f		 pop	 edi
  005ea	5e		 pop	 esi
  005eb	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005ee	33 cd		 xor	 ecx, ebp
  005f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f5	8b e5		 mov	 esp, ebp
  005f7	5d		 pop	 ebp
  005f8	8b e3		 mov	 esp, ebx
  005fa	5b		 pop	 ebx
  005fb	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$19:
  00000	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0d 00 00
	00		 je	 $LN49@Odczytaj_l
  0000c	83 65 e8 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8d 4d a0	 lea	 ecx, DWORD PTR _numers$[ebp+104]
  00013	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN49@Odczytaj_l:
  00019	c3		 ret	 0
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$20:
  0001a	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+32]
  00020	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$22:
  00026	8b 8d 50 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00032	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp]
  00038	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  0003d	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
  00048	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0004e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$10:
  00053	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]
  00059	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$11:
  0005e	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T65[ebp]
  00064	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$167:
  00069	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  0006c	83 e0 20	 and	 eax, 32			; 00000020H
  0006f	0f 84 10 00 00
	00		 je	 $LN725@Odczytaj_l
  00075	83 65 e8 df	 and	 DWORD PTR $T1[ebp], -33	; ffffffdfH
  00079	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$90[ebp+104]
  0007f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN725@Odczytaj_l:
  00085	c3		 ret	 0
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$168:
  00086	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$90[ebp+32]
  0008c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$170:
  00092	8b 8d 50 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00098	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$13:
  0009e	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$90[ebp]
  000a4	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$14:
  000a9	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T81[ebp]
  000af	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$15:
  000b4	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T82[ebp]
  000ba	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$16:
  000bf	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T83[ebp]
  000c5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  000ca	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000ce	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000d1	8b 8a 20 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-480]
  000d7	33 c8		 xor	 ecx, eax
  000d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000de	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  000e1	33 c8		 xor	 ecx, eax
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  000ed	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Odczytaj_liczbê
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 637  : 		{	// destroy the object

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8d 71 68	 lea	 esi, DWORD PTR [ecx+104]

; 638  : 		}

  00006	8d 4e b0	 lea	 ecx, DWORD PTR [esi-80]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00014	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  0001d	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00026	8d 4e b8	 lea	 ecx, DWORD PTR [esi-72]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0002f	8b ce		 mov	 ecx, esi
  00031	5e		 pop	 esi
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	68 b0 00 00 00	 push	 176			; 000000b0H
  00005	6a 00		 push	 0
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memset
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00010	c2 04 00	 ret	 4
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_typ_zak³adu$GSCopy$1$ = -180				; size = 4
_log$GSCopy$1$ = -176					; size = 4
tv3038 = -176						; size = 4
_wylosowana_liczba$GSCopy$1$ = -172			; size = 4
tv3033 = -172						; size = 4
_kwota_zak³adu$GSCopy$1$ = -168				; size = 4
_iloœæ_pieniêdzy$GSCopy$1$ = -164			; size = 4
_buf2$179 = -160					; size = 24
_buf2$180 = -136					; size = 24
_buf2$181 = -112					; size = 24
_buf2$182 = -88						; size = 24
_bufor2$183 = -64					; size = 24
_buf$184 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_co_kontynuowaæ$ = 8					; size = 4
_iloœæ_pieniêdzy$ = 12					; size = 4
_kwota_zak³adu$ = 16					; size = 4
_wylosowana_liczba$ = 20				; size = 4
_typ_zak³adu$ = 24					; size = 4
?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; Wczytaj_z_pliku, COMDAT
; _log_ogólny$ = ecx
; _log$ = edx

; 430  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b fa		 mov	 edi, edx
  00030	89 bd 50 ff ff
	ff		 mov	 DWORD PTR _log$GSCopy$1$[ebp], edi
  00036	8b f1		 mov	 esi, ecx

; 431  : 	if (!czy_kontynuowaæ_grê) //Je¿eli czy_kontynuowaæ_grê == 0

  00038	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?czy_kontynuowaæ_grê@@3FA, 0 ; czy_kontynuowaæ_grê
  00040	8b 45 0c	 mov	 eax, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  00043	8b 5d 08	 mov	 ebx, DWORD PTR _co_kontynuowaæ$[ebp]
  00046	89 85 5c ff ff
	ff		 mov	 DWORD PTR _iloœæ_pieniêdzy$GSCopy$1$[ebp], eax
  0004c	8b 45 10	 mov	 eax, DWORD PTR _kwota_zak³adu$[ebp]
  0004f	89 85 58 ff ff
	ff		 mov	 DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp], eax
  00055	8b 45 14	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00058	89 85 54 ff ff
	ff		 mov	 DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp], eax
  0005e	8b 45 18	 mov	 eax, DWORD PTR _typ_zak³adu$[ebp]
  00061	89 85 4c ff ff
	ff		 mov	 DWORD PTR _typ_zak³adu$GSCopy$1$[ebp], eax
  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___access
  0006c	75 54		 jne	 SHORT $LN31@Wczytaj_z_

; 432  : 		if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  0006e	6a 00		 push	 0
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00075	ff d0		 call	 eax
  00077	83 c4 08	 add	 esp, 8
  0007a	85 c0		 test	 eax, eax
  0007c	75 3f		 jne	 SHORT $LN1274@Wczytaj_z_

; 433  : 		{
; 434  : 			co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 435  : 			remove("log_aktualny.txt"); //Usuniêcie pliku log aktualny poniewa¿ rozpoczyna siê now¹ grê

  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00083	c6 03 6e	 mov	 BYTE PTR [ebx], 110	; 0000006eH
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__remove
  0008c	83 c4 04	 add	 esp, 4

; 436  : 			log_ogólny << endl << "Uruchomiono ponownie grê z wy³¹czon¹ opcj¹ kontynuowania" << endl; //Wpisanie do buforu logu ogólnego informacje o rozpoczêciu nowej gry spowodowane ustawieniem gry

  0008f	8b ce		 mov	 ecx, esi
  00091	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00096	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  000a1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@
  000a6	8b c8		 mov	 ecx, eax
  000a8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000ad	8b c8		 mov	 ecx, eax
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 437  : 			log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000b5	8b ce		 mov	 ecx, esi
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN1274@Wczytaj_z_:

; 432  : 		if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___access
$LN31@Wczytaj_z_:

; 440  : 	if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000c2	6a 00		 push	 0
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000c9	ff d0		 call	 eax
  000cb	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000ce	51		 push	 ecx
  000cf	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 440  : 	if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000d2	85 c0		 test	 eax, eax
  000d4	0f 85 e1 08 00
	00		 jne	 $LN32@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000da	6a 01		 push	 1
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000e1	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  000e6	85 c0		 test	 eax, eax

; 1360 : 			_Myios::setstate(ios_base::failbit);

  000e8	8b 07		 mov	 eax, DWORD PTR [edi]
  000ea	6a 00		 push	 0
  000ec	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ef	75 0c		 jne	 SHORT $LN74@Wczytaj_z_
  000f1	6a 02		 push	 2
  000f3	03 cf		 add	 ecx, edi
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1361 : 		else

  000fb	eb 0a		 jmp	 SHORT $LN75@Wczytaj_z_
$LN74@Wczytaj_z_:

; 1362 : 			_Myios::clear();	// added with C++11

  000fd	6a 00		 push	 0
  000ff	03 cf		 add	 ecx, edi
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN75@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00107	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _buf$184[ebp+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0010e	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _buf$184[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00115	c6 45 d8 00	 mov	 BYTE PTR _buf$184[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 443  : 		string buf, bufor2; //Uworzenie 2 buforów na tekst, pierwszy na ostatni¹ linie tekst, drugi na przedostani¹ nie pust¹ linie tekstu lub ostani¹ w przypadku gdy ostania jest pusta

  00119	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00120	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _bufor2$183[ebp+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00127	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _bufor2$183[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0012e	c6 45 c0 00	 mov	 BYTE PTR _bufor2$183[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 443  : 		string buf, bufor2; //Uworzenie 2 buforów na tekst, pierwszy na ostatni¹ linie tekst, drugi na przedostani¹ nie pust¹ linie tekstu lub ostani¹ w przypadku gdy ostania jest pusta

  00132	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00136	8b 07		 mov	 eax, DWORD PTR [edi]
  00138	6a 0a		 push	 10			; 0000000aH
  0013a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013d	03 cf		 add	 ecx, edi
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00145	0f b6 c0	 movzx	 eax, al
  00148	8d 55 d8	 lea	 edx, DWORD PTR _buf$184[ebp]
  0014b	50		 push	 eax
  0014c	8b cf		 mov	 ecx, edi
  0014e	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 314  : 		return (_Mystate);

  00153	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00155	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 314  : 		return (_Mystate);

  00158	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  0015b	f6 44 38 0c 01	 test	 BYTE PTR [eax+edi+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 445  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  00160	75 54		 jne	 SHORT $LN3@Wczytaj_z_
$LL2@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3956 : 	return (!(_Left == _Right));

  00162	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00167	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  0016a	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0016f	84 c0		 test	 al, al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 447  : 			if (buf != "") bufor2 = buf; //Sprawdzenie czy odczytana linia nie jest pusta, je¿eli nie jest pusta to skopiowanie do drugiego bufora celem posiadania dwóch ostatnich linijek tekstu bêd¹cego w pliku

  00171	75 17		 jne	 SHORT $LN135@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00173	83 7d ec 10	 cmp	 DWORD PTR _buf$184[ebp+20], 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00177	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0017a	ff 75 e8	 push	 DWORD PTR _buf$184[ebp+16]

; 1607 : 		if (_Large_string_engaged())

  0017d	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$184[ebp]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00181	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$183[ebp]
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN135@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  0018a	8b 07		 mov	 eax, DWORD PTR [edi]
  0018c	6a 0a		 push	 10			; 0000000aH
  0018e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00191	03 cf		 add	 ecx, edi
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00199	0f b6 c0	 movzx	 eax, al
  0019c	8d 55 d8	 lea	 edx, DWORD PTR _buf$184[ebp]
  0019f	50		 push	 eax
  001a0	8b cf		 mov	 ecx, edi
  001a2	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 314  : 		return (_Mystate);

  001a7	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  001a9	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 314  : 		return (_Mystate);

  001ac	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  001af	f6 44 38 0c 01	 test	 BYTE PTR [eax+edi+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 445  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  001b4	74 ac		 je	 SHORT $LL2@Wczytaj_z_
$LN3@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001b6	83 7d e8 00	 cmp	 DWORD PTR _buf$184[ebp+16], 0
  001ba	75 1b		 jne	 SHORT $LN195@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001bc	33 c0		 xor	 eax, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001be	75 17		 jne	 SHORT $LN195@Wczytaj_z_

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001c0	83 7d d4 10	 cmp	 DWORD PTR _bufor2$183[ebp+20], 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  001c4	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$183[ebp]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  001c7	ff 75 d0	 push	 DWORD PTR _bufor2$183[ebp+16]

; 1607 : 		if (_Large_string_engaged())

  001ca	0f 43 45 c0	 cmovae	 eax, DWORD PTR _bufor2$183[ebp]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  001ce	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN195@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 451  : 		if (buf.find("Posiadasz") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o skoñczeniu rundy

  001d7	51		 push	 ecx
  001d8	68 00 00 00 00	 push	 OFFSET ??_C@_09LFKNBKJA@Posiadasz?$AA@
  001dd	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  001e0	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  001e5	83 f8 ff	 cmp	 eax, -1
  001e8	0f 84 f1 00 00
	00		 je	 $LN36@Wczytaj_z_

; 452  : 		{
; 453  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 454  : 			auto pocz¹tek = (unsigned short)buf.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst pozycji ostatniego znaku tekstu o kwocie pieniêdzy któr¹ posiada jeszcze gracz, typ zmiennej auto wsazuje, ¿e kompilator sam wybierze typ zmiennej

  001ee	0f b7 75 e8	 movzx	 esi, WORD PTR _buf$184[ebp+16]
  001f2	8b 55 ec	 mov	 edx, DWORD PTR _buf$184[ebp+20]
  001f5	c6 03 6e	 mov	 BYTE PTR [ebx], 110	; 0000006eH
  001f8	8b 5d d8	 mov	 ebx, DWORD PTR _buf$184[ebp]
  001fb	0f 1f 44 00 00	 npad	 5
$LL4@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00200	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 455  : 			while (buf[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  00203	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00206	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  00209	0f 43 cb	 cmovae	 ecx, ebx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 455  : 			while (buf[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  0020c	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  00210	74 0d		 je	 SHORT $LN5@Wczytaj_z_
  00212	66 85 f6	 test	 si, si
  00215	74 08		 je	 SHORT $LN5@Wczytaj_z_
  00217	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  0021d	eb e1		 jmp	 SHORT $LL4@Wczytaj_z_
$LN5@Wczytaj_z_:

; 456  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu
; 457  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeœniej odczytanego tekstu

  0021f	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]
  00222	46		 inc	 esi
  00223	50		 push	 eax
  00224	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$180[ebp]
  0022a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0022f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00233	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$180[ebp]

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00239	8b 45 88	 mov	 eax, DWORD PTR _buf2$180[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 458  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  0023c	0f b7 d6	 movzx	 edx, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  0023f	3b c2		 cmp	 eax, edx
  00241	0f 42 d0	 cmovb	 edx, eax

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00244	83 7d 8c 10	 cmp	 DWORD PTR _buf2$180[ebp+20], 16 ; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00248	0f 43 8d 78 ff
	ff ff		 cmovae	 ecx, DWORD PTR _buf2$180[ebp]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  0024f	2b c2		 sub	 eax, edx

; 2622 : 		_My_data._Mysize = _New_size;

  00251	89 45 88	 mov	 DWORD PTR _buf2$180[ebp+16], eax

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00254	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00255	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00256	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00259	50		 push	 eax
  0025a	51		 push	 ecx
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 459  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00261	8b 75 88	 mov	 esi, DWORD PTR _buf2$180[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00264	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 459  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00267	8d 5e ff	 lea	 ebx, DWORD PTR [esi-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  0026a	3b f3		 cmp	 esi, ebx
  0026c	73 05		 jae	 SHORT $LN291@Wczytaj_z_

; 1623 : 			{
; 1624 : 			_Xran();

  0026e	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN1277@Wczytaj_z_:
$LN291@Wczytaj_z_:

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00273	8b c6		 mov	 eax, esi

; 1595 : 		value_type * _Result = _Bx._Buf;

  00275	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$180[ebp]

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  0027b	2b c3		 sub	 eax, ebx
  0027d	ba 01 00 00 00	 mov	 edx, 1
  00282	3b c2		 cmp	 eax, edx
  00284	0f 42 d0	 cmovb	 edx, eax

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00287	83 7d 8c 10	 cmp	 DWORD PTR _buf2$180[ebp+20], 16 ; 00000010H

; 1596 : 		if (_Large_string_engaged())

  0028b	0f 43 8d 78 ff
	ff ff		 cmovae	 ecx, DWORD PTR _buf2$180[ebp]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00292	2b f2		 sub	 esi, edx
  00294	03 cb		 add	 ecx, ebx

; 2622 : 		_My_data._Mysize = _New_size;

  00296	89 75 88	 mov	 DWORD PTR _buf2$180[ebp+16], esi

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00299	2b f3		 sub	 esi, ebx
  0029b	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0029c	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0029d	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  002a0	50		 push	 eax
  002a1	51		 push	 ecx
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002a8	83 7d 8c 10	 cmp	 DWORD PTR _buf2$180[ebp+20], 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  002ac	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buf2$180[ebp]

; 1607 : 		if (_Large_string_engaged())

  002b2	0f 43 85 78 ff
	ff ff		 cmovae	 eax, DWORD PTR _buf2$180[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 460  : 			iloœæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  002b9	50		 push	 eax
  002ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  002c0	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloœæ_pieniêdzy$GSCopy$1$[ebp]
  002c6	83 c4 10	 add	 esp, 16			; 00000010H

; 461  : 		}

  002c9	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  002cd	89 01		 mov	 DWORD PTR [ecx], eax
  002cf	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$180[ebp]
  002d5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002da	e9 17 06 00 00	 jmp	 $LN50@Wczytaj_z_
$LN36@Wczytaj_z_:

; 462  : 		else if (buf.find("Wylosowano") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o wylosowaniu liczby

  002df	51		 push	 ecx
  002e0	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DAFLKCID@Wylosowano?$AA@
  002e5	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  002e8	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  002ed	83 f8 ff	 cmp	 eax, -1
  002f0	0f 84 7a 02 00
	00		 je	 $LN38@Wczytaj_z_

; 463  : 		{
; 464  : 			co_kontynuowaæ = 'w'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od sprawdzenia wygranej
; 465  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o wylosowanej liczbie

  002f6	8b 55 e8	 mov	 edx, DWORD PTR _buf$184[ebp+16]
  002f9	33 f6		 xor	 esi, esi
  002fb	c6 03 77	 mov	 BYTE PTR [ebx], 119	; 00000077H
  002fe	8b 5d ec	 mov	 ebx, DWORD PTR _buf$184[ebp+20]
$LL6@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00301	83 fb 10	 cmp	 ebx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 466  : 			while (buf[pocz¹tek] != 'y' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukiwanie od pocz¹tku litery y która wystêpuje w wyrazie po którym jest wylosowana liczba

  00304	0f b7 ce	 movzx	 ecx, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00307	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  0030a	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$184[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 466  : 			while (buf[pocz¹tek] != 'y' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukiwanie od pocz¹tku litery y która wystêpuje w wyrazie po którym jest wylosowana liczba

  0030e	80 3c 01 79	 cmp	 BYTE PTR [ecx+eax], 121	; 00000079H
  00312	74 07		 je	 SHORT $LN7@Wczytaj_z_
  00314	3b ca		 cmp	 ecx, edx
  00316	7d 03		 jge	 SHORT $LN7@Wczytaj_z_
  00318	46		 inc	 esi
  00319	eb e6		 jmp	 SHORT $LL6@Wczytaj_z_
$LN7@Wczytaj_z_:

; 467  : 			pocz¹tek += 10; //Przesuniêcie o +10 pozycji pocz¹tku tekstu o po której jest wylosowana liczba
; 468  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeœniej odczytanego tekstu

  0031b	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]
  0031e	83 c6 0a	 add	 esi, 10			; 0000000aH
  00321	50		 push	 eax
  00322	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  00325	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 469  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  0032a	0f b7 c6	 movzx	 eax, si
  0032d	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  00330	50		 push	 eax
  00331	6a 00		 push	 0
  00333	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00337	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0033c	83 7d bc 10	 cmp	 DWORD PTR _buf2$182[ebp+20], 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00340	8d 45 a8	 lea	 eax, DWORD PTR _buf2$182[ebp]

; 1607 : 		if (_Large_string_engaged())

  00343	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$182[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 470  : 			wylosowana_liczba = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  00347	50		 push	 eax
  00348	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0034e	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  00354	83 c4 04	 add	 esp, 4

; 471  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o typie zak³adu

  00357	8b 5d ec	 mov	 ebx, DWORD PTR _buf$184[ebp+20]
  0035a	33 f6		 xor	 esi, esi
  0035c	8b 55 e8	 mov	 edx, DWORD PTR _buf$184[ebp+16]
  0035f	89 01		 mov	 DWORD PTR [ecx], eax
$LL8@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00361	83 fb 10	 cmp	 ebx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 472  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (int)buf.size()) ++pocz¹tek;

  00364	0f b7 ce	 movzx	 ecx, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00367	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  0036a	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$184[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 472  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (int)buf.size()) ++pocz¹tek;

  0036e	80 3c 01 64	 cmp	 BYTE PTR [ecx+eax], 100	; 00000064H
  00372	74 07		 je	 SHORT $LN9@Wczytaj_z_
  00374	3b ca		 cmp	 ecx, edx
  00376	7d 03		 jge	 SHORT $LN9@Wczytaj_z_
  00378	46		 inc	 esi
  00379	eb e6		 jmp	 SHORT $LL8@Wczytaj_z_
$LN9@Wczytaj_z_:

; 473  : 			pocz¹tek += 2;  //Przesuniêcie o +2 pozycji pocz¹tku tekstu o po której jest typ zak³adu

  0037b	83 c6 02	 add	 esi, 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0037e	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00381	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00384	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  00387	52		 push	 edx

; 1607 : 		if (_Large_string_engaged())

  00388	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$184[ebp]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0038c	50		 push	 eax
  0038d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 475  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00392	0f b7 c6	 movzx	 eax, si
  00395	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  00398	50		 push	 eax
  00399	6a 00		 push	 0
  0039b	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3062 : 		return (this->_Get_data()._Mysize);

  003a0	8b 75 b8	 mov	 esi, DWORD PTR _buf2$182[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 476  : 			buf2.erase(buf2.find(" Wylosowano"), buf2.size() - buf2.find(" Wylosowano"));

  003a3	51		 push	 ecx
  003a4	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
  003a9	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  003ac	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  003b1	2b f0		 sub	 esi, eax
  003b3	56		 push	 esi
  003b4	51		 push	 ecx
  003b5	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
  003ba	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  003bd	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  003c2	50		 push	 eax
  003c3	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  003c6	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2253 : 		if (this != _STD addressof(_Right))

  003cb	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _typ_zak³adu$GSCopy$1$[ebp]
  003d1	8d 45 a8	 lea	 eax, DWORD PTR _buf2$182[ebp]
  003d4	3b c8		 cmp	 ecx, eax
  003d6	74 11		 je	 SHORT $LN426@Wczytaj_z_

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003d8	83 7d bc 10	 cmp	 DWORD PTR _buf2$182[ebp+20], 16 ; 00000010H

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  003dc	ff 75 b8	 push	 DWORD PTR _buf2$182[ebp+16]

; 1607 : 		if (_Large_string_engaged())

  003df	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$182[ebp]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  003e3	50		 push	 eax
  003e4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN426@Wczytaj_z_:

; 3062 : 		return (this->_Get_data()._Mysize);

  003e9	8b 75 e8	 mov	 esi, DWORD PTR _buf$184[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 478  : 			buf.erase(buf.find("Obstawiono zaklad"), buf.size() - buf.find("Obstawiono zaklad"));

  003ec	51		 push	 ecx
  003ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  003f2	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  003f5	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  003fa	2b f0		 sub	 esi, eax
  003fc	56		 push	 esi
  003fd	51		 push	 ecx
  003fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  00403	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  00406	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0040b	50		 push	 eax
  0040c	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  0040f	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00414	8b 5d ec	 mov	 ebx, DWORD PTR _buf$184[ebp+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00417	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  0041a	8b 4d d8	 mov	 ecx, DWORD PTR _buf$184[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 479  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie zak³adu

  0041d	33 d2		 xor	 edx, edx

; 481  : 			else //Je¿eli nie to

  0041f	66 8b 7d e8	 mov	 di, WORD PTR _buf$184[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00423	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00426	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 480  : 			if (buf[12] == 'a') { pocz¹tek = 14; } //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a œwiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  00429	80 78 0c 61	 cmp	 BYTE PTR [eax+12], 97	; 00000061H
  0042d	75 07		 jne	 SHORT $LN1264@Wczytaj_z_
  0042f	ba 0e 00 00 00	 mov	 edx, 14			; 0000000eH

; 481  : 			else //Je¿eli nie to

  00434	eb 2a		 jmp	 SHORT $LN41@Wczytaj_z_
$LN1264@Wczytaj_z_:
  00436	8b 75 d8	 mov	 esi, DWORD PTR _buf$184[ebp]
  00439	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00440	83 fb 10	 cmp	 ebx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 483  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z œwiadcz¹cej o wyrazie po którym jest kwota zak³adu

  00443	0f b7 c2	 movzx	 eax, dx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00446	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  00449	0f 43 ce	 cmovae	 ecx, esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 483  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z œwiadcz¹cej o wyrazie po którym jest kwota zak³adu

  0044c	80 3c 08 7a	 cmp	 BYTE PTR [eax+ecx], 122	; 0000007aH
  00450	74 08		 je	 SHORT $LN11@Wczytaj_z_
  00452	66 3b d7	 cmp	 dx, di
  00455	73 03		 jae	 SHORT $LN11@Wczytaj_z_
  00457	42		 inc	 edx
  00458	eb e6		 jmp	 SHORT $LL10@Wczytaj_z_
$LN11@Wczytaj_z_:
  0045a	8b 4d d8	 mov	 ecx, DWORD PTR _buf$184[ebp]

; 484  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  0045d	83 c2 03	 add	 edx, 3
$LN41@Wczytaj_z_:

; 485  : 			}
; 486  : 			int koniec = pocz¹tek + 1; //Przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  00460	0f b7 c2	 movzx	 eax, dx
  00463	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv3033[ebp], eax
  00469	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0046c	0f 1f 40 00	 npad	 4
$LL12@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00470	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  00473	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  00476	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 487  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Poszukujemy znaku dolara przed którym jest kwota zak³adu

  00479	80 3c 30 24	 cmp	 BYTE PTR [eax+esi], 36	; 00000024H
  0047d	74 0a		 je	 SHORT $LN13@Wczytaj_z_
  0047f	0f b7 c7	 movzx	 eax, di
  00482	3b f0		 cmp	 esi, eax
  00484	7d 03		 jge	 SHORT $LN13@Wczytaj_z_
  00486	46		 inc	 esi
  00487	eb e7		 jmp	 SHORT $LL12@Wczytaj_z_
$LN13@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00489	ff 75 e8	 push	 DWORD PTR _buf$184[ebp+16]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0048c	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0048f	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 1607 : 		if (_Large_string_engaged())

  00492	0f 43 c1	 cmovae	 eax, ecx

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00495	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  00498	50		 push	 eax
  00499	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 489  : 			buf2.erase(koniec, buf2.size() - koniec); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  0049e	8b 45 b8	 mov	 eax, DWORD PTR _buf2$182[ebp+16]
  004a1	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  004a4	2b c6		 sub	 eax, esi
  004a6	50		 push	 eax
  004a7	56		 push	 esi
  004a8	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 490  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  004ad	ff b5 54 ff ff
	ff		 push	 DWORD PTR tv3033[ebp]
  004b3	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  004b6	6a 00		 push	 0
  004b8	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004bd	83 7d bc 10	 cmp	 DWORD PTR _buf2$182[ebp+20], 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  004c1	8d 45 a8	 lea	 eax, DWORD PTR _buf2$182[ebp]

; 1607 : 		if (_Large_string_engaged())

  004c4	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$182[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 491  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  004c8	50		 push	 eax
  004c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  004cf	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]
  004d5	83 c4 04	 add	 esp, 4

; 492  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  004d8	0f b7 75 d0	 movzx	 esi, WORD PTR _bufor2$183[ebp+16]
  004dc	8b 55 d4	 mov	 edx, DWORD PTR _bufor2$183[ebp+20]
  004df	8b 5d c0	 mov	 ebx, DWORD PTR _bufor2$183[ebp]
  004e2	8b bd 50 ff ff
	ff		 mov	 edi, DWORD PTR _log$GSCopy$1$[ebp]
  004e8	89 01		 mov	 DWORD PTR [ecx], eax
  004ea	66 0f 1f 44 00
	00		 npad	 6
$LL14@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004f0	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 493  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  004f3	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  004f6	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$183[ebp]

; 1596 : 		if (_Large_string_engaged())

  004f9	0f 43 cb	 cmovae	 ecx, ebx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 493  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  004fc	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  00500	74 0d		 je	 SHORT $LN15@Wczytaj_z_
  00502	66 85 f6	 test	 si, si
  00505	74 08		 je	 SHORT $LN15@Wczytaj_z_
  00507	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  0050d	eb e1		 jmp	 SHORT $LL14@Wczytaj_z_
$LN15@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0050f	ff 75 d0	 push	 DWORD PTR _bufor2$183[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 494  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  00512	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00513	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$183[ebp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00516	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00519	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]

; 1607 : 		if (_Large_string_engaged())

  0051c	0f 43 c3	 cmovae	 eax, ebx

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0051f	50		 push	 eax
  00520	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 496  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00525	0f b7 c6	 movzx	 eax, si
  00528	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  0052b	50		 push	 eax
  0052c	6a 00		 push	 0
  0052e	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 497  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00533	8b 45 b8	 mov	 eax, DWORD PTR _buf2$182[ebp+16]
  00536	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  00539	6a 01		 push	 1
  0053b	48		 dec	 eax
  0053c	50		 push	 eax
  0053d	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00542	83 7d bc 10	 cmp	 DWORD PTR _buf2$182[ebp+20], 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00546	8d 45 a8	 lea	 eax, DWORD PTR _buf2$182[ebp]

; 1607 : 		if (_Large_string_engaged())

  00549	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$182[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 498  : 			iloœæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  0054d	50		 push	 eax
  0054e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00554	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloœæ_pieniêdzy$GSCopy$1$[ebp]
  0055a	83 c4 04	 add	 esp, 4

; 499  : 		}

  0055d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00561	89 01		 mov	 DWORD PTR [ecx], eax
  00563	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  00566	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0056b	e9 86 03 00 00	 jmp	 $LN50@Wczytaj_z_
$LN38@Wczytaj_z_:

; 500  : 		else if (buf.find("Obstawiono zaklad") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o typie obstawionego zak³adu

  00570	51		 push	 ecx
  00571	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  00576	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  00579	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0057e	83 f8 ff	 cmp	 eax, -1
  00581	0f 84 d9 01 00
	00		 je	 $LN42@Wczytaj_z_

; 501  : 		{
; 502  : 			co_kontynuowaæ = 't'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od wylosowania liczby
; 503  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o typie zak³adu

  00587	66 8b 55 e8	 mov	 dx, WORD PTR _buf$184[ebp+16]
  0058b	33 f6		 xor	 esi, esi
  0058d	c6 03 74	 mov	 BYTE PTR [ebx], 116	; 00000074H
  00590	8b 5d ec	 mov	 ebx, DWORD PTR _buf$184[ebp+20]
$LL16@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00593	83 fb 10	 cmp	 ebx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 504  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek;

  00596	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00599	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  0059c	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _buf$184[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 504  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek;

  005a0	80 3c 08 64	 cmp	 BYTE PTR [eax+ecx], 100	; 00000064H
  005a4	74 08		 je	 SHORT $LN17@Wczytaj_z_
  005a6	66 3b f2	 cmp	 si, dx
  005a9	73 03		 jae	 SHORT $LN17@Wczytaj_z_
  005ab	46		 inc	 esi
  005ac	eb e5		 jmp	 SHORT $LL16@Wczytaj_z_
$LN17@Wczytaj_z_:

; 505  : 			pocz¹tek += 2; //Przesuniêcie pozycji pocz¹tku tekstu o 2 po której jest typ zak³adu
; 506  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeœniej odczytanego tekstu

  005ae	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]
  005b1	83 c6 02	 add	 esi, 2
  005b4	50		 push	 eax
  005b5	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$181[ebp]
  005b8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 507  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  005bd	0f b7 c6	 movzx	 eax, si
  005c0	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$181[ebp]
  005c3	50		 push	 eax
  005c4	6a 00		 push	 0
  005c6	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  005ca	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2253 : 		if (this != _STD addressof(_Right))

  005cf	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _typ_zak³adu$GSCopy$1$[ebp]
  005d5	8d 45 90	 lea	 eax, DWORD PTR _buf2$181[ebp]
  005d8	3b c8		 cmp	 ecx, eax
  005da	74 11		 je	 SHORT $LN674@Wczytaj_z_

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005dc	83 7d a4 10	 cmp	 DWORD PTR _buf2$181[ebp+20], 16 ; 00000010H

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  005e0	ff 75 a0	 push	 DWORD PTR _buf2$181[ebp+16]

; 1607 : 		if (_Large_string_engaged())

  005e3	0f 43 45 90	 cmovae	 eax, DWORD PTR _buf2$181[ebp]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  005e7	50		 push	 eax
  005e8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN674@Wczytaj_z_:

; 3062 : 		return (this->_Get_data()._Mysize);

  005ed	8b 75 e8	 mov	 esi, DWORD PTR _buf$184[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 509  : 			buf.erase(buf.find("Obstawiono zaklad"), buf.size() - buf.find("Obstawiono zaklad"));

  005f0	51		 push	 ecx
  005f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  005f6	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  005f9	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  005fe	2b f0		 sub	 esi, eax
  00600	56		 push	 esi
  00601	51		 push	 ecx
  00602	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  00607	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  0060a	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0060f	50		 push	 eax
  00610	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  00613	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00618	8b 55 ec	 mov	 edx, DWORD PTR _buf$184[ebp+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  0061b	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  0061e	8b 4d d8	 mov	 ecx, DWORD PTR _buf$184[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 510  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie zak³adu

  00621	33 db		 xor	 ebx, ebx

; 511  : 			if (buf[12] == 'a') pocz¹tek = 14; //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a œwiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  00623	8b 75 e8	 mov	 esi, DWORD PTR _buf$184[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00626	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00629	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 511  : 			if (buf[12] == 'a') pocz¹tek = 14; //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a œwiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  0062c	80 78 0c 61	 cmp	 BYTE PTR [eax+12], 97	; 00000061H
  00630	75 0e		 jne	 SHORT $LL18@Wczytaj_z_
  00632	bb 0e 00 00 00	 mov	 ebx, 14			; 0000000eH

; 512  : 			else //Je¿eli nie to

  00637	eb 26		 jmp	 SHORT $LN45@Wczytaj_z_
  00639	0f 1f 80 00 00
	00 00		 npad	 7
$LL18@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00640	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  00643	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  00646	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 514  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukanie litery z œwiadcz¹cej o wyrazie po którym jest kwota zak³adu

  00649	0f b7 cb	 movzx	 ecx, bx
  0064c	80 3c 08 7a	 cmp	 BYTE PTR [eax+ecx], 122	; 0000007aH
  00650	74 0a		 je	 SHORT $LN19@Wczytaj_z_
  00652	3b ce		 cmp	 ecx, esi
  00654	7d 06		 jge	 SHORT $LN19@Wczytaj_z_
  00656	8b 4d d8	 mov	 ecx, DWORD PTR _buf$184[ebp]
  00659	43		 inc	 ebx
  0065a	eb e4		 jmp	 SHORT $LL18@Wczytaj_z_
$LN19@Wczytaj_z_:

; 515  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  0065c	83 c3 03	 add	 ebx, 3
$LN45@Wczytaj_z_:

; 516  : 			}
; 517  : 			unsigned short koniec = pocz¹tek + 1; //Przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  0065f	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00662	0f b7 f0	 movzx	 esi, ax
$LL20@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00665	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 518  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Pêtla poszukuj¹ca znaku dolara, pêtla koñczy siê znalezieniem znaku dolara

  00668	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  0066b	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  0066e	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _buf$184[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 518  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Pêtla poszukuj¹ca znaku dolara, pêtla koñczy siê znalezieniem znaku dolara

  00672	80 3c 08 24	 cmp	 BYTE PTR [eax+ecx], 36	; 00000024H
  00676	74 09		 je	 SHORT $LN21@Wczytaj_z_
  00678	66 3b 75 e8	 cmp	 si, WORD PTR _buf$184[ebp+16]
  0067c	73 03		 jae	 SHORT $LN21@Wczytaj_z_
  0067e	46		 inc	 esi
  0067f	eb e4		 jmp	 SHORT $LL20@Wczytaj_z_
$LN21@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00681	ff 75 e8	 push	 DWORD PTR _buf$184[ebp+16]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00684	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00687	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0068a	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$181[ebp]

; 1607 : 		if (_Large_string_engaged())

  0068d	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$184[ebp]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00691	50		 push	 eax
  00692	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 520  : 			buf2.erase(koniec, buf2.size() - koniec); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  00697	8b 45 a0	 mov	 eax, DWORD PTR _buf2$181[ebp+16]
  0069a	0f b7 ce	 movzx	 ecx, si
  0069d	2b c1		 sub	 eax, ecx
  0069f	50		 push	 eax
  006a0	51		 push	 ecx
  006a1	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$181[ebp]
  006a4	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 521  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  006a9	0f b7 c3	 movzx	 eax, bx
  006ac	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$181[ebp]
  006af	50		 push	 eax
  006b0	6a 00		 push	 0
  006b2	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006b7	83 7d a4 10	 cmp	 DWORD PTR _buf2$181[ebp+20], 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  006bb	8d 45 90	 lea	 eax, DWORD PTR _buf2$181[ebp]

; 1607 : 		if (_Large_string_engaged())

  006be	0f 43 45 90	 cmovae	 eax, DWORD PTR _buf2$181[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 522  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  006c2	50		 push	 eax
  006c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  006c9	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]
  006cf	83 c4 04	 add	 esp, 4

; 523  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  006d2	0f b7 75 d0	 movzx	 esi, WORD PTR _bufor2$183[ebp+16]
  006d6	8b 55 d4	 mov	 edx, DWORD PTR _bufor2$183[ebp+20]
  006d9	8b 5d c0	 mov	 ebx, DWORD PTR _bufor2$183[ebp]
  006dc	89 01		 mov	 DWORD PTR [ecx], eax
  006de	66 90		 npad	 2
$LL22@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006e0	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 524  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  006e3	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  006e6	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$183[ebp]

; 1596 : 		if (_Large_string_engaged())

  006e9	0f 43 cb	 cmovae	 ecx, ebx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 524  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  006ec	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  006f0	74 0d		 je	 SHORT $LN23@Wczytaj_z_
  006f2	66 85 f6	 test	 si, si
  006f5	74 08		 je	 SHORT $LN23@Wczytaj_z_
  006f7	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  006fd	eb e1		 jmp	 SHORT $LL22@Wczytaj_z_
$LN23@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  006ff	ff 75 d0	 push	 DWORD PTR _bufor2$183[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 525  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  00702	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00703	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$183[ebp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00706	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00709	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$181[ebp]

; 1607 : 		if (_Large_string_engaged())

  0070c	0f 43 c3	 cmovae	 eax, ebx

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0070f	50		 push	 eax
  00710	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 527  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00715	0f b7 c6	 movzx	 eax, si
  00718	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$181[ebp]
  0071b	50		 push	 eax
  0071c	6a 00		 push	 0
  0071e	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 528  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00723	8b 45 a0	 mov	 eax, DWORD PTR _buf2$181[ebp+16]
  00726	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$181[ebp]
  00729	6a 01		 push	 1
  0072b	48		 dec	 eax
  0072c	50		 push	 eax
  0072d	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00732	83 7d a4 10	 cmp	 DWORD PTR _buf2$181[ebp+20], 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00736	8d 45 90	 lea	 eax, DWORD PTR _buf2$181[ebp]

; 1607 : 		if (_Large_string_engaged())

  00739	0f 43 45 90	 cmovae	 eax, DWORD PTR _buf2$181[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 529  : 			iloœæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  0073d	50		 push	 eax
  0073e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00744	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloœæ_pieniêdzy$GSCopy$1$[ebp]
  0074a	83 c4 04	 add	 esp, 4

; 530  : 		}

  0074d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00751	89 01		 mov	 DWORD PTR [ecx], eax
  00753	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$181[ebp]
  00756	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0075b	e9 96 01 00 00	 jmp	 $LN50@Wczytaj_z_
$LN42@Wczytaj_z_:

; 531  : 		else if (buf.find("Obstawiono za") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o kwocie obstawionego zak³adu

  00760	51		 push	 ecx
  00761	68 00 00 00 00	 push	 OFFSET ??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@
  00766	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  00769	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0076e	83 f8 ff	 cmp	 eax, -1
  00771	0f 84 6e 01 00
	00		 je	 $LN46@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00777	8b 55 ec	 mov	 edx, DWORD PTR _buf$184[ebp+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  0077a	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  0077d	8b 4d d8	 mov	 ecx, DWORD PTR _buf$184[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 534  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  00780	33 f6		 xor	 esi, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00782	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 533  : 			co_kontynuowaæ = 'k';  //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od zapytania o typ zak³adu

  00785	c6 03 6b	 mov	 BYTE PTR [ebx], 107	; 0000006bH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1596 : 		if (_Large_string_engaged())

  00788	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 535  : 			if (buf[12] == 'a') { pocz¹tek = 14; } //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a œwiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  0078b	80 78 0c 61	 cmp	 BYTE PTR [eax+12], 97	; 00000061H
  0078f	75 07		 jne	 SHORT $LN1261@Wczytaj_z_
  00791	be 0e 00 00 00	 mov	 esi, 14			; 0000000eH

; 536  : 			else //Je¿eli nie to

  00796	eb 29		 jmp	 SHORT $LN49@Wczytaj_z_
$LN1261@Wczytaj_z_:
  00798	8b 5d d8	 mov	 ebx, DWORD PTR _buf$184[ebp]
  0079b	0f 1f 44 00 00	 npad	 5
$LL24@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007a0	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 538  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z œwiadcz¹cej o wyrazie po którym jest kwota zak³adu

  007a3	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  007a6	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  007a9	0f 43 cb	 cmovae	 ecx, ebx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 538  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z œwiadcz¹cej o wyrazie po którym jest kwota zak³adu

  007ac	80 3c 08 7a	 cmp	 BYTE PTR [eax+ecx], 122	; 0000007aH
  007b0	74 09		 je	 SHORT $LN25@Wczytaj_z_
  007b2	66 3b 75 e8	 cmp	 si, WORD PTR _buf$184[ebp+16]
  007b6	73 03		 jae	 SHORT $LN25@Wczytaj_z_
  007b8	46		 inc	 esi
  007b9	eb e5		 jmp	 SHORT $LL24@Wczytaj_z_
$LN25@Wczytaj_z_:
  007bb	8b 4d d8	 mov	 ecx, DWORD PTR _buf$184[ebp]

; 539  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  007be	83 c6 03	 add	 esi, 3
$LN49@Wczytaj_z_:

; 540  : 			}
; 541  : 			unsigned short koniec = pocz¹tek + 1; //Utworzenie i przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  007c1	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  007c4	0f b7 d8	 movzx	 ebx, ax
$LL26@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007c7	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  007ca	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]

; 1596 : 		if (_Large_string_engaged())

  007cd	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 542  : 			while (buf[koniec] != '$' && koniec < (int)buf.size()) ++koniec;

  007d0	0f b7 cb	 movzx	 ecx, bx
  007d3	80 3c 01 24	 cmp	 BYTE PTR [ecx+eax], 36	; 00000024H
  007d7	74 0b		 je	 SHORT $LN27@Wczytaj_z_
  007d9	3b 4d e8	 cmp	 ecx, DWORD PTR _buf$184[ebp+16]
  007dc	7d 06		 jge	 SHORT $LN27@Wczytaj_z_
  007de	8b 4d d8	 mov	 ecx, DWORD PTR _buf$184[ebp]
  007e1	43		 inc	 ebx
  007e2	eb e3		 jmp	 SHORT $LL26@Wczytaj_z_
$LN27@Wczytaj_z_:

; 543  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeœniej odczytanego tekstu

  007e4	8d 45 d8	 lea	 eax, DWORD PTR _buf$184[ebp]
  007e7	50		 push	 eax
  007e8	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$179[ebp]
  007ee	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  007f3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 544  : 			buf2.erase(koniec, buf2.size() - koniec); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  007f7	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _buf2$179[ebp+16]
  007fd	0f b7 cb	 movzx	 ecx, bx
  00800	2b c1		 sub	 eax, ecx
  00802	50		 push	 eax
  00803	51		 push	 ecx
  00804	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$179[ebp]
  0080a	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 545  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  0080f	0f b7 c6	 movzx	 eax, si
  00812	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$179[ebp]
  00818	50		 push	 eax
  00819	6a 00		 push	 0
  0081b	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00820	83 bd 74 ff ff
	ff 10		 cmp	 DWORD PTR _buf2$179[ebp+20], 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00827	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _buf2$179[ebp]

; 1607 : 		if (_Large_string_engaged())

  0082d	0f 43 85 60 ff
	ff ff		 cmovae	 eax, DWORD PTR _buf2$179[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 546  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  00834	50		 push	 eax
  00835	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0083b	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]
  00841	83 c4 04	 add	 esp, 4

; 547  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  00844	0f b7 75 d0	 movzx	 esi, WORD PTR _bufor2$183[ebp+16]
  00848	8b 55 d4	 mov	 edx, DWORD PTR _bufor2$183[ebp+20]
  0084b	8b 5d c0	 mov	 ebx, DWORD PTR _bufor2$183[ebp]
  0084e	89 01		 mov	 DWORD PTR [ecx], eax
$LL28@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00850	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 548  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  00853	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00856	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$183[ebp]

; 1596 : 		if (_Large_string_engaged())

  00859	0f 43 cb	 cmovae	 ecx, ebx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 548  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  0085c	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  00860	74 0d		 je	 SHORT $LN29@Wczytaj_z_
  00862	66 85 f6	 test	 si, si
  00865	74 08		 je	 SHORT $LN29@Wczytaj_z_
  00867	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  0086d	eb e1		 jmp	 SHORT $LL28@Wczytaj_z_
$LN29@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0086f	ff 75 d0	 push	 DWORD PTR _bufor2$183[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 549  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  00872	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00873	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$183[ebp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00876	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00879	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$179[ebp]

; 1607 : 		if (_Large_string_engaged())

  0087f	0f 43 c3	 cmovae	 eax, ebx

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00882	50		 push	 eax
  00883	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 551  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00888	0f b7 c6	 movzx	 eax, si
  0088b	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$179[ebp]
  00891	50		 push	 eax
  00892	6a 00		 push	 0
  00894	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 552  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00899	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _buf2$179[ebp+16]
  0089f	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$179[ebp]
  008a5	6a 01		 push	 1
  008a7	48		 dec	 eax
  008a8	50		 push	 eax
  008a9	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008ae	83 bd 74 ff ff
	ff 10		 cmp	 DWORD PTR _buf2$179[ebp+20], 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  008b5	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _buf2$179[ebp]

; 1607 : 		if (_Large_string_engaged())

  008bb	0f 43 85 60 ff
	ff ff		 cmovae	 eax, DWORD PTR _buf2$179[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 553  : 			iloœæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  008c2	50		 push	 eax
  008c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  008c9	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloœæ_pieniêdzy$GSCopy$1$[ebp]
  008cf	83 c4 04	 add	 esp, 4

; 554  : 		}

  008d2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  008d6	89 01		 mov	 DWORD PTR [ecx], eax
  008d8	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$179[ebp]
  008de	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  008e3	eb 11		 jmp	 SHORT $LN50@Wczytaj_z_
$LN46@Wczytaj_z_:

; 555  : 		else if (buf.find("Gra rozpoczeta dnia") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o rozpoczêciu nowej gry

  008e5	51		 push	 ecx
  008e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@
  008eb	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  008ee	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  008f3	c6 03 6e	 mov	 BYTE PTR [ebx], 110	; 0000006eH
$LN50@Wczytaj_z_:

; 556  : 		{
; 557  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 558  : 		}
; 559  : 		else //Je¿eli coœ pójdzie nie tak, to warunek aby gra siê niewysypa³a
; 560  : 		{
; 561  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 562  : 		}
; 563  : 		log.close(); //Zamkniêcie pliku logu ogólnego

  008f6	8b cf		 mov	 ecx, edi
  008f8	e8 00 00 00 00	 call	 ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::close
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  008fd	51		 push	 ecx
  008fe	6a 0a		 push	 10			; 0000000aH
  00900	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00905	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00908	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  0090d	85 c0		 test	 eax, eax

; 1360 : 			_Myios::setstate(ios_base::failbit);

  0090f	8b 07		 mov	 eax, DWORD PTR [edi]
  00911	6a 00		 push	 0
  00913	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00916	75 0c		 jne	 SHORT $LN1061@Wczytaj_z_
  00918	6a 02		 push	 2
  0091a	03 cf		 add	 ecx, edi
  0091c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1361 : 		else

  00922	eb 0a		 jmp	 SHORT $LN1062@Wczytaj_z_
$LN1061@Wczytaj_z_:

; 1362 : 			_Myios::clear();	// added with C++11

  00924	6a 00		 push	 0
  00926	03 cf		 add	 ecx, edi
  00928	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN1062@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0092e	8b 45 d4	 mov	 eax, DWORD PTR _bufor2$183[ebp+20]
  00931	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  00934	72 2e		 jb	 SHORT $LN1091@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00936	8b 4d c0	 mov	 ecx, DWORD PTR _bufor2$183[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00939	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0093a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0093f	72 1a		 jb	 SHORT $LN1094@Wczytaj_z_

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00941	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00944	75 6f		 jne	 SHORT $_Invalid_parameter$1279

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00946	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00949	3b c1		 cmp	 eax, ecx
  0094b	73 68		 jae	 SHORT $_Invalid_parameter$1279

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0094d	2b c8		 sub	 ecx, eax
  0094f	83 f9 04	 cmp	 ecx, 4
  00952	72 61		 jb	 SHORT $_Invalid_parameter$1279

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00954	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00957	77 5c		 ja	 SHORT $_Invalid_parameter$1279

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00959	8b c8		 mov	 ecx, eax
$LN1094@Wczytaj_z_:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0095b	51		 push	 ecx
  0095c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00961	83 c4 04	 add	 esp, 4
$LN1091@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00964	8b 45 ec	 mov	 eax, DWORD PTR _buf$184[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  00967	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _bufor2$183[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0096e	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _bufor2$183[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00975	c6 45 c0 00	 mov	 BYTE PTR _bufor2$183[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00979	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  0097c	0f 82 a0 02 00
	00		 jb	 $LN33@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00982	8b 4d d8	 mov	 ecx, DWORD PTR _buf$184[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00985	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00986	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0098b	72 1a		 jb	 SHORT $LN1140@Wczytaj_z_

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0098d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00990	75 23		 jne	 SHORT $_Invalid_parameter$1279

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00992	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00995	3b c1		 cmp	 eax, ecx
  00997	73 1c		 jae	 SHORT $_Invalid_parameter$1279

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00999	2b c8		 sub	 ecx, eax
  0099b	83 f9 04	 cmp	 ecx, 4
  0099e	72 15		 jb	 SHORT $_Invalid_parameter$1279

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  009a0	83 f9 23	 cmp	 ecx, 35			; 00000023H
  009a3	77 10		 ja	 SHORT $_Invalid_parameter$1279

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  009a5	8b c8		 mov	 ecx, eax
$LN1140@Wczytaj_z_:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  009a7	51		 push	 ecx
  009a8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  009ad	83 c4 04	 add	 esp, 4
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 566  : 	else

  009b0	e9 6d 02 00 00	 jmp	 $LN33@Wczytaj_z_
$_Invalid_parameter$1279:
$_Invalid_parameter$1280:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  009b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1278@Wczytaj_z_:
$LN32@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  009bb	6a 02		 push	 2
  009bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 568  : 		co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  009c2	c6 03 6e	 mov	 BYTE PTR [ebx], 110	; 0000006eH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  009c5	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  009ca	85 c0		 test	 eax, eax

; 1360 : 			_Myios::setstate(ios_base::failbit);

  009cc	8b 07		 mov	 eax, DWORD PTR [edi]
  009ce	6a 00		 push	 0
  009d0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  009d3	75 0c		 jne	 SHORT $LN1157@Wczytaj_z_
  009d5	6a 02		 push	 2
  009d7	03 cf		 add	 ecx, edi
  009d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1361 : 		else

  009df	eb 0a		 jmp	 SHORT $LN1158@Wczytaj_z_
$LN1157@Wczytaj_z_:

; 1362 : 			_Myios::clear();	// added with C++11

  009e1	6a 00		 push	 0
  009e3	03 cf		 add	 ecx, edi
  009e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN1158@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 570  : 		GetSystemTime(&Czas); //Pobieranie aktualnej daty i czasu z zegara systemowego

  009eb	68 00 00 00 00	 push	 OFFSET ?Czas@@3U_SYSTEMTIME@@A ; Czas
  009f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemTime@4

; 571  : 		log << "Gra rozpoczeta dnia " << Czas.wDay << "." << Czas.wMonth << "." << Czas.wYear << " o godzinie "; //Wpisanie do bufora zapisu danych o dniu,miesi¹cu i roku do pliku log_aktualny.txt

  009f6	33 c0		 xor	 eax, eax
  009f8	8d 5f 10	 lea	 ebx, DWORD PTR [edi+16]
  009fb	85 ff		 test	 edi, edi
  009fd	89 9d 50 ff ff
	ff		 mov	 DWORD PTR tv3038[ebp], ebx
  00a03	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@
  00a08	0f 44 d8	 cmove	 ebx, eax
  00a0b	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A
  00a12	50		 push	 eax
  00a13	0f b7 05 02 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+2
  00a1a	8b cb		 mov	 ecx, ebx
  00a1c	50		 push	 eax
  00a1d	0f b7 05 06 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+6
  00a24	50		 push	 eax
  00a25	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00a2a	8b c8		 mov	 ecx, eax
  00a2c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00a32	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00a37	8b c8		 mov	 ecx, eax
  00a39	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00a3e	8b c8		 mov	 ecx, eax
  00a40	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00a46	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00a4b	8b c8		 mov	 ecx, eax
  00a4d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00a52	8b c8		 mov	 ecx, eax
  00a54	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00a5a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
  00a5f	8b c8		 mov	 ecx, eax
  00a61	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 572  : 		if (Czas.wHour < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania godzinny je¿eli godzina jest minejsza ni¿ 10 do pliku log_aktualny.txt

  00a66	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
  00a6c	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00a70	73 12		 jae	 SHORT $LN52@Wczytaj_z_
  00a72	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00a77	8b cb		 mov	 ecx, ebx
  00a79	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00a7e	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
$LN52@Wczytaj_z_:

; 573  : 		log << Czas.wHour << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia godzin od minut do pliku log_aktualny.txt

  00a84	8b bd 50 ff ff
	ff		 mov	 edi, DWORD PTR tv3038[ebp]
  00a8a	8b cf		 mov	 ecx, edi
  00a8c	0f b7 c0	 movzx	 eax, ax
  00a8f	50		 push	 eax
  00a90	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00a96	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00a9b	8b c8		 mov	 ecx, eax
  00a9d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 574  : 		if (Czas.wMinute < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania minut je¿eli minuty jest minejsze ni¿ 10 do pliku log_aktualny.txt

  00aa2	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
  00aa8	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00aac	73 12		 jae	 SHORT $LN53@Wczytaj_z_
  00aae	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00ab3	8b cb		 mov	 ecx, ebx
  00ab5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00aba	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
$LN53@Wczytaj_z_:

; 575  : 		log << Czas.wMinute << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia minut od sekund do pliku log_aktualny.txt

  00ac0	0f b7 c0	 movzx	 eax, ax
  00ac3	8b cf		 mov	 ecx, edi
  00ac5	50		 push	 eax
  00ac6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00acc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00ad1	8b c8		 mov	 ecx, eax
  00ad3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 576  : 		if (Czas.wSecond < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania sekund je¿eli sekundy jest minejsza ni¿ 10 do pliku log_aktualny.txt

  00ad8	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
  00ade	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00ae2	73 12		 jae	 SHORT $LN54@Wczytaj_z_
  00ae4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00ae9	8b cb		 mov	 ecx, ebx
  00aeb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00af0	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
$LN54@Wczytaj_z_:

; 577  : 		log << Czas.wSecond << endl; // Wpisanie do bufora zapisu danych o sekundzie do pliku log_aktualny.txt

  00af6	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00afb	0f b7 c0	 movzx	 eax, ax
  00afe	8b cf		 mov	 ecx, edi
  00b00	50		 push	 eax
  00b01	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00b07	8b c8		 mov	 ecx, eax
  00b09	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 578  : 		log_ogólny << "Nowa gra rozpoczeta dnia " << Czas.wDay << "." << Czas.wMonth << "." << Czas.wYear << " o godzinie "; //Wpisanie do bufora zapisu danych o dniu,miesi¹cu i roku do pliku log_ogólny.txt

  00b0f	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A
  00b16	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@
  00b1b	50		 push	 eax
  00b1c	0f b7 05 02 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+2
  00b23	8b ce		 mov	 ecx, esi
  00b25	50		 push	 eax
  00b26	0f b7 05 06 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+6
  00b2d	50		 push	 eax
  00b2e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00b33	8b c8		 mov	 ecx, eax
  00b35	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00b3b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00b40	8b c8		 mov	 ecx, eax
  00b42	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00b47	8b c8		 mov	 ecx, eax
  00b49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00b4f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00b54	8b c8		 mov	 ecx, eax
  00b56	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00b5b	8b c8		 mov	 ecx, eax
  00b5d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00b63	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
  00b68	8b c8		 mov	 ecx, eax
  00b6a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 579  : 		if (Czas.wHour < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania godzinny je¿eli godzina jest minejsza ni¿ 10 do pliku log_ogólny.txt

  00b6f	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
  00b75	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00b79	73 12		 jae	 SHORT $LN55@Wczytaj_z_
  00b7b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00b80	8b ce		 mov	 ecx, esi
  00b82	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00b87	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
$LN55@Wczytaj_z_:

; 580  : 		log_ogólny << Czas.wHour << ":";//Wpisanie do bufora zapisu znaku : dla rozdzielenia godzin od minut do pliku log_aktualny.txt

  00b8d	0f b7 c0	 movzx	 eax, ax
  00b90	8b ce		 mov	 ecx, esi
  00b92	50		 push	 eax
  00b93	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00b99	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00b9e	8b c8		 mov	 ecx, eax
  00ba0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 581  : 		if (Czas.wMinute < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania minut je¿eli minuty jest minejsza ni¿ 10 do pliku log_ogólny.txt

  00ba5	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
  00bab	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00baf	73 12		 jae	 SHORT $LN56@Wczytaj_z_
  00bb1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00bb6	8b ce		 mov	 ecx, esi
  00bb8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00bbd	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
$LN56@Wczytaj_z_:

; 582  : 		log_ogólny << Czas.wMinute << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia minut od sekund do pliku log_ogólny.txt

  00bc3	0f b7 c0	 movzx	 eax, ax
  00bc6	8b ce		 mov	 ecx, esi
  00bc8	50		 push	 eax
  00bc9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00bcf	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00bd4	8b c8		 mov	 ecx, eax
  00bd6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 583  : 		if (Czas.wSecond < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania sekund je¿eli sekundy jest minejsza ni¿ 10 do pliku log_ogólny.txt

  00bdb	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
  00be1	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00be5	73 12		 jae	 SHORT $LN57@Wczytaj_z_
  00be7	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00bec	8b ce		 mov	 ecx, esi
  00bee	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00bf3	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
$LN57@Wczytaj_z_:

; 584  : 		log_ogólny << Czas.wSecond << endl; // Wpisanie do bufora zapisu danych o sekundzie do pliku log_ogólny.txt

  00bf9	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00bfe	0f b7 c0	 movzx	 eax, ax
  00c01	8b ce		 mov	 ecx, esi
  00c03	50		 push	 eax
  00c04	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00c0a	8b c8		 mov	 ecx, eax
  00c0c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 585  : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  00c12	8b cf		 mov	 ecx, edi
  00c14	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 586  : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00c1a	8b ce		 mov	 ecx, esi
  00c1c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN33@Wczytaj_z_:

; 587  : 	}
; 588  : }

  00c22	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00c25	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00c2c	59		 pop	 ecx
  00c2d	5f		 pop	 edi
  00c2e	5e		 pop	 esi
  00c2f	5b		 pop	 ebx
  00c30	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c33	33 cd		 xor	 ecx, ebp
  00c35	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c3a	8b e5		 mov	 esp, ebp
  00c3c	5d		 pop	 ebp
  00c3d	c3		 ret	 0
$LN1276@Wczytaj_z_:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _buf$184[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$183[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2:
  00010	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$180[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3:
  0001b	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$182[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4:
  00023	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$181[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5:
  0002b	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$179[ebp]
  00031	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
  00036	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003d	8b 8a 44 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-188]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0004d	33 c8		 xor	 ecx, eax
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  00059	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; Wczytaj_z_pliku
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?SprawdŸ_Pliki@@YAXXZ
_TEXT	SEGMENT
$T444 = -520						; size = 24
$T370 = -520						; size = 24
$T235 = -520						; size = 24
$T441 = -496						; size = 24
$T362 = -496						; size = 24
$T214 = -496						; size = 24
$T443 = -472						; size = 24
$T349 = -472						; size = 24
$T266 = -472						; size = 24
$T233 = -472						; size = 24
$T442 = -448						; size = 24
$T320 = -448						; size = 24
$T265 = -448						; size = 24
$T215 = -448						; size = 24
$T445 = -424						; size = 24
$T350 = -424						; size = 24
$T236 = -424						; size = 24
$T148 = -424						; size = 24
$T130 = -424						; size = 24
$T112 = -424						; size = 24
$T94 = -424						; size = 24
$T76 = -424						; size = 24
$T54 = -424						; size = 24
$T240 = -400						; size = 1
tv9917 = -400						; size = 4
$T334 = -396						; size = 1
$T219 = -396						; size = 1
$T376 = -392						; size = 1
$T183 = -392						; size = 1
$T446 = -388						; size = 24
$T438 = -388						; size = 24
$T328 = -388						; size = 24
$T225 = -388						; size = 24
$T149 = -388						; size = 24
$T131 = -388						; size = 24
$T113 = -388						; size = 24
$T95 = -388						; size = 24
$T77 = -388						; size = 24
$T55 = -388						; size = 24
$T340 = -364						; size = 24
$T170 = -364						; size = 24
__Result$1$ = -340					; size = 4
$T272 = -340						; size = 1
_this$ = -340						; size = 4
$T447 = -336						; size = 24
$T439 = -336						; size = 24
$T308 = -336						; size = 24
$T264 = -336						; size = 24
$T246 = -336						; size = 24
$T151 = -336						; size = 24
$T133 = -336						; size = 24
$T115 = -336						; size = 24
$T97 = -336						; size = 24
$T79 = -336						; size = 24
$T57 = -336						; size = 24
$T382 = -312						; size = 24
$T278 = -312						; size = 24
$T189 = -312						; size = 24
$T448 = -288						; size = 24
$T437 = -288						; size = 24
$T307 = -288						; size = 24
$T254 = -288						; size = 24
$T160 = -288						; size = 24
$T152 = -288						; size = 24
$T142 = -288						; size = 24
$T134 = -288						; size = 24
$T124 = -288						; size = 24
$T116 = -288						; size = 24
$T106 = -288						; size = 24
$T98 = -288						; size = 24
$T88 = -288						; size = 24
$T80 = -288						; size = 24
$T66 = -288						; size = 24
$T58 = -288						; size = 24
$T44 = -288						; size = 24
$T39 = -288						; size = 24
$T29 = -288						; size = 24
_i$1$ = -264						; size = 4
$T450 = -264						; size = 4
$T10 = -264						; size = 1
$T1 = -264						; size = 4
_czy_pobrano$1$ = -258					; size = 1
_czy_pobierano$1$ = -257				; size = 1
_czy_pobierano$1$ = -257				; size = 1
_numers$451 = -256					; size = 176
_numers$452 = -256					; size = 176
_link$453 = -80						; size = 24
$T314 = -56						; size = 1
__Ch$ = -56						; size = 1
$T356 = -52						; size = 1
__Ch$ = -52						; size = 1
_g³os2$454 = -48					; size = 24
_i$1$ = -24						; size = 4
$T455 = -24						; size = 4
$T164 = -24						; size = 1
$T15 = -24						; size = 1
__Ch$ = -24						; size = 1
$T7 = -24						; size = 1
_i$1$ = -20						; size = 4
__Result$1$ = -20					; size = 4
__Result$1$ = -20					; size = 4
__Ch$ = -20						; size = 1
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?SprawdŸ_Pliki@@YAXXZ PROC				; SprawdŸ_Pliki, COMDAT

; 591  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SprawdŸ_Pliki@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec fc 01 00
	00		 sub	 esp, 508		; 000001fcH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 592  : 	if (efekty_dŸwiêkowe == 1) //Je¿eli w³¹czono efekty dŸwiêkowe

  00037	66 83 3d 00 00
	00 00 01	 cmp	 WORD PTR ?efekty_dŸwiêkowe@@3FA, 1 ; efekty_dŸwiêkowe
  0003f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___access
  00045	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__URLDownloadToFileA@20
  0004b	0f 85 54 02 00
	00		 jne	 $LN31@SprawdŸ_P

; 593  : 	{
; 594  : 		if ((_access("Efekty_dŸwiêkowe", 0))) //SprawdŸ czy nie ma folderu Efekty dŸwiêkowe

  00051	6a 00		 push	 0
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
  00058	ff d6		 call	 esi
  0005a	83 c4 08	 add	 esp, 8
  0005d	85 c0		 test	 eax, eax
  0005f	74 0d		 je	 SHORT $LN14@SprawdŸ_P

; 595  : 		{
; 596  : 			CreateDirectoryA("Efekty_dŸwiêkowe", nullptr); //Je¿eli nie ma to utwórz go

  00061	6a 00		 push	 0
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8
$LN14@SprawdŸ_P:

; 597  : 		}
; 598  : 
; 599  : 		bool czy_pobierano = false; //Utworzenie zmiennej informuj¹c¹ czy rozpoczêto pobieranie plików
; 600  : 		bool czy_pobrano = true; //Utworzenie zmiennej informuj¹c¹ czy ostatnie pobieranie zakoñczy³o siê sukesem
; 601  : 
; 602  : 		if ((_access("Efekty_dŸwiêkowe/bankrut.wav", 0))) //Sprawdzenie czy plik nie istnieje

  0006e	6a 00		 push	 0
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  00075	c6 85 ff fe ff
	ff 00		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0007c	c6 85 fe fe ff
	ff 01		 mov	 BYTE PTR _czy_pobrano$1$[ebp], 1
  00083	ff d6		 call	 esi
  00085	83 c4 08	 add	 esp, 8
  00088	85 c0		 test	 eax, eax
  0008a	74 65		 je	 SHORT $LN18@SprawdŸ_P

; 603  : 		{
; 604  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o
; 605  : 			{
; 606  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00092	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00097	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0009c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000a1	8b c8		 mov	 ecx, eax
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 607  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 608  : 			}
; 609  : 			auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/bankrut.wav", "Efekty_dŸwiêkowe/bankrut.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  000a9	6a 00		 push	 0
  000ab	6a 00		 push	 0
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@
  000b7	6a 00		 push	 0
  000b9	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  000c0	ff d7		 call	 edi

; 610  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  000c2	85 c0		 test	 eax, eax
  000c4	74 2b		 je	 SHORT $LN18@SprawdŸ_P

; 611  : 				if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 612  : 				{
; 613  : 					czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoœæ false
; 614  : 					cout << "Brak plików dla efektów dŸwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dŸwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  000c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000cc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  000d1	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000d6	c6 85 fe fe ff
	ff 00		 mov	 BYTE PTR _czy_pobrano$1$[ebp], 0
  000dd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000e2	8b c8		 mov	 ecx, eax
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 615  : 					EfektyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  000ea	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
$LN18@SprawdŸ_P:

; 616  : 				}
; 617  : 		}
; 618  : 
; 619  : 		if ((_access("Efekty_dŸwiêkowe/wygrana1.wav", 0))) //Sprawdzenie czy plik nie istnieje

  000f1	6a 00		 push	 0
  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
  000f8	ff d6		 call	 esi
  000fa	83 c4 08	 add	 esp, 8
  000fd	85 c0		 test	 eax, eax
  000ff	74 77		 je	 SHORT $LN22@SprawdŸ_P

; 620  : 		{
; 621  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00101	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00108	75 24		 jne	 SHORT $LN20@SprawdŸ_P

; 622  : 			{
; 623  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00110	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00115	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0011a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0011f	8b c8		 mov	 ecx, eax
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 624  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00127	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN20@SprawdŸ_P:

; 625  : 			}
; 626  : 			auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/wygrana1.wav", "Efekty_dŸwiêkowe/wygrana1.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  0012e	6a 00		 push	 0
  00130	6a 00		 push	 0
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@
  0013c	6a 00		 push	 0
  0013e	ff d7		 call	 edi

; 627  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00140	85 c0		 test	 eax, eax
  00142	74 34		 je	 SHORT $LN22@SprawdŸ_P

; 628  : 				if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo

  00144	80 bd fe fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobrano$1$[ebp], 0
  0014b	74 2b		 je	 SHORT $LN22@SprawdŸ_P

; 629  : 				{
; 630  : 					czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoœæ false
; 631  : 					cout << "Brak plików dla efektów dŸwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dŸwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  0014d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00153	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  00158	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0015d	c6 85 fe fe ff
	ff 00		 mov	 BYTE PTR _czy_pobrano$1$[ebp], 0
  00164	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00169	8b c8		 mov	 ecx, eax
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 632  : 					EfektyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  00171	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
$LN22@SprawdŸ_P:

; 633  : 				}
; 634  : 		}
; 635  : 
; 636  : 		if ((_access("Efekty_dŸwiêkowe/wygrana2.wav", 0))) //Sprawdzenie czy plik nie istnieje

  00178	6a 00		 push	 0
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
  0017f	ff d6		 call	 esi
  00181	83 c4 08	 add	 esp, 8
  00184	85 c0		 test	 eax, eax
  00186	74 77		 je	 SHORT $LN26@SprawdŸ_P

; 637  : 		{
; 638  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00188	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0018f	75 24		 jne	 SHORT $LN24@SprawdŸ_P

; 639  : 			{
; 640  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00191	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00197	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0019c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001a1	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001a6	8b c8		 mov	 ecx, eax
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 641  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  001ae	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN24@SprawdŸ_P:

; 642  : 			}
; 643  : 			auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/wygrana2.wav", "Efekty_dŸwiêkowe/wygrana2.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  001b5	6a 00		 push	 0
  001b7	6a 00		 push	 0
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
  001be	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@
  001c3	6a 00		 push	 0
  001c5	ff d7		 call	 edi

; 644  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  001c7	85 c0		 test	 eax, eax
  001c9	74 34		 je	 SHORT $LN26@SprawdŸ_P

; 645  : 				if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo

  001cb	80 bd fe fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobrano$1$[ebp], 0
  001d2	74 2b		 je	 SHORT $LN26@SprawdŸ_P

; 646  : 				{
; 647  : 					czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoœæ false
; 648  : 					cout << "Brak plików dla efektów dŸwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dŸwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  001d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001da	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  001df	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001e4	c6 85 fe fe ff
	ff 00		 mov	 BYTE PTR _czy_pobrano$1$[ebp], 0
  001eb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001f0	8b c8		 mov	 ecx, eax
  001f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 649  : 					EfektyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  001f8	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
$LN26@SprawdŸ_P:

; 650  : 				}
; 651  : 		}
; 652  : 
; 653  : 		if ((_access("Efekty_dŸwiêkowe/zwielokrotnenie.wav", 0))) //Sprawdzenie czy plik nie istnieje

  001ff	6a 00		 push	 0
  00201	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  00206	ff d6		 call	 esi
  00208	83 c4 08	 add	 esp, 8
  0020b	85 c0		 test	 eax, eax
  0020d	74 70		 je	 SHORT $LN30@SprawdŸ_P

; 654  : 		{
; 655  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  0020f	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00216	75 24		 jne	 SHORT $LN28@SprawdŸ_P

; 656  : 			{
; 657  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00218	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0021e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00223	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00228	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0022d	8b c8		 mov	 ecx, eax
  0022f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 658  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00235	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN28@SprawdŸ_P:

; 659  : 			}
; 660  : 			auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/zwielokrotnenie.wav", "Efekty_dŸwiêkowe/zwielokrotnenie.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  0023c	6a 00		 push	 0
  0023e	6a 00		 push	 0
  00240	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  00245	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@
  0024a	6a 00		 push	 0
  0024c	ff d7		 call	 edi

; 661  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0024e	85 c0		 test	 eax, eax
  00250	74 2d		 je	 SHORT $LN30@SprawdŸ_P

; 662  : 				if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo

  00252	80 bd fe fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobrano$1$[ebp], 0
  00259	74 24		 je	 SHORT $LN30@SprawdŸ_P

; 663  : 				{
; 664  : 					czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoœæ false
; 665  : 					cout << "Brak plików dla efektów dŸwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dŸwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00261	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  00266	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0026b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00270	8b c8		 mov	 ecx, eax
  00272	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 666  : 					EfektyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  00278	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
$LN30@SprawdŸ_P:

; 667  : 				}
; 668  : 		}
; 669  : 
; 670  : 		if (czy_pobierano) cout << "Pobrano brakuj¹ce pliki efektów" << endl; //Poinformowanie o ukoñczonu pobierania plików

  0027f	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00286	74 1d		 je	 SHORT $LN31@SprawdŸ_P
  00288	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0028e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@
  00293	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00298	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0029d	8b c8		 mov	 ecx, eax
  0029f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN31@SprawdŸ_P:

; 671  : 	}
; 672  : 
; 673  : 	if (g³os_odczytu_numeru > 0) //Je¿eli w³¹czono odczyt g³osowy

  002a5	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?g³os_odczytu_numeru@@3FA, 0 ; g³os_odczytu_numeru
  002ad	0f 8e 28 1d 00
	00		 jle	 $LN32@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002b3	6a 05		 push	 5
  002b5	68 00 00 00 00	 push	 OFFSET ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  002ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  002bf	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 677  : 		switch (g³os_odczytu_numeru) //U¿ycie warunku wielokrotnego wyboru do wpisania odpowiedniej nazwy g³osu do zmiennej g³os_nazwa

  002c4	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?g³os_odczytu_numeru@@3FA ; g³os_odczytu_numeru
  002cb	48		 dec	 eax
  002cc	83 f8 08	 cmp	 eax, 8
  002cf	77 4e		 ja	 SHORT $LN42@SprawdŸ_P
  002d1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN3671@SprawdŸ_P[eax*4]
$LN33@SprawdŸ_P:

; 678  : 		{
; 679  : 		case 1: //Gdy g³os_odczytu_numeru==1
; 680  : 		{
; 681  : 			G³os += "Jacek"; //Dodanie do zmiennej nazwy wybranego g³osu Jacek

  002d8	68 00 00 00 00	 push	 OFFSET ??_C@_05KFCKMKOB@Jacek?$AA@

; 682  : 			break; //Wyjœcie z instrukcji case //Wyjœcie z instrukcji case

  002dd	eb 36		 jmp	 SHORT $LN3670@SprawdŸ_P
$LN34@SprawdŸ_P:

; 683  : 		}
; 684  : 		case 2: //Gdy g³os_odczytu_numeru==2
; 685  : 		{
; 686  : 			G³os += "Ewa"; //Dodanie do zmiennej nazwy wybranego g³osu Ewa

  002df	68 00 00 00 00	 push	 OFFSET ??_C@_03FPCJKMNP@Ewa?$AA@

; 687  : 			break; //Wyjœcie z instrukcji case

  002e4	eb 2f		 jmp	 SHORT $LN3670@SprawdŸ_P
$LN35@SprawdŸ_P:

; 688  : 		}
; 689  : 		case 3: //Gdy g³os_odczytu_numeru==3
; 690  : 		{
; 691  : 			G³os += "Maja"; //Dodanie do zmiennej nazwy wybranego g³osu Maja

  002e6	68 00 00 00 00	 push	 OFFSET ??_C@_04CDICBAGM@Maja?$AA@

; 692  : 			break; //Wyjœcie z instrukcji case

  002eb	eb 28		 jmp	 SHORT $LN3670@SprawdŸ_P
$LN36@SprawdŸ_P:

; 693  : 		}
; 694  : 		case 4: //Gdy g³os_odczytu_numeru==4
; 695  : 		{
; 696  : 			G³os += "Jan"; //Dodanie do zmiennej nazwy wybranego g³osu Jan

  002ed	68 00 00 00 00	 push	 OFFSET ??_C@_03JIHJHPIE@Jan?$AA@

; 697  : 			break; //Wyjœcie z instrukcji case

  002f2	eb 21		 jmp	 SHORT $LN3670@SprawdŸ_P
$LN37@SprawdŸ_P:

; 698  : 		}
; 699  : 		case 5: //Gdy g³os_odczytu_numeru==5
; 700  : 		{
; 701  : 			G³os += "Jacek2"; //Dodanie do zmiennej nazwy wybranego g³osu Jacek 2

  002f4	68 00 00 00 00	 push	 OFFSET ??_C@_06DKNIKMFF@Jacek2?$AA@

; 702  : 			break; //Wyjœcie z instrukcji case

  002f9	eb 1a		 jmp	 SHORT $LN3670@SprawdŸ_P
$LN38@SprawdŸ_P:

; 703  : 		}
; 704  : 
; 705  : 		case 6: //Gdy g³os_odczytu_numeru==6
; 706  : 		{
; 707  : 			G³os += "Ewa2"; //Dodanie do zmiennej nazwy wybranego g³osu Ewa 2

  002fb	68 00 00 00 00	 push	 OFFSET ??_C@_04PLEDLCJI@Ewa2?$AA@

; 708  : 			break; //Wyjœcie z instrukcji case

  00300	eb 13		 jmp	 SHORT $LN3670@SprawdŸ_P
$LN39@SprawdŸ_P:

; 709  : 		}
; 710  : 		case 7: //Gdy g³os_odczytu_numeru==7
; 711  : 		{
; 712  : 			G³os += "Maja2"; //Dodanie do zmiennej nazwy wybranego g³osu Maja 2

  00302	68 00 00 00 00	 push	 OFFSET ??_C@_05KJFHPLBC@Maja2?$AA@

; 713  : 			break; //Wyjœcie z instrukcji case

  00307	eb 0c		 jmp	 SHORT $LN3670@SprawdŸ_P
$LN40@SprawdŸ_P:

; 714  : 		}
; 715  : 		case 8: //Gdy g³os_odczytu_numeru==8
; 716  : 		{
; 717  : 			G³os += "Jan2"; //Dodanie do zmiennej nazwy wybranego g³osu Jan 2

  00309	68 00 00 00 00	 push	 OFFSET ??_C@_04HDNGKDH@Jan2?$AA@

; 718  : 			break; //Wyjœcie z instrukcji case

  0030e	eb 05		 jmp	 SHORT $LN3670@SprawdŸ_P
$LN41@SprawdŸ_P:

; 719  : 		}
; 720  : 		case 9: //Gdy g³os_odczytu_numeru==9
; 721  : 		{
; 722  : 			G³os += "Agata"; //Dodanie do zmiennej nazwy wybranego g³osu Agata

  00310	68 00 00 00 00	 push	 OFFSET ??_C@_05NKPCGME@Agata?$AA@
$LN3670@SprawdŸ_P:
  00315	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0031a	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN42@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  0031f	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00325	8b c2		 mov	 eax, edx
  00327	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0032d	2b c1		 sub	 eax, ecx
  0032f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00335	6a 01		 push	 1
  00337	68 00 00 00 00	 push	 OFFSET ??_C@_01IDAFKMJL@_?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  0033c	83 f8 01	 cmp	 eax, 1
  0033f	72 25		 jb	 SHORT $LN173@SprawdŸ_P

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00341	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  00344	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00347	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  0034c	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1596 : 		if (_Large_string_engaged())

  00351	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00358	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0035a	56		 push	 esi
  0035b	ff d7		 call	 edi
  0035d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00360	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  00364	eb 13		 jmp	 SHORT $LN172@SprawdŸ_P
$LN173@SprawdŸ_P:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  00366	c6 45 e8 00	 mov	 BYTE PTR $T7[ebp], 0
  0036a	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0036f	ff 75 e8	 push	 DWORD PTR $T7[ebp]
  00372	6a 01		 push	 1
  00374	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN172@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 730  : 		G³os += '0' + g³os_szybkoœæ_odczytu_numeru; //Dodanie do zmiennej szybkoœci mowy

  00379	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  0037f	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 730  : 		G³os += '0' + g³os_szybkoœæ_odczytu_numeru; //Dodanie do zmiennej szybkoœci mowy

  00385	80 c1 30	 add	 cl, 48			; 00000030H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2992 : 		if (_Old_size < _My_data._Myres)

  00388	8b 35 14 00 00
	00		 mov	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20

; 2314 : 		push_back(_Ch);

  0038e	88 4d e8	 mov	 BYTE PTR __Ch$[ebp], cl

; 2992 : 		if (_Old_size < _My_data._Myres)

  00391	3b d6		 cmp	 edx, esi
  00393	73 21		 jae	 SHORT $LN197@SprawdŸ_P

; 2993 : 			{
; 2994 : 			_My_data._Mysize = _Old_size + 1;

  00395	8d 42 01	 lea	 eax, DWORD PTR [edx+1]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00398	83 fe 10	 cmp	 esi, 16			; 00000010H

; 2994 : 			_My_data._Mysize = _Old_size + 1;

  0039b	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  003a0	b8 00 00 00 00	 mov	 eax, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1596 : 		if (_Large_string_engaged())

  003a5	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  003ac	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  003af	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2998 : 			return;

  003b4	eb 1b		 jmp	 SHORT $LN196@SprawdŸ_P
$LN197@SprawdŸ_P:

; 3001 : 		_Reallocate_grow_by(1,

  003b6	ff 75 e8	 push	 DWORD PTR __Ch$[ebp]
  003b9	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR $T10[ebp], 0
  003c0	ff b5 f8 fe ff
	ff		 push	 DWORD PTR $T10[ebp]
  003c6	51		 push	 ecx
  003c7	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  003cc	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN196@SprawdŸ_P:

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  003d1	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  003d7	8b c2		 mov	 eax, edx
  003d9	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  003df	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  003e1	6a 01		 push	 1
  003e3	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  003e8	83 f8 01	 cmp	 eax, 1
  003eb	72 25		 jb	 SHORT $LN228@SprawdŸ_P

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003ed	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  003f0	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 1595 : 		value_type * _Result = _Bx._Buf;

  003f3	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  003f8	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1596 : 		if (_Large_string_engaged())

  003fd	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00404	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00406	56		 push	 esi
  00407	ff d7		 call	 edi
  00409	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  0040c	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  00410	eb 13		 jmp	 SHORT $LN227@SprawdŸ_P
$LN228@SprawdŸ_P:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  00412	c6 45 e8 00	 mov	 BYTE PTR $T15[ebp], 0
  00416	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0041b	ff 75 e8	 push	 DWORD PTR $T15[ebp]
  0041e	6a 01		 push	 1
  00420	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN227@SprawdŸ_P:

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00425	6a 42		 push	 66			; 00000042H
  00427	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
  0042c	8d 4d b0	 lea	 ecx, DWORD PTR _link$453[ebp]

; 3698 : 		_My_data._Mysize = 0;

  0042f	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _link$453[ebp+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00436	c7 45 c4 0f 00
	00 00		 mov	 DWORD PTR _link$453[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0043d	c6 45 b0 00	 mov	 BYTE PTR _link$453[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00441	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 733  : 		const string link = "https://github.com/talez2709/Ruletka/raw/master/Ruletka/G%C5%82os/"; //Zmienna przechowywuj¹ca pocz¹tek strony do pobierania g³osu

  00446	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  0044d	a1 10 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 3698 : 		_My_data._Mysize = 0;

  00452	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _g³os2$454[ebp+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00459	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR _g³os2$454[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00460	c6 45 d0 00	 mov	 BYTE PTR _g³os2$454[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  00464	83 f8 05	 cmp	 eax, 5
  00467	73 05		 jae	 SHORT $LN319@SprawdŸ_P

; 1623 : 			{
; 1624 : 			_Xran();

  00469	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN3672@SprawdŸ_P:
$LN319@SprawdŸ_P:

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  0046e	83 c0 fb	 add	 eax, -5			; fffffffbH
  00471	83 c9 ff	 or	 ecx, -1
  00474	83 f8 ff	 cmp	 eax, -1
  00477	0f 42 c8	 cmovb	 ecx, eax

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0047a	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00481	b8 00 00 00 00	 mov	 eax, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1607 : 		if (_Large_string_engaged())

  00486	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0048d	51		 push	 ecx
  0048e	83 c0 05	 add	 eax, 5
  00491	8d 4d d0	 lea	 ecx, DWORD PTR _g³os2$454[ebp]
  00494	50		 push	 eax
  00495	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0049a	bf 01 00 00 00	 mov	 edi, 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 737  : 		if ((_access("G³os", 0))) //SprawdŸ czy nie ma folderu G³os

  0049f	6a 00		 push	 0
  004a1	68 00 00 00 00	 push	 OFFSET ??_C@_04JLFAMLOH@G?$LDos?$AA@
  004a6	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  004aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access

; 738  : 		{
; 739  : 			CreateDirectoryA("G³os", nullptr); //Je¿eli nie ma to utwórz go

  004b0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateDirectoryA@8
  004b6	83 c4 08	 add	 esp, 8
  004b9	85 c0		 test	 eax, eax
  004bb	74 09		 je	 SHORT $LN43@SprawdŸ_P
  004bd	6a 00		 push	 0
  004bf	68 00 00 00 00	 push	 OFFSET ??_C@_04JLFAMLOH@G?$LDos?$AA@
  004c4	ff d6		 call	 esi
$LN43@SprawdŸ_P:

; 741  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //SprawdŸ czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoœci¹ g³osu

  004c6	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  004c9	50		 push	 eax
  004ca	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  004d0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  004d5	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004d8	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  004dc	72 02		 jb	 SHORT $LN348@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  004de	8b 00		 mov	 eax, DWORD PTR [eax]
$LN348@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 741  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //SprawdŸ czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoœci¹ g³osu

  004e0	6a 00		 push	 0
  004e2	50		 push	 eax
  004e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004e9	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR $T29[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 741  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //SprawdŸ czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoœci¹ g³osu

  004ef	83 c4 08	 add	 esp, 8
  004f2	89 45 e8	 mov	 DWORD PTR $T455[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004f5	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  004f8	72 45		 jb	 SHORT $LN381@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  004fa	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T29[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00500	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00501	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00507	72 2a		 jb	 SHORT $LN384@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00509	f6 c2 1f	 test	 dl, 31			; 0000001fH
  0050c	0f 85 c5 07 00
	00		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00512	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00515	3b c2		 cmp	 eax, edx
  00517	0f 83 ba 07 00
	00		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0051d	2b d0		 sub	 edx, eax
  0051f	83 fa 04	 cmp	 edx, 4
  00522	0f 82 af 07 00
	00		 jb	 $_Invalid_parameter$3674

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00528	83 fa 23	 cmp	 edx, 35			; 00000023H
  0052b	0f 87 a6 07 00
	00		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00531	8b d0		 mov	 edx, eax
$LN384@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00533	52		 push	 edx
  00534	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00539	8b 45 e8	 mov	 eax, DWORD PTR $T455[ebp]
  0053c	83 c4 04	 add	 esp, 4
$LN381@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 741  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //SprawdŸ czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoœci¹ g³osu

  0053f	85 c0		 test	 eax, eax
  00541	74 2a		 je	 SHORT $LN44@SprawdŸ_P

; 743  : 			CreateDirectoryA(("G³os/" + g³os2).c_str(), nullptr); //Je¿eli nie ma to utwórz go

  00543	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  00546	50		 push	 eax
  00547	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T39[ebp]
  0054d	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00552	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00555	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00559	72 02		 jb	 SHORT $LN410@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0055b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN410@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 743  : 			CreateDirectoryA(("G³os/" + g³os2).c_str(), nullptr); //Je¿eli nie ma to utwórz go

  0055d	6a 00		 push	 0
  0055f	50		 push	 eax
  00560	ff d6		 call	 esi
  00562	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T39[ebp]
  00568	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN44@SprawdŸ_P:

; 748  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0056d	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  00572	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  00578	c6 85 ff fe ff
	ff 00		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0057f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00584	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00587	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0058b	72 02		 jb	 SHORT $LN426@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0058d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN426@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 748  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0058f	6a 00		 push	 0
  00591	50		 push	 eax
  00592	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00598	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR $T44[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 748  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0059e	83 c4 08	 add	 esp, 8
  005a1	8b f0		 mov	 esi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005a3	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  005a6	72 42		 jb	 SHORT $LN459@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  005a8	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T44[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  005ae	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  005af	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  005b5	72 2a		 jb	 SHORT $LN462@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  005b7	f6 c2 1f	 test	 dl, 31			; 0000001fH
  005ba	0f 85 17 07 00
	00		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  005c0	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  005c3	3b c2		 cmp	 eax, edx
  005c5	0f 83 0c 07 00
	00		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  005cb	2b d0		 sub	 edx, eax
  005cd	83 fa 04	 cmp	 edx, 4
  005d0	0f 82 01 07 00
	00		 jb	 $_Invalid_parameter$3674

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  005d6	83 fa 23	 cmp	 edx, 35			; 00000023H
  005d9	0f 87 f8 06 00
	00		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  005df	8b d0		 mov	 edx, eax
$LN462@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  005e1	52		 push	 edx
  005e2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  005e7	83 c4 04	 add	 esp, 4
$LN459@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 748  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  005ea	85 f6		 test	 esi, esi
  005ec	0f 84 d2 00 00
	00		 je	 $LN47@SprawdŸ_P

; 749  : 		{
; 750  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o
; 751  : 			{
; 752  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  005f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005f8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  005fd	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00602	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00607	8b c8		 mov	 ecx, eax
  00609	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 755  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0060f	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  00612	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  00619	50		 push	 eax
  0061a	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T54[ebp]
  00620	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00625	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  0062a	8b d0		 mov	 edx, eax
  0062c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00630	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]
  00636	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0063b	8b f0		 mov	 esi, eax
  0063d	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  00640	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00644	50		 push	 eax
  00645	8d 55 b0	 lea	 edx, DWORD PTR _link$453[ebp]
  00648	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T57[ebp]
  0064e	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00653	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  00658	8b d0		 mov	 edx, eax
  0065a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0065e	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T58[ebp]
  00664	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00669	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0066c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00670	72 02		 jb	 SHORT $LN488@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00672	8b 36		 mov	 esi, DWORD PTR [esi]
$LN488@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00674	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00678	72 02		 jb	 SHORT $LN504@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0067a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN504@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 755  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0067c	6a 00		 push	 0
  0067e	6a 00		 push	 0
  00680	56		 push	 esi
  00681	50		 push	 eax
  00682	6a 00		 push	 0
  00684	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  0068a	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T58[ebp]
  00690	8b f0		 mov	 esi, eax
  00692	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00697	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T57[ebp]
  0069d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  006a2	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]
  006a8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  006ad	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T54[ebp]
  006b3	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  006b7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 756  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  006bc	85 f6		 test	 esi, esi
  006be	0f 85 0a 0c 00
	00		 jne	 $LN3579@SprawdŸ_P
$LN47@SprawdŸ_P:

; 764  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  006c4	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  006c9	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T66[ebp]
  006cf	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  006d4	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006d7	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  006db	72 02		 jb	 SHORT $LN520@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  006dd	8b 00		 mov	 eax, DWORD PTR [eax]
$LN520@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 764  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  006df	6a 00		 push	 0
  006e1	50		 push	 eax
  006e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006e8	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR $T66[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 764  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  006ee	83 c4 08	 add	 esp, 8
  006f1	8b f0		 mov	 esi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006f3	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  006f6	72 42		 jb	 SHORT $LN553@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  006f8	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T66[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  006fe	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  006ff	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00705	72 2a		 jb	 SHORT $LN556@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00707	f6 c2 1f	 test	 dl, 31			; 0000001fH
  0070a	0f 85 c7 05 00
	00		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00710	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00713	3b c2		 cmp	 eax, edx
  00715	0f 83 bc 05 00
	00		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0071b	2b d0		 sub	 edx, eax
  0071d	83 fa 04	 cmp	 edx, 4
  00720	0f 82 b1 05 00
	00		 jb	 $_Invalid_parameter$3674

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00726	83 fa 23	 cmp	 edx, 35			; 00000023H
  00729	0f 87 a8 05 00
	00		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0072f	8b d0		 mov	 edx, eax
$LN556@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00731	52		 push	 edx
  00732	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00737	83 c4 04	 add	 esp, 4
$LN553@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 764  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0073a	85 f6		 test	 esi, esi
  0073c	0f 84 db 00 00
	00		 je	 $LN50@SprawdŸ_P

; 765  : 		{
; 766  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00742	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00749	75 24		 jne	 SHORT $LN49@SprawdŸ_P

; 767  : 			{
; 768  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0074b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00751	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00756	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0075b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00760	8b c8		 mov	 ecx, eax
  00762	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 769  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00768	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN49@SprawdŸ_P:

; 771  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0076f	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  00772	50		 push	 eax
  00773	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T76[ebp]
  00779	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0077e	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  00783	8b d0		 mov	 edx, eax
  00785	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00789	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T77[ebp]
  0078f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00794	8b f0		 mov	 esi, eax
  00796	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  00799	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0079d	50		 push	 eax
  0079e	8d 55 b0	 lea	 edx, DWORD PTR _link$453[ebp]
  007a1	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T79[ebp]
  007a7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  007ac	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  007b1	8b d0		 mov	 edx, eax
  007b3	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  007b7	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T80[ebp]
  007bd	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  007c2	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007c5	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  007c9	72 02		 jb	 SHORT $LN582@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  007cb	8b 36		 mov	 esi, DWORD PTR [esi]
$LN582@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007cd	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  007d1	72 02		 jb	 SHORT $LN598@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  007d3	8b 00		 mov	 eax, DWORD PTR [eax]
$LN598@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 771  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  007d5	6a 00		 push	 0
  007d7	6a 00		 push	 0
  007d9	56		 push	 esi
  007da	50		 push	 eax
  007db	6a 00		 push	 0
  007dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  007e3	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T80[ebp]
  007e9	8b f0		 mov	 esi, eax
  007eb	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  007f0	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T79[ebp]
  007f6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  007fb	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T77[ebp]
  00801	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00806	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T76[ebp]
  0080c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00810	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 772  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00815	85 f6		 test	 esi, esi
  00817	0f 85 b1 0a 00
	00		 jne	 $LN3579@SprawdŸ_P
$LN50@SprawdŸ_P:

; 780  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0081d	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  00822	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T88[ebp]
  00828	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0082d	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00830	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00834	72 02		 jb	 SHORT $LN614@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00836	8b 00		 mov	 eax, DWORD PTR [eax]
$LN614@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 780  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00838	6a 00		 push	 0
  0083a	50		 push	 eax
  0083b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  00841	83 c4 08	 add	 esp, 8
  00844	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T88[ebp]
  0084a	8b f0		 mov	 esi, eax
  0084c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00851	85 f6		 test	 esi, esi
  00853	0f 84 db 00 00
	00		 je	 $LN53@SprawdŸ_P

; 781  : 		{
; 782  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00859	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00860	75 24		 jne	 SHORT $LN52@SprawdŸ_P

; 783  : 			{
; 784  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00862	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00868	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0086d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00872	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00877	8b c8		 mov	 ecx, eax
  00879	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 785  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  0087f	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN52@SprawdŸ_P:

; 787  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00886	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  00889	50		 push	 eax
  0088a	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T94[ebp]
  00890	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00895	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  0089a	8b d0		 mov	 edx, eax
  0089c	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  008a0	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T95[ebp]
  008a6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  008ab	8b f0		 mov	 esi, eax
  008ad	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  008b0	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  008b4	50		 push	 eax
  008b5	8d 55 b0	 lea	 edx, DWORD PTR _link$453[ebp]
  008b8	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T97[ebp]
  008be	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  008c3	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  008c8	8b d0		 mov	 edx, eax
  008ca	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  008ce	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T98[ebp]
  008d4	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  008d9	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008dc	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  008e0	72 02		 jb	 SHORT $LN630@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  008e2	8b 36		 mov	 esi, DWORD PTR [esi]
$LN630@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008e4	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  008e8	72 02		 jb	 SHORT $LN646@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  008ea	8b 00		 mov	 eax, DWORD PTR [eax]
$LN646@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 787  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  008ec	6a 00		 push	 0
  008ee	6a 00		 push	 0
  008f0	56		 push	 esi
  008f1	50		 push	 eax
  008f2	6a 00		 push	 0
  008f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  008fa	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T98[ebp]
  00900	8b f0		 mov	 esi, eax
  00902	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00907	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T97[ebp]
  0090d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00912	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T95[ebp]
  00918	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0091d	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T94[ebp]
  00923	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00927	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 788  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0092c	85 f6		 test	 esi, esi
  0092e	0f 85 9a 09 00
	00		 jne	 $LN3579@SprawdŸ_P
$LN53@SprawdŸ_P:

; 796  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00934	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  00939	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T106[ebp]
  0093f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00944	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00947	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0094b	72 02		 jb	 SHORT $LN662@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0094d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN662@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 796  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0094f	6a 00		 push	 0
  00951	50		 push	 eax
  00952	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  00958	83 c4 08	 add	 esp, 8
  0095b	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T106[ebp]
  00961	8b f0		 mov	 esi, eax
  00963	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00968	85 f6		 test	 esi, esi
  0096a	0f 84 db 00 00
	00		 je	 $LN56@SprawdŸ_P

; 797  : 		{
; 798  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00970	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00977	75 24		 jne	 SHORT $LN55@SprawdŸ_P

; 799  : 			{
; 800  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00979	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0097f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00984	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00989	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0098e	8b c8		 mov	 ecx, eax
  00990	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 801  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00996	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN55@SprawdŸ_P:

; 803  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "b.wav").c_str(), ("G³os/" + g³os2 + "b.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0099d	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  009a0	50		 push	 eax
  009a1	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T112[ebp]
  009a7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  009ac	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  009b1	8b d0		 mov	 edx, eax
  009b3	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  009b7	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T113[ebp]
  009bd	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  009c2	8b f0		 mov	 esi, eax
  009c4	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  009c7	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  009cb	50		 push	 eax
  009cc	8d 55 b0	 lea	 edx, DWORD PTR _link$453[ebp]
  009cf	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T115[ebp]
  009d5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  009da	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  009df	8b d0		 mov	 edx, eax
  009e1	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  009e5	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T116[ebp]
  009eb	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  009f0	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  009f3	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  009f7	72 02		 jb	 SHORT $LN678@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  009f9	8b 36		 mov	 esi, DWORD PTR [esi]
$LN678@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  009fb	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  009ff	72 02		 jb	 SHORT $LN694@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00a01	8b 00		 mov	 eax, DWORD PTR [eax]
$LN694@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 803  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "b.wav").c_str(), ("G³os/" + g³os2 + "b.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00a03	6a 00		 push	 0
  00a05	6a 00		 push	 0
  00a07	56		 push	 esi
  00a08	50		 push	 eax
  00a09	6a 00		 push	 0
  00a0b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  00a11	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T116[ebp]
  00a17	8b f0		 mov	 esi, eax
  00a19	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a1e	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T115[ebp]
  00a24	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a29	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T113[ebp]
  00a2f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a34	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T112[ebp]
  00a3a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00a3e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 804  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00a43	85 f6		 test	 esi, esi
  00a45	0f 85 83 08 00
	00		 jne	 $LN3579@SprawdŸ_P
$LN56@SprawdŸ_P:

; 812  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00a4b	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  00a50	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T124[ebp]
  00a56	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00a5b	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00a5e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00a62	72 02		 jb	 SHORT $LN710@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00a64	8b 00		 mov	 eax, DWORD PTR [eax]
$LN710@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 812  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00a66	6a 00		 push	 0
  00a68	50		 push	 eax
  00a69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  00a6f	83 c4 08	 add	 esp, 8
  00a72	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T124[ebp]
  00a78	8b f0		 mov	 esi, eax
  00a7a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a7f	85 f6		 test	 esi, esi
  00a81	0f 84 db 00 00
	00		 je	 $LN59@SprawdŸ_P

; 813  : 		{
; 814  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00a87	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00a8e	75 24		 jne	 SHORT $LN58@SprawdŸ_P

; 815  : 			{
; 816  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00a90	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00a96	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00a9b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00aa0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00aa5	8b c8		 mov	 ecx, eax
  00aa7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 817  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00aad	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN58@SprawdŸ_P:

; 819  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "g.wav").c_str(), ("G³os/" + g³os2 + "g.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00ab4	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  00ab7	50		 push	 eax
  00ab8	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T130[ebp]
  00abe	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00ac3	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  00ac8	8b d0		 mov	 edx, eax
  00aca	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00ace	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T131[ebp]
  00ad4	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00ad9	8b f0		 mov	 esi, eax
  00adb	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  00ade	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00ae2	50		 push	 eax
  00ae3	8d 55 b0	 lea	 edx, DWORD PTR _link$453[ebp]
  00ae6	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T133[ebp]
  00aec	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00af1	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  00af6	8b d0		 mov	 edx, eax
  00af8	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  00afc	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T134[ebp]
  00b02	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00b07	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b0a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00b0e	72 02		 jb	 SHORT $LN726@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00b10	8b 36		 mov	 esi, DWORD PTR [esi]
$LN726@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b12	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00b16	72 02		 jb	 SHORT $LN742@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00b18	8b 00		 mov	 eax, DWORD PTR [eax]
$LN742@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 819  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "g.wav").c_str(), ("G³os/" + g³os2 + "g.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00b1a	6a 00		 push	 0
  00b1c	6a 00		 push	 0
  00b1e	56		 push	 esi
  00b1f	50		 push	 eax
  00b20	6a 00		 push	 0
  00b22	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  00b28	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T134[ebp]
  00b2e	8b f0		 mov	 esi, eax
  00b30	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b35	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T133[ebp]
  00b3b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b40	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T131[ebp]
  00b46	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b4b	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T130[ebp]
  00b51	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00b55	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 820  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00b5a	85 f6		 test	 esi, esi
  00b5c	0f 85 6c 07 00
	00		 jne	 $LN3579@SprawdŸ_P
$LN59@SprawdŸ_P:

; 828  : 		if ((_access((G³os + "d.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00b62	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  00b67	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T142[ebp]
  00b6d	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00b72	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b75	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00b79	72 02		 jb	 SHORT $LN758@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00b7b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN758@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 828  : 		if ((_access((G³os + "d.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00b7d	6a 00		 push	 0
  00b7f	50		 push	 eax
  00b80	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  00b86	83 c4 08	 add	 esp, 8
  00b89	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T142[ebp]
  00b8f	8b f0		 mov	 esi, eax
  00b91	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b96	85 f6		 test	 esi, esi
  00b98	0f 84 db 00 00
	00		 je	 $LN62@SprawdŸ_P

; 829  : 		{
; 830  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00b9e	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00ba5	75 24		 jne	 SHORT $LN61@SprawdŸ_P

; 831  : 			{
; 832  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00ba7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00bad	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00bb2	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00bb7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00bbc	8b c8		 mov	 ecx, eax
  00bbe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 833  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00bc4	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN61@SprawdŸ_P:

; 835  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "d.wav").c_str(), ("G³os/" + g³os2 + "d.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00bcb	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  00bce	50		 push	 eax
  00bcf	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T148[ebp]
  00bd5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00bda	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  00bdf	8b d0		 mov	 edx, eax
  00be1	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  00be5	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T149[ebp]
  00beb	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00bf0	8b f0		 mov	 esi, eax
  00bf2	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  00bf5	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  00bf9	50		 push	 eax
  00bfa	8d 55 b0	 lea	 edx, DWORD PTR _link$453[ebp]
  00bfd	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T151[ebp]
  00c03	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00c08	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  00c0d	8b d0		 mov	 edx, eax
  00c0f	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  00c13	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T152[ebp]
  00c19	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00c1e	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00c21	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00c25	72 02		 jb	 SHORT $LN774@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00c27	8b 36		 mov	 esi, DWORD PTR [esi]
$LN774@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00c29	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00c2d	72 02		 jb	 SHORT $LN790@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00c2f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN790@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 835  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "d.wav").c_str(), ("G³os/" + g³os2 + "d.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00c31	6a 00		 push	 0
  00c33	6a 00		 push	 0
  00c35	56		 push	 esi
  00c36	50		 push	 eax
  00c37	6a 00		 push	 0
  00c39	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  00c3f	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T152[ebp]
  00c45	8b f0		 mov	 esi, eax
  00c47	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00c4c	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T151[ebp]
  00c52	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00c57	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T149[ebp]
  00c5d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00c62	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T148[ebp]
  00c68	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00c6c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 836  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00c71	85 f6		 test	 esi, esi
  00c73	0f 85 55 06 00
	00		 jne	 $LN3579@SprawdŸ_P
$LN62@SprawdŸ_P:

; 837  : 			{
; 838  : 				cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 839  : 				G³osyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio
; 840  : 				return; //Wyjœcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 841  : 			}
; 842  : 		}
; 843  : 
; 844  : 		for (unsigned short i = 1; i <= 3; ++i) //Pêtla licz¹ca od 1 do 3

  00c79	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _i$1$[ebp], 1
  00c83	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL6@SprawdŸ_P:

; 846  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00c90	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  00c95	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T160[ebp]
  00c9b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00ca0	83 c4 04	 add	 esp, 4
  00ca3	8b f0		 mov	 esi, eax
  00ca5	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  00ca9	8a 8d f8 fe ff
	ff		 mov	 cl, BYTE PTR _i$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  00caf	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 846  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00cb2	80 c1 30	 add	 cl, 48			; 00000030H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3895 : 	_Left.push_back(_Right);

  00cb5	88 4d ec	 mov	 BYTE PTR __Ch$[ebp], cl

; 2992 : 		if (_Old_size < _My_data._Myres)

  00cb8	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  00cbb	73 20		 jae	 SHORT $LN801@SprawdŸ_P

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00cbd	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2994 : 			_My_data._Mysize = _Old_size + 1;

  00cc1	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00cc4	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00cc7	8b c6		 mov	 eax, esi

; 1596 : 		if (_Large_string_engaged())

  00cc9	72 02		 jb	 SHORT $LN810@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00ccb	8b 06		 mov	 eax, DWORD PTR [esi]
$LN810@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00ccd	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00cd0	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2998 : 			return;

  00cd5	eb 18		 jmp	 SHORT $LN800@SprawdŸ_P
$_Invalid_parameter$3674:
$_Invalid_parameter$3675:
$_Invalid_parameter$3676:
$_Invalid_parameter$3677:
$_Invalid_parameter$3678:
$_Invalid_parameter$3679:
$_Invalid_parameter$3680:
$_Invalid_parameter$3681:
$_Invalid_parameter$3682:
$_Invalid_parameter$3683:
$_Invalid_parameter$3684:
$_Invalid_parameter$3685:
$_Invalid_parameter$3686:
$_Invalid_parameter$3687:
$_Invalid_parameter$3688:
$_Invalid_parameter$3689:
$_Invalid_parameter$3690:
$_Invalid_parameter$3691:
$_Invalid_parameter$3692:
$_Invalid_parameter$3693:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00cd7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3673@SprawdŸ_P:
$LN801@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3001 : 		_Reallocate_grow_by(1,

  00cdd	ff 75 ec	 push	 DWORD PTR __Ch$[ebp]
  00ce0	c6 45 e8 00	 mov	 BYTE PTR $T164[ebp], 0
  00ce4	ff 75 e8	 push	 DWORD PTR $T164[ebp]
  00ce7	51		 push	 ecx
  00ce8	8b ce		 mov	 ecx, esi
  00cea	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN800@SprawdŸ_P:

; 1576 : 		_Mysize(0),

  00cef	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T170[ebp+16], 0

; 1577 : 		_Myres(0)

  00cf9	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T170[ebp+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00d03	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00d06	0f 11 85 94 fe
	ff ff		 movups	 XMMWORD PTR $T170[ebp], xmm0
  00d0d	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  00d12	66 0f d6 85 a4
	fe ff ff	 movq	 QWORD PTR $T170[ebp+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00d1a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00d21	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00d28	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 846  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00d2b	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00d2f	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR $T170[ebp+20]
  00d35	8b c2		 mov	 eax, edx
  00d37	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR $T170[ebp+16]
  00d3d	8b f1		 mov	 esi, ecx
  00d3f	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00d41	6a 04		 push	 4
  00d43	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00d48	83 f8 04	 cmp	 eax, 4
  00d4b	72 31		 jb	 SHORT $LN895@SprawdŸ_P

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  00d4d	83 c1 04	 add	 ecx, 4

; 1595 : 		value_type * _Result = _Bx._Buf;

  00d50	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR $T170[ebp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00d56	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  00d59	89 8d a4 fe ff
	ff		 mov	 DWORD PTR $T170[ebp+16], ecx

; 1596 : 		if (_Large_string_engaged())

  00d5f	0f 43 85 94 fe
	ff ff		 cmovae	 eax, DWORD PTR $T170[ebp]

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00d66	03 f0		 add	 esi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00d68	56		 push	 esi
  00d69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00d6f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00d72	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  00d76	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR $T170[ebp]
  00d7c	eb 1a		 jmp	 SHORT $LN894@SprawdŸ_P
$LN895@SprawdŸ_P:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  00d7e	c6 85 78 fe ff
	ff 00		 mov	 BYTE PTR $T183[ebp], 0
  00d85	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR $T170[ebp]
  00d8b	ff b5 78 fe ff
	ff		 push	 DWORD PTR $T183[ebp]
  00d91	6a 04		 push	 4
  00d93	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN894@SprawdŸ_P:

; 1576 : 		_Mysize(0),

  00d98	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T189[ebp+16], 0
  00da2	83 cf 06	 or	 edi, 6

; 1577 : 		_Myres(0)

  00da5	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T189[ebp+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00daf	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 846  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00db2	6a 00		 push	 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00db4	0f 11 85 c8 fe
	ff ff		 movups	 XMMWORD PTR $T189[ebp], xmm0
  00dbb	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00dc0	66 0f d6 85 d8
	fe ff ff	 movq	 QWORD PTR $T189[ebp+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00dc8	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00dcf	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00dd6	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00dd9	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T189[ebp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00ddf	83 bd dc fe ff
	ff 10		 cmp	 DWORD PTR $T189[ebp+20], 16 ; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00de6	0f 43 85 c8 fe
	ff ff		 cmovae	 eax, DWORD PTR $T189[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 846  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00ded	50		 push	 eax
  00dee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00df4	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR $T189[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 846  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00dfa	83 c4 08	 add	 esp, 8
  00dfd	8b f0		 mov	 esi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00dff	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  00e02	72 3c		 jb	 SHORT $LN1020@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00e04	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T189[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00e0a	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00e0b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00e11	72 24		 jb	 SHORT $LN1023@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00e13	f6 c2 1f	 test	 dl, 31			; 0000001fH
  00e16	0f 85 bb fe ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00e1c	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00e1f	3b c2		 cmp	 eax, edx
  00e21	0f 83 b0 fe ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00e27	2b d0		 sub	 edx, eax
  00e29	83 ea 04	 sub	 edx, 4
  00e2c	83 fa 1f	 cmp	 edx, 31			; 0000001fH
  00e2f	0f 87 a2 fe ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00e35	8b d0		 mov	 edx, eax
$LN1023@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00e37	52		 push	 edx
  00e38	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00e3d	83 c4 04	 add	 esp, 4
$LN1020@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 846  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00e40	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00e44	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR $T170[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  00e4a	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T189[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00e54	c7 85 dc fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T189[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00e5e	c6 85 c8 fe ff
	ff 00		 mov	 BYTE PTR $T189[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00e65	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  00e68	72 3b		 jb	 SHORT $LN1066@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00e6a	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR $T170[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00e70	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00e71	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00e76	72 24		 jb	 SHORT $LN1069@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00e78	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00e7b	0f 85 56 fe ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00e81	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00e84	3b c1		 cmp	 eax, ecx
  00e86	0f 83 4b fe ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00e8c	2b c8		 sub	 ecx, eax
  00e8e	83 e9 04	 sub	 ecx, 4
  00e91	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  00e94	0f 87 3d fe ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00e9a	8b c8		 mov	 ecx, eax
$LN1069@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00e9c	51		 push	 ecx
  00e9d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ea2	83 c4 04	 add	 esp, 4
$LN1066@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 846  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00ea5	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00ea9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR $T160[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  00eaf	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T170[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00eb9	c7 85 a8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T170[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00ec3	c6 85 94 fe ff
	ff 00		 mov	 BYTE PTR $T170[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00eca	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  00ecd	72 3b		 jb	 SHORT $LN1112@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00ecf	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR $T160[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00ed5	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00ed6	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00edb	72 24		 jb	 SHORT $LN1115@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00edd	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00ee0	0f 85 f1 fd ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00ee6	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00ee9	3b c1		 cmp	 eax, ecx
  00eeb	0f 83 e6 fd ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00ef1	2b c8		 sub	 ecx, eax
  00ef3	83 e9 04	 sub	 ecx, 4
  00ef6	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  00ef9	0f 87 d8 fd ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00eff	8b c8		 mov	 ecx, eax
$LN1115@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00f01	51		 push	 ecx
  00f02	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00f07	83 c4 04	 add	 esp, 4
$LN1112@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 846  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00f0a	85 f6		 test	 esi, esi
  00f0c	0f 84 52 02 00
	00		 je	 $LN4@SprawdŸ_P

; 847  : 			{
; 848  : 				if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00f12	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00f19	75 24		 jne	 SHORT $LN64@SprawdŸ_P

; 849  : 				{
; 850  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00f1b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00f21	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00f26	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00f2b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00f30	8b c8		 mov	 ecx, eax
  00f32	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 851  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00f38	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN64@SprawdŸ_P:

; 853  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00f3f	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  00f42	50		 push	 eax
  00f43	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T214[ebp]
  00f49	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00f4e	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  00f53	8b d0		 mov	 edx, eax
  00f55	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  00f59	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T215[ebp]
  00f5f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00f64	83 c4 08	 add	 esp, 8
  00f67	8b f0		 mov	 esi, eax
  00f69	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3895 : 	_Left.push_back(_Right);

  00f6d	8a 4d ec	 mov	 cl, BYTE PTR __Ch$[ebp]

; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  00f70	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 3895 : 	_Left.push_back(_Right);

  00f73	88 4d cc	 mov	 BYTE PTR __Ch$[ebp], cl

; 2992 : 		if (_Old_size < _My_data._Myres)

  00f76	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  00f79	73 1a		 jae	 SHORT $LN1136@SprawdŸ_P

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00f7b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2994 : 			_My_data._Mysize = _Old_size + 1;

  00f7f	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00f82	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00f85	8b c6		 mov	 eax, esi

; 1596 : 		if (_Large_string_engaged())

  00f87	72 02		 jb	 SHORT $LN1145@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00f89	8b 06		 mov	 eax, DWORD PTR [esi]
$LN1145@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00f8b	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00f8e	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2998 : 			return;

  00f93	eb 18		 jmp	 SHORT $LN1135@SprawdŸ_P
$LN1136@SprawdŸ_P:

; 3001 : 		_Reallocate_grow_by(1,

  00f95	ff 75 cc	 push	 DWORD PTR __Ch$[ebp]
  00f98	c6 85 74 fe ff
	ff 00		 mov	 BYTE PTR $T219[ebp], 0
  00f9f	ff b5 74 fe ff
	ff		 push	 DWORD PTR $T219[ebp]
  00fa5	51		 push	 ecx
  00fa6	8b ce		 mov	 ecx, esi
  00fa8	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN1135@SprawdŸ_P:

; 1576 : 		_Mysize(0),

  00fad	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T225[ebp+16], 0

; 1577 : 		_Myres(0)

  00fb7	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T225[ebp+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00fc1	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00fc4	0f 11 85 7c fe
	ff ff		 movups	 XMMWORD PTR $T225[ebp], xmm0
  00fcb	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  00fd0	66 0f d6 85 8c
	fe ff ff	 movq	 QWORD PTR $T225[ebp+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00fd8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00fdf	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00fe6	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 853  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00fe9	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  00fee	8d 95 7c fe ff
	ff		 lea	 edx, DWORD PTR $T225[ebp]
  00ff4	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  00ff8	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T233[ebp]
  00ffe	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01003	89 85 ac fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
  01009	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  0100c	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H
  01010	50		 push	 eax
  01011	8d 55 b0	 lea	 edx, DWORD PTR _link$453[ebp]
  01014	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T235[ebp]
  0101a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0101f	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  01024	8b d0		 mov	 edx, eax
  01026	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  0102a	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T236[ebp]
  01030	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01035	83 c4 0c	 add	 esp, 12			; 0000000cH
  01038	8b f0		 mov	 esi, eax
  0103a	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3895 : 	_Left.push_back(_Right);

  0103e	8a 4d ec	 mov	 cl, BYTE PTR __Ch$[ebp]

; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  01041	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 3895 : 	_Left.push_back(_Right);

  01044	88 4d c8	 mov	 BYTE PTR __Ch$[ebp], cl

; 2992 : 		if (_Old_size < _My_data._Myres)

  01047	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  0104a	73 1a		 jae	 SHORT $LN1239@SprawdŸ_P

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0104c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2994 : 			_My_data._Mysize = _Old_size + 1;

  01050	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  01053	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  01056	8b c6		 mov	 eax, esi

; 1596 : 		if (_Large_string_engaged())

  01058	72 02		 jb	 SHORT $LN1248@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0105a	8b 06		 mov	 eax, DWORD PTR [esi]
$LN1248@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0105c	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  0105f	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2998 : 			return;

  01064	eb 18		 jmp	 SHORT $LN1238@SprawdŸ_P
$LN1239@SprawdŸ_P:

; 3001 : 		_Reallocate_grow_by(1,

  01066	ff 75 c8	 push	 DWORD PTR __Ch$[ebp]
  01069	c6 85 70 fe ff
	ff 00		 mov	 BYTE PTR $T240[ebp], 0
  01070	ff b5 70 fe ff
	ff		 push	 DWORD PTR $T240[ebp]
  01076	51		 push	 ecx
  01077	8b ce		 mov	 ecx, esi
  01079	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN1238@SprawdŸ_P:

; 1576 : 		_Mysize(0),

  0107e	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T246[ebp+16], 0
  01088	83 cf 18	 or	 edi, 24			; 00000018H

; 1577 : 		_Myres(0)

  0108b	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T246[ebp+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01095	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  01098	0f 11 85 b0 fe
	ff ff		 movups	 XMMWORD PTR $T246[ebp], xmm0
  0109f	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  010a4	66 0f d6 85 c0
	fe ff ff	 movq	 QWORD PTR $T246[ebp+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  010ac	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  010b3	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  010ba	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 853  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  010bd	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  010c2	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR $T246[ebp]
  010c8	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  010cc	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T254[ebp]
  010d2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  010d7	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR __Result$1$[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 853  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  010dd	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  010e0	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  010e4	72 02		 jb	 SHORT $LN1228@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  010e6	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1228@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  010e8	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  010ec	72 02		 jb	 SHORT $LN1331@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  010ee	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1331@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 853  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  010f0	6a 00		 push	 0
  010f2	6a 00		 push	 0
  010f4	51		 push	 ecx
  010f5	50		 push	 eax
  010f6	6a 00		 push	 0
  010f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  010fe	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T254[ebp]
  01104	8b f0		 mov	 esi, eax
  01106	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0110b	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T246[ebp]
  01111	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01116	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T236[ebp]
  0111c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01121	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T235[ebp]
  01127	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0112c	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T233[ebp]
  01132	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01137	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T225[ebp]
  0113d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01142	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T215[ebp]
  01148	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0114d	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T214[ebp]
  01153	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01157	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 854  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0115c	85 f6		 test	 esi, esi
  0115e	0f 85 6a 01 00
	00		 jne	 $LN3579@SprawdŸ_P
$LN4@SprawdŸ_P:

; 837  : 			{
; 838  : 				cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 839  : 				G³osyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio
; 840  : 				return; //Wyjœcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 841  : 			}
; 842  : 		}
; 843  : 
; 844  : 		for (unsigned short i = 1; i <= 3; ++i) //Pêtla licz¹ca od 1 do 3

  01164	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  0116a	40		 inc	 eax
  0116b	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  01171	66 83 f8 03	 cmp	 ax, 3
  01175	0f 86 15 fb ff
	ff		 jbe	 $LL6@SprawdŸ_P

; 863  : 		for (unsigned short i = 1; i <= 12; ++i) //Pêtla licz¹ca od 1 do 12

  0117b	be 01 00 00 00	 mov	 esi, 1
  01180	89 75 e8	 mov	 DWORD PTR _i$1$[ebp], esi
$LL9@SprawdŸ_P:
  01183	68 b0 00 00 00	 push	 176			; 000000b0H
  01188	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _numers$452[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 593  : 		{	// construct empty character buffer

  0118e	89 bd 70 fe ff
	ff		 mov	 DWORD PTR tv9917[ebp], edi
  01194	6a 00		 push	 0
  01196	50		 push	 eax
  01197	e8 00 00 00 00	 call	 _memset
  0119c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0119f	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$452[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  011a9	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+104]
  011af	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$452[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  011b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  011bf	6a 00		 push	 0
  011c1	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _numers$452[ebp+24]
  011c7	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+8], 29 ; 0000001dH
  011cb	83 cf 20	 or	 edi, 32			; 00000020H

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	typedef typename allocator_traits<allocator_type>::pointer _Ptrty;
; 350  : 
; 351  : 	enum
; 352  : 		{	// constant for minimum buffer size
; 353  : 		_MINSIZE = 32};
; 354  : 
; 355  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 356  : 		{	// convert open mode to stream state bits
; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);
; 367  : 		}
; 368  : 
; 369  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 370  : 	_Strstate _Mystate;	// the stream state
; 371  : 	allocator_type _Al;	// the allocator object
; 372  : 	};
; 373  : 
; 374  : 	// basic_stringbuf TEMPLATE OPERATORS
; 375  : template<class _Elem,
; 376  : 	class _Traits,
; 377  : 	class _Alloc> inline
; 378  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 379  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 380  : 	{	// swap _Left and _Right basic_stringbufs
; 381  : 	_Left.swap(_Right);
; 382  : 	}
; 383  : 
; 384  : 		// TEMPLATE CLASS basic_istringstream
; 385  : template<class _Elem,
; 386  : 	class _Traits,
; 387  : 	class _Alloc>
; 388  : 	class basic_istringstream
; 389  : 		: public basic_istream<_Elem, _Traits>
; 390  : 	{	// input stream associated with a character array
; 391  : public:
; 392  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 393  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 394  : 	typedef _Alloc allocator_type;
; 395  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 396  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 397  : 
; 398  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 399  : 		: _Mybase(&_Stringbuffer),
; 400  : 			_Stringbuffer(_Mode | ios_base::in)
; 401  : 		{	// construct empty readable character buffer
; 402  : 		}
; 403  : 
; 404  : 	explicit basic_istringstream(const _Mystr& _Str,
; 405  : 		ios_base::openmode _Mode = ios_base::in)
; 406  : 		: _Mybase(&_Stringbuffer),
; 407  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 408  : 		{	// construct readable character buffer from NTCS
; 409  : 		}
; 410  : 
; 411  : 	basic_istringstream(_Myt&& _Right)
; 412  : 		: _Mybase(&_Stringbuffer)
; 413  : 		{	// construct by moving _Right
; 414  : 		_Assign_rv(_STD move(_Right));
; 415  : 		}
; 416  : 
; 417  : 	_Myt& operator=(_Myt&& _Right)
; 418  : 		{	// move from _Right
; 419  : 		_Assign_rv(_STD move(_Right));
; 420  : 		return (*this);
; 421  : 		}
; 422  : 
; 423  : 	void _Assign_rv(_Myt&& _Right)
; 424  : 		{	// assign by moving _Right
; 425  : 		if (this != _STD addressof(_Right))
; 426  : 			{	// different, worth moving
; 427  : 			_Stringbuffer.str(_Mystr());
; 428  : 			this->swap(_Right);
; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 	void swap(_Myt& _Right)
; 433  : 		{	// swap with _Right
; 434  : 		if (this != _STD addressof(_Right))
; 435  : 			{	// different, swap base and buffer
; 436  : 			_Mybase::swap(_Right);
; 437  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 438  : 			}
; 439  : 		}
; 440  : 
; 441  : 	basic_istringstream(const _Myt&) = delete;
; 442  : 	_Myt& operator=(const _Myt&) = delete;
; 443  : 
; 444  : 	virtual ~basic_istringstream() _NOEXCEPT
; 445  : 		{	// destroy the object
; 446  : 		}
; 447  : 
; 448  : 	_Mysb *rdbuf() const
; 449  : 		{	// return pointer to file buffer
; 450  : 		return ((_Mysb *)&_Stringbuffer);
; 451  : 		}
; 452  : 
; 453  : 	_Mystr str() const
; 454  : 		{	// return string copy of character array
; 455  : 		return (_Stringbuffer.str());
; 456  : 		}
; 457  : 
; 458  : 	void str(const _Mystr& _Newstr)
; 459  : 		{	// replace character array from string
; 460  : 		_Stringbuffer.str(_Newstr);
; 461  : 		}
; 462  : 
; 463  : private:
; 464  : 	_Mysb _Stringbuffer;	// the string buffer
; 465  : 	};
; 466  : 
; 467  : 	// basic_istringstream TEMPLATE OPERATORS
; 468  : template<class _Elem,
; 469  : 	class _Traits,
; 470  : 	class _Alloc> inline
; 471  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 472  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 473  : 	{	// swap _Left and _Right basic_istringstreams
; 474  : 	_Left.swap(_Right);
; 475  : 	}
; 476  : 
; 477  : 		// TEMPLATE CLASS basic_ostringstream
; 478  : template<class _Elem,
; 479  : 	class _Traits,
; 480  : 	class _Alloc>
; 481  : 	class basic_ostringstream
; 482  : 		: public basic_ostream<_Elem, _Traits>
; 483  : 	{	// output stream associated with a character array
; 484  : public:
; 485  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 486  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 487  : 	typedef _Alloc allocator_type;
; 488  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 489  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 490  : 
; 491  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 492  : 		: _Mybase(&_Stringbuffer),
; 493  : 			_Stringbuffer(_Mode | ios_base::out)
; 494  : 		{	// construct empty writable character buffer
; 495  : 		}
; 496  : 
; 497  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 498  : 		ios_base::openmode _Mode = ios_base::out)
; 499  : 		: _Mybase(&_Stringbuffer),
; 500  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 501  : 		{	// construct writable character buffer from NTCS
; 502  : 		}
; 503  : 
; 504  : 	basic_ostringstream(_Myt&& _Right)
; 505  : 		: _Mybase(&_Stringbuffer)
; 506  : 		{	// construct by moving _Right
; 507  : 		_Assign_rv(_STD move(_Right));
; 508  : 		}
; 509  : 
; 510  : 	_Myt& operator=(_Myt&& _Right)
; 511  : 		{	// move from _Right
; 512  : 		_Assign_rv(_STD move(_Right));
; 513  : 		return (*this);
; 514  : 		}
; 515  : 
; 516  : 	void _Assign_rv(_Myt&& _Right)
; 517  : 		{	// assign by moving _Right
; 518  : 		if (this != _STD addressof(_Right))
; 519  : 			{	// different, worth moving
; 520  : 			_Stringbuffer.str(_Mystr());
; 521  : 			this->swap(_Right);
; 522  : 			}
; 523  : 		}
; 524  : 
; 525  : 	void swap(_Myt& _Right)
; 526  : 		{	// swap with _Right
; 527  : 		if (this != _STD addressof(_Right))
; 528  : 			{	// different, swap base and buffer
; 529  : 			_Mybase::swap(_Right);
; 530  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 531  : 			}
; 532  : 		}
; 533  : 
; 534  : 	basic_ostringstream(const _Myt&) = delete;
; 535  : 	_Myt& operator=(const _Myt&) = delete;
; 536  : 
; 537  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 538  : 		{	// destroy the object
; 539  : 		}
; 540  : 
; 541  : 	_Mysb *rdbuf() const
; 542  : 		{	// return pointer to buffer
; 543  : 		return ((_Mysb *)&_Stringbuffer);
; 544  : 		}
; 545  : 
; 546  : 	_Mystr str() const
; 547  : 		{	// return string copy of character array
; 548  : 		return (_Stringbuffer.str());
; 549  : 		}
; 550  : 
; 551  : 	void str(const _Mystr& _Newstr)
; 552  : 		{	// replace character array from string
; 553  : 		_Stringbuffer.str(_Newstr);
; 554  : 		}
; 555  : 
; 556  : private:
; 557  : 	_Mysb _Stringbuffer;	// the string buffer
; 558  : 	};
; 559  : 
; 560  : 	// basic_ostringstream TEMPLATE OPERATORS
; 561  : template<class _Elem,
; 562  : 	class _Traits,
; 563  : 	class _Alloc> inline
; 564  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 565  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 566  : 	{	// swap _Left and _Right basic_ostringstreams
; 567  : 	_Left.swap(_Right);
; 568  : 	}
; 569  : 
; 570  : 		// TEMPLATE CLASS basic_stringstream
; 571  : template<class _Elem,
; 572  : 	class _Traits,
; 573  : 	class _Alloc>
; 574  : 	class basic_stringstream
; 575  : 		: public basic_iostream<_Elem, _Traits>
; 576  : 	{	// input/output stream associated with a character array
; 577  : public:
; 578  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 579  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 580  : 	typedef _Elem char_type;
; 581  : 	typedef _Traits traits_type;
; 582  : 	typedef _Alloc allocator_type;
; 583  : 	typedef typename _Traits::int_type int_type;
; 584  : 	typedef typename _Traits::pos_type pos_type;
; 585  : 	typedef typename _Traits::off_type off_type;
; 586  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 587  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 588  : 
; 589  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 590  : 		ios_base::in | ios_base::out)
; 591  : 		: _Mybase(&_Stringbuffer),

  011ce	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp]
  011d4	50		 push	 eax
  011d5	89 bd f8 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], edi
  011db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  011e1	c7 45 fc 1e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 30 ; 0000001eH

; 593  : 		{	// construct empty character buffer

  011e8	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _numers$452[ebp]
  011ee	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  011f1	c7 84 05 00 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$452[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  011fc	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _numers$452[ebp]
  01202	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01205	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  01208	89 84 0d fc fe
	ff ff		 mov	 DWORD PTR _numers$452[ebp+ecx-4], eax
  0120f	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _numers$452[ebp+24]

; 30   : 		{	// construct empty character buffer from mode

  01215	8b c8		 mov	 ecx, eax

; 592  : 			_Stringbuffer(_Mode)

  01217	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

  0121a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  01220	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$452[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

  0122a	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$452[ebp+80], 0

; 312  : 		_Mystate = _State;

  01234	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$452[ebp+84], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 866  : 			numers << i; //Wpisanie do typu wartoœci z obrotu pêtli

  0123e	56		 push	 esi
  0123f	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+16]
  01245	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
  01249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 647  : 		return (_Stringbuffer.str());

  0124f	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR $T264[ebp]
  01255	50		 push	 eax
  01256	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+24]
  0125c	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 867  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01261	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  01266	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T265[ebp]
  0126c	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
  01270	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01275	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T264[ebp]
  0127b	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
  0127f	51		 push	 ecx
  01280	8b d0		 mov	 edx, eax
  01282	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T266[ebp]
  01288	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0128d	83 c4 08	 add	 esp, 8
  01290	8b f8		 mov	 edi, eax
  01292	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+8], 35 ; 00000023H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  01296	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  01299	8b c2		 mov	 eax, edx
  0129b	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0129e	2b c1		 sub	 eax, ecx
  012a0	83 f8 04	 cmp	 eax, 4
  012a3	72 52		 jb	 SHORT $LN1715@SprawdŸ_P

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  012a5	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  012a8	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  012ab	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  012ad	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  012b0	72 02		 jb	 SHORT $LN1724@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  012b2	8b 07		 mov	 eax, DWORD PTR [edi]
$LN1724@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  012b4	6a 04		 push	 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  012b6	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  012b9	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  012be	56		 push	 esi
  012bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  012c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  012c8	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  012cc	eb 48		 jmp	 SHORT $LN1714@SprawdŸ_P
$LN3579@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 856  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  012ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  012d4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  012d9	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  012de	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  012e3	8b c8		 mov	 ecx, eax
  012e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 857  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  012eb	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  012f2	e9 d4 0c 00 00	 jmp	 $LN72@SprawdŸ_P
$LN1715@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2360 : 		return (_Reallocate_grow_by(_Count,

  012f7	6a 04		 push	 4
  012f9	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  012fe	c6 85 ac fe ff
	ff 00		 mov	 BYTE PTR $T272[ebp], 0
  01305	8b cf		 mov	 ecx, edi
  01307	ff b5 ac fe ff
	ff		 push	 DWORD PTR $T272[ebp]
  0130d	6a 04		 push	 4
  0130f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  01314	8b f8		 mov	 edi, eax
$LN1714@SprawdŸ_P:

; 1576 : 		_Mysize(0),

  01316	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T278[ebp+16], 0

; 1606 : 		const value_type * _Result = _Bx._Buf;

  01320	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T278[ebp]

; 1577 : 		_Myres(0)

  01326	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T278[ebp+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01330	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 867  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01333	6a 00		 push	 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01335	0f 11 85 c8 fe
	ff ff		 movups	 XMMWORD PTR $T278[ebp], xmm0
  0133c	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  01341	66 0f d6 85 d8
	fe ff ff	 movq	 QWORD PTR $T278[ebp+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  01349	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01350	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01357	c6 07 00	 mov	 BYTE PTR [edi], 0
  0135a	8b bd 70 fe ff
	ff		 mov	 edi, DWORD PTR tv9917[ebp]
  01360	81 cf 60 01 00
	00		 or	 edi, 352		; 00000160H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01366	83 bd dc fe ff
	ff 10		 cmp	 DWORD PTR $T278[ebp+20], 16 ; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0136d	89 bd f8 fe ff
	ff		 mov	 DWORD PTR $T450[ebp], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1607 : 		if (_Large_string_engaged())

  01373	0f 43 85 c8 fe
	ff ff		 cmovae	 eax, DWORD PTR $T278[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 867  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0137a	50		 push	 eax
  0137b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01381	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR $T278[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 867  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01387	83 c4 08	 add	 esp, 8
  0138a	8b f0		 mov	 esi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0138c	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  0138f	72 3c		 jb	 SHORT $LN1840@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01391	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T278[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01397	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01398	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0139e	72 24		 jb	 SHORT $LN1843@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  013a0	f6 c2 1f	 test	 dl, 31			; 0000001fH
  013a3	0f 85 2e f9 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  013a9	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  013ac	3b c2		 cmp	 eax, edx
  013ae	0f 83 23 f9 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  013b4	2b d0		 sub	 edx, eax
  013b6	83 ea 04	 sub	 edx, 4
  013b9	83 fa 1f	 cmp	 edx, 31			; 0000001fH
  013bc	0f 87 15 f9 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  013c2	8b d0		 mov	 edx, eax
$LN1843@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  013c4	52		 push	 edx
  013c5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  013ca	83 c4 04	 add	 esp, 4
$LN1840@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 867  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  013cd	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  013d1	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR $T266[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  013d7	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T278[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  013e1	c7 85 dc fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T278[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  013eb	c6 85 c8 fe ff
	ff 00		 mov	 BYTE PTR $T278[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  013f2	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  013f5	72 3b		 jb	 SHORT $LN1886@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  013f7	8b 8d 28 fe ff
	ff		 mov	 ecx, DWORD PTR $T266[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  013fd	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  013fe	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  01403	72 24		 jb	 SHORT $LN1889@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01405	f6 c1 1f	 test	 cl, 31			; 0000001fH
  01408	0f 85 c9 f8 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0140e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01411	3b c1		 cmp	 eax, ecx
  01413	0f 83 be f8 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01419	2b c8		 sub	 ecx, eax
  0141b	83 e9 04	 sub	 ecx, 4
  0141e	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01421	0f 87 b0 f8 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01427	8b c8		 mov	 ecx, eax
$LN1889@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01429	51		 push	 ecx
  0142a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0142f	83 c4 04	 add	 esp, 4
$LN1886@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 867  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01432	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01436	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR $T265[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  0143c	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T266[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01446	c7 85 3c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T266[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01450	c6 85 28 fe ff
	ff 00		 mov	 BYTE PTR $T266[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01457	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  0145a	72 3b		 jb	 SHORT $LN1932@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0145c	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR $T265[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01462	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01463	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  01468	72 24		 jb	 SHORT $LN1935@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0146a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0146d	0f 85 64 f8 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01473	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01476	3b c1		 cmp	 eax, ecx
  01478	0f 83 59 f8 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0147e	2b c8		 sub	 ecx, eax
  01480	83 e9 04	 sub	 ecx, 4
  01483	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01486	0f 87 4b f8 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0148c	8b c8		 mov	 ecx, eax
$LN1935@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0148e	51		 push	 ecx
  0148f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01494	83 c4 04	 add	 esp, 4
$LN1932@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 867  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01497	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0149b	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR $T264[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  014a1	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T265[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  014ab	c7 85 54 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T265[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  014b5	c6 85 40 fe ff
	ff 00		 mov	 BYTE PTR $T265[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  014bc	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  014bf	72 3b		 jb	 SHORT $LN1978@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  014c1	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR $T264[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  014c7	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  014c8	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  014cd	72 24		 jb	 SHORT $LN1981@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  014cf	f6 c1 1f	 test	 cl, 31			; 0000001fH
  014d2	0f 85 ff f7 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  014d8	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  014db	3b c1		 cmp	 eax, ecx
  014dd	0f 83 f4 f7 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  014e3	2b c8		 sub	 ecx, eax
  014e5	83 e9 04	 sub	 ecx, 4
  014e8	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  014eb	0f 87 e6 f7 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  014f1	8b c8		 mov	 ecx, eax
$LN1981@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  014f3	51		 push	 ecx
  014f4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  014f9	83 c4 04	 add	 esp, 4
$LN1978@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 867  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  014fc	85 f6		 test	 esi, esi
  014fe	0f 84 4c 07 00
	00		 je	 $LN68@SprawdŸ_P

; 868  : 			{
; 869  : 				if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  01504	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0150b	75 24		 jne	 SHORT $LN67@SprawdŸ_P

; 870  : 				{
; 871  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0150d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01513	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01518	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0151d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01522	8b c8		 mov	 ecx, eax
  01524	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 872  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  0152a	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN67@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 647  : 		return (_Stringbuffer.str());

  01531	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T307[ebp]
  01537	50		 push	 eax
  01538	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+24]
  0153e	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01543	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  01546	c6 45 fc 24	 mov	 BYTE PTR __$EHRec$[ebp+8], 36 ; 00000024H
  0154a	50		 push	 eax
  0154b	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T308[ebp]
  01551	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01556	83 c4 04	 add	 esp, 4
  01559	8b f8		 mov	 edi, eax
  0155b	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+8], 37 ; 00000025H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  0155f	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  01562	8b c2		 mov	 eax, edx
  01564	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  01567	2b c1		 sub	 eax, ecx
  01569	83 f8 01	 cmp	 eax, 1
  0156c	72 29		 jb	 SHORT $LN2314@SprawdŸ_P

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  0156e	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  01571	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  01574	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01576	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  01579	72 02		 jb	 SHORT $LN2323@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0157b	8b 07		 mov	 eax, DWORD PTR [edi]
$LN2323@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0157d	6a 01		 push	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0157f	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  01582	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  01587	56		 push	 esi
  01588	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0158e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  01591	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  01595	eb 19		 jmp	 SHORT $LN2313@SprawdŸ_P
$LN2314@SprawdŸ_P:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  01597	6a 01		 push	 1
  01599	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  0159e	c6 45 c8 00	 mov	 BYTE PTR $T314[ebp], 0
  015a2	8b cf		 mov	 ecx, edi
  015a4	ff 75 c8	 push	 DWORD PTR $T314[ebp]
  015a7	6a 01		 push	 1
  015a9	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  015ae	8b f8		 mov	 edi, eax
$LN2313@SprawdŸ_P:

; 1576 : 		_Mysize(0),

  015b0	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T320[ebp+16], 0

; 1577 : 		_Myres(0)

  015ba	c7 85 54 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T320[ebp+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  015c4	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  015c7	0f 11 85 40 fe
	ff ff		 movups	 XMMWORD PTR $T320[ebp], xmm0
  015ce	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  015d3	66 0f d6 85 50
	fe ff ff	 movq	 QWORD PTR $T320[ebp+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  015db	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  015e2	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  015e9	c6 07 00	 mov	 BYTE PTR [edi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  015ec	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T307[ebp]
  015f2	c6 45 fc 26	 mov	 BYTE PTR __$EHRec$[ebp+8], 38 ; 00000026H
  015f6	50		 push	 eax
  015f7	8d 95 40 fe ff
	ff		 lea	 edx, DWORD PTR $T320[ebp]
  015fd	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T328[ebp]
  01603	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01608	83 c4 04	 add	 esp, 4
  0160b	8b f0		 mov	 esi, eax
  0160d	c6 45 fc 27	 mov	 BYTE PTR __$EHRec$[ebp+8], 39 ; 00000027H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  01611	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  01614	8b c1		 mov	 eax, ecx
  01616	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  01619	2b c7		 sub	 eax, edi
  0161b	83 f8 04	 cmp	 eax, 4
  0161e	72 32		 jb	 SHORT $LN2408@SprawdŸ_P

; 1595 : 		value_type * _Result = _Bx._Buf;

  01620	89 75 ec	 mov	 DWORD PTR __Result$1$[ebp], esi

; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  01623	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  01626	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  01629	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0162b	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  0162e	72 05		 jb	 SHORT $LN2417@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  01630	8b 06		 mov	 eax, DWORD PTR [esi]
  01632	89 45 ec	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN2417@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  01635	6a 04		 push	 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  01637	03 c7		 add	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  01639	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  0163e	50		 push	 eax
  0163f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 517  : 		_Left = _Right;

  01645	8b 45 ec	 mov	 eax, DWORD PTR __Result$1$[ebp]

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  01648	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  0164b	c6 44 07 04 00	 mov	 BYTE PTR [edi+eax+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  01650	eb 1f		 jmp	 SHORT $LN2407@SprawdŸ_P
$LN2408@SprawdŸ_P:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  01652	6a 04		 push	 4
  01654	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01659	c6 85 74 fe ff
	ff 00		 mov	 BYTE PTR $T334[ebp], 0
  01660	8b ce		 mov	 ecx, esi
  01662	ff b5 74 fe ff
	ff		 push	 DWORD PTR $T334[ebp]
  01668	6a 04		 push	 4
  0166a	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  0166f	8b f0		 mov	 esi, eax
$LN2407@SprawdŸ_P:

; 1576 : 		_Mysize(0),

  01671	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T340[ebp+16], 0

; 1577 : 		_Myres(0)

  0167b	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T340[ebp+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01685	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  01688	0f 11 85 94 fe
	ff ff		 movups	 XMMWORD PTR $T340[ebp], xmm0
  0168f	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  01694	66 0f d6 85 a4
	fe ff ff	 movq	 QWORD PTR $T340[ebp+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  0169c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  016a3	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  016aa	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 647  : 		return (_Stringbuffer.str());

  016ad	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T349[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  016b3	c6 45 fc 28	 mov	 BYTE PTR __$EHRec$[ebp+8], 40 ; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 647  : 		return (_Stringbuffer.str());

  016b7	50		 push	 eax
  016b8	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+24]
  016be	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  016c3	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  016c6	c6 45 fc 29	 mov	 BYTE PTR __$EHRec$[ebp+8], 41 ; 00000029H
  016ca	50		 push	 eax
  016cb	8d 55 b0	 lea	 edx, DWORD PTR _link$453[ebp]
  016ce	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T350[ebp]
  016d4	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  016d9	83 c4 04	 add	 esp, 4
  016dc	8b f8		 mov	 edi, eax
  016de	c6 45 fc 2a	 mov	 BYTE PTR __$EHRec$[ebp+8], 42 ; 0000002aH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  016e2	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  016e5	8b c2		 mov	 eax, edx
  016e7	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  016ea	2b c1		 sub	 eax, ecx
  016ec	83 f8 01	 cmp	 eax, 1
  016ef	72 29		 jb	 SHORT $LN2823@SprawdŸ_P

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  016f1	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  016f4	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  016f7	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  016f9	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  016fc	72 02		 jb	 SHORT $LN2832@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  016fe	8b 07		 mov	 eax, DWORD PTR [edi]
$LN2832@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  01700	6a 01		 push	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  01702	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  01705	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  0170a	56		 push	 esi
  0170b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  01711	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  01714	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  01718	eb 19		 jmp	 SHORT $LN2822@SprawdŸ_P
$LN2823@SprawdŸ_P:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  0171a	6a 01		 push	 1
  0171c	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  01721	c6 45 cc 00	 mov	 BYTE PTR $T356[ebp], 0
  01725	8b cf		 mov	 ecx, edi
  01727	ff 75 cc	 push	 DWORD PTR $T356[ebp]
  0172a	6a 01		 push	 1
  0172c	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  01731	8b f8		 mov	 edi, eax
$LN2822@SprawdŸ_P:

; 1576 : 		_Mysize(0),

  01733	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T362[ebp+16], 0

; 1577 : 		_Myres(0)

  0173d	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T362[ebp+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01747	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  0174a	0f 11 85 10 fe
	ff ff		 movups	 XMMWORD PTR $T362[ebp], xmm0
  01751	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  01756	66 0f d6 85 20
	fe ff ff	 movq	 QWORD PTR $T362[ebp+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  0175e	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01765	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0176c	c6 07 00	 mov	 BYTE PTR [edi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0176f	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T349[ebp]
  01775	c6 45 fc 2b	 mov	 BYTE PTR __$EHRec$[ebp+8], 43 ; 0000002bH
  01779	50		 push	 eax
  0177a	8d 95 10 fe ff
	ff		 lea	 edx, DWORD PTR $T362[ebp]
  01780	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T370[ebp]
  01786	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0178b	83 c4 04	 add	 esp, 4
  0178e	8b f0		 mov	 esi, eax
  01790	c6 45 fc 2c	 mov	 BYTE PTR __$EHRec$[ebp+8], 44 ; 0000002cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  01794	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  01797	8b c1		 mov	 eax, ecx
  01799	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0179c	2b c7		 sub	 eax, edi
  0179e	83 f8 04	 cmp	 eax, 4
  017a1	72 32		 jb	 SHORT $LN2917@SprawdŸ_P

; 1595 : 		value_type * _Result = _Bx._Buf;

  017a3	89 75 ec	 mov	 DWORD PTR __Result$1$[ebp], esi

; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  017a6	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  017a9	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  017ac	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  017ae	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  017b1	72 05		 jb	 SHORT $LN2926@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  017b3	8b 06		 mov	 eax, DWORD PTR [esi]
  017b5	89 45 ec	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN2926@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  017b8	6a 04		 push	 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  017ba	03 c7		 add	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  017bc	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  017c1	50		 push	 eax
  017c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 517  : 		_Left = _Right;

  017c8	8b 45 ec	 mov	 eax, DWORD PTR __Result$1$[ebp]

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  017cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  017ce	c6 44 07 04 00	 mov	 BYTE PTR [edi+eax+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  017d3	eb 1f		 jmp	 SHORT $LN2916@SprawdŸ_P
$LN2917@SprawdŸ_P:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  017d5	6a 04		 push	 4
  017d7	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  017dc	c6 85 78 fe ff
	ff 00		 mov	 BYTE PTR $T376[ebp], 0
  017e3	8b ce		 mov	 ecx, esi
  017e5	ff b5 78 fe ff
	ff		 push	 DWORD PTR $T376[ebp]
  017eb	6a 04		 push	 4
  017ed	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  017f2	8b f0		 mov	 esi, eax
$LN2916@SprawdŸ_P:
  017f4	8b bd f8 fe ff
	ff		 mov	 edi, DWORD PTR $T450[ebp]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  017fa	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR $T340[ebp]

; 1576 : 		_Mysize(0),

  01800	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T382[ebp+16], 0

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0180a	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T382[ebp]

; 1577 : 		_Myres(0)

  01810	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T382[ebp+20], 0
  0181a	81 cf 00 ba 01
	00		 or	 edi, 113152		; 0001ba00H

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01820	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01823	6a 00		 push	 0
  01825	6a 00		 push	 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01827	0f 11 85 c8 fe
	ff ff		 movups	 XMMWORD PTR $T382[ebp], xmm0
  0182e	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  01833	66 0f d6 85 d8
	fe ff ff	 movq	 QWORD PTR $T382[ebp+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  0183b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01842	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01849	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0184c	83 bd a8 fe ff
	ff 10		 cmp	 DWORD PTR $T340[ebp+20], 16 ; 00000010H

; 1607 : 		if (_Large_string_engaged())

  01853	0f 43 8d 94 fe
	ff ff		 cmovae	 ecx, DWORD PTR $T340[ebp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0185a	83 bd dc fe ff
	ff 10		 cmp	 DWORD PTR $T382[ebp+20], 16 ; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01861	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1607 : 		if (_Large_string_engaged())

  01862	0f 43 85 c8 fe
	ff ff		 cmovae	 eax, DWORD PTR $T382[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01869	50		 push	 eax
  0186a	6a 00		 push	 0
  0186c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01872	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR $T382[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01878	8b f0		 mov	 esi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0187a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  0187d	72 3c		 jb	 SHORT $LN3042@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0187f	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T382[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01885	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01886	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0188c	72 24		 jb	 SHORT $LN3045@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0188e	f6 c2 1f	 test	 dl, 31			; 0000001fH
  01891	0f 85 40 f4 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01897	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0189a	3b c2		 cmp	 eax, edx
  0189c	0f 83 35 f4 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  018a2	2b d0		 sub	 edx, eax
  018a4	83 ea 04	 sub	 edx, 4
  018a7	83 fa 1f	 cmp	 edx, 31			; 0000001fH
  018aa	0f 87 27 f4 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  018b0	8b d0		 mov	 edx, eax
$LN3045@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  018b2	52		 push	 edx
  018b3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  018b8	83 c4 04	 add	 esp, 4
$LN3042@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  018bb	c6 45 fc 2b	 mov	 BYTE PTR __$EHRec$[ebp+8], 43 ; 0000002bH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  018bf	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR $T370[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  018c5	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T382[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  018cf	c7 85 dc fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T382[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  018d9	c6 85 c8 fe ff
	ff 00		 mov	 BYTE PTR $T382[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  018e0	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  018e3	72 3b		 jb	 SHORT $LN3088@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  018e5	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR $T370[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  018eb	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  018ec	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  018f1	72 24		 jb	 SHORT $LN3091@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  018f3	f6 c1 1f	 test	 cl, 31			; 0000001fH
  018f6	0f 85 db f3 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  018fc	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  018ff	3b c1		 cmp	 eax, ecx
  01901	0f 83 d0 f3 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01907	2b c8		 sub	 ecx, eax
  01909	83 e9 04	 sub	 ecx, 4
  0190c	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  0190f	0f 87 c2 f3 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01915	8b c8		 mov	 ecx, eax
$LN3091@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01917	51		 push	 ecx
  01918	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0191d	83 c4 04	 add	 esp, 4
$LN3088@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01920	c6 45 fc 2a	 mov	 BYTE PTR __$EHRec$[ebp+8], 42 ; 0000002aH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01924	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR $T362[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  0192a	c7 85 08 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T370[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01934	c7 85 0c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T370[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0193e	c6 85 f8 fd ff
	ff 00		 mov	 BYTE PTR $T370[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01945	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  01948	72 3b		 jb	 SHORT $LN3134@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0194a	8b 8d 10 fe ff
	ff		 mov	 ecx, DWORD PTR $T362[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01950	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01951	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  01956	72 24		 jb	 SHORT $LN3137@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01958	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0195b	0f 85 76 f3 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01961	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01964	3b c1		 cmp	 eax, ecx
  01966	0f 83 6b f3 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0196c	2b c8		 sub	 ecx, eax
  0196e	83 e9 04	 sub	 ecx, 4
  01971	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01974	0f 87 5d f3 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0197a	8b c8		 mov	 ecx, eax
$LN3137@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0197c	51		 push	 ecx
  0197d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01982	83 c4 04	 add	 esp, 4
$LN3134@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01985	c6 45 fc 29	 mov	 BYTE PTR __$EHRec$[ebp+8], 41 ; 00000029H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01989	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR $T350[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  0198f	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T362[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01999	c7 85 24 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T362[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  019a3	c6 85 10 fe ff
	ff 00		 mov	 BYTE PTR $T362[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  019aa	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  019ad	72 3b		 jb	 SHORT $LN3180@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  019af	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR $T350[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  019b5	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  019b6	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  019bb	72 24		 jb	 SHORT $LN3183@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  019bd	f6 c1 1f	 test	 cl, 31			; 0000001fH
  019c0	0f 85 11 f3 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  019c6	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  019c9	3b c1		 cmp	 eax, ecx
  019cb	0f 83 06 f3 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  019d1	2b c8		 sub	 ecx, eax
  019d3	83 e9 04	 sub	 ecx, 4
  019d6	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  019d9	0f 87 f8 f2 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  019df	8b c8		 mov	 ecx, eax
$LN3183@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  019e1	51		 push	 ecx
  019e2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  019e7	83 c4 04	 add	 esp, 4
$LN3180@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  019ea	c6 45 fc 28	 mov	 BYTE PTR __$EHRec$[ebp+8], 40 ; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  019ee	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR $T349[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  019f4	c7 85 68 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T350[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  019fe	c7 85 6c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T350[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01a08	c6 85 58 fe ff
	ff 00		 mov	 BYTE PTR $T350[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01a0f	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  01a12	72 3b		 jb	 SHORT $LN3226@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01a14	8b 8d 28 fe ff
	ff		 mov	 ecx, DWORD PTR $T349[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01a1a	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01a1b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  01a20	72 24		 jb	 SHORT $LN3229@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01a22	f6 c1 1f	 test	 cl, 31			; 0000001fH
  01a25	0f 85 ac f2 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01a2b	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01a2e	3b c1		 cmp	 eax, ecx
  01a30	0f 83 a1 f2 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01a36	2b c8		 sub	 ecx, eax
  01a38	83 e9 04	 sub	 ecx, 4
  01a3b	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01a3e	0f 87 93 f2 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01a44	8b c8		 mov	 ecx, eax
$LN3229@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01a46	51		 push	 ecx
  01a47	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01a4c	83 c4 04	 add	 esp, 4
$LN3226@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01a4f	c6 45 fc 27	 mov	 BYTE PTR __$EHRec$[ebp+8], 39 ; 00000027H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01a53	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR $T340[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  01a59	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T349[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01a63	c7 85 3c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T349[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01a6d	c6 85 28 fe ff
	ff 00		 mov	 BYTE PTR $T349[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01a74	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  01a77	72 3b		 jb	 SHORT $LN3272@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01a79	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR $T340[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01a7f	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01a80	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  01a85	72 24		 jb	 SHORT $LN3275@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01a87	f6 c1 1f	 test	 cl, 31			; 0000001fH
  01a8a	0f 85 47 f2 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01a90	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01a93	3b c1		 cmp	 eax, ecx
  01a95	0f 83 3c f2 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01a9b	2b c8		 sub	 ecx, eax
  01a9d	83 e9 04	 sub	 ecx, 4
  01aa0	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01aa3	0f 87 2e f2 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01aa9	8b c8		 mov	 ecx, eax
$LN3275@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01aab	51		 push	 ecx
  01aac	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01ab1	83 c4 04	 add	 esp, 4
$LN3272@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01ab4	c6 45 fc 26	 mov	 BYTE PTR __$EHRec$[ebp+8], 38 ; 00000026H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01ab8	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR $T328[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  01abe	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T340[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01ac8	c7 85 a8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T340[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01ad2	c6 85 94 fe ff
	ff 00		 mov	 BYTE PTR $T340[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01ad9	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  01adc	72 3b		 jb	 SHORT $LN3318@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01ade	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR $T328[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01ae4	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01ae5	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  01aea	72 24		 jb	 SHORT $LN3321@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01aec	f6 c1 1f	 test	 cl, 31			; 0000001fH
  01aef	0f 85 e2 f1 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01af5	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01af8	3b c1		 cmp	 eax, ecx
  01afa	0f 83 d7 f1 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01b00	2b c8		 sub	 ecx, eax
  01b02	83 e9 04	 sub	 ecx, 4
  01b05	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01b08	0f 87 c9 f1 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01b0e	8b c8		 mov	 ecx, eax
$LN3321@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01b10	51		 push	 ecx
  01b11	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01b16	83 c4 04	 add	 esp, 4
$LN3318@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01b19	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+8], 37 ; 00000025H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01b1d	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR $T320[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  01b23	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T328[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01b2d	c7 85 90 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T328[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01b37	c6 85 7c fe ff
	ff 00		 mov	 BYTE PTR $T328[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01b3e	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  01b41	72 3b		 jb	 SHORT $LN3364@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01b43	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR $T320[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01b49	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01b4a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  01b4f	72 24		 jb	 SHORT $LN3367@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01b51	f6 c1 1f	 test	 cl, 31			; 0000001fH
  01b54	0f 85 7d f1 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01b5a	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01b5d	3b c1		 cmp	 eax, ecx
  01b5f	0f 83 72 f1 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01b65	2b c8		 sub	 ecx, eax
  01b67	83 e9 04	 sub	 ecx, 4
  01b6a	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01b6d	0f 87 64 f1 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01b73	8b c8		 mov	 ecx, eax
$LN3367@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01b75	51		 push	 ecx
  01b76	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01b7b	83 c4 04	 add	 esp, 4
$LN3364@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01b7e	c6 45 fc 24	 mov	 BYTE PTR __$EHRec$[ebp+8], 36 ; 00000024H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01b82	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR $T308[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  01b88	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T320[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01b92	c7 85 54 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T320[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01b9c	c6 85 40 fe ff
	ff 00		 mov	 BYTE PTR $T320[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01ba3	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  01ba6	72 3b		 jb	 SHORT $LN3410@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01ba8	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR $T308[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01bae	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01baf	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  01bb4	72 24		 jb	 SHORT $LN3413@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01bb6	f6 c1 1f	 test	 cl, 31			; 0000001fH
  01bb9	0f 85 18 f1 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01bbf	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01bc2	3b c1		 cmp	 eax, ecx
  01bc4	0f 83 0d f1 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01bca	2b c8		 sub	 ecx, eax
  01bcc	83 e9 04	 sub	 ecx, 4
  01bcf	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01bd2	0f 87 ff f0 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01bd8	8b c8		 mov	 ecx, eax
$LN3413@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01bda	51		 push	 ecx
  01bdb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01be0	83 c4 04	 add	 esp, 4
$LN3410@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01be3	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01be7	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR $T307[ebp+20]

; 3717 : 		_My_data._Mysize = 0;

  01bed	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T308[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01bf7	c7 85 c4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T308[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01c01	c6 85 b0 fe ff
	ff 00		 mov	 BYTE PTR $T308[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01c08	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  01c0b	72 3b		 jb	 SHORT $LN3456@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01c0d	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR $T307[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01c13	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01c14	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  01c19	72 24		 jb	 SHORT $LN3459@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01c1b	f6 c1 1f	 test	 cl, 31			; 0000001fH
  01c1e	0f 85 b3 f0 ff
	ff		 jne	 $_Invalid_parameter$3674

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01c24	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01c27	3b c1		 cmp	 eax, ecx
  01c29	0f 83 a8 f0 ff
	ff		 jae	 $_Invalid_parameter$3674

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01c2f	2b c8		 sub	 ecx, eax
  01c31	83 e9 04	 sub	 ecx, 4
  01c34	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01c37	0f 87 9a f0 ff
	ff		 ja	 $_Invalid_parameter$3674

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01c3d	8b c8		 mov	 ecx, eax
$LN3459@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01c3f	51		 push	 ecx
  01c40	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01c45	83 c4 04	 add	 esp, 4
$LN3456@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 875  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01c48	85 f6		 test	 esi, esi
  01c4a	0f 85 a6 03 00
	00		 jne	 $LN3650@SprawdŸ_P
$LN68@SprawdŸ_P:

; 879  : 					return; //Wyjœcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 880  : 				}
; 881  : 			}
; 882  : 		}

  01c50	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 637  : 		{	// destroy the object

  01c54	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _numers$452[ebp]
  01c5a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01c5d	c7 84 05 00 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$452[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  01c68	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _numers$452[ebp]
  01c6e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01c71	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  01c74	89 84 0d fc fe
	ff ff		 mov	 DWORD PTR _numers$452[ebp+ecx-4], eax

; 638  : 		}

  01c7b	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+24]
  01c81	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  01c86	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+32]
  01c8c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  01c92	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+104]
  01c98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 863  : 		for (unsigned short i = 1; i <= 12; ++i) //Pêtla licz¹ca od 1 do 12

  01c9e	8b 75 e8	 mov	 esi, DWORD PTR _i$1$[ebp]
  01ca1	46		 inc	 esi
  01ca2	89 75 e8	 mov	 DWORD PTR _i$1$[ebp], esi
  01ca5	66 83 fe 0c	 cmp	 si, 12			; 0000000cH
  01ca9	0f 86 d4 f4 ff
	ff		 jbe	 $LL9@SprawdŸ_P

; 883  : 
; 884  : 		for (unsigned short i = 0; i <= 36; ++i) //Pêtla licz¹ca od 0 do 36

  01caf	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
  01cb6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL12@SprawdŸ_P:
  01cc0	68 b0 00 00 00	 push	 176			; 000000b0H
  01cc5	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _numers$451[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 593  : 		{	// construct empty character buffer

  01ccb	8b f7		 mov	 esi, edi
  01ccd	6a 00		 push	 0
  01ccf	50		 push	 eax
  01cd0	e8 00 00 00 00	 call	 _memset
  01cd5	83 c4 0c	 add	 esp, 12			; 0000000cH
  01cd8	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$451[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  01ce2	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$451[ebp+104]
  01ce8	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$451[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  01cf2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  01cf8	6a 00		 push	 0
  01cfa	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _numers$451[ebp+24]
  01d00	c6 45 fc 2d	 mov	 BYTE PTR __$EHRec$[ebp+8], 45 ; 0000002dH
  01d04	81 cf 00 00 02
	00		 or	 edi, 131072		; 00020000H

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	typedef typename allocator_traits<allocator_type>::pointer _Ptrty;
; 350  : 
; 351  : 	enum
; 352  : 		{	// constant for minimum buffer size
; 353  : 		_MINSIZE = 32};
; 354  : 
; 355  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 356  : 		{	// convert open mode to stream state bits
; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);
; 367  : 		}
; 368  : 
; 369  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 370  : 	_Strstate _Mystate;	// the stream state
; 371  : 	allocator_type _Al;	// the allocator object
; 372  : 	};
; 373  : 
; 374  : 	// basic_stringbuf TEMPLATE OPERATORS
; 375  : template<class _Elem,
; 376  : 	class _Traits,
; 377  : 	class _Alloc> inline
; 378  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 379  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 380  : 	{	// swap _Left and _Right basic_stringbufs
; 381  : 	_Left.swap(_Right);
; 382  : 	}
; 383  : 
; 384  : 		// TEMPLATE CLASS basic_istringstream
; 385  : template<class _Elem,
; 386  : 	class _Traits,
; 387  : 	class _Alloc>
; 388  : 	class basic_istringstream
; 389  : 		: public basic_istream<_Elem, _Traits>
; 390  : 	{	// input stream associated with a character array
; 391  : public:
; 392  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 393  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 394  : 	typedef _Alloc allocator_type;
; 395  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 396  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 397  : 
; 398  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 399  : 		: _Mybase(&_Stringbuffer),
; 400  : 			_Stringbuffer(_Mode | ios_base::in)
; 401  : 		{	// construct empty readable character buffer
; 402  : 		}
; 403  : 
; 404  : 	explicit basic_istringstream(const _Mystr& _Str,
; 405  : 		ios_base::openmode _Mode = ios_base::in)
; 406  : 		: _Mybase(&_Stringbuffer),
; 407  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 408  : 		{	// construct readable character buffer from NTCS
; 409  : 		}
; 410  : 
; 411  : 	basic_istringstream(_Myt&& _Right)
; 412  : 		: _Mybase(&_Stringbuffer)
; 413  : 		{	// construct by moving _Right
; 414  : 		_Assign_rv(_STD move(_Right));
; 415  : 		}
; 416  : 
; 417  : 	_Myt& operator=(_Myt&& _Right)
; 418  : 		{	// move from _Right
; 419  : 		_Assign_rv(_STD move(_Right));
; 420  : 		return (*this);
; 421  : 		}
; 422  : 
; 423  : 	void _Assign_rv(_Myt&& _Right)
; 424  : 		{	// assign by moving _Right
; 425  : 		if (this != _STD addressof(_Right))
; 426  : 			{	// different, worth moving
; 427  : 			_Stringbuffer.str(_Mystr());
; 428  : 			this->swap(_Right);
; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 	void swap(_Myt& _Right)
; 433  : 		{	// swap with _Right
; 434  : 		if (this != _STD addressof(_Right))
; 435  : 			{	// different, swap base and buffer
; 436  : 			_Mybase::swap(_Right);
; 437  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 438  : 			}
; 439  : 		}
; 440  : 
; 441  : 	basic_istringstream(const _Myt&) = delete;
; 442  : 	_Myt& operator=(const _Myt&) = delete;
; 443  : 
; 444  : 	virtual ~basic_istringstream() _NOEXCEPT
; 445  : 		{	// destroy the object
; 446  : 		}
; 447  : 
; 448  : 	_Mysb *rdbuf() const
; 449  : 		{	// return pointer to file buffer
; 450  : 		return ((_Mysb *)&_Stringbuffer);
; 451  : 		}
; 452  : 
; 453  : 	_Mystr str() const
; 454  : 		{	// return string copy of character array
; 455  : 		return (_Stringbuffer.str());
; 456  : 		}
; 457  : 
; 458  : 	void str(const _Mystr& _Newstr)
; 459  : 		{	// replace character array from string
; 460  : 		_Stringbuffer.str(_Newstr);
; 461  : 		}
; 462  : 
; 463  : private:
; 464  : 	_Mysb _Stringbuffer;	// the string buffer
; 465  : 	};
; 466  : 
; 467  : 	// basic_istringstream TEMPLATE OPERATORS
; 468  : template<class _Elem,
; 469  : 	class _Traits,
; 470  : 	class _Alloc> inline
; 471  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 472  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 473  : 	{	// swap _Left and _Right basic_istringstreams
; 474  : 	_Left.swap(_Right);
; 475  : 	}
; 476  : 
; 477  : 		// TEMPLATE CLASS basic_ostringstream
; 478  : template<class _Elem,
; 479  : 	class _Traits,
; 480  : 	class _Alloc>
; 481  : 	class basic_ostringstream
; 482  : 		: public basic_ostream<_Elem, _Traits>
; 483  : 	{	// output stream associated with a character array
; 484  : public:
; 485  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 486  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 487  : 	typedef _Alloc allocator_type;
; 488  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 489  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 490  : 
; 491  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 492  : 		: _Mybase(&_Stringbuffer),
; 493  : 			_Stringbuffer(_Mode | ios_base::out)
; 494  : 		{	// construct empty writable character buffer
; 495  : 		}
; 496  : 
; 497  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 498  : 		ios_base::openmode _Mode = ios_base::out)
; 499  : 		: _Mybase(&_Stringbuffer),
; 500  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 501  : 		{	// construct writable character buffer from NTCS
; 502  : 		}
; 503  : 
; 504  : 	basic_ostringstream(_Myt&& _Right)
; 505  : 		: _Mybase(&_Stringbuffer)
; 506  : 		{	// construct by moving _Right
; 507  : 		_Assign_rv(_STD move(_Right));
; 508  : 		}
; 509  : 
; 510  : 	_Myt& operator=(_Myt&& _Right)
; 511  : 		{	// move from _Right
; 512  : 		_Assign_rv(_STD move(_Right));
; 513  : 		return (*this);
; 514  : 		}
; 515  : 
; 516  : 	void _Assign_rv(_Myt&& _Right)
; 517  : 		{	// assign by moving _Right
; 518  : 		if (this != _STD addressof(_Right))
; 519  : 			{	// different, worth moving
; 520  : 			_Stringbuffer.str(_Mystr());
; 521  : 			this->swap(_Right);
; 522  : 			}
; 523  : 		}
; 524  : 
; 525  : 	void swap(_Myt& _Right)
; 526  : 		{	// swap with _Right
; 527  : 		if (this != _STD addressof(_Right))
; 528  : 			{	// different, swap base and buffer
; 529  : 			_Mybase::swap(_Right);
; 530  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 531  : 			}
; 532  : 		}
; 533  : 
; 534  : 	basic_ostringstream(const _Myt&) = delete;
; 535  : 	_Myt& operator=(const _Myt&) = delete;
; 536  : 
; 537  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 538  : 		{	// destroy the object
; 539  : 		}
; 540  : 
; 541  : 	_Mysb *rdbuf() const
; 542  : 		{	// return pointer to buffer
; 543  : 		return ((_Mysb *)&_Stringbuffer);
; 544  : 		}
; 545  : 
; 546  : 	_Mystr str() const
; 547  : 		{	// return string copy of character array
; 548  : 		return (_Stringbuffer.str());
; 549  : 		}
; 550  : 
; 551  : 	void str(const _Mystr& _Newstr)
; 552  : 		{	// replace character array from string
; 553  : 		_Stringbuffer.str(_Newstr);
; 554  : 		}
; 555  : 
; 556  : private:
; 557  : 	_Mysb _Stringbuffer;	// the string buffer
; 558  : 	};
; 559  : 
; 560  : 	// basic_ostringstream TEMPLATE OPERATORS
; 561  : template<class _Elem,
; 562  : 	class _Traits,
; 563  : 	class _Alloc> inline
; 564  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 565  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 566  : 	{	// swap _Left and _Right basic_ostringstreams
; 567  : 	_Left.swap(_Right);
; 568  : 	}
; 569  : 
; 570  : 		// TEMPLATE CLASS basic_stringstream
; 571  : template<class _Elem,
; 572  : 	class _Traits,
; 573  : 	class _Alloc>
; 574  : 	class basic_stringstream
; 575  : 		: public basic_iostream<_Elem, _Traits>
; 576  : 	{	// input/output stream associated with a character array
; 577  : public:
; 578  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 579  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 580  : 	typedef _Elem char_type;
; 581  : 	typedef _Traits traits_type;
; 582  : 	typedef _Alloc allocator_type;
; 583  : 	typedef typename _Traits::int_type int_type;
; 584  : 	typedef typename _Traits::pos_type pos_type;
; 585  : 	typedef typename _Traits::off_type off_type;
; 586  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 587  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 588  : 
; 589  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 590  : 		ios_base::in | ios_base::out)
; 591  : 		: _Mybase(&_Stringbuffer),

  01d0a	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$451[ebp]
  01d10	50		 push	 eax
  01d11	89 bd f8 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], edi
  01d17	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  01d1d	c7 45 fc 2e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 46 ; 0000002eH

; 593  : 		{	// construct empty character buffer

  01d24	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _numers$451[ebp]
  01d2a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01d2d	c7 84 05 00 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$451[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  01d38	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _numers$451[ebp]
  01d3e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01d41	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  01d44	89 84 0d fc fe
	ff ff		 mov	 DWORD PTR _numers$451[ebp+ecx-4], eax
  01d4b	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _numers$451[ebp+24]

; 30   : 		{	// construct empty character buffer from mode

  01d51	8b c8		 mov	 ecx, eax

; 592  : 			_Stringbuffer(_Mode)

  01d53	89 85 ac fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

  01d59	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  01d5f	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$451[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

  01d69	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$451[ebp+80], 0

; 312  : 		_Mystate = _State;

  01d73	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$451[ebp+84], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 886  : 			stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  01d7d	c6 45 fc 30	 mov	 BYTE PTR __$EHRec$[ebp+8], 48 ; 00000030H

; 887  : 			numers << i; //Wpisanie do typu wartoœci z obrotu pêtli

  01d81	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$451[ebp+16]
  01d87	ff 75 ec	 push	 DWORD PTR _i$1$[ebp]
  01d8a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 647  : 		return (_Stringbuffer.str());

  01d90	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T437[ebp]
  01d96	50		 push	 eax
  01d97	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$451[ebp+24]
  01d9d	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
  01da2	8b fe		 mov	 edi, esi
  01da4	81 cf 00 00 06
	00		 or	 edi, 393216		; 00060000H
  01daa	89 bd f8 fe ff
	ff		 mov	 DWORD PTR $T450[ebp], edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 888  : 			if ((_access((G³os + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01db0	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T437[ebp]
  01db6	c6 45 fc 31	 mov	 BYTE PTR __$EHRec$[ebp+8], 49 ; 00000031H
  01dba	50		 push	 eax
  01dbb	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T438[ebp]
  01dc1	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01dc6	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01dcb	8b d0		 mov	 edx, eax
  01dcd	c6 45 fc 32	 mov	 BYTE PTR __$EHRec$[ebp+8], 50 ; 00000032H
  01dd1	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T439[ebp]
  01dd7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ddc	83 c4 08	 add	 esp, 8
  01ddf	8b c8		 mov	 ecx, eax
  01de1	6a 00		 push	 0
  01de3	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01de8	50		 push	 eax
  01de9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  01def	83 c4 08	 add	 esp, 8
  01df2	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T439[ebp]
  01df8	8b f0		 mov	 esi, eax
  01dfa	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01dff	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T438[ebp]
  01e05	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e0a	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T437[ebp]
  01e10	c6 45 fc 30	 mov	 BYTE PTR __$EHRec$[ebp+8], 48 ; 00000030H
  01e14	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e19	85 f6		 test	 esi, esi
  01e1b	0f 84 64 01 00
	00		 je	 $LN71@SprawdŸ_P

; 889  : 			{
; 890  : 				if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  01e21	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  01e28	75 24		 jne	 SHORT $LN70@SprawdŸ_P

; 891  : 				{
; 892  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01e2a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01e30	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01e35	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  01e3a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01e3f	8b c8		 mov	 ecx, eax
  01e41	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 893  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01e47	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN70@SprawdŸ_P:

; 894  : 				}
; 895  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01e4e	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR $T441[ebp]
  01e54	50		 push	 eax
  01e55	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$451[ebp]
  01e5b	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01e60	8b f0		 mov	 esi, eax
  01e62	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  01e65	c6 45 fc 33	 mov	 BYTE PTR __$EHRec$[ebp+8], 51 ; 00000033H
  01e69	50		 push	 eax
  01e6a	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T442[ebp]
  01e70	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01e75	56		 push	 esi
  01e76	8b d0		 mov	 edx, eax
  01e78	c6 45 fc 34	 mov	 BYTE PTR __$EHRec$[ebp+8], 52 ; 00000034H
  01e7c	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T443[ebp]
  01e82	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01e87	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01e8c	8b d0		 mov	 edx, eax
  01e8e	c6 45 fc 35	 mov	 BYTE PTR __$EHRec$[ebp+8], 53 ; 00000035H
  01e92	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T444[ebp]
  01e98	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01e9d	83 c4 0c	 add	 esp, 12			; 0000000cH
  01ea0	8b f8		 mov	 edi, eax
  01ea2	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR $T445[ebp]
  01ea8	c6 45 fc 36	 mov	 BYTE PTR __$EHRec$[ebp+8], 54 ; 00000036H
  01eac	50		 push	 eax
  01ead	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$451[ebp]
  01eb3	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01eb8	8b f0		 mov	 esi, eax
  01eba	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$454[ebp]
  01ebd	c6 45 fc 37	 mov	 BYTE PTR __$EHRec$[ebp+8], 55 ; 00000037H
  01ec1	50		 push	 eax
  01ec2	8d 55 b0	 lea	 edx, DWORD PTR _link$453[ebp]
  01ec5	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T446[ebp]
  01ecb	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ed0	56		 push	 esi
  01ed1	8b d0		 mov	 edx, eax
  01ed3	c6 45 fc 38	 mov	 BYTE PTR __$EHRec$[ebp+8], 56 ; 00000038H
  01ed7	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T447[ebp]
  01edd	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ee2	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01ee7	8b d0		 mov	 edx, eax
  01ee9	c6 45 fc 39	 mov	 BYTE PTR __$EHRec$[ebp+8], 57 ; 00000039H
  01eed	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T448[ebp]
  01ef3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ef8	83 c4 0c	 add	 esp, 12			; 0000000cH
  01efb	8b cf		 mov	 ecx, edi
  01efd	8b d0		 mov	 edx, eax
  01eff	6a 00		 push	 0
  01f01	6a 00		 push	 0
  01f03	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01f08	50		 push	 eax
  01f09	8b ca		 mov	 ecx, edx
  01f0b	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01f10	50		 push	 eax
  01f11	6a 00		 push	 0
  01f13	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  01f19	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T448[ebp]
  01f1f	8b f0		 mov	 esi, eax
  01f21	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f26	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T447[ebp]
  01f2c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f31	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T446[ebp]
  01f37	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f3c	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T445[ebp]
  01f42	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f47	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T444[ebp]
  01f4d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f52	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T443[ebp]
  01f58	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f5d	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T442[ebp]
  01f63	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f68	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T441[ebp]
  01f6e	c6 45 fc 30	 mov	 BYTE PTR __$EHRec$[ebp+8], 48 ; 00000030H
  01f72	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 896  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01f77	85 f6		 test	 esi, esi
  01f79	0f 85 ea 00 00
	00		 jne	 $LN3651@SprawdŸ_P
  01f7f	8b bd f8 fe ff
	ff		 mov	 edi, DWORD PTR $T450[ebp]
$LN71@SprawdŸ_P:

; 901  : 				}
; 902  : 			}
; 903  : 		}

  01f85	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$451[ebp]
  01f8b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01f8f	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  01f94	8b 45 ec	 mov	 eax, DWORD PTR _i$1$[ebp]
  01f97	40		 inc	 eax
  01f98	89 45 ec	 mov	 DWORD PTR _i$1$[ebp], eax
  01f9b	66 83 f8 24	 cmp	 ax, 36			; 00000024H
  01f9f	0f 86 1b fd ff
	ff		 jbe	 $LL12@SprawdŸ_P

; 904  : 
; 905  : 		if (czy_pobierano) cout << "Pobrano brakuj¹ce pliki g³osów" << endl; //Poinformowanie o ukoñczonu pobierania plików

  01fa5	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  01fac	74 1d		 je	 SHORT $LN72@SprawdŸ_P
  01fae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01fb4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@
  01fb9	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  01fbe	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01fc3	8b c8		 mov	 ecx, eax
  01fc5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN72@SprawdŸ_P:

; 906  : 	}

  01fcb	8d 4d d0	 lea	 ecx, DWORD PTR _g³os2$454[ebp]
  01fce	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01fd3	8d 4d b0	 lea	 ecx, DWORD PTR _link$453[ebp]
  01fd6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN32@SprawdŸ_P:

; 907  : }

  01fdb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01fde	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01fe5	59		 pop	 ecx
  01fe6	5f		 pop	 edi
  01fe7	5e		 pop	 esi
  01fe8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01feb	33 cd		 xor	 ecx, ebp
  01fed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01ff2	8b e5		 mov	 esp, ebp
  01ff4	5d		 pop	 ebp
  01ff5	c3		 ret	 0
$LN3650@SprawdŸ_P:

; 876  : 				{
; 877  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  01ff6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01ffc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  02001	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  02006	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0200b	8b c8		 mov	 ecx, eax
  0200d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 637  : 		{	// destroy the object

  02013	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _numers$452[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 878  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  02019	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 637  : 		{	// destroy the object

  02020	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  02023	c7 84 05 00 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$452[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0202e	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _numers$452[ebp]
  02034	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02037	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  0203a	89 84 0d fc fe
	ff ff		 mov	 DWORD PTR _numers$452[ebp+ecx-4], eax

; 638  : 		}

  02041	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+24]
  02047	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  0204c	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+32]
  02052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  02058	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+104]
  0205e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  02064	e9 62 ff ff ff	 jmp	 $LN72@SprawdŸ_P
$LN3651@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 898  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  02069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0206f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  02074	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  02079	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0207e	8b c8		 mov	 ecx, eax
  02080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 899  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio
; 900  : 					return; //Wyjœcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej

  02086	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$451[ebp]
  0208c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  02093	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  02098	e9 2e ff ff ff	 jmp	 $LN72@SprawdŸ_P
$LN3669@SprawdŸ_P:
  0209d	0f 1f 00	 npad	 3
$LN3671@SprawdŸ_P:

; 907  : }

  020a0	00 00 00 00	 DD	 $LN33@SprawdŸ_P
  020a4	00 00 00 00	 DD	 $LN34@SprawdŸ_P
  020a8	00 00 00 00	 DD	 $LN35@SprawdŸ_P
  020ac	00 00 00 00	 DD	 $LN36@SprawdŸ_P
  020b0	00 00 00 00	 DD	 $LN37@SprawdŸ_P
  020b4	00 00 00 00	 DD	 $LN38@SprawdŸ_P
  020b8	00 00 00 00	 DD	 $LN39@SprawdŸ_P
  020bc	00 00 00 00	 DD	 $LN40@SprawdŸ_P
  020c0	00 00 00 00	 DD	 $LN41@SprawdŸ_P
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR _link$453[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$1:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR _g³os2$454[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$5:
  00010	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T54[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$6:
  0001b	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$7:
  00026	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T57[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$10:
  00031	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T76[ebp]
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$11:
  0003c	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T77[ebp]
  00042	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$12:
  00047	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T79[ebp]
  0004d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$15:
  00052	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T94[ebp]
  00058	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$16:
  0005d	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T95[ebp]
  00063	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$17:
  00068	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T97[ebp]
  0006e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$20:
  00073	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T112[ebp]
  00079	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$21:
  0007e	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T113[ebp]
  00084	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$22:
  00089	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T115[ebp]
  0008f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$25:
  00094	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T130[ebp]
  0009a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$26:
  0009f	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T131[ebp]
  000a5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$27:
  000aa	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T133[ebp]
  000b0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$30:
  000b5	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T148[ebp]
  000bb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$31:
  000c0	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T149[ebp]
  000c6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$32:
  000cb	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T151[ebp]
  000d1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$34:
  000d6	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T160[ebp]
  000dc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$35:
  000e1	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR $T170[ebp]
  000e7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$37:
  000ec	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T214[ebp]
  000f2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$38:
  000f7	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T215[ebp]
  000fd	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$39:
  00102	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T225[ebp]
  00108	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$40:
  0010d	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T233[ebp]
  00113	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$41:
  00118	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T235[ebp]
  0011e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$42:
  00123	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T236[ebp]
  00129	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$43:
  0012e	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T246[ebp]
  00134	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$304:
  00139	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  0013f	83 e0 20	 and	 eax, 32			; 00000020H
  00142	0f 84 13 00 00
	00		 je	 $LN1344@SprawdŸ_P
  00148	83 a5 f8 fe ff
	ff df		 and	 DWORD PTR $T1[ebp], -33	; ffffffdfH
  0014f	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+104]
  00155	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN1344@SprawdŸ_P:
  0015b	c3		 ret	 0
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$305:
  0015c	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp+32]
  00162	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$307:
  00168	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$45:
  00171	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$452[ebp]
  00177	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$46:
  0017c	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T264[ebp]
  00182	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$47:
  00187	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T265[ebp]
  0018d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$48:
  00192	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T266[ebp]
  00198	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$50:
  0019d	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T307[ebp]
  001a3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$51:
  001a8	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T308[ebp]
  001ae	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$52:
  001b3	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T320[ebp]
  001b9	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$53:
  001be	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T328[ebp]
  001c4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$54:
  001c9	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR $T340[ebp]
  001cf	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$55:
  001d4	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T349[ebp]
  001da	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$56:
  001df	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T350[ebp]
  001e5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$57:
  001ea	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T362[ebp]
  001f0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$58:
  001f5	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T370[ebp]
  001fb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$756:
  00200	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00206	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  0020b	0f 84 16 00 00
	00		 je	 $LN3494@SprawdŸ_P
  00211	81 a5 f8 fe ff
	ff ff ff fd ff	 and	 DWORD PTR $T1[ebp], -131073 ; fffdffffH
  0021b	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$451[ebp+104]
  00221	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN3494@SprawdŸ_P:
  00227	c3		 ret	 0
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$757:
  00228	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$451[ebp+32]
  0022e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$759:
  00234	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0023a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$60:
  00240	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$451[ebp]
  00246	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$61:
  0024b	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T437[ebp]
  00251	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$62:
  00256	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T438[ebp]
  0025c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$64:
  00261	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T441[ebp]
  00267	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$65:
  0026c	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T442[ebp]
  00272	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$66:
  00277	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T443[ebp]
  0027d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$67:
  00282	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T444[ebp]
  00288	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$68:
  0028d	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T445[ebp]
  00293	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$69:
  00298	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T446[ebp]
  0029e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_Pliki@@YAXXZ$70:
  002a3	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T447[ebp]
  002a9	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?SprawdŸ_Pliki@@YAXXZ:
  002ae	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  002b2	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  002b5	8b 8a f8 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-520]
  002bb	33 c8		 xor	 ecx, eax
  002bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c2	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  002c5	33 c8		 xor	 ecx, eax
  002c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cc	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SprawdŸ_Pliki@@YAXXZ
  002d1	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SprawdŸ_Pliki@@YAXXZ ENDP				; SprawdŸ_Pliki
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?SprawdŸ_ustawienia@@YAXXZ
_TEXT	SEGMENT
_this$ = -408						; size = 4
$T1 = -404						; size = 4
_ustawienia$11 = -400					; size = 184
_ustawienia$12 = -216					; size = 176
_buf$13 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?SprawdŸ_ustawienia@@YAXXZ PROC				; SprawdŸ_ustawienia, COMDAT

; 910  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SprawdŸ_ustawienia@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 911  : 	if (!_access("setting.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  0002e	6a 00		 push	 0
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COFBHHKL@setting?4txt?$AA@
  00035	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  00045	83 c4 08	 add	 esp, 8
  00048	85 c0		 test	 eax, eax
  0004a	0f 85 4b 02 00
	00		 jne	 $LN4@SprawdŸ_u
  00050	68 b8 00 00 00	 push	 184			; 000000b8H
  00055	50		 push	 eax
  00056	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _ustawienia$11[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _memset
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 759  : 		{	// construct unopened

  00065	c7 85 70 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$11[ebp], OFFSET ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  0006f	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp+112]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  0007b	6a 00		 push	 0
  0007d	6a 00		 push	 0
  0007f	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR _ustawienia$11[ebp+16]
  00085	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008c	50		 push	 eax
  0008d	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp]
  00093	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T1[ebp], 1

; 654  : 		}
; 655  : 
; 656  : 	bool _Endwrite()
; 657  : 		{	// put shift to initial conversion state, as needed
; 658  : 		if (_Pcvt == 0 || !_Wrotesome)
; 659  : 			return (true);
; 660  : 		else
; 661  : 			{	// may have to put
; 662  : 			const int _STRING_INC = 8;
; 663  : 			char *_Dest;
; 664  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 665  : 				return (false);
; 666  : 
; 667  : 			string _Str(_STRING_INC, '\0');
; 668  : 			for (; ; )
; 669  : 				switch (_Pcvt->unshift(_State,
; 670  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 671  : 				{	// test result of homing conversion
; 672  : 				case codecvt_base::ok:
; 673  : 					_Wrotesome = false;	// homed successfully
; 674  : 
; 675  : 				case codecvt_base::partial:	// fall through
; 676  : 					{	// put any generated bytes
; 677  : 					size_t _Count = _Dest - &*_Str.begin();
; 678  : 					if (0 < _Count && _Count !=
; 679  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 680  : 						return (false);	// write failed
; 681  : 					if (!_Wrotesome)
; 682  : 						return (true);
; 683  : 					if (_Count == 0)
; 684  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 685  : 					break;
; 686  : 					}
; 687  : 
; 688  : 				case codecvt_base::noconv:
; 689  : 					return (true);	// nothing to do
; 690  : 
; 691  : 				default:
; 692  : 					return (false);	// conversion failed
; 693  : 				}
; 694  : 			}
; 695  : 		}
; 696  : 
; 697  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 698  : 		{	// initialize codecvt pointer
; 699  : 		if (_Newpcvt->always_noconv())
; 700  : 			_Pcvt = 0;	// nothing to do
; 701  : 		else
; 702  : 			{	// set up for nontrivial codecvt facet
; 703  : 			_Pcvt = _Newpcvt;
; 704  : 			_Mysb::_Init();	// reset any buffering
; 705  : 			}
; 706  : 		}
; 707  : 
; 708  : private:
; 709  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 710  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 711  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 712  : 	typename _Traits::state_type _State;	// current conversion state
; 713  : 	bool _Closef;	// true if C stream must be closed
; 714  : 	_Filet *_Myfile;	// pointer to C stream
; 715  : 
; 716  : 	void _Reset_back()
; 717  : 		{	// restore buffer after putback
; 718  : 		if (_Mysb::eback() == &_Mychar)
; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 720  : 		}
; 721  : 
; 722  : 	void _Set_back()
; 723  : 		{	// set up putback area
; 724  : 		if (_Mysb::eback() != &_Mychar)
; 725  : 			{	// save current get buffer
; 726  : 			_Set_eback = _Mysb::eback();
; 727  : 			_Set_egptr = _Mysb::egptr();
; 728  : 			}
; 729  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 730  : 		}
; 731  : 
; 732  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 733  : 	_Elem *_Set_egptr;	// saves egptr()
; 734  : 	};
; 735  : 
; 736  : 	// basic_filebuf TEMPLATE OPERATORS
; 737  : template<class _Elem,
; 738  : 	class _Traits> inline
; 739  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 740  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 741  : 	{	// swap _Left and _Right basic_filebufs
; 742  : 	_Left.swap(_Right);
; 743  : 	}
; 744  : 
; 745  : 		// TEMPLATE CLASS basic_ifstream
; 746  : template<class _Elem,
; 747  : 	class _Traits>
; 748  : 	class basic_ifstream
; 749  : 		: public basic_istream<_Elem, _Traits>
; 750  : 	{	// input stream associated with a C stream
; 751  : public:
; 752  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 753  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 754  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 755  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 756  : 
; 757  : 	basic_ifstream()
; 758  : 		: _Mybase(&_Filebuffer)

  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  000a3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 759  : 		{	// construct unopened

  000aa	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$11[ebp]
  000b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b3	c7 84 05 70 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ustawienia$11[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  000be	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$11[ebp]
  000c4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c7	8d 41 90	 lea	 eax, DWORD PTR [ecx-112]
  000ca	89 84 0d 6c fe
	ff ff		 mov	 DWORD PTR _ustawienia$11[ebp+ecx-4], eax
  000d1	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR _ustawienia$11[ebp+16]

; 155  : 		: _Mysb()

  000d7	8b c8		 mov	 ecx, eax

; 759  : 		{	// construct unopened

  000d9	89 85 68 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 155  : 		: _Mysb()

  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  000e5	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  000e9	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp+16]

; 156  : 		{	// construct from pointer to C stream

  000ef	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$11[ebp+16], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 625  : 		_Closef = _Which == _Openfl;

  000f9	c6 85 c8 fe ff
	ff 00		 mov	 BYTE PTR _ustawienia$11[ebp+88], 0

; 626  : 		_Wrotesome = false;

  00100	c6 85 bd fe ff
	ff 00		 mov	 BYTE PTR _ustawienia$11[ebp+77], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;
; 652  : 		_State = _Stinit;

  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  00112	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _ustawienia$11[ebp+80], eax
  00118	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  0011d	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$11[ebp+92], 0
  00127	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _ustawienia$11[ebp+84], eax

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  0012d	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$11[ebp+72], 0

; 922  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00137	51		 push	 ecx
  00138	6a 01		 push	 1
  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COFBHHKL@setting?4txt?$AA@
  0013f	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 913  : 		ifstream ustawienia; //Utworzenie typu do celu odczytu z pliku

  00145	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 922  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  0014c	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00151	85 c0		 test	 eax, eax

; 923  : 			_Myios::setstate(ios_base::failbit);

  00153	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp]
  00159	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$11[ebp]
  0015f	6a 00		 push	 0
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	75 0c		 jne	 SHORT $LN47@SprawdŸ_u
  00166	6a 02		 push	 2
  00168	03 c8		 add	 ecx, eax
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 924  : 		else

  00170	eb 0a		 jmp	 SHORT $LN48@SprawdŸ_u
$LN47@SprawdŸ_u:

; 925  : 			_Myios::clear();	// added with C++11

  00172	6a 00		 push	 0
  00174	03 c8		 add	 ecx, eax
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN48@SprawdŸ_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0017c	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  00181	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _buf$13[ebp+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00188	32 db		 xor	 bl, bl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0018a	89 55 ec	 mov	 DWORD PTR _buf$13[ebp+20], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0018d	88 5d d8	 mov	 BYTE PTR _buf$13[ebp], bl
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 915  : 		string buf; //Utworzenie buforu do odczytu z pliku

  00190	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 314  : 		return (_Mystate);

  00194	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _ustawienia$11[ebp]
  0019a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  0019d	f6 84 05 7c fe
	ff ff 01	 test	 BYTE PTR _ustawienia$11[ebp+eax+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 916  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  001a5	75 4f		 jne	 SHORT $LN3@SprawdŸ_u
  001a7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@SprawdŸ_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  001b0	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp]
  001b6	6a 0a		 push	 10			; 0000000aH
  001b8	03 c8		 add	 ecx, eax
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  001c0	0f b6 c0	 movzx	 eax, al
  001c3	8d 55 d8	 lea	 edx, DWORD PTR _buf$13[ebp]
  001c6	50		 push	 eax
  001c7	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp]
  001cd	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  001d2	83 c4 04	 add	 esp, 4
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 919  : 			Ustaw_ustawienia(buf); //Zamiana wczytanej lini na ustawienie programu

  001d5	8d 4d d8	 lea	 ecx, DWORD PTR _buf$13[ebp]
  001d8	e8 00 00 00 00	 call	 ?Ustaw_ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ustaw_ustawienia
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 314  : 		return (_Mystate);

  001dd	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _ustawienia$11[ebp]
  001e3	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  001e6	f6 84 05 7c fe
	ff ff 01	 test	 BYTE PTR _ustawienia$11[ebp+eax+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 916  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  001ee	74 c0		 je	 SHORT $LL2@SprawdŸ_u
  001f0	8b 55 ec	 mov	 edx, DWORD PTR _buf$13[ebp+20]
  001f3	8a 5d d8	 mov	 bl, BYTE PTR _buf$13[ebp]
$LN3@SprawdŸ_u:

; 921  : 	}

  001f6	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001fa	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  001fd	72 3a		 jb	 SHORT $LN109@SprawdŸ_u
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  001ff	8b 4d d8	 mov	 ecx, DWORD PTR _buf$13[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00202	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00205	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0020a	72 1e		 jb	 SHORT $LN112@SprawdŸ_u

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0020c	f6 c3 1f	 test	 bl, 31			; 0000001fH
  0020f	0f 85 80 00 00
	00		 jne	 $_Invalid_parameter$157

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00215	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00218	3b c1		 cmp	 eax, ecx
  0021a	73 79		 jae	 SHORT $_Invalid_parameter$157

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0021c	2b c8		 sub	 ecx, eax
  0021e	83 f9 04	 cmp	 ecx, 4
  00221	72 72		 jb	 SHORT $_Invalid_parameter$157

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00223	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00226	77 6d		 ja	 SHORT $_Invalid_parameter$157

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00228	8b c8		 mov	 ecx, eax
$LN112@SprawdŸ_u:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0022a	51		 push	 ecx
  0022b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00230	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _ustawienia$11[ebp]
  00236	83 c4 04	 add	 esp, 4
$LN109@SprawdŸ_u:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 921  : 	}

  00239	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00240	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _buf$13[ebp+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00247	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _buf$13[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0024e	c6 45 d8 00	 mov	 BYTE PTR _buf$13[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 905  : 		{	// destroy the object

  00252	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00255	c7 84 05 70 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ustawienia$11[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00260	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$11[ebp]
  00266	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00269	8d 41 90	 lea	 eax, DWORD PTR [ecx-112]
  0026c	89 84 0d 6c fe
	ff ff		 mov	 DWORD PTR _ustawienia$11[ebp+ecx-4], eax

; 906  : 		}

  00273	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp+16]
  00279	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0027e	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp+24]
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0028a	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp+112]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 922  : 	else

  00290	e9 10 02 00 00	 jmp	 $LN155@SprawdŸ_u
$_Invalid_parameter$157:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00295	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN156@SprawdŸ_u:
$LN4@SprawdŸ_u:
  0029b	68 b0 00 00 00	 push	 176			; 000000b0H
  002a0	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _ustawienia$12[ebp]
  002a6	6a 00		 push	 0
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 _memset
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 924  : 		ofstream ustawienia; //Utworzenie typu do celu zapisu do pliku

  002ae	83 c4 08	 add	 esp, 8
  002b1	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  002b7	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  002bc	51		 push	 ecx
  002bd	6a 02		 push	 2
  002bf	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COFBHHKL@setting?4txt?$AA@
  002c4	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp+4]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 924  : 		ofstream ustawienia; //Utworzenie typu do celu zapisu do pliku

  002ca	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  002d1	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  002d6	85 c0		 test	 eax, eax

; 1139 : 			_Myios::setstate(ios_base::failbit);

  002d8	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  002de	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _ustawienia$12[ebp]
  002e4	6a 00		 push	 0
  002e6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002e9	75 0c		 jne	 SHORT $LN139@SprawdŸ_u
  002eb	6a 02		 push	 2
  002ed	03 c8		 add	 ecx, eax
  002ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1140 : 		else

  002f5	eb 0a		 jmp	 SHORT $LN140@SprawdŸ_u
$LN139@SprawdŸ_u:

; 1141 : 			_Myios::clear();	// added with C++11

  002f7	6a 00		 push	 0
  002f9	03 c8		 add	 ecx, eax
  002fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN140@SprawdŸ_u:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 926  : 		ustawienia << "iloœæ_minimalna_obrotów_ruletki 2" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych iloœæ_minimalna_obrotów_ruletki

  00301	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00306	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@
  0030b	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  00311	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00316	8b c8		 mov	 ecx, eax
  00318	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 927  : 		ustawienia << "iloœæ_max_dodatkowych_obrotów_ruletki 3" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych iloœæ_max_dodatkowych_obrotów_ruletki

  0031e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00323	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
  00328	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  0032e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00333	8b c8		 mov	 ecx, eax
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 928  : 		ustawienia << "czas_przeskoku_kulki_szybki 50" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych czas_przeskoku_kulki_szybki

  0033b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00340	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@
  00345	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  0034b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00350	8b c8		 mov	 ecx, eax
  00352	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 929  : 		ustawienia << "czas_przeskoku_kulki_wolny 75" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych czas_przeskoku_kulki_wolny

  00358	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0035d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@
  00362	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  00368	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0036d	8b c8		 mov	 ecx, eax
  0036f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 930  : 		ustawienia << "czas_przerwy_dzwiêku 500" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych czas_przerwy_dzwiêku

  00375	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0037a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@
  0037f	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  00385	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0038a	8b c8		 mov	 ecx, eax
  0038c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 931  : 		ustawienia << "styl_liczenia_wygranej 1" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych styl_liczenia_wygranej

  00392	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00397	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@
  0039c	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  003a2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003a7	8b c8		 mov	 ecx, eax
  003a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 932  : 		ustawienia << "kwota_pocz¹tkowa 1000" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych kwota_pocz¹tkowa

  003af	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  003b4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@
  003b9	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  003bf	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003c4	8b c8		 mov	 ecx, eax
  003c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 933  : 		ustawienia << "stan_dŸwiêków 1" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych stan_dŸwiêków

  003cc	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  003d1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@
  003d6	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  003dc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003e1	8b c8		 mov	 ecx, eax
  003e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 934  : 		ustawienia << "czy_kontynuowaæ_grê 1" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych czy_kontynuowaæ_grê

  003e9	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  003ee	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@
  003f3	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  003f9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003fe	8b c8		 mov	 ecx, eax
  00400	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 935  : 		ustawienia << "g³os_odczytu_numeru 1" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych g³os_odczytu_numeru

  00406	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0040b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@
  00410	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  00416	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0041b	8b c8		 mov	 ecx, eax
  0041d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 936  : 		ustawienia << "g³os_szybkoœæ_odczytu_numeru 4" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych g³os_szybkoœæ_odczytu_numeru

  00423	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00428	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@
  0042d	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  00433	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00438	8b c8		 mov	 ecx, eax
  0043a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 937  : 		ustawienia << "efekty_dŸwiêkowe 1" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych efekty_dŸwiêkowe

  00440	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00445	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@
  0044a	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  00450	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00455	8b c8		 mov	 ecx, eax
  00457	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 938  : 	}

  0045d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1121 : 		{	// destroy the object

  00464	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _ustawienia$12[ebp]
  0046a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0046d	c7 84 05 28 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ustawienia$12[ebp+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00478	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _ustawienia$12[ebp]
  0047e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00481	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00484	89 84 0d 24 ff
	ff ff		 mov	 DWORD PTR _ustawienia$12[ebp+ecx-4], eax

; 1122 : 		}

  0048b	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp+4]
  00491	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00496	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp+8]
  0049c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  004a2	8d 4d 90	 lea	 ecx, DWORD PTR _ustawienia$12[ebp+104]
$LN155@SprawdŸ_u:
  004a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 940  : 	if (czas_przeskoku_kulki_wolny < czas_przeskoku_kulki_szybki) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  004ab	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?czas_przeskoku_kulki_wolny@@3FA ; czas_przeskoku_kulki_wolny
  004b1	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ?czas_przeskoku_kulki_szybki@@3FA ; czas_przeskoku_kulki_szybki
  004b8	7d 50		 jge	 SHORT $LN6@SprawdŸ_u

; 941  : 	{
; 942  : 		cout << "Wartoœæ wolnego czasu przeskoku kulki musi byæ ni¿sza ni¿ wartoœæ szybkiego czasu przeskoku kulki" << endl; //(Wartoœci tych zmiennych to czas opóŸnienia wiêc im jest wy¿szy tym d³u¿sza przerwa)

  004ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004c0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@
  004c5	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  004ca	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004cf	8b c8		 mov	 ecx, eax
  004d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 943  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  004d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004dd	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  004e2	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  004e7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004ec	8b c8		 mov	 ecx, eax
  004ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 944  : 		czas_przeskoku_kulki_szybki = 50; //Ustawienie wartoœci domyœlnej

  004f4	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  004f9	66 a3 00 00 00
	00		 mov	 WORD PTR ?czas_przeskoku_kulki_szybki@@3FA, ax ; czas_przeskoku_kulki_szybki

; 945  : 		czas_przeskoku_kulki_wolny = 75; //Ustawienie wartoœci domyœlnej

  004ff	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00504	66 a3 00 00 00
	00		 mov	 WORD PTR ?czas_przeskoku_kulki_wolny@@3FA, ax ; czas_przeskoku_kulki_wolny
$LN6@SprawdŸ_u:

; 946  : 	}
; 947  : 	if (iloœæ_minimalna_obrotów_ruletki < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0050a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA ; iloœæ_minimalna_obrotów_ruletki
  00510	be 02 00 00 00	 mov	 esi, 2
  00515	66 85 c0	 test	 ax, ax
  00518	79 42		 jns	 SHORT $LN7@SprawdŸ_u

; 948  : 	{
; 949  : 		cout << "Iloœæ minimalna obrotów ruletki nie mo¿e byæ mniejsza od 0" << endl;

  0051a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00520	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@
  00525	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0052a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0052f	8b c8		 mov	 ecx, eax
  00531	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 950  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  00537	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0053d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00542	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00547	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0054c	8b c8		 mov	 ecx, eax
  0054e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 951  : 		iloœæ_minimalna_obrotów_ruletki = 2; //Ustawienie wartoœci domyœlnej

  00554	8b c6		 mov	 eax, esi
  00556	66 a3 00 00 00
	00		 mov	 WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA, ax ; iloœæ_minimalna_obrotów_ruletki
$LN7@SprawdŸ_u:

; 952  : 	}
; 953  : 	if (iloœæ_max_dodatkowych_obrotów_ruletki < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0055c	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA ; iloœæ_max_dodatkowych_obrotów_ruletki
  00563	bf 03 00 00 00	 mov	 edi, 3
  00568	66 85 c9	 test	 cx, cx
  0056b	79 49		 jns	 SHORT $LN8@SprawdŸ_u

; 954  : 	{
; 955  : 		cout << "Iloœæ max obrotów ruletki nie mo¿e byæ mniejsza od 0" << endl;

  0056d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00573	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@
  00578	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0057d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00582	8b c8		 mov	 ecx, eax
  00584	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 956  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  0058a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00590	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00595	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0059a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0059f	8b c8		 mov	 ecx, eax
  005a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 957  : 		iloœæ_max_dodatkowych_obrotów_ruletki = 3; //Ustawienie wartoœci domyœlnej

  005a7	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA ; iloœæ_minimalna_obrotów_ruletki
  005ad	8b cf		 mov	 ecx, edi
  005af	66 89 0d 00 00
	00 00		 mov	 WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA, cx ; iloœæ_max_dodatkowych_obrotów_ruletki
$LN8@SprawdŸ_u:

; 958  : 	}
; 959  : 	if ((iloœæ_minimalna_obrotów_ruletki == 0) && (iloœæ_max_dodatkowych_obrotów_ruletki == 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  005b6	66 85 c0	 test	 ax, ax
  005b9	75 4d		 jne	 SHORT $LN9@SprawdŸ_u
  005bb	66 85 c9	 test	 cx, cx
  005be	75 48		 jne	 SHORT $LN9@SprawdŸ_u

; 960  : 	{
; 961  : 		cout << "Jedna z deklaracji w sprawie obrotów ruletki musi byæ wiêksza od zera" << endl;

  005c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005c6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@
  005cb	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  005d0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005d5	8b c8		 mov	 ecx, eax
  005d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 962  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  005dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005e3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  005e8	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  005ed	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005f2	8b c8		 mov	 ecx, eax
  005f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 963  : 		iloœæ_minimalna_obrotów_ruletki = 2; //Ustawienie wartoœci domyœlnej

  005fa	66 89 35 00 00
	00 00		 mov	 WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA, si ; iloœæ_minimalna_obrotów_ruletki

; 964  : 		iloœæ_max_dodatkowych_obrotów_ruletki = 3; //Ustawienie wartoœci domyœlnej

  00601	66 89 3d 00 00
	00 00		 mov	 WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA, di ; iloœæ_max_dodatkowych_obrotów_ruletki
$LN9@SprawdŸ_u:

; 965  : 	}
; 966  : 	if (((styl_liczenia_wygranej > 1) || (styl_liczenia_wygranej < 0))) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00608	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?styl_liczenia_wygranej@@3FA ; styl_liczenia_wygranej
  0060e	be 01 00 00 00	 mov	 esi, 1
  00613	66 3b c6	 cmp	 ax, si
  00616	7f 05		 jg	 SHORT $LN11@SprawdŸ_u
  00618	66 85 c0	 test	 ax, ax
  0061b	79 41		 jns	 SHORT $LN10@SprawdŸ_u
$LN11@SprawdŸ_u:

; 967  : 	{
; 968  : 		cout << "Styl liczeia wygranej przyjmuje wartoœci tylko 0 lub 1" << endl;

  0061d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00623	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@
  00628	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0062d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00632	8b c8		 mov	 ecx, eax
  00634	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 969  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  0063a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00640	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00645	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0064a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0064f	8b c8		 mov	 ecx, eax
  00651	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 970  : 		styl_liczenia_wygranej = 1; //Ustawienie wartoœci domyœlnej

  00657	66 89 35 00 00
	00 00		 mov	 WORD PTR ?styl_liczenia_wygranej@@3FA, si ; styl_liczenia_wygranej
$LN10@SprawdŸ_u:

; 971  : 	}
; 972  : 	if (czas_przerwy_dzwiêku < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0065e	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?czas_przerwy_dzwiêku@@3FA, 0 ; czas_przerwy_dzwiêku
  00666	7d 45		 jge	 SHORT $LN12@SprawdŸ_u

; 973  : 	{
; 974  : 		cout << "Czas przerwy dŸwiêku nie mo¿e byæ mniejszy od zera" << endl;

  00668	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0066e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@
  00673	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00678	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0067d	8b c8		 mov	 ecx, eax
  0067f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 975  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  00685	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0068b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00690	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00695	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0069a	8b c8		 mov	 ecx, eax
  0069c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 976  : 		czas_przerwy_dzwiêku = 500; //Ustawienie wartoœci domyœlnej

  006a2	b8 f4 01 00 00	 mov	 eax, 500		; 000001f4H
  006a7	66 a3 00 00 00
	00		 mov	 WORD PTR ?czas_przerwy_dzwiêku@@3FA, ax ; czas_przerwy_dzwiêku
$LN12@SprawdŸ_u:

; 977  : 	}
; 978  : 	if (kwota_pocz¹tkowa < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  006ad	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?kwota_pocz¹tkowa@@3HA, 0 ; kwota_pocz¹tkowa
  006b4	7d 44		 jge	 SHORT $LN13@SprawdŸ_u

; 979  : 	{
; 980  : 		cout << "Kwota pocz¹tkowa nie mo¿e byæ mniejsza od zera" << endl;

  006b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006bc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@
  006c1	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  006c6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  006cb	8b c8		 mov	 ecx, eax
  006cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 981  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  006d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006d9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  006de	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  006e3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  006e8	8b c8		 mov	 ecx, eax
  006ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 982  : 		kwota_pocz¹tkowa = 1000; //Ustawienie wartoœci domyœlnej

  006f0	c7 05 00 00 00
	00 e8 03 00 00	 mov	 DWORD PTR ?kwota_pocz¹tkowa@@3HA, 1000 ; kwota_pocz¹tkowa, 000003e8H
$LN13@SprawdŸ_u:

; 983  : 	}
; 984  : 	if ((stan_dŸwiêków > 1) || (stan_dŸwiêków < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  006fa	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?stan_dŸwiêków@@3FA ; stan_dŸwiêków
  00700	66 83 f8 01	 cmp	 ax, 1
  00704	7f 05		 jg	 SHORT $LN15@SprawdŸ_u
  00706	66 85 c0	 test	 ax, ax
  00709	79 41		 jns	 SHORT $LN14@SprawdŸ_u
$LN15@SprawdŸ_u:

; 985  : 	{
; 986  : 		cout << "Stan dŸwiêków przyjmuje wartoœci tylko 0 lub 1" << endl;

  0070b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00711	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@
  00716	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0071b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00720	8b c8		 mov	 ecx, eax
  00722	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 987  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  00728	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0072e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00733	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00738	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0073d	8b c8		 mov	 ecx, eax
  0073f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 988  : 		stan_dŸwiêków = 1; //Ustawienie wartoœci domyœlnej

  00745	66 89 35 00 00
	00 00		 mov	 WORD PTR ?stan_dŸwiêków@@3FA, si ; stan_dŸwiêków
$LN14@SprawdŸ_u:

; 989  : 	}
; 990  : 	if ((czy_kontynuowaæ_grê > 1) || (czy_kontynuowaæ_grê < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0074c	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?czy_kontynuowaæ_grê@@3FA ; czy_kontynuowaæ_grê
  00752	66 83 f8 01	 cmp	 ax, 1
  00756	7f 05		 jg	 SHORT $LN17@SprawdŸ_u
  00758	66 85 c0	 test	 ax, ax
  0075b	79 41		 jns	 SHORT $LN16@SprawdŸ_u
$LN17@SprawdŸ_u:

; 991  : 	{
; 992  : 		cout << "Opcja kontynuowania gry przyjmuje wartoœci tylko 0 lub 1" << endl;

  0075d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00763	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@
  00768	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0076d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00772	8b c8		 mov	 ecx, eax
  00774	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 993  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  0077a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00780	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00785	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0078a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0078f	8b c8		 mov	 ecx, eax
  00791	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 994  : 		czy_kontynuowaæ_grê = 1; //Ustawienie wartoœci domyœlnej

  00797	66 89 35 00 00
	00 00		 mov	 WORD PTR ?czy_kontynuowaæ_grê@@3FA, si ; czy_kontynuowaæ_grê
$LN16@SprawdŸ_u:

; 995  : 	}
; 996  : 	if ((g³os_odczytu_numeru > 10) || (g³os_odczytu_numeru < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0079e	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?g³os_odczytu_numeru@@3FA ; g³os_odczytu_numeru
  007a4	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  007a8	7f 05		 jg	 SHORT $LN19@SprawdŸ_u
  007aa	66 85 c0	 test	 ax, ax
  007ad	79 41		 jns	 SHORT $LN18@SprawdŸ_u
$LN19@SprawdŸ_u:

; 997  : 	{
; 998  : 		cout << "Opcja g³os odczytu numeru przyjmuje wartoœci w przedziale [0;10]" << endl;

  007af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007b5	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@
  007ba	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  007bf	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  007c4	8b c8		 mov	 ecx, eax
  007c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 999  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  007cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007d2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  007d7	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  007dc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  007e1	8b c8		 mov	 ecx, eax
  007e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1000 : 		g³os_odczytu_numeru = 1; //Ustawienie wartoœci domyœlnej

  007e9	66 89 35 00 00
	00 00		 mov	 WORD PTR ?g³os_odczytu_numeru@@3FA, si ; g³os_odczytu_numeru
$LN18@SprawdŸ_u:

; 1001 : 	}
; 1002 : 	if ((g³os_szybkoœæ_odczytu_numeru > 5) || (g³os_szybkoœæ_odczytu_numeru < 1)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  007f0	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA ; g³os_szybkoœæ_odczytu_numeru
  007f6	66 83 f8 05	 cmp	 ax, 5
  007fa	7f 06		 jg	 SHORT $LN21@SprawdŸ_u
  007fc	66 83 f8 01	 cmp	 ax, 1
  00800	7d 45		 jge	 SHORT $LN20@SprawdŸ_u
$LN21@SprawdŸ_u:

; 1003 : 	{
; 1004 : 		cout << "Opcja szybkoœæ g³osu odczytu przyjmuje wartoœci w przedziale [1;5]" << endl;

  00802	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00808	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@
  0080d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00812	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00817	8b c8		 mov	 ecx, eax
  00819	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1005 : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  0081f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00825	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0082a	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0082f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00834	8b c8		 mov	 ecx, eax
  00836	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1006 : 		g³os_szybkoœæ_odczytu_numeru = 4; //Ustawienie wartoœci domyœlnej

  0083c	b8 04 00 00 00	 mov	 eax, 4
  00841	66 a3 00 00 00
	00		 mov	 WORD PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA, ax ; g³os_szybkoœæ_odczytu_numeru
$LN20@SprawdŸ_u:

; 1007 : 	}
; 1008 : 	if ((efekty_dŸwiêkowe > 1) || (efekty_dŸwiêkowe < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00847	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?efekty_dŸwiêkowe@@3FA ; efekty_dŸwiêkowe
  0084d	66 83 f8 01	 cmp	 ax, 1
  00851	7f 11		 jg	 SHORT $LN23@SprawdŸ_u
  00853	66 85 c0	 test	 ax, ax
  00856	78 0c		 js	 SHORT $LN23@SprawdŸ_u

; 1013 : 	}
; 1014 : 	if (efekty_dŸwiêkowe == 1 && stan_dŸwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00858	66 83 f8 01	 cmp	 ax, 1
  0085c	0f 85 8e 00 00
	00		 jne	 $LN24@SprawdŸ_u
  00862	eb 41		 jmp	 SHORT $LN152@SprawdŸ_u
$LN23@SprawdŸ_u:

; 1009 : 	{
; 1010 : 		cout << "Opcja efekty dŸwiêkowe przyjmuje wartoœci 0 lub 1" << endl;

  00864	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0086a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@
  0086f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00874	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00879	8b c8		 mov	 ecx, eax
  0087b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1011 : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  00881	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00887	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0088c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00891	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00896	8b c8		 mov	 ecx, eax
  00898	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1012 : 		efekty_dŸwiêkowe = 1; //Ustawienie wartoœci domyœlnej

  0089e	66 89 35 00 00
	00 00		 mov	 WORD PTR ?efekty_dŸwiêkowe@@3FA, si ; efekty_dŸwiêkowe
$LN152@SprawdŸ_u:

; 1013 : 	}
; 1014 : 	if (efekty_dŸwiêkowe == 1 && stan_dŸwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  008a5	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?stan_dŸwiêków@@3FA, 0 ; stan_dŸwiêków
  008ad	75 41		 jne	 SHORT $LN24@SprawdŸ_u

; 1015 : 	{
; 1016 : 		cout << "Nie mo¿esz mieæ wy³¹czonych dŸwiêków i w³¹czonych efektów dŸwiêkowych" << endl;

  008af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008b5	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
  008ba	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  008bf	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  008c4	8b c8		 mov	 ecx, eax
  008c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1017 : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  008cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008d2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  008d7	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  008dc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  008e1	8b c8		 mov	 ecx, eax
  008e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1018 : 		stan_dŸwiêków = 1; //Ustawienie wartoœci domyœlnej

  008e9	66 89 35 00 00
	00 00		 mov	 WORD PTR ?stan_dŸwiêków@@3FA, si ; stan_dŸwiêków
$LN24@SprawdŸ_u:

; 1019 : 	}
; 1020 : 	if (g³os_odczytu_numeru > 0 && stan_dŸwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  008f0	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?g³os_odczytu_numeru@@3FA, 0 ; g³os_odczytu_numeru
  008f8	7e 4b		 jle	 SHORT $LN25@SprawdŸ_u
  008fa	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?stan_dŸwiêków@@3FA, 0 ; stan_dŸwiêków
  00902	75 41		 jne	 SHORT $LN25@SprawdŸ_u

; 1021 : 	{
; 1022 : 		cout << "Nie mo¿esz mieæ wy³¹czonych dŸwiêków i w³¹czon¹ mowê" << endl;

  00904	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0090a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
  0090f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00914	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00919	8b c8		 mov	 ecx, eax
  0091b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1023 : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  00921	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00927	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0092c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00931	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00936	8b c8		 mov	 ecx, eax
  00938	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1024 : 		stan_dŸwiêków = 1; //Ustawienie wartoœci domyœlnej

  0093e	66 89 35 00 00
	00 00		 mov	 WORD PTR ?stan_dŸwiêków@@3FA, si ; stan_dŸwiêków
$LN25@SprawdŸ_u:

; 1025 : 	}
; 1026 : }

  00945	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00948	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0094f	59		 pop	 ecx
  00950	5f		 pop	 edi
  00951	5e		 pop	 esi
  00952	5b		 pop	 ebx
  00953	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00956	33 cd		 xor	 ecx, ebp
  00958	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0095d	8b e5		 mov	 esp, ebp
  0095f	5d		 pop	 ebp
  00960	c3		 ret	 0
$LN154@SprawdŸ_u:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$4:
  00000	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00006	83 e0 01	 and	 eax, 1
  00009	0f 84 13 00 00
	00		 je	 $LN37@SprawdŸ_u
  0000f	83 a5 6c fe ff
	ff fe		 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00016	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp+112]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN37@SprawdŸ_u:
  00022	c3		 ret	 0
__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$5:
  00023	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp+24]
  00029	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$7:
  0002f	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00035	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$0:
  0003b	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$11[ebp]
  00041	e9 00 00 00 00	 jmp	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$1:
  00046	8d 4d d8	 lea	 ecx, DWORD PTR _buf$13[ebp]
  00049	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SprawdŸ_ustawienia@@YAXXZ$2:
  0004e	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$12[ebp]
  00054	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__ehhandler$?SprawdŸ_ustawienia@@YAXXZ:
  00059	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00060	8b 8a 64 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-412]
  00066	33 c8		 xor	 ecx, eax
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00070	33 c8		 xor	 ecx, eax
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SprawdŸ_ustawienia@@YAXXZ
  0007c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SprawdŸ_ustawienia@@YAXXZ ENDP				; SprawdŸ_ustawienia
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 905  : 		{	// destroy the object

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8d 71 70	 lea	 esi, DWORD PTR [ecx+112]

; 906  : 		}

  00006	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 90 00
	00 00 00	 mov	 DWORD PTR [eax+esi-112], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 90	 mov	 eax, DWORD PTR [esi-112]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 90	 lea	 eax, DWORD PTR [edx-112]
  0001d	89 44 32 8c	 mov	 DWORD PTR [edx+esi-116], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0002f	8b ce		 mov	 ecx, esi
  00031	5e		 pop	 esi
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	68 b8 00 00 00	 push	 184			; 000000b8H
  00005	6a 00		 push	 0
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memset
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00010	c2 04 00	 ret	 4
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Og³oœ_wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 24
_kwota_zak³adu$1$ = -12					; size = 4
_wygrana$1$ = -8					; size = 4
_iloœæ_pieniêdzy$ = 8					; size = 4
_log_ogólny$ = 12					; size = 4
_log$ = 16						; size = 4
?Og³oœ_wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z PROC ; Og³oœ_wynik, COMDAT
; _wygrana$ = ecx
; _kwota_zak³adu$ = edx

; 1029 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx
  00007	8b c2		 mov	 eax, edx
  00009	89 4d f8	 mov	 DWORD PTR _wygrana$1$[ebp], ecx
  0000c	56		 push	 esi

; 1030 : 	if (wygrana >= kwota_zak³adu) //Je¿eli wygrana jest wiêksza lub równa kwocie zak³adu to znaczy, ¿e siê wygra³o zak³ad

  0000d	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000f	57		 push	 edi
  00010	8b 38		 mov	 edi, DWORD PTR [eax]
  00012	89 45 f4	 mov	 DWORD PTR _kwota_zak³adu$1$[ebp], eax
  00015	3b f7		 cmp	 esi, edi
  00017	0f 8c 7a 01 00
	00		 jl	 $LN2@Og?

; 1031 : 	{
; 1032 : 		iloœæ_pieniêdzy += wygrana; //Dopisanie do salda kwoty wygranej z zak³adu

  0001d	8b 5d 08	 mov	 ebx, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  00020	01 33		 add	 DWORD PTR [ebx], esi

; 1033 : 		if (styl_liczenia_wygranej) iloœæ_pieniêdzy += kwota_zak³adu; //Dopisanie do salda kwoty zak³adu

  00022	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?styl_liczenia_wygranej@@3FA, 0 ; styl_liczenia_wygranej
  0002a	74 04		 je	 SHORT $LN4@Og?
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	01 03		 add	 DWORD PTR [ebx], eax
$LN4@Og?:

; 1034 : 		log << " Wygrywasz " << wygrana << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie wygranej zak³adu

  00030	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  00033	33 d2		 xor	 edx, edx
  00035	ff 31		 push	 DWORD PTR [ecx]
  00037	85 c0		 test	 eax, eax
  00039	51		 push	 ecx
  0003a	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0003d	8b f7		 mov	 esi, edi
  0003f	0f 44 f2	 cmove	 esi, edx
  00042	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
  00047	8b ce		 mov	 ecx, esi
  00049	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0004e	83 c4 04	 add	 esp, 4
  00051	8b c8		 mov	 ecx, eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00059	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0005e	8b c8		 mov	 ecx, eax
  00060	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1035 : 		log << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  00065	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0006a	51		 push	 ecx
  0006b	ff 33		 push	 DWORD PTR [ebx]
  0006d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00072	51		 push	 ecx
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0007a	83 c4 04	 add	 esp, 4
  0007d	8b c8		 mov	 ecx, eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00085	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0008a	8b c8		 mov	 ecx, eax
  0008c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00091	83 c4 04	 add	 esp, 4
  00094	8b c8		 mov	 ecx, eax
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1036 : 		log_ogólny << " Wygrywasz " << wygrana << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie wygranej zak³adu

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _wygrana$1$[ebp]
  0009f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
  000a4	8b 75 0c	 mov	 esi, DWORD PTR _log_ogólny$[ebp]
  000a7	ff 30		 push	 DWORD PTR [eax]
  000a9	51		 push	 ecx
  000aa	8b ce		 mov	 ecx, esi
  000ac	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000b1	83 c4 04	 add	 esp, 4
  000b4	8b c8		 mov	 ecx, eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000bc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000c1	8b c8		 mov	 ecx, eax
  000c3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1037 : 		log_ogólny << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  000c8	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000cd	51		 push	 ecx
  000ce	ff 33		 push	 DWORD PTR [ebx]
  000d0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  000d5	51		 push	 ecx
  000d6	8b ce		 mov	 ecx, esi
  000d8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000dd	83 c4 04	 add	 esp, 4
  000e0	8b c8		 mov	 ecx, eax
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000e8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000ed	8b c8		 mov	 ecx, eax
  000ef	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000f4	83 c4 04	 add	 esp, 4
  000f7	8b c8		 mov	 ecx, eax
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1038 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  000ff	8b cf		 mov	 ecx, edi
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1039 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00107	8b ce		 mov	 ecx, esi
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1040 : 		if (stan_dŸwiêków)

  0010f	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?stan_dŸwiêków@@3FA, 0 ; stan_dŸwiêków
  00117	0f 84 9f 02 00
	00		 je	 $LN12@Og?

; 1041 : 		{
; 1042 : 			if (EfektyKompletne) //Je¿eli s¹ wszystkie pliki efektów dŸwiêkowych to

  0011d	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  00124	74 32		 je	 SHORT $LN6@Og?

; 1044 : 				PlaySound((G³os + "win.wav").c_str(), nullptr, SND_SYNC); //Odtworzenie efektu wygrania zak³adu

  00126	68 00 00 00 00	 push	 OFFSET ??_C@_07KIPBKJCE@win?4wav?$AA@
  0012b	8d 4d dc	 lea	 ecx, DWORD PTR $T1[ebp]
  0012e	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00133	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00136	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0013a	72 02		 jb	 SHORT $LN37@Og?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0013c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN37@Og?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1044 : 				PlaySound((G³os + "win.wav").c_str(), nullptr, SND_SYNC); //Odtworzenie efektu wygrania zak³adu

  0013e	6a 00		 push	 0
  00140	6a 00		 push	 0
  00142	50		 push	 eax
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PlaySoundA@12
  00149	8d 4d dc	 lea	 ecx, DWORD PTR $T1[ebp]
  0014c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1081 : 	}
; 1082 : }

  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	5b		 pop	 ebx
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
$LN6@Og?:

; 1045 : 			}
; 1046 : 			else
; 1047 : 			{
; 1048 : 				cout << "\a"; //Wywo³anie pikniêcia w g³oœniku

  00158	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0015e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01PBGHHLMH@?$AH?$AA@
  00163	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1049 : 				Sleep(czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  00168	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?czas_przerwy_dzwiêku@@3FA ; czas_przerwy_dzwiêku
  0016f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__Sleep@4
  00175	50		 push	 eax
  00176	ff d6		 call	 esi

; 1050 : 				cout << "\a"; //Wywo³anie pikniêcia w g³oœniku

  00178	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0017e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01PBGHHLMH@?$AH?$AA@
  00183	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1051 : 				Sleep(czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  00188	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?czas_przerwy_dzwiêku@@3FA ; czas_przerwy_dzwiêku
  0018f	50		 push	 eax
  00190	ff d6		 call	 esi

; 1052 : 				cout << "\a"; //Wywo³anie pikniêcia w g³oœniku
; 1053 : 			}
; 1054 : 		}
; 1055 : 	}

  00192	e9 15 02 00 00	 jmp	 $LN43@Og?
$LN2@Og?:

; 1056 : 	else if (wygrana == (kwota_zak³adu / 2)) //Je¿eli wygrana jest równa po³owie kwocie zak³adu to znaczy, ¿e dostaje siê zwrot po³owy kwoty zak³adu

  00197	8b c7		 mov	 eax, edi
  00199	99		 cdq
  0019a	2b c2		 sub	 eax, edx
  0019c	d1 f8		 sar	 eax, 1
  0019e	3b f0		 cmp	 esi, eax
  001a0	0f 85 14 01 00
	00		 jne	 $LN8@Og?

; 1057 : 	{
; 1058 : 		iloœæ_pieniêdzy += wygrana; //Dopisanie do salda kwoty zwrotu z zak³adu
; 1059 : 		log << " Dostajesz polowe zak³adu " << wygrana << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie zwrotu zak³adu

  001a6	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  001a9	33 d2		 xor	 edx, edx
  001ab	8b 7d 08	 mov	 edi, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  001ae	8d 58 10	 lea	 ebx, DWORD PTR [eax+16]
  001b1	01 37		 add	 DWORD PTR [edi], esi
  001b3	85 c0		 test	 eax, eax
  001b5	ff 31		 push	 DWORD PTR [ecx]
  001b7	8b f3		 mov	 esi, ebx
  001b9	0f 44 f2	 cmove	 esi, edx
  001bc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
  001c1	51		 push	 ecx
  001c2	8b ce		 mov	 ecx, esi
  001c4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001c9	83 c4 04	 add	 esp, 4
  001cc	8b c8		 mov	 ecx, eax
  001ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  001d4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  001d9	8b c8		 mov	 ecx, eax
  001db	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1060 : 		log << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  001e0	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001e5	51		 push	 ecx
  001e6	ff 37		 push	 DWORD PTR [edi]
  001e8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  001ed	51		 push	 ecx
  001ee	8b ce		 mov	 ecx, esi
  001f0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001f5	83 c4 04	 add	 esp, 4
  001f8	8b c8		 mov	 ecx, eax
  001fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00200	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00205	8b c8		 mov	 ecx, eax
  00207	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0020c	83 c4 04	 add	 esp, 4
  0020f	8b c8		 mov	 ecx, eax
  00211	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1061 : 		log_ogólny << " Dostajesz polowe zak³adu " << wygrana << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie zwrotu zak³adu

  00217	8b 45 f8	 mov	 eax, DWORD PTR _wygrana$1$[ebp]
  0021a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
  0021f	8b 75 0c	 mov	 esi, DWORD PTR _log_ogólny$[ebp]
  00222	ff 30		 push	 DWORD PTR [eax]
  00224	51		 push	 ecx
  00225	8b ce		 mov	 ecx, esi
  00227	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0022c	83 c4 04	 add	 esp, 4
  0022f	8b c8		 mov	 ecx, eax
  00231	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00237	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0023c	8b c8		 mov	 ecx, eax
  0023e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1062 : 		log_ogólny << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  00243	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00248	51		 push	 ecx
  00249	ff 37		 push	 DWORD PTR [edi]
  0024b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00250	51		 push	 ecx
  00251	8b ce		 mov	 ecx, esi
  00253	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00258	83 c4 04	 add	 esp, 4
  0025b	8b c8		 mov	 ecx, eax
  0025d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00263	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00268	8b c8		 mov	 ecx, eax
  0026a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0026f	83 c4 04	 add	 esp, 4
  00272	8b c8		 mov	 ecx, eax
  00274	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1063 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0027a	8b cb		 mov	 ecx, ebx
  0027c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1064 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00282	8b ce		 mov	 ecx, esi
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1065 : 		if (!EfektyKompletne) //Je¿eli nie ma wszystkich plików efektów dŸwiêkowych to

  0028a	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  00291	0f 85 25 01 00
	00		 jne	 $LN12@Og?

; 1066 : 		{
; 1067 : 			cout << "\a"; //Wywo³anie pikniêcia w g³oœniku

  00297	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0029d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01PBGHHLMH@?$AH?$AA@
  002a2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1068 : 			Sleep(czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  002a7	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?czas_przerwy_dzwiêku@@3FA ; czas_przerwy_dzwiêku
  002ae	50		 push	 eax
  002af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 1069 : 			cout << "\a"; //Wywo³anie pikniêcia w g³oœniku
; 1070 : 		}
; 1071 : 	}

  002b5	e9 f2 00 00 00	 jmp	 $LN43@Og?
$LN8@Og?:

; 1072 : 	else if (wygrana == 0) //Je¿eli wygrana jest równa 0 to znaczy, ¿e siê zak³ad przegra³o

  002ba	85 f6		 test	 esi, esi
  002bc	0f 85 fa 00 00
	00		 jne	 $LN12@Og?

; 1073 : 	{
; 1074 : 		log << " Przegrales " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o przegranej kwocie

  002c2	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  002c5	33 c9		 xor	 ecx, ecx
  002c7	85 c0		 test	 eax, eax
  002c9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
  002ce	57		 push	 edi
  002cf	51		 push	 ecx
  002d0	8d 58 10	 lea	 ebx, DWORD PTR [eax+16]
  002d3	8b f3		 mov	 esi, ebx
  002d5	0f 44 f1	 cmove	 esi, ecx
  002d8	8b ce		 mov	 ecx, esi
  002da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002df	83 c4 04	 add	 esp, 4
  002e2	8b c8		 mov	 ecx, eax
  002e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  002ea	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  002ef	8b c8		 mov	 ecx, eax
  002f1	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1075 : 		log << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  002f6	8b 7d 08	 mov	 edi, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  002f9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  002fe	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00303	51		 push	 ecx
  00304	ff 37		 push	 DWORD PTR [edi]
  00306	51		 push	 ecx
  00307	8b ce		 mov	 ecx, esi
  00309	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0030e	83 c4 04	 add	 esp, 4
  00311	8b c8		 mov	 ecx, eax
  00313	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00319	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0031e	8b c8		 mov	 ecx, eax
  00320	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00325	83 c4 04	 add	 esp, 4
  00328	8b c8		 mov	 ecx, eax
  0032a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1076 : 		log_ogólny << " Przegrales " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o przegranej kwocie

  00330	8b 45 f4	 mov	 eax, DWORD PTR _kwota_zak³adu$1$[ebp]
  00333	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
  00338	8b 75 0c	 mov	 esi, DWORD PTR _log_ogólny$[ebp]
  0033b	ff 30		 push	 DWORD PTR [eax]
  0033d	51		 push	 ecx
  0033e	8b ce		 mov	 ecx, esi
  00340	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00345	83 c4 04	 add	 esp, 4
  00348	8b c8		 mov	 ecx, eax
  0034a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00350	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00355	8b c8		 mov	 ecx, eax
  00357	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1077 : 		log_ogólny << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  0035c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00361	51		 push	 ecx
  00362	ff 37		 push	 DWORD PTR [edi]
  00364	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00369	51		 push	 ecx
  0036a	8b ce		 mov	 ecx, esi
  0036c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00371	83 c4 04	 add	 esp, 4
  00374	8b c8		 mov	 ecx, eax
  00376	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0037c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00381	8b c8		 mov	 ecx, eax
  00383	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00388	83 c4 04	 add	 esp, 4
  0038b	8b c8		 mov	 ecx, eax
  0038d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1078 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  00393	8b cb		 mov	 ecx, ebx
  00395	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1079 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  0039b	8b ce		 mov	 ecx, esi
  0039d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1080 : 		if (!EfektyKompletne) cout << "\a";  //Je¿eli nie ma wszystkich plików efektów dŸwiêkowych to wywo³anie pikniêcia w g³oœniku

  003a3	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  003aa	75 10		 jne	 SHORT $LN12@Og?
$LN43@Og?:
  003ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  003b2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01PBGHHLMH@?$AH?$AA@
  003b7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
$LN12@Og?:

; 1081 : 	}
; 1082 : }

  003bc	5f		 pop	 edi
  003bd	5e		 pop	 esi
  003be	5b		 pop	 ebx
  003bf	8b e5		 mov	 esp, ebp
  003c1	5d		 pop	 ebp
  003c2	c3		 ret	 0
?Og³oœ_wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ENDP ; Og³oœ_wynik
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Koniec_gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z
_TEXT	SEGMENT
_iloœæ_pieniêdzy$ = 8					; size = 4
?Koniec_gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z PROC ; Koniec_gry, COMDAT
; _log_ogólny$ = ecx
; _log$ = edx

; 1085 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx

; 1086 : 	cout << endl << "Koñczysz grê z wynikiem " << iloœæ_pieniêdzy << "$" << endl; //Poinformowanie u¿ytkownika o saldzie konta

  00007	8b 45 08	 mov	 eax, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00012	51		 push	 ecx
  00013	ff 30		 push	 DWORD PTR [eax]
  00015	8b f9		 mov	 edi, ecx
  00017	8b da		 mov	 ebx, edx
  00019	51		 push	 ecx
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00020	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0002b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00037	83 c4 04	 add	 esp, 4
  0003a	8b c8		 mov	 ecx, eax
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00042	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00047	8b c8		 mov	 ecx, eax
  00049	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0004e	83 c4 04	 add	 esp, 4
  00051	8b c8		 mov	 ecx, eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1087 : 	log << endl << "Koñczysz grê z wynikiem " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  00059	8b 45 08	 mov	 eax, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  0005c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00061	51		 push	 ecx
  00062	ff 30		 push	 DWORD PTR [eax]
  00064	51		 push	 ecx
  00065	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0006a	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00073	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  00078	8b c8		 mov	 ecx, eax
  0007a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0007f	83 c4 04	 add	 esp, 4
  00082	8b c8		 mov	 ecx, eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0008a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0008f	8b c8		 mov	 ecx, eax
  00091	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00096	83 c4 04	 add	 esp, 4
  00099	8b c8		 mov	 ecx, eax
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1088 : 	log_ogólny << "Koñczysz grê z wynikiem " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  000a1	8b 45 08	 mov	 eax, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  000a4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  000a9	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000ae	51		 push	 ecx
  000af	ff 30		 push	 DWORD PTR [eax]
  000b1	51		 push	 ecx
  000b2	8b cf		 mov	 ecx, edi
  000b4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000b9	83 c4 04	 add	 esp, 4
  000bc	8b c8		 mov	 ecx, eax
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000c4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000c9	8b c8		 mov	 ecx, eax
  000cb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000d0	83 c4 04	 add	 esp, 4
  000d3	8b c8		 mov	 ecx, eax
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1089 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  000db	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1090 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000e4	8b cf		 mov	 ecx, edi
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1091 : 	log.close(); //Zamkniêcie pliku log aktualny

  000ec	8b cb		 mov	 ecx, ebx
  000ee	e8 00 00 00 00	 call	 ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::close

; 1092 : 	remove("log_aktualny.txt"); //Usuniêcie pliku log aktualny poniewa¿ skoñczy³o siê grê

  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__remove

; 1093 : 
; 1094 : 	if (stan_dŸwiêków == 1) //Je¿eli stan_dŸwiêków == 1

  000fe	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__PlaySoundA@12
  00104	83 c4 04	 add	 esp, 4
  00107	66 83 3d 00 00
	00 00 01	 cmp	 WORD PTR ?stan_dŸwiêków@@3FA, 1 ; stan_dŸwiêków

; 1095 : 		if (iloœæ_pieniêdzy == 0) //Je¿eli bud¿et jest równy 0 to

  0010f	8b 75 08	 mov	 esi, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  00112	75 4e		 jne	 SHORT $LN3@Koniec_gry
  00114	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00117	75 49		 jne	 SHORT $LN3@Koniec_gry

; 1096 : 			if (EfektyKompletne) PlaySound("Efekty_dŸwiêkowe/bankrut.wav", nullptr, SND_SYNC); //Je¿eli pliki efektów s¹ dostêpne, odtworzenie efektu bankruta

  00119	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  00120	74 0d		 je	 SHORT $LN7@Koniec_gry
  00122	6a 00		 push	 0
  00124	6a 00		 push	 0
  00126	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  0012b	ff d3		 call	 ebx

; 1097 : 			else //W przeciwym wypadku

  0012d	eb 33		 jmp	 SHORT $LN3@Koniec_gry
$LN7@Koniec_gry:

; 1098 : 				for (unsigned short i = 0; i < 5; ++i) //Rozpoczêcie pêtli która wykona 5 obrotów

  0012f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Sleep@4
  00135	be 05 00 00 00	 mov	 esi, 5
  0013a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Koniec_gry:

; 1099 : 				{
; 1100 : 					cout << "\a"; //Wywo³anie pikniêcia w g³oœniku

  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00146	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01PBGHHLMH@?$AH?$AA@
  0014b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1101 : 					Sleep(czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem //Przerwa przed kolejnym pikniêciem

  00150	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?czas_przerwy_dzwiêku@@3FA ; czas_przerwy_dzwiêku
  00157	50		 push	 eax
  00158	ff d7		 call	 edi
  0015a	83 ee 01	 sub	 esi, 1
  0015d	75 e1		 jne	 SHORT $LL4@Koniec_gry

; 1093 : 
; 1094 : 	if (stan_dŸwiêków == 1) //Je¿eli stan_dŸwiêków == 1

  0015f	8b 75 08	 mov	 esi, DWORD PTR _iloœæ_pieniêdzy$[ebp]
$LN3@Koniec_gry:

; 1102 : 				}
; 1103 : 
; 1104 : 	if (iloœæ_pieniêdzy > kwota_pocz¹tkowa && iloœæ_pieniêdzy < kwota_pocz¹tkowa * 2) //Sprawdzenie czy zwiêkszy³o siê bud¿et

  00162	8b 16		 mov	 edx, DWORD PTR [esi]
  00164	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?kwota_pocz¹tkowa@@3HA ; kwota_pocz¹tkowa
  0016a	3b d6		 cmp	 edx, esi
  0016c	7e 49		 jle	 SHORT $LN9@Koniec_gry
  0016e	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  00171	3b d0		 cmp	 edx, eax
  00173	7d 42		 jge	 SHORT $LN9@Koniec_gry

; 1105 : 	{
; 1106 : 		cout << "Gratuluje zwiêkszy³eœ swój zasób finansowy" << endl; //Wyœwietlenie gratulacji z powodu zwiêkszenia bud¿etu

  00175	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0017a	51		 push	 ecx
  0017b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00181	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@
  00186	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0018b	83 c4 04	 add	 esp, 4
  0018e	8b c8		 mov	 ecx, eax
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1107 : 		if (EfektyKompletne) //Je¿eli pliki efektów s¹ dostêpne

  00196	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  0019d	74 72		 je	 SHORT $LN15@Koniec_gry

; 1108 : 			if (rand() % 1) PlaySound("Efekty_dŸwiêkowe/wygrana1.wav", nullptr, SND_SYNC); //Wylosowanie numeru otworzonego efektu, odtworzenie je¿eli wylosowano efekt 0

  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand

; 1109 : 			else PlaySound("Efekty_dŸwiêkowe/wygrana2.wav", nullptr, SND_SYNC); //Odtworzenie je¿eli wylosowano efekt 1

  001a5	6a 00		 push	 0
  001a7	6a 00		 push	 0
  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@

; 1114 : 		if (EfektyKompletne) PlaySound("Efekty_dŸwiêkowe/zwielokrotnenie.wav", nullptr, SND_SYNC); //Odtworzenie efektu dŸwiêkowego wzamian za zwielokrotnienie bud¿etu, je¿eli pliki efektów s¹ dostêpne

  001ae	ff d3		 call	 ebx

; 1115 : 	}
; 1116 : }

  001b0	5f		 pop	 edi
  001b1	5e		 pop	 esi
  001b2	5b		 pop	 ebx
  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	c3		 ret	 0
$LN9@Koniec_gry:

; 1110 : 	}
; 1111 : 	else if (iloœæ_pieniêdzy >= kwota_pocz¹tkowa * 2) //Sprawdzenie czy zwielokrotniono przynajmniej 2 razy bud¿et

  001b7	8d 0c 36	 lea	 ecx, DWORD PTR [esi+esi]
  001ba	3b d1		 cmp	 edx, ecx
  001bc	7c 53		 jl	 SHORT $LN15@Koniec_gry

; 1112 : 	{
; 1113 : 		cout << "Gratuluje zwiêkszy³eœ " << iloœæ_pieniêdzy / kwota_pocz¹tkowa << " krotnie swój zasób finansowy" << endl; //Wyœwietlenie gratulacji z powodu zwielokrotnienia przynajmniej 2 razy bud¿etu

  001be	8b c2		 mov	 eax, edx
  001c0	99		 cdq
  001c1	f7 fe		 idiv	 esi
  001c3	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001c8	51		 push	 ecx
  001c9	50		 push	 eax
  001ca	51		 push	 ecx
  001cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001d1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@
  001d6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001db	83 c4 04	 add	 esp, 4
  001de	8b c8		 mov	 ecx, eax
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  001e6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@
  001eb	8b c8		 mov	 ecx, eax
  001ed	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001f2	83 c4 04	 add	 esp, 4
  001f5	8b c8		 mov	 ecx, eax
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1114 : 		if (EfektyKompletne) PlaySound("Efekty_dŸwiêkowe/zwielokrotnenie.wav", nullptr, SND_SYNC); //Odtworzenie efektu dŸwiêkowego wzamian za zwielokrotnienie bud¿etu, je¿eli pliki efektów s¹ dostêpne

  001fd	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  00204	74 0b		 je	 SHORT $LN15@Koniec_gry
  00206	6a 00		 push	 0
  00208	6a 00		 push	 0
  0020a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  0020f	ff d3		 call	 ebx
$LN15@Koniec_gry:

; 1115 : 	}
; 1116 : }

  00211	5f		 pop	 edi
  00212	5e		 pop	 esi
  00213	5b		 pop	 ebx
  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	c3		 ret	 0
?Koniec_gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z ENDP ; Koniec_gry
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Pêtla_g³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
_kwota_zak³adu$1$ = -32					; size = 4
_wygrana$1$ = -28					; size = 4
$T1 = -24						; size = 24
_iloœæ_pieniêdzy$ = 8					; size = 4
_log_ogólny$ = 12					; size = 4
_log$ = 16						; size = 4
_co_kontynuowaæ$ = 20					; size = 4
_typ_zak³adu$ = 24					; size = 4
_wylosowana_liczba$ = 28				; size = 4
?Pêtla_g³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; Pêtla_g³ówna, COMDAT
; _wygrana$ = ecx
; _kwota_zak³adu$ = edx

; 1119 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 24	 sub	 esp, 36			; 00000024H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 1120 : 	if (co_kontynuowaæ == 'n') Wczytaj_Kwotê_Zak³adu(kwota_zak³adu, iloœæ_pieniêdzy); //Przypisanie do zmiennej pobranej od u¿ytkownika kwoty zak³adu

  0000b	8b 75 14	 mov	 esi, DWORD PTR _co_kontynuowaæ$[ebp]
  0000e	8b da		 mov	 ebx, edx
  00010	57		 push	 edi
  00011	89 5c 24 10	 mov	 DWORD PTR _kwota_zak³adu$1$[esp+48], ebx
  00015	89 4c 24 14	 mov	 DWORD PTR _wygrana$1$[esp+48], ecx
  00019	80 3e 6e	 cmp	 BYTE PTR [esi], 110	; 0000006eH
  0001c	75 0c		 jne	 SHORT $LN2@P?
  0001e	8b 55 08	 mov	 edx, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  00021	8b cb		 mov	 ecx, ebx
  00023	e8 00 00 00 00	 call	 ?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z ; Wczytaj_Kwotê_Zak³adu
  00028	eb 3b		 jmp	 SHORT $LN3@P?
$LN2@P?:

; 1121 : 	else cout << "Obstawiono za " << kwota_zak³adu << "$" << endl; //Wypisanie wczytanej kwoty zak³adu

  0002a	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0002f	51		 push	 ecx
  00030	ff 33		 push	 DWORD PTR [ebx]
  00032	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  00037	51		 push	 ecx
  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0003e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00043	83 c4 04	 add	 esp, 4
  00046	8b c8		 mov	 ecx, eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0004e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00053	8b c8		 mov	 ecx, eax
  00055	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0005a	83 c4 04	 add	 esp, 4
  0005d	8b c8		 mov	 ecx, eax
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN3@P?:

; 1122 : 	if (co_kontynuowaæ == 'n') log << "Obstawiono za " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie obstawionego zak³adu

  00065	80 3e 6e	 cmp	 BYTE PTR [esi], 110	; 0000006eH
  00068	8b 7d 0c	 mov	 edi, DWORD PTR _log_ogólny$[ebp]
  0006b	75 5c		 jne	 SHORT $LN5@P?
  0006d	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  00070	33 d2		 xor	 edx, edx
  00072	ff 33		 push	 DWORD PTR [ebx]
  00074	85 c0		 test	 eax, eax
  00076	51		 push	 ecx
  00077	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  0007a	0f 44 ca	 cmove	 ecx, edx
  0007d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  00082	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00087	83 c4 04	 add	 esp, 4
  0008a	8b c8		 mov	 ecx, eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00092	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00097	8b c8		 mov	 ecx, eax
  00099	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1123 : 	if (co_kontynuowaæ == 'n') log_ogólny << "Obstawiono za " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie obstawionego zak³adu

  0009e	80 3e 6e	 cmp	 BYTE PTR [esi], 110	; 0000006eH
  000a1	75 26		 jne	 SHORT $LN5@P?
  000a3	ff 33		 push	 DWORD PTR [ebx]
  000a5	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  000aa	51		 push	 ecx
  000ab	8b cf		 mov	 ecx, edi
  000ad	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000b2	83 c4 04	 add	 esp, 4
  000b5	8b c8		 mov	 ecx, eax
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000bd	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000c2	8b c8		 mov	 ecx, eax
  000c4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
$LN5@P?:

; 1124 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  000c9	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  000cc	83 c0 10	 add	 eax, 16			; 00000010H
  000cf	8b c8		 mov	 ecx, eax
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1125 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000d7	8b cf		 mov	 ecx, edi
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1126 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  000df	8a 06		 mov	 al, BYTE PTR [esi]
  000e1	3c 6e		 cmp	 al, 110			; 0000006eH
  000e3	74 41		 je	 SHORT $LN8@P?
  000e5	3c 6b		 cmp	 al, 107			; 0000006bH
  000e7	74 3d		 je	 SHORT $LN8@P?

; 1127 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  000e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000ef	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@
  000f4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3062 : 		return (this->_Get_data()._Mysize);

  000f9	8b 5d 18	 mov	 ebx, DWORD PTR _typ_zak³adu$[ebp]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  000fc	8b d3		 mov	 edx, ebx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000fe	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00102	72 02		 jb	 SHORT $LN201@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00104	8b 13		 mov	 edx, DWORD PTR [ebx]
$LN201@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1127 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  00106	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  0010b	51		 push	 ecx
  0010c	ff 73 10	 push	 DWORD PTR [ebx+16]
  0010f	8b c8		 mov	 ecx, eax
  00111	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  00116	83 c4 08	 add	 esp, 8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1127 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  00119	8b c8		 mov	 ecx, eax
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00121	e9 d4 00 00 00	 jmp	 $LN161@P?
$LN8@P?:

; 1126 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  00126	8d 4c 24 18	 lea	 ecx, DWORD PTR $T1[esp+48]
  0012a	e8 00 00 00 00	 call	 ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2086 : 		if (this != _STD addressof(_Right))

  0012f	8b 5d 18	 mov	 ebx, DWORD PTR _typ_zak³adu$[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1126 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  00132	8b f8		 mov	 edi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2086 : 		if (this != _STD addressof(_Right))

  00134	3b df		 cmp	 ebx, edi
  00136	74 77		 je	 SHORT $LN131@P?

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00138	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0013b	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  0013e	72 3d		 jb	 SHORT $LN69@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00140	8b 0b		 mov	 ecx, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00142	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00143	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00148	72 2a		 jb	 SHORT $LN72@P?

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0014a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0014d	0f 85 df 01 00
	00		 jne	 $_Invalid_parameter$270

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00153	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00156	3b c1		 cmp	 eax, ecx
  00158	0f 83 d4 01 00
	00		 jae	 $_Invalid_parameter$270

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0015e	2b c8		 sub	 ecx, eax
  00160	83 f9 04	 cmp	 ecx, 4
  00163	0f 82 c9 01 00
	00		 jb	 $_Invalid_parameter$270

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00169	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0016c	0f 87 c0 01 00
	00		 ja	 $_Invalid_parameter$270

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00172	8b c8		 mov	 ecx, eax
$LN72@P?:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0017a	83 c4 04	 add	 esp, 4
$LN69@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  0017d	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00184	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0018b	c6 03 00	 mov	 BYTE PTR [ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0018e	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00191	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  00194	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  00199	66 0f d6 43 10	 movq	 QWORD PTR [ebx+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  0019e	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001a5	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  001ac	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN131@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001af	8b 44 24 2c	 mov	 eax, DWORD PTR $T1[esp+68]
  001b3	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  001b6	72 3f		 jb	 SHORT $LN265@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  001b8	8b 4c 24 18	 mov	 ecx, DWORD PTR $T1[esp+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001bc	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  001bd	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001c2	72 2a		 jb	 SHORT $LN164@P?

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  001c4	f6 c1 1f	 test	 cl, 31			; 0000001fH
  001c7	0f 85 65 01 00
	00		 jne	 $_Invalid_parameter$270

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001cd	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  001d0	3b c1		 cmp	 eax, ecx
  001d2	0f 83 5a 01 00
	00		 jae	 $_Invalid_parameter$270

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001d8	2b c8		 sub	 ecx, eax
  001da	83 f9 04	 cmp	 ecx, 4
  001dd	0f 82 4f 01 00
	00		 jb	 $_Invalid_parameter$270

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  001e3	83 f9 23	 cmp	 ecx, 35			; 00000023H
  001e6	0f 87 46 01 00
	00		 ja	 $_Invalid_parameter$270

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  001ec	8b c8		 mov	 ecx, eax
$LN164@P?:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  001ee	51		 push	 ecx
  001ef	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001f4	83 c4 04	 add	 esp, 4
$LN265@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3709 : 		if (_My_data._Large_string_engaged())

  001f7	8b 7d 0c	 mov	 edi, DWORD PTR _log_ogólny$[ebp]
$LN161@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1128 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') log << " Obstawiono zaklad " << typ_zak³adu; //Zapisanie do bufora pliku logu aktualnego informacji o typie obstawionego zak³adu

  001fa	8a 06		 mov	 al, BYTE PTR [esi]
  001fc	3c 6e		 cmp	 al, 110			; 0000006eH
  001fe	74 04		 je	 SHORT $LN10@P?
  00200	3c 6b		 cmp	 al, 107			; 0000006bH
  00202	75 2e		 jne	 SHORT $LN9@P?
$LN10@P?:
  00204	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  00207	33 d2		 xor	 edx, edx
  00209	85 c0		 test	 eax, eax
  0020b	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  0020e	0f 44 ca	 cmove	 ecx, edx
  00211	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
  00216	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0021b	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0021f	8b d3		 mov	 edx, ebx

; 1607 : 		if (_Large_string_engaged())

  00221	72 02		 jb	 SHORT $LN228@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00223	8b 13		 mov	 edx, DWORD PTR [ebx]
$LN228@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  00225	ff 73 10	 push	 DWORD PTR [ebx+16]
  00228	8b c8		 mov	 ecx, eax
  0022a	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  0022f	83 c4 04	 add	 esp, 4
$LN9@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1129 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') log_ogólny << " Obstawiono zaklad " << typ_zak³adu; //Zapisanie do bufora pliku logu ogólnego informacji o typie obstawionego zak³adu

  00232	8a 06		 mov	 al, BYTE PTR [esi]
  00234	3c 6e		 cmp	 al, 110			; 0000006eH
  00236	74 04		 je	 SHORT $LN12@P?
  00238	3c 6b		 cmp	 al, 107			; 0000006bH
  0023a	75 23		 jne	 SHORT $LN11@P?
$LN12@P?:
  0023c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
  00241	8b cf		 mov	 ecx, edi
  00243	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00248	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0024c	8b d3		 mov	 edx, ebx

; 1607 : 		if (_Large_string_engaged())

  0024e	72 02		 jb	 SHORT $LN255@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00250	8b 13		 mov	 edx, DWORD PTR [ebx]
$LN255@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  00252	ff 73 10	 push	 DWORD PTR [ebx+16]
  00255	8b c8		 mov	 ecx, eax
  00257	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  0025c	83 c4 04	 add	 esp, 4
$LN11@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1130 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0025f	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  00262	83 c0 10	 add	 eax, 16			; 00000010H
  00265	8b c8		 mov	 ecx, eax
  00267	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1131 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  0026d	8b cf		 mov	 ecx, edi
  0026f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1132 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') iloœæ_pieniêdzy -= kwota_zak³adu; //Odjêcie od iloœci pieniêdzy kwoty zak³adu

  00275	8a 06		 mov	 al, BYTE PTR [esi]
  00277	3c 6e		 cmp	 al, 110			; 0000006eH
  00279	74 0c		 je	 SHORT $LN14@P?
  0027b	3c 6b		 cmp	 al, 107			; 0000006bH
  0027d	74 08		 je	 SHORT $LN14@P?
  0027f	3c 74		 cmp	 al, 116			; 00000074H
  00281	74 04		 je	 SHORT $LN14@P?
  00283	3c 77		 cmp	 al, 119			; 00000077H
  00285	75 0b		 jne	 SHORT $LN13@P?
$LN14@P?:
  00287	8b 44 24 10	 mov	 eax, DWORD PTR _kwota_zak³adu$1$[esp+48]
  0028b	8b 4d 08	 mov	 ecx, DWORD PTR _iloœæ_pieniêdzy$[ebp]
  0028e	8b 00		 mov	 eax, DWORD PTR [eax]
  00290	29 01		 sub	 DWORD PTR [ecx], eax
$LN13@P?:

; 1133 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') cout << "Kulka w grze, zaczekaj na wylosowanie numeru..." << endl; //Poinformowanie u¿ytkownika o rozpoczêciu losowania

  00292	8a 06		 mov	 al, BYTE PTR [esi]
  00294	3c 6e		 cmp	 al, 110			; 0000006eH
  00296	74 08		 je	 SHORT $LN16@P?
  00298	3c 6b		 cmp	 al, 107			; 0000006bH
  0029a	74 04		 je	 SHORT $LN16@P?
  0029c	3c 74		 cmp	 al, 116			; 00000074H
  0029e	75 21		 jne	 SHORT $LN15@P?
$LN16@P?:
  002a0	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002a5	51		 push	 ecx
  002a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002ac	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@
  002b1	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002b6	83 c4 04	 add	 esp, 4
  002b9	8b c8		 mov	 ecx, eax
  002bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN15@P?:

; 1134 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') wylosowana_liczba = Zakrêæ_Ruletk¹(); //Wylosowanie i przypisanie do zmiennej liczby bêdêcej na  wylosowanej pozycji na kole ruletki

  002c1	8a 06		 mov	 al, BYTE PTR [esi]
  002c3	3c 6e		 cmp	 al, 110			; 0000006eH
  002c5	74 71		 je	 SHORT $LN19@P?
  002c7	3c 6b		 cmp	 al, 107			; 0000006bH
  002c9	74 6d		 je	 SHORT $LN19@P?
  002cb	3c 74		 cmp	 al, 116			; 00000074H
  002cd	74 69		 je	 SHORT $LN19@P?

; 1135 : 	else {
; 1136 : 		cout << "Wylosowano numer "; //Poinformowaniu o wylosowaniu liczby

  002cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002d5	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
  002da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1137 : 		Change_Col(Ruletka_plansza_kolor_col[wylosowana_liczba]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  002df	8b 75 1c	 mov	 esi, DWORD PTR _wylosowana_liczba$[ebp]

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  002e2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetStdHandle@4
  002e8	6a f5		 push	 -11			; fffffff5H

; 1137 : 		Change_Col(Ruletka_plansza_kolor_col[wylosowana_liczba]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  002ea	8b 36		 mov	 esi, DWORD PTR [esi]

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  002ec	ff d7		 call	 edi

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  002ee	0f b7 0c b5 00
	00 00 00	 movzx	 ecx, WORD PTR ?Ruletka_plansza_kolor_col@@3QBHB[esi*4]
  002f6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetConsoleTextAttribute@8
  002fc	51		 push	 ecx
  002fd	50		 push	 eax
  002fe	ff d6		 call	 esi

; 1138 : 		cout << wylosowana_liczba; //Wypisanie wylosowanej liczby

  00300	8b 45 1c	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00303	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00309	ff 30		 push	 DWORD PTR [eax]
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00311	6a f5		 push	 -11			; fffffff5H
  00313	ff d7		 call	 edi

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00315	6a 07		 push	 7
  00317	50		 push	 eax
  00318	ff d6		 call	 esi

; 1139 : 		Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 1140 : 		cout << ". "; //Wypisanie kropki koñcz¹cej zdanie

  0031a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00320	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KHOJGJKF@?4?5?$AA@
  00325	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0032a	8b 75 14	 mov	 esi, DWORD PTR _co_kontynuowaæ$[ebp]
  0032d	8b 7d 1c	 mov	 edi, DWORD PTR _wylosowana_liczba$[ebp]
  00330	eb 10		 jmp	 SHORT $LN18@P?
$_Invalid_parameter$270:
$_Invalid_parameter$271:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00332	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN269@P?:
$LN19@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1134 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') wylosowana_liczba = Zakrêæ_Ruletk¹(); //Wylosowanie i przypisanie do zmiennej liczby bêdêcej na  wylosowanej pozycji na kole ruletki

  00338	e8 00 00 00 00	 call	 ?Zakrêæ_Ruletk¹@@YAHXZ	; Zakrêæ_Ruletk¹
  0033d	8b 7d 1c	 mov	 edi, DWORD PTR _wylosowana_liczba$[ebp]
  00340	89 07		 mov	 DWORD PTR [edi], eax
$LN18@P?:

; 1141 : 	}
; 1142 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') log << " Wylosowano " << wylosowana_liczba; //Zapisanie do bufora pliku logu aktualnego informacji o wylosowanej liczbie

  00342	8a 06		 mov	 al, BYTE PTR [esi]
  00344	3c 6e		 cmp	 al, 110			; 0000006eH
  00346	74 08		 je	 SHORT $LN21@P?
  00348	3c 6b		 cmp	 al, 107			; 0000006bH
  0034a	74 04		 je	 SHORT $LN21@P?
  0034c	3c 74		 cmp	 al, 116			; 00000074H
  0034e	75 25		 jne	 SHORT $LN20@P?
$LN21@P?:
  00350	8b 55 10	 mov	 edx, DWORD PTR _log$[ebp]
  00353	33 c0		 xor	 eax, eax
  00355	ff 37		 push	 DWORD PTR [edi]
  00357	85 d2		 test	 edx, edx
  00359	51		 push	 ecx
  0035a	8d 4a 10	 lea	 ecx, DWORD PTR [edx+16]
  0035d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
  00362	0f 44 c8	 cmove	 ecx, eax
  00365	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0036a	83 c4 04	 add	 esp, 4
  0036d	8b c8		 mov	 ecx, eax
  0036f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
$LN20@P?:

; 1143 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') log_ogólny << " Wylosowano " << wylosowana_liczba; //Zapisanie do bufora pliku logu ogólnego informacji o wylosowanej liczbie

  00375	8a 06		 mov	 al, BYTE PTR [esi]
  00377	3c 6e		 cmp	 al, 110			; 0000006eH
  00379	74 08		 je	 SHORT $LN23@P?
  0037b	3c 6b		 cmp	 al, 107			; 0000006bH
  0037d	74 04		 je	 SHORT $LN23@P?
  0037f	3c 74		 cmp	 al, 116			; 00000074H
  00381	75 1b		 jne	 SHORT $LN22@P?
$LN23@P?:
  00383	ff 37		 push	 DWORD PTR [edi]
  00385	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
  0038a	51		 push	 ecx
  0038b	8b 4d 0c	 mov	 ecx, DWORD PTR _log_ogólny$[ebp]
  0038e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00393	83 c4 04	 add	 esp, 4
  00396	8b c8		 mov	 ecx, eax
  00398	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
$LN22@P?:

; 1144 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0039e	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  003a1	83 c0 10	 add	 eax, 16			; 00000010H
  003a4	8b c8		 mov	 ecx, eax
  003a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1145 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  003ac	8b 4d 0c	 mov	 ecx, DWORD PTR _log_ogólny$[ebp]
  003af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1146 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') Odczytaj_liczbê(wylosowana_liczba, typ_zak³adu);

  003b5	8a 06		 mov	 al, BYTE PTR [esi]
  003b7	3c 6e		 cmp	 al, 110			; 0000006eH
  003b9	74 08		 je	 SHORT $LN25@P?
  003bb	3c 6b		 cmp	 al, 107			; 0000006bH
  003bd	74 04		 je	 SHORT $LN25@P?
  003bf	3c 74		 cmp	 al, 116			; 00000074H
  003c1	75 09		 jne	 SHORT $LN24@P?
$LN25@P?:
  003c3	8b d3		 mov	 edx, ebx
  003c5	8b cf		 mov	 ecx, edi
  003c7	e8 00 00 00 00	 call	 ?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Odczytaj_liczbê
$LN24@P?:

; 1147 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') wygrana = SprawdŸ_Zak³ad(kwota_zak³adu, typ_zak³adu, wylosowana_liczba); //Przypisanie do wygranej kwoty zgodnej z wygran¹, je¿eli siê coœwygra³o

  003cc	8a 06		 mov	 al, BYTE PTR [esi]
  003ce	3c 6e		 cmp	 al, 110			; 0000006eH
  003d0	74 0c		 je	 SHORT $LN27@P?
  003d2	3c 6b		 cmp	 al, 107			; 0000006bH
  003d4	74 08		 je	 SHORT $LN27@P?
  003d6	3c 74		 cmp	 al, 116			; 00000074H
  003d8	74 04		 je	 SHORT $LN27@P?
  003da	3c 77		 cmp	 al, 119			; 00000077H
  003dc	75 19		 jne	 SHORT $LN266@P?
$LN27@P?:
  003de	8b d3		 mov	 edx, ebx
  003e0	8b 5c 24 10	 mov	 ebx, DWORD PTR _kwota_zak³adu$1$[esp+48]
  003e4	57		 push	 edi
  003e5	8b cb		 mov	 ecx, ebx
  003e7	e8 00 00 00 00	 call	 ?SprawdŸ_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; SprawdŸ_Zak³ad
  003ec	8b 4c 24 18	 mov	 ecx, DWORD PTR _wygrana$1$[esp+52]
  003f0	83 c4 04	 add	 esp, 4
  003f3	89 01		 mov	 DWORD PTR [ecx], eax
  003f5	eb 08		 jmp	 SHORT $LN26@P?
$LN266@P?:
  003f7	8b 5c 24 10	 mov	 ebx, DWORD PTR _kwota_zak³adu$1$[esp+48]
  003fb	8b 4c 24 14	 mov	 ecx, DWORD PTR _wygrana$1$[esp+48]
$LN26@P?:

; 1148 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') Og³oœ_wynik(wygrana, kwota_zak³adu, iloœæ_pieniêdzy, log_ogólny, log); //Funkcja informuj¹ca u¿ytkownika czy wygra³ zak³ad

  003ff	8a 06		 mov	 al, BYTE PTR [esi]
  00401	3c 6e		 cmp	 al, 110			; 0000006eH
  00403	74 0c		 je	 SHORT $LN29@P?
  00405	3c 6b		 cmp	 al, 107			; 0000006bH
  00407	74 08		 je	 SHORT $LN29@P?
  00409	3c 74		 cmp	 al, 116			; 00000074H
  0040b	74 04		 je	 SHORT $LN29@P?
  0040d	3c 77		 cmp	 al, 119			; 00000077H
  0040f	75 13		 jne	 SHORT $LN28@P?
$LN29@P?:
  00411	ff 75 10	 push	 DWORD PTR _log$[ebp]
  00414	8b d3		 mov	 edx, ebx
  00416	ff 75 0c	 push	 DWORD PTR _log_ogólny$[ebp]
  00419	ff 75 08	 push	 DWORD PTR _iloœæ_pieniêdzy$[ebp]
  0041c	e8 00 00 00 00	 call	 ?Og³oœ_wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ; Og³oœ_wynik
  00421	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@P?:

; 1149 : }

  00424	5f		 pop	 edi
  00425	5e		 pop	 esi
  00426	5b		 pop	 ebx
  00427	8b e5		 mov	 esp, ebp
  00429	5d		 pop	 ebp
  0042a	c3		 ret	 0
$LN268@P?:
?Pêtla_g³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; Pêtla_g³ówna
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Ustaw_ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
?Ustaw_ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Ustaw_ustawienia, COMDAT
; _tekst$ = ecx

; 1151 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 1152 : 	if (tekst.find("iloœæ_minimalna_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00003	51		 push	 ecx
  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00010	83 f8 ff	 cmp	 eax, -1
  00013	0f 84 94 00 00
	00		 je	 $LN35@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  00019	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0001c	8d 5e 10	 lea	 ebx, DWORD PTR [esi+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0001f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00024	8b d6		 mov	 edx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00026	3b c1		 cmp	 eax, ecx
  00028	0f 42 c8	 cmovb	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0002b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1596 : 		if (_Large_string_engaged())

  0002f	72 02		 jb	 SHORT $LN112@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00031	8b 16		 mov	 edx, DWORD PTR [esi]
$LN112@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00033	2b c1		 sub	 eax, ecx

; 2622 : 		_My_data._Mysize = _New_size;

  00035	89 03		 mov	 DWORD PTR [ebx], eax

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00037	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00038	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00039	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0003c	50		 push	 eax
  0003d	52		 push	 edx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00047	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00049	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0004d	72 02		 jb	 SHORT $LN132@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN132@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1155 : 		if (atoi(tekst.c_str())) iloœæ_minimalna_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00051	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00057	50		 push	 eax
  00058	ff d7		 call	 edi
  0005a	83 c4 04	 add	 esp, 4
  0005d	85 c0		 test	 eax, eax
  0005f	74 18		 je	 SHORT $LN37@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00061	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00065	72 02		 jb	 SHORT $LN148@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00067	8b 36		 mov	 esi, DWORD PTR [esi]
$LN148@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1155 : 		if (atoi(tekst.c_str())) iloœæ_minimalna_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00069	56		 push	 esi
  0006a	ff d7		 call	 edi
  0006c	83 c4 04	 add	 esp, 4
  0006f	66 a3 00 00 00
	00		 mov	 WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA, ax ; iloœæ_minimalna_obrotów_ruletki

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	c3		 ret	 0
$LN37@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00079	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  0007c	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0007e	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00081	72 04		 jb	 SHORT $LN180@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00083	8b 06		 mov	 eax, DWORD PTR [esi]
  00085	8b f0		 mov	 esi, eax
$LN180@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00087	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00089	03 ce		 add	 ecx, esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1158 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  0008b	3b c1		 cmp	 eax, ecx
  0008d	0f 84 02 05 00
	00		 je	 $LN30@Ustaw_usta
$LL4@Ustaw_usta:

; 1159 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00093	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00096	0f 85 86 05 00
	00		 jne	 $LN87@Ustaw_usta

; 1158 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  0009c	40		 inc	 eax
  0009d	3b c1		 cmp	 eax, ecx
  0009f	75 f2		 jne	 SHORT $LL4@Ustaw_usta

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  000a1	5f		 pop	 edi
  000a2	33 c0		 xor	 eax, eax
  000a4	5e		 pop	 esi
  000a5	66 a3 00 00 00
	00		 mov	 WORD PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA, ax ; g³os_szybkoœæ_odczytu_numeru
  000ab	5b		 pop	 ebx
  000ac	c3		 ret	 0
$LN35@Ustaw_usta:

; 1160 : 			g³os_szybkoœæ_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0
; 1161 : 		}
; 1162 : 	}
; 1163 : 	else if (tekst.find("iloœæ_max_dodatkowych_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  000ad	51		 push	 ecx
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
  000b3	8b ce		 mov	 ecx, esi
  000b5	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  000ba	83 f8 ff	 cmp	 eax, -1
  000bd	0f 84 97 00 00
	00		 je	 $LN40@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  000c3	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000c6	8d 5e 10	 lea	 ebx, DWORD PTR [esi+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  000c9	b9 26 00 00 00	 mov	 ecx, 38			; 00000026H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  000ce	8b d6		 mov	 edx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  000d0	3b c1		 cmp	 eax, ecx
  000d2	0f 42 c8	 cmovb	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000d5	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1596 : 		if (_Large_string_engaged())

  000d9	72 02		 jb	 SHORT $LN208@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000db	8b 16		 mov	 edx, DWORD PTR [esi]
$LN208@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  000dd	2b c1		 sub	 eax, ecx

; 2622 : 		_My_data._Mysize = _New_size;

  000df	89 03		 mov	 DWORD PTR [ebx], eax

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  000e1	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000e2	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  000e3	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000e6	50		 push	 eax
  000e7	52		 push	 edx
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  000f1	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000f3	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  000f7	72 02		 jb	 SHORT $LN227@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000f9	8b 06		 mov	 eax, DWORD PTR [esi]
$LN227@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1166 : 		if (atoi(tekst.c_str())) iloœæ_max_dodatkowych_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  000fb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00101	50		 push	 eax
  00102	ff d7		 call	 edi
  00104	83 c4 04	 add	 esp, 4
  00107	85 c0		 test	 eax, eax
  00109	74 18		 je	 SHORT $LN42@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0010b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0010f	72 02		 jb	 SHORT $LN243@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00111	8b 36		 mov	 esi, DWORD PTR [esi]
$LN243@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1166 : 		if (atoi(tekst.c_str())) iloœæ_max_dodatkowych_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00113	56		 push	 esi
  00114	ff d7		 call	 edi
  00116	83 c4 04	 add	 esp, 4
  00119	66 a3 00 00 00
	00		 mov	 WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA, ax ; iloœæ_max_dodatkowych_obrotów_ruletki

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi
  00121	5b		 pop	 ebx
  00122	c3		 ret	 0
$LN42@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00123	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00126	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00128	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  0012b	72 04		 jb	 SHORT $LN275@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0012d	8b 06		 mov	 eax, DWORD PTR [esi]
  0012f	8b f0		 mov	 esi, eax
$LN275@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00131	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00133	03 ce		 add	 ecx, esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1169 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00135	3b c1		 cmp	 eax, ecx
  00137	74 15		 je	 SHORT $LN6@Ustaw_usta
  00139	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@Ustaw_usta:

; 1170 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00140	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00143	0f 85 d9 04 00
	00		 jne	 $LN87@Ustaw_usta

; 1169 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00149	40		 inc	 eax
  0014a	3b c1		 cmp	 eax, ecx
  0014c	75 f2		 jne	 SHORT $LL7@Ustaw_usta
$LN6@Ustaw_usta:

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  0014e	5f		 pop	 edi
  0014f	33 c0		 xor	 eax, eax
  00151	5e		 pop	 esi
  00152	66 a3 00 00 00
	00		 mov	 WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA, ax ; iloœæ_max_dodatkowych_obrotów_ruletki
  00158	5b		 pop	 ebx
  00159	c3		 ret	 0
$LN40@Ustaw_usta:

; 1171 : 			iloœæ_max_dodatkowych_obrotów_ruletki = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0
; 1172 : 		}
; 1173 : 	}
; 1174 : 	else if (tekst.find("czas_przeskoku_kulki_szybki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0015a	51		 push	 ecx
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@
  00160	8b ce		 mov	 ecx, esi
  00162	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00167	83 f8 ff	 cmp	 eax, -1
  0016a	74 75		 je	 SHORT $LN45@Ustaw_usta

; 1175 : 	{
; 1176 : 		tekst.erase(0, size("czas_przeskoku_kulki_szybki")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoœci¹ ustawienia

  0016c	6a 1c		 push	 28			; 0000001cH
  0016e	6a 00		 push	 0
  00170	8b ce		 mov	 ecx, esi
  00172	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00177	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0017b	8b c6		 mov	 eax, esi

; 1607 : 		if (_Large_string_engaged())

  0017d	72 02		 jb	 SHORT $LN294@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0017f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN294@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1177 : 		if (atoi(tekst.c_str())) czas_przeskoku_kulki_szybki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00181	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00187	50		 push	 eax
  00188	ff d7		 call	 edi
  0018a	83 c4 04	 add	 esp, 4
  0018d	85 c0		 test	 eax, eax
  0018f	74 18		 je	 SHORT $LN47@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00191	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00195	72 02		 jb	 SHORT $LN310@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00197	8b 36		 mov	 esi, DWORD PTR [esi]
$LN310@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1177 : 		if (atoi(tekst.c_str())) czas_przeskoku_kulki_szybki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00199	56		 push	 esi
  0019a	ff d7		 call	 edi
  0019c	83 c4 04	 add	 esp, 4
  0019f	66 a3 00 00 00
	00		 mov	 WORD PTR ?czas_przeskoku_kulki_szybki@@3FA, ax ; czas_przeskoku_kulki_szybki

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  001a5	5f		 pop	 edi
  001a6	5e		 pop	 esi
  001a7	5b		 pop	 ebx
  001a8	c3		 ret	 0
$LN47@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001a9	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  001ac	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001ae	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  001b1	72 02		 jb	 SHORT $LN326@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  001b3	8b 06		 mov	 eax, DWORD PTR [esi]
$LN326@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  001b5	8b d6		 mov	 edx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001b7	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  001ba	72 02		 jb	 SHORT $LN342@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  001bc	8b 16		 mov	 edx, DWORD PTR [esi]
$LN342@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  001be	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001c1	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1180 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  001c3	3b c1		 cmp	 eax, ecx
  001c5	74 0e		 je	 SHORT $LN9@Ustaw_usta
$LL10@Ustaw_usta:

; 1181 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  001c7	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  001ca	0f 85 52 04 00
	00		 jne	 $LN87@Ustaw_usta

; 1180 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  001d0	40		 inc	 eax
  001d1	3b c1		 cmp	 eax, ecx
  001d3	75 f2		 jne	 SHORT $LL10@Ustaw_usta
$LN9@Ustaw_usta:

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  001d5	5f		 pop	 edi
  001d6	33 c0		 xor	 eax, eax
  001d8	5e		 pop	 esi
  001d9	66 a3 00 00 00
	00		 mov	 WORD PTR ?czas_przeskoku_kulki_szybki@@3FA, ax ; czas_przeskoku_kulki_szybki
  001df	5b		 pop	 ebx
  001e0	c3		 ret	 0
$LN45@Ustaw_usta:

; 1182 : 			czas_przeskoku_kulki_szybki = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0
; 1183 : 		}
; 1184 : 	}
; 1185 : 	else if (tekst.find("czas_przeskoku_kulki_wolny") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  001e1	51		 push	 ecx
  001e2	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@
  001e7	8b ce		 mov	 ecx, esi
  001e9	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  001ee	83 f8 ff	 cmp	 eax, -1
  001f1	74 77		 je	 SHORT $LN50@Ustaw_usta

; 1186 : 	{
; 1187 : 		tekst.erase(0, size("czas_przeskoku_kulki_wolny")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoœci¹ ustawienia

  001f3	6a 1b		 push	 27			; 0000001bH
  001f5	6a 00		 push	 0
  001f7	8b ce		 mov	 ecx, esi
  001f9	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001fe	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00202	8b c6		 mov	 eax, esi

; 1607 : 		if (_Large_string_engaged())

  00204	72 02		 jb	 SHORT $LN361@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
$LN361@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1188 : 		if (atoi(tekst.c_str())) czas_przeskoku_kulki_wolny = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00208	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  0020e	50		 push	 eax
  0020f	ff d7		 call	 edi
  00211	83 c4 04	 add	 esp, 4
  00214	85 c0		 test	 eax, eax
  00216	74 18		 je	 SHORT $LN52@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00218	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0021c	72 02		 jb	 SHORT $LN377@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0021e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN377@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1188 : 		if (atoi(tekst.c_str())) czas_przeskoku_kulki_wolny = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00220	56		 push	 esi
  00221	ff d7		 call	 edi
  00223	83 c4 04	 add	 esp, 4
  00226	66 a3 00 00 00
	00		 mov	 WORD PTR ?czas_przeskoku_kulki_wolny@@3FA, ax ; czas_przeskoku_kulki_wolny

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  0022c	5f		 pop	 edi
  0022d	5e		 pop	 esi
  0022e	5b		 pop	 ebx
  0022f	c3		 ret	 0
$LN52@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00230	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00233	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00235	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00238	72 02		 jb	 SHORT $LN393@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0023a	8b 06		 mov	 eax, DWORD PTR [esi]
$LN393@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  0023c	8b d6		 mov	 edx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0023e	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00241	72 02		 jb	 SHORT $LN409@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00243	8b 16		 mov	 edx, DWORD PTR [esi]
$LN409@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00245	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00248	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1191 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  0024a	3b c1		 cmp	 eax, ecx
  0024c	74 10		 je	 SHORT $LN12@Ustaw_usta
  0024e	66 90		 npad	 2
$LL13@Ustaw_usta:

; 1192 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00250	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00253	0f 85 c9 03 00
	00		 jne	 $LN87@Ustaw_usta

; 1191 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00259	40		 inc	 eax
  0025a	3b c1		 cmp	 eax, ecx
  0025c	75 f2		 jne	 SHORT $LL13@Ustaw_usta
$LN12@Ustaw_usta:

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  0025e	5f		 pop	 edi
  0025f	33 c0		 xor	 eax, eax
  00261	5e		 pop	 esi
  00262	66 a3 00 00 00
	00		 mov	 WORD PTR ?czas_przeskoku_kulki_wolny@@3FA, ax ; czas_przeskoku_kulki_wolny
  00268	5b		 pop	 ebx
  00269	c3		 ret	 0
$LN50@Ustaw_usta:

; 1193 : 			czas_przeskoku_kulki_wolny = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0
; 1194 : 		}
; 1195 : 	}
; 1196 : 	else if (tekst.find("styl_liczenia_wygranej") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0026a	51		 push	 ecx
  0026b	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@
  00270	8b ce		 mov	 ecx, esi
  00272	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00277	83 f8 ff	 cmp	 eax, -1
  0027a	74 75		 je	 SHORT $LN55@Ustaw_usta

; 1197 : 	{
; 1198 : 		tekst.erase(0, size("styl_liczenia_wygranej")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoœci¹ ustawienia

  0027c	6a 17		 push	 23			; 00000017H
  0027e	6a 00		 push	 0
  00280	8b ce		 mov	 ecx, esi
  00282	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00287	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0028b	8b c6		 mov	 eax, esi

; 1607 : 		if (_Large_string_engaged())

  0028d	72 02		 jb	 SHORT $LN428@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0028f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN428@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1199 : 		if (atoi(tekst.c_str())) styl_liczenia_wygranej = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00291	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00297	50		 push	 eax
  00298	ff d7		 call	 edi
  0029a	83 c4 04	 add	 esp, 4
  0029d	85 c0		 test	 eax, eax
  0029f	74 18		 je	 SHORT $LN57@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002a1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  002a5	72 02		 jb	 SHORT $LN444@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002a7	8b 36		 mov	 esi, DWORD PTR [esi]
$LN444@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1199 : 		if (atoi(tekst.c_str())) styl_liczenia_wygranej = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  002a9	56		 push	 esi
  002aa	ff d7		 call	 edi
  002ac	83 c4 04	 add	 esp, 4
  002af	66 a3 00 00 00
	00		 mov	 WORD PTR ?styl_liczenia_wygranej@@3FA, ax ; styl_liczenia_wygranej

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  002b5	5f		 pop	 edi
  002b6	5e		 pop	 esi
  002b7	5b		 pop	 ebx
  002b8	c3		 ret	 0
$LN57@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002b9	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  002bc	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002be	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  002c1	72 02		 jb	 SHORT $LN460@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002c3	8b 06		 mov	 eax, DWORD PTR [esi]
$LN460@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  002c5	8b d6		 mov	 edx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002c7	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  002ca	72 02		 jb	 SHORT $LN476@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002cc	8b 16		 mov	 edx, DWORD PTR [esi]
$LN476@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  002ce	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  002d1	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1202 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  002d3	3b c1		 cmp	 eax, ecx
  002d5	74 0e		 je	 SHORT $LN15@Ustaw_usta
$LL16@Ustaw_usta:

; 1203 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  002d7	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  002da	0f 85 42 03 00
	00		 jne	 $LN87@Ustaw_usta

; 1202 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  002e0	40		 inc	 eax
  002e1	3b c1		 cmp	 eax, ecx
  002e3	75 f2		 jne	 SHORT $LL16@Ustaw_usta
$LN15@Ustaw_usta:

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  002e5	5f		 pop	 edi
  002e6	33 c0		 xor	 eax, eax
  002e8	5e		 pop	 esi
  002e9	66 a3 00 00 00
	00		 mov	 WORD PTR ?styl_liczenia_wygranej@@3FA, ax ; styl_liczenia_wygranej
  002ef	5b		 pop	 ebx
  002f0	c3		 ret	 0
$LN55@Ustaw_usta:

; 1204 : 			styl_liczenia_wygranej = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0
; 1205 : 		}
; 1206 : 	}
; 1207 : 	else if (tekst.find("kwota_pocz¹tkowa") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  002f1	51		 push	 ecx
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@
  002f7	8b ce		 mov	 ecx, esi
  002f9	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  002fe	83 f8 ff	 cmp	 eax, -1
  00301	74 79		 je	 SHORT $LN60@Ustaw_usta

; 1208 : 	{
; 1209 : 		tekst.erase(0, size("kwota_pocz¹tkowa")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoœci¹ ustawienia

  00303	6a 11		 push	 17			; 00000011H
  00305	6a 00		 push	 0
  00307	8b ce		 mov	 ecx, esi
  00309	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0030e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00312	8b c6		 mov	 eax, esi

; 1607 : 		if (_Large_string_engaged())

  00314	72 02		 jb	 SHORT $LN495@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00316	8b 06		 mov	 eax, DWORD PTR [esi]
$LN495@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1210 : 		if (atoi(tekst.c_str())) kwota_pocz¹tkowa = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00318	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  0031e	50		 push	 eax
  0031f	ff d7		 call	 edi
  00321	83 c4 04	 add	 esp, 4
  00324	85 c0		 test	 eax, eax
  00326	74 17		 je	 SHORT $LN62@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00328	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0032c	72 02		 jb	 SHORT $LN511@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0032e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN511@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1210 : 		if (atoi(tekst.c_str())) kwota_pocz¹tkowa = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00330	56		 push	 esi
  00331	ff d7		 call	 edi
  00333	83 c4 04	 add	 esp, 4
  00336	a3 00 00 00 00	 mov	 DWORD PTR ?kwota_pocz¹tkowa@@3HA, eax ; kwota_pocz¹tkowa

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  0033b	5f		 pop	 edi
  0033c	5e		 pop	 esi
  0033d	5b		 pop	 ebx
  0033e	c3		 ret	 0
$LN62@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0033f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00342	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00344	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00347	72 02		 jb	 SHORT $LN527@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00349	8b 06		 mov	 eax, DWORD PTR [esi]
$LN527@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  0034b	8b d6		 mov	 edx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0034d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00350	72 02		 jb	 SHORT $LN543@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00352	8b 16		 mov	 edx, DWORD PTR [esi]
$LN543@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00354	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00357	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1213 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00359	3b c1		 cmp	 eax, ecx
  0035b	74 11		 je	 SHORT $LN18@Ustaw_usta
  0035d	0f 1f 00	 npad	 3
$LL19@Ustaw_usta:

; 1214 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00360	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00363	0f 85 b9 02 00
	00		 jne	 $LN87@Ustaw_usta

; 1213 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00369	40		 inc	 eax
  0036a	3b c1		 cmp	 eax, ecx
  0036c	75 f2		 jne	 SHORT $LL19@Ustaw_usta
$LN18@Ustaw_usta:

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  0036e	5f		 pop	 edi
  0036f	5e		 pop	 esi
  00370	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?kwota_pocz¹tkowa@@3HA, 0 ; kwota_pocz¹tkowa
  0037a	5b		 pop	 ebx
  0037b	c3		 ret	 0
$LN60@Ustaw_usta:

; 1215 : 			kwota_pocz¹tkowa = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0
; 1216 : 		}
; 1217 : 	}
; 1218 : 	else if (tekst.find("stan_dŸwiêków") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0037c	51		 push	 ecx
  0037d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@
  00382	8b ce		 mov	 ecx, esi
  00384	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00389	83 f8 ff	 cmp	 eax, -1
  0038c	74 7c		 je	 SHORT $LN65@Ustaw_usta

; 1219 : 	{
; 1220 : 		tekst.erase(0, size("stan_dŸwiêków")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoœci¹ ustawienia

  0038e	6a 0e		 push	 14			; 0000000eH
  00390	6a 00		 push	 0
  00392	8b ce		 mov	 ecx, esi
  00394	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00399	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0039d	8b c6		 mov	 eax, esi

; 1607 : 		if (_Large_string_engaged())

  0039f	72 02		 jb	 SHORT $LN562@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  003a1	8b 06		 mov	 eax, DWORD PTR [esi]
$LN562@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1221 : 		if (atoi(tekst.c_str())) stan_dŸwiêków = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  003a3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  003a9	50		 push	 eax
  003aa	ff d7		 call	 edi
  003ac	83 c4 04	 add	 esp, 4
  003af	85 c0		 test	 eax, eax
  003b1	74 18		 je	 SHORT $LN67@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003b3	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  003b7	72 02		 jb	 SHORT $LN578@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  003b9	8b 36		 mov	 esi, DWORD PTR [esi]
$LN578@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1221 : 		if (atoi(tekst.c_str())) stan_dŸwiêków = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  003bb	56		 push	 esi
  003bc	ff d7		 call	 edi
  003be	83 c4 04	 add	 esp, 4
  003c1	66 a3 00 00 00
	00		 mov	 WORD PTR ?stan_dŸwiêków@@3FA, ax ; stan_dŸwiêków

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  003c7	5f		 pop	 edi
  003c8	5e		 pop	 esi
  003c9	5b		 pop	 ebx
  003ca	c3		 ret	 0
$LN67@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003cb	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  003ce	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003d0	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  003d3	72 02		 jb	 SHORT $LN594@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  003d5	8b 06		 mov	 eax, DWORD PTR [esi]
$LN594@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  003d7	8b d6		 mov	 edx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003d9	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  003dc	72 02		 jb	 SHORT $LN610@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  003de	8b 16		 mov	 edx, DWORD PTR [esi]
$LN610@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  003e0	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  003e3	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1224 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  003e5	3b c1		 cmp	 eax, ecx
  003e7	74 15		 je	 SHORT $LN21@Ustaw_usta
  003e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL22@Ustaw_usta:

; 1225 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  003f0	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  003f3	0f 85 29 02 00
	00		 jne	 $LN87@Ustaw_usta

; 1224 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  003f9	40		 inc	 eax
  003fa	3b c1		 cmp	 eax, ecx
  003fc	75 f2		 jne	 SHORT $LL22@Ustaw_usta
$LN21@Ustaw_usta:

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  003fe	5f		 pop	 edi
  003ff	33 c0		 xor	 eax, eax
  00401	5e		 pop	 esi
  00402	66 a3 00 00 00
	00		 mov	 WORD PTR ?stan_dŸwiêków@@3FA, ax ; stan_dŸwiêków
  00408	5b		 pop	 ebx
  00409	c3		 ret	 0
$LN65@Ustaw_usta:

; 1226 : 			stan_dŸwiêków = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0
; 1227 : 		}
; 1228 : 	}
; 1229 : 	else if (tekst.find("czy_kontynuowaæ_grê") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0040a	51		 push	 ecx
  0040b	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@
  00410	8b ce		 mov	 ecx, esi
  00412	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00417	83 f8 ff	 cmp	 eax, -1
  0041a	74 75		 je	 SHORT $LN70@Ustaw_usta

; 1230 : 	{
; 1231 : 		tekst.erase(0, size("czy_kontynuowaæ_grê")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoœci¹ ustawienia

  0041c	6a 14		 push	 20			; 00000014H
  0041e	6a 00		 push	 0
  00420	8b ce		 mov	 ecx, esi
  00422	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00427	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0042b	8b c6		 mov	 eax, esi

; 1607 : 		if (_Large_string_engaged())

  0042d	72 02		 jb	 SHORT $LN629@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0042f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN629@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1232 : 		if (atoi(tekst.c_str())) czy_kontynuowaæ_grê = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00431	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00437	50		 push	 eax
  00438	ff d7		 call	 edi
  0043a	83 c4 04	 add	 esp, 4
  0043d	85 c0		 test	 eax, eax
  0043f	74 18		 je	 SHORT $LN72@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00441	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00445	72 02		 jb	 SHORT $LN645@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00447	8b 36		 mov	 esi, DWORD PTR [esi]
$LN645@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1232 : 		if (atoi(tekst.c_str())) czy_kontynuowaæ_grê = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00449	56		 push	 esi
  0044a	ff d7		 call	 edi
  0044c	83 c4 04	 add	 esp, 4
  0044f	66 a3 00 00 00
	00		 mov	 WORD PTR ?czy_kontynuowaæ_grê@@3FA, ax ; czy_kontynuowaæ_grê

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  00455	5f		 pop	 edi
  00456	5e		 pop	 esi
  00457	5b		 pop	 ebx
  00458	c3		 ret	 0
$LN72@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00459	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  0045c	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0045e	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00461	72 02		 jb	 SHORT $LN661@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00463	8b 06		 mov	 eax, DWORD PTR [esi]
$LN661@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00465	8b d6		 mov	 edx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00467	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  0046a	72 02		 jb	 SHORT $LN677@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0046c	8b 16		 mov	 edx, DWORD PTR [esi]
$LN677@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0046e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00471	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1235 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00473	3b c1		 cmp	 eax, ecx
  00475	74 0e		 je	 SHORT $LN24@Ustaw_usta
$LL25@Ustaw_usta:

; 1236 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00477	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  0047a	0f 85 a2 01 00
	00		 jne	 $LN87@Ustaw_usta

; 1235 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00480	40		 inc	 eax
  00481	3b c1		 cmp	 eax, ecx
  00483	75 f2		 jne	 SHORT $LL25@Ustaw_usta
$LN24@Ustaw_usta:

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  00485	5f		 pop	 edi
  00486	33 c0		 xor	 eax, eax
  00488	5e		 pop	 esi
  00489	66 a3 00 00 00
	00		 mov	 WORD PTR ?czy_kontynuowaæ_grê@@3FA, ax ; czy_kontynuowaæ_grê
  0048f	5b		 pop	 ebx
  00490	c3		 ret	 0
$LN70@Ustaw_usta:

; 1237 : 			czy_kontynuowaæ_grê = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0
; 1238 : 		}
; 1239 : 	}
; 1240 : 	else if (tekst.find("g³os_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00491	51		 push	 ecx
  00492	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@
  00497	8b ce		 mov	 ecx, esi
  00499	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0049e	83 f8 ff	 cmp	 eax, -1
  004a1	74 77		 je	 SHORT $LN75@Ustaw_usta

; 1241 : 	{
; 1242 : 		tekst.erase(0, size("g³os_odczytu_numeru")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoœci¹ ustawienia

  004a3	6a 14		 push	 20			; 00000014H
  004a5	6a 00		 push	 0
  004a7	8b ce		 mov	 ecx, esi
  004a9	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004ae	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  004b2	8b c6		 mov	 eax, esi

; 1607 : 		if (_Large_string_engaged())

  004b4	72 02		 jb	 SHORT $LN696@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  004b6	8b 06		 mov	 eax, DWORD PTR [esi]
$LN696@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1243 : 		if (atoi(tekst.c_str())) g³os_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  004b8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  004be	50		 push	 eax
  004bf	ff d7		 call	 edi
  004c1	83 c4 04	 add	 esp, 4
  004c4	85 c0		 test	 eax, eax
  004c6	74 18		 je	 SHORT $LN77@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004c8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  004cc	72 02		 jb	 SHORT $LN712@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  004ce	8b 36		 mov	 esi, DWORD PTR [esi]
$LN712@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1243 : 		if (atoi(tekst.c_str())) g³os_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  004d0	56		 push	 esi
  004d1	ff d7		 call	 edi
  004d3	83 c4 04	 add	 esp, 4
  004d6	66 a3 00 00 00
	00		 mov	 WORD PTR ?g³os_odczytu_numeru@@3FA, ax ; g³os_odczytu_numeru

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  004dc	5f		 pop	 edi
  004dd	5e		 pop	 esi
  004de	5b		 pop	 ebx
  004df	c3		 ret	 0
$LN77@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004e0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  004e3	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004e5	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  004e8	72 02		 jb	 SHORT $LN728@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  004ea	8b 06		 mov	 eax, DWORD PTR [esi]
$LN728@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  004ec	8b d6		 mov	 edx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004ee	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  004f1	72 02		 jb	 SHORT $LN744@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  004f3	8b 16		 mov	 edx, DWORD PTR [esi]
$LN744@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  004f5	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  004f8	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1246 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  004fa	3b c1		 cmp	 eax, ecx
  004fc	74 10		 je	 SHORT $LN27@Ustaw_usta
  004fe	66 90		 npad	 2
$LL28@Ustaw_usta:

; 1247 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00500	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00503	0f 85 19 01 00
	00		 jne	 $LN87@Ustaw_usta

; 1246 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00509	40		 inc	 eax
  0050a	3b c1		 cmp	 eax, ecx
  0050c	75 f2		 jne	 SHORT $LL28@Ustaw_usta
$LN27@Ustaw_usta:

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  0050e	5f		 pop	 edi
  0050f	33 c0		 xor	 eax, eax
  00511	5e		 pop	 esi
  00512	66 a3 00 00 00
	00		 mov	 WORD PTR ?g³os_odczytu_numeru@@3FA, ax ; g³os_odczytu_numeru
  00518	5b		 pop	 ebx
  00519	c3		 ret	 0
$LN75@Ustaw_usta:

; 1248 : 			g³os_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0
; 1249 : 		}
; 1250 : 	}
; 1251 : 	else if (tekst.find("g³os_szybkoœæ_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0051a	51		 push	 ecx
  0051b	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@
  00520	8b ce		 mov	 ecx, esi
  00522	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00527	83 f8 ff	 cmp	 eax, -1
  0052a	74 75		 je	 SHORT $LN80@Ustaw_usta

; 1252 : 	{
; 1253 : 		tekst.erase(0, size("g³os_szybkoœæ_odczytu_numeru")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoœci¹ ustawienia

  0052c	6a 1d		 push	 29			; 0000001dH
  0052e	6a 00		 push	 0
  00530	8b ce		 mov	 ecx, esi
  00532	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00537	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0053b	8b c6		 mov	 eax, esi

; 1607 : 		if (_Large_string_engaged())

  0053d	72 02		 jb	 SHORT $LN763@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0053f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN763@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1254 : 		if (atoi(tekst.c_str())) g³os_szybkoœæ_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00541	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00547	50		 push	 eax
  00548	ff d7		 call	 edi
  0054a	83 c4 04	 add	 esp, 4
  0054d	85 c0		 test	 eax, eax
  0054f	74 18		 je	 SHORT $LN82@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00551	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00555	72 02		 jb	 SHORT $LN779@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00557	8b 36		 mov	 esi, DWORD PTR [esi]
$LN779@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1254 : 		if (atoi(tekst.c_str())) g³os_szybkoœæ_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00559	56		 push	 esi
  0055a	ff d7		 call	 edi
  0055c	83 c4 04	 add	 esp, 4
  0055f	66 a3 00 00 00
	00		 mov	 WORD PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA, ax ; g³os_szybkoœæ_odczytu_numeru

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  00565	5f		 pop	 edi
  00566	5e		 pop	 esi
  00567	5b		 pop	 ebx
  00568	c3		 ret	 0
$LN82@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00569	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  0056c	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0056e	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00571	72 02		 jb	 SHORT $LN795@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00573	8b 06		 mov	 eax, DWORD PTR [esi]
$LN795@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00575	8b d6		 mov	 edx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00577	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  0057a	72 02		 jb	 SHORT $LN811@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0057c	8b 16		 mov	 edx, DWORD PTR [esi]
$LN811@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0057e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00581	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1257 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00583	3b c1		 cmp	 eax, ecx
  00585	74 0e		 je	 SHORT $LN30@Ustaw_usta
$LL31@Ustaw_usta:

; 1258 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00587	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  0058a	0f 85 92 00 00
	00		 jne	 $LN87@Ustaw_usta

; 1257 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00590	40		 inc	 eax
  00591	3b c1		 cmp	 eax, ecx
  00593	75 f2		 jne	 SHORT $LL31@Ustaw_usta
$LN30@Ustaw_usta:

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  00595	5f		 pop	 edi
  00596	33 c0		 xor	 eax, eax
  00598	5e		 pop	 esi
  00599	66 a3 00 00 00
	00		 mov	 WORD PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA, ax ; g³os_szybkoœæ_odczytu_numeru
  0059f	5b		 pop	 ebx
  005a0	c3		 ret	 0
$LN80@Ustaw_usta:

; 1259 : 			g³os_szybkoœæ_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0
; 1260 : 		}
; 1261 : 	}
; 1262 : 	else if (tekst.find("efekty_dŸwiêkowe") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  005a1	51		 push	 ecx
  005a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@
  005a7	8b ce		 mov	 ecx, esi
  005a9	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  005ae	83 f8 ff	 cmp	 eax, -1
  005b1	74 6f		 je	 SHORT $LN87@Ustaw_usta

; 1263 : 	{
; 1264 : 		tekst.erase(0, size("efekty_dŸwiêkowe")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoœci¹ ustawienia

  005b3	6a 11		 push	 17			; 00000011H
  005b5	6a 00		 push	 0
  005b7	8b ce		 mov	 ecx, esi
  005b9	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005be	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  005c2	8b c6		 mov	 eax, esi

; 1607 : 		if (_Large_string_engaged())

  005c4	72 02		 jb	 SHORT $LN830@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  005c6	8b 06		 mov	 eax, DWORD PTR [esi]
$LN830@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1265 : 		if (atoi(tekst.c_str())) efekty_dŸwiêkowe = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  005c8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  005ce	50		 push	 eax
  005cf	ff d7		 call	 edi
  005d1	83 c4 04	 add	 esp, 4
  005d4	85 c0		 test	 eax, eax
  005d6	74 18		 je	 SHORT $LN86@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005d8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  005dc	72 02		 jb	 SHORT $LN846@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  005de	8b 36		 mov	 esi, DWORD PTR [esi]
$LN846@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1265 : 		if (atoi(tekst.c_str())) efekty_dŸwiêkowe = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  005e0	56		 push	 esi
  005e1	ff d7		 call	 edi
  005e3	83 c4 04	 add	 esp, 4

; 1270 : 			efekty_dŸwiêkowe = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  005e6	66 a3 00 00 00
	00		 mov	 WORD PTR ?efekty_dŸwiêkowe@@3FA, ax ; efekty_dŸwiêkowe

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  005ec	5f		 pop	 edi
  005ed	5e		 pop	 esi
  005ee	5b		 pop	 ebx
  005ef	c3		 ret	 0
$LN86@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005f0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  005f3	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005f5	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  005f8	72 02		 jb	 SHORT $LN862@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  005fa	8b 06		 mov	 eax, DWORD PTR [esi]
$LN862@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  005fc	8b d6		 mov	 edx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005fe	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00601	72 02		 jb	 SHORT $LN878@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00603	8b 16		 mov	 edx, DWORD PTR [esi]
$LN878@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00605	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00608	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1268 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  0060a	3b c1		 cmp	 eax, ecx
  0060c	74 0c		 je	 SHORT $LN33@Ustaw_usta
  0060e	66 90		 npad	 2
$LL34@Ustaw_usta:

; 1269 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00610	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00613	75 0d		 jne	 SHORT $LN87@Ustaw_usta

; 1268 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00615	40		 inc	 eax
  00616	3b c1		 cmp	 eax, ecx
  00618	75 f6		 jne	 SHORT $LL34@Ustaw_usta
$LN33@Ustaw_usta:

; 1270 : 			efekty_dŸwiêkowe = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  0061a	33 c0		 xor	 eax, eax
  0061c	66 a3 00 00 00
	00		 mov	 WORD PTR ?efekty_dŸwiêkowe@@3FA, ax ; efekty_dŸwiêkowe
$LN87@Ustaw_usta:

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  00622	5f		 pop	 edi
  00623	5e		 pop	 esi
  00624	5b		 pop	 ebx
  00625	c3		 ret	 0
?Ustaw_ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Ustaw_ustawienia
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0?$uniform_int_distribution@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0?$uniform_int_distribution@H@std@@QAE@HH@Z PROC	; std::uniform_int_distribution<int>::uniform_int_distribution<int>, COMDAT
; _this$ = ecx

; 2444 : 		{	// construct from parameters

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2256 : 			_Min = _Min0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Min0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 2257 : 			_Max = _Max0;

  00008	8b 45 0c	 mov	 eax, DWORD PTR __Max0$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2445 : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0?$uniform_int_distribution@H@std@@QAE@HH@Z ENDP	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ
_TEXT	SEGMENT
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator(), COMDAT
; _this$ = ecx

; 1374 : 		{	// return next value

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1375 : 		if (this->_Idx == _Nx)

  00004	8b 07		 mov	 eax, DWORD PTR [edi]
  00006	3d 70 02 00 00	 cmp	 eax, 624		; 00000270H
  0000b	75 41		 jne	 SHORT $LN2@operator

; 1426 : 		for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix)

  0000d	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  00010	8b f0		 mov	 esi, eax
$LL9@operator:

; 1427 : 			{	// fill in values
; 1428 : 			_Ty _Tmp = (this->_Ax[_Ix - _Nx] & _HMSK)
; 1429 : 				| (this->_Ax[_Ix - _Nx + 1] & _LMSK);

  00012	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00015	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  00018	33 4a fc	 xor	 ecx, DWORD PTR [edx-4]
  0001b	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  00021	33 4a f8	 xor	 ecx, DWORD PTR [edx-8]

; 1430 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00024	8b c1		 mov	 eax, ecx
  00026	24 01		 and	 al, 1
  00028	0f b6 c0	 movzx	 eax, al
  0002b	f7 d8		 neg	 eax
  0002d	1b c0		 sbb	 eax, eax
  0002f	d1 e9		 shr	 ecx, 1
  00031	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00036	33 82 2c 06 00
	00		 xor	 eax, DWORD PTR [edx+1580]
  0003c	33 c1		 xor	 eax, ecx
  0003e	89 82 b8 09 00
	00		 mov	 DWORD PTR [edx+2488], eax
  00044	83 ee 01	 sub	 esi, 1
  00047	75 c9		 jne	 SHORT $LL9@operator

; 1431 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1432 : 			}
; 1433 : 		}

  00049	e9 c6 00 00 00	 jmp	 $LN4@operator
$LN2@operator:

; 1376 : 			_Refill_upper();
; 1377 : 		else if (2 * _Nx <= this->_Idx)

  0004e	3d e0 04 00 00	 cmp	 eax, 1248		; 000004e0H
  00053	0f 82 bb 00 00
	00		 jb	 $LN4@operator

; 1401 : 		for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix)

  00059	53		 push	 ebx
  0005a	8d b7 c4 09 00
	00		 lea	 esi, DWORD PTR [edi+2500]
  00060	bb e3 00 00 00	 mov	 ebx, 227		; 000000e3H
$LL14@operator:

; 1402 : 			{	// fill in lower region
; 1403 : 			_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK)
; 1404 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00065	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00068	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0006b	33 4e fc	 xor	 ecx, DWORD PTR [esi-4]
  0006e	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  00074	33 4e fc	 xor	 ecx, DWORD PTR [esi-4]

; 1405 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00077	8b c1		 mov	 eax, ecx
  00079	24 01		 and	 al, 1
  0007b	0f b6 c0	 movzx	 eax, al
  0007e	f7 d8		 neg	 eax
  00080	1b c0		 sbb	 eax, eax
  00082	d1 e9		 shr	 ecx, 1
  00084	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00089	33 86 30 06 00
	00		 xor	 eax, DWORD PTR [esi+1584]
  0008f	33 c1		 xor	 eax, ecx
  00091	89 86 3c f6 ff
	ff		 mov	 DWORD PTR [esi-2500], eax
  00097	83 eb 01	 sub	 ebx, 1
  0009a	75 c9		 jne	 SHORT $LL14@operator

; 1406 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];
; 1407 : 			}
; 1408 : 
; 1409 : 		for (; _Ix < _Nx - 1; ++_Ix)

  0009c	8d b7 50 0d 00
	00		 lea	 esi, DWORD PTR [edi+3408]
  000a2	bb 8c 01 00 00	 mov	 ebx, 396		; 0000018cH
$LL17@operator:

; 1410 : 			{	// fill in upper region (avoids modulus operation)
; 1411 : 			_Ty _Tmp = (this->_Ax[_Ix +_Nx] & _HMSK)
; 1412 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  000a7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a9	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  000ac	33 0e		 xor	 ecx, DWORD PTR [esi]
  000ae	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  000b4	33 4e fc	 xor	 ecx, DWORD PTR [esi-4]

; 1413 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  000b7	8b c1		 mov	 eax, ecx
  000b9	24 01		 and	 al, 1
  000bb	0f b6 c0	 movzx	 eax, al
  000be	f7 d8		 neg	 eax
  000c0	1b c0		 sbb	 eax, eax
  000c2	d1 e9		 shr	 ecx, 1
  000c4	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  000c9	33 86 b0 f2 ff
	ff		 xor	 eax, DWORD PTR [esi-3408]
  000cf	33 c1		 xor	 eax, ecx
  000d1	89 86 3c f6 ff
	ff		 mov	 DWORD PTR [esi-2500], eax
  000d7	83 eb 01	 sub	 ebx, 1
  000da	75 cb		 jne	 SHORT $LL17@operator

; 1414 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1415 : 			}
; 1416 : 
; 1417 : 		_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

  000dc	8b 8f 80 13 00
	00		 mov	 ecx, DWORD PTR [edi+4992]
  000e2	33 4f 04	 xor	 ecx, DWORD PTR [edi+4]
  000e5	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  000eb	33 8f 80 13 00
	00		 xor	 ecx, DWORD PTR [edi+4992]

; 1418 : 		this->_Ax[_Ix] = (_Tmp >> 1)

  000f1	8b c1		 mov	 eax, ecx
  000f3	24 01		 and	 al, 1
  000f5	0f b6 c0	 movzx	 eax, al
  000f8	f7 d8		 neg	 eax
  000fa	1b c0		 sbb	 eax, eax
  000fc	d1 e9		 shr	 ecx, 1
  000fe	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00103	33 87 34 06 00
	00		 xor	 eax, DWORD PTR [edi+1588]
  00109	33 c1		 xor	 eax, ecx
  0010b	89 87 c0 09 00
	00		 mov	 DWORD PTR [edi+2496], eax

; 1419 : 			^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];
; 1420 : 		this->_Idx = 0;

  00111	89 1f		 mov	 DWORD PTR [edi], ebx
  00113	5b		 pop	 ebx
$LN4@operator:

; 1378 : 			_Refill_lower();
; 1379 : 
; 1380 : 		_Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

  00114	8b 07		 mov	 eax, DWORD PTR [edi]
  00116	8b 54 87 04	 mov	 edx, DWORD PTR [edi+eax*4+4]
  0011a	40		 inc	 eax
  0011b	89 07		 mov	 DWORD PTR [edi], eax

; 1381 : 		_Res ^= (_Res >> _Ux) & _Dxval;

  0011d	8b ca		 mov	 ecx, edx
  0011f	8b 87 84 13 00
	00		 mov	 eax, DWORD PTR [edi+4996]
  00125	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  00128	23 c1		 and	 eax, ecx
  0012a	33 d0		 xor	 edx, eax

; 1382 : 		_Res ^= (_Res << _Sx) & _Bx;

  0012c	8b c2		 mov	 eax, edx
  0012e	25 ad 58 3a ff	 and	 eax, -12953427		; ff3a58adH
  00133	c1 e0 07	 shl	 eax, 7
  00136	33 d0		 xor	 edx, eax

; 1383 : 		_Res ^= (_Res << _Tx) & _Cx;

  00138	8b c2		 mov	 eax, edx
  0013a	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  0013f	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  00142	33 d0		 xor	 edx, eax

; 1384 : 		_Res ^= (_Res & _WMSK) >> _Lx;

  00144	8b c2		 mov	 eax, edx
  00146	c1 e8 12	 shr	 eax, 18			; 00000012H

; 1385 : 		return (_Res);

  00149	5f		 pop	 edi
  0014a	33 c2		 xor	 eax, edx
  0014c	5e		 pop	 esi

; 1386 : 		}

  0014d	c3		 ret	 0
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>, COMDAT
; _this$ = ecx

; 1545 : 		{	// construct with default seed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1337 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00003	8b 55 08	 mov	 edx, DWORD PTR __X0$[ebp]

; 1545 : 		{	// construct with default seed

  00006	56		 push	 esi
  00007	57		 push	 edi

; 1321 : 		: _Dxval(_Dxarg)

  00008	c7 81 84 13 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+4996], -1
  00012	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]

; 1337 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00015	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1321 : 		: _Dxval(_Dxarg)

  00018	be 01 00 00 00	 mov	 esi, 1
  0001d	0f 1f 00	 npad	 3
$LL8@mersenne_t:

; 1339 : 			_Prev = this->_Ax[_Ix] =

  00020	8b c2		 mov	 eax, edx
  00022	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00025	c1 e8 1e	 shr	 eax, 30			; 0000001eH
  00028	33 c2		 xor	 eax, edx
  0002a	69 d0 65 89 07
	6c		 imul	 edx, eax, 1812433253
  00030	03 d6		 add	 edx, esi
  00032	46		 inc	 esi
  00033	89 57 fc	 mov	 DWORD PTR [edi-4], edx
  00036	81 fe 70 02 00
	00		 cmp	 esi, 624		; 00000270H
  0003c	7c e2		 jl	 SHORT $LL8@mersenne_t

; 1546 : 		}

  0003e	5f		 pop	 edi

; 1341 : 		this->_Idx = _Nx;

  0003f	c7 01 70 02 00
	00		 mov	 DWORD PTR [ecx], 624	; 00000270H

; 1546 : 		}

  00045	8b c1		 mov	 eax, ecx
  00047	5e		 pop	 esi
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$dead$ = 12					; size = 4
__Count$dead$ = 16					; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$dead$ = ecx

; 3482 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 3698 : 		_My_data._Mysize = 0;

  00007	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0000e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00015	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  00018	a1 10 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0001d	83 f8 05	 cmp	 eax, 5
  00020	72 32		 jb	 SHORT $LN61@substr

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00022	83 c0 fb	 add	 eax, -5			; fffffffbH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00025	83 ca ff	 or	 edx, -1
  00028	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0002b	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00030	0f 42 d0	 cmovb	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00033	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0003a	52		 push	 edx

; 1607 : 		if (_Large_string_engaged())

  0003b	0f 43 0d 00 00
	00 00		 cmovae	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00042	83 c1 05	 add	 ecx, 5
  00045	51		 push	 ecx
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3483 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi

; 3484 : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN61@substr:

; 1624 : 			_Xran();

  00054	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN63@substr:
$LN60@substr:
  00059	cc		 int	 3
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z
_TEXT	SEGMENT
__Possible_matches_end$1$ = -8				; size = 4
__Result$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Off$dead$ = 12					; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 3271 : 		{	// look for [_Ptr, <null>) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00008	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  0000b	8b de		 mov	 ebx, esi
  0000d	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
$LL42@find:
  00010	8a 03		 mov	 al, BYTE PTR [ebx]
  00012	43		 inc	 ebx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL42@find
  00017	2b da		 sub	 ebx, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00019	89 4d fc	 mov	 DWORD PTR __Result$1$[ebp], ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0001c	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00020	8b d1		 mov	 edx, ecx

; 1607 : 		if (_Large_string_engaged())

  00022	72 05		 jb	 SHORT $LN13@find
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	89 55 fc	 mov	 DWORD PTR __Result$1$[ebp], edx
$LN13@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  00029	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0002c	3b d8		 cmp	 ebx, eax
  0002e	0f 87 c4 00 00
	00		 ja	 $LN24@find

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)

  00034	85 db		 test	 ebx, ebx
  00036	75 0a		 jne	 SHORT $LN25@find

; 3273 : 		return (static_cast<size_type>(

  00038	5e		 pop	 esi
  00039	33 c0		 xor	 eax, eax

; 3274 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3275 : 		}

  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN25@find:

; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00042	2b c3		 sub	 eax, ebx
  00044	40		 inc	 eax
  00045	03 c2		 add	 eax, edx
  00047	89 45 f8	 mov	 DWORD PTR __Possible_matches_end$1$[ebp], eax

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0004a	2b c2		 sub	 eax, edx
  0004c	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0004d	50		 push	 eax
  0004e	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00051	50		 push	 eax
  00052	52		 push	 edx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  00059	8b f8		 mov	 edi, eax
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  0005e	85 ff		 test	 edi, edi
  00060	0f 84 78 00 00
	00		 je	 $LN37@find
$LL22@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00066	8b c3		 mov	 eax, ebx
  00068	8b d7		 mov	 edx, edi
  0006a	83 e8 04	 sub	 eax, 4
  0006d	72 12		 jb	 SHORT $LN45@find
  0006f	90		 npad	 1
$LL46@find:
  00070	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00072	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  00074	75 10		 jne	 SHORT $LN44@find
  00076	83 c2 04	 add	 edx, 4
  00079	83 c6 04	 add	 esi, 4
  0007c	83 e8 04	 sub	 eax, 4
  0007f	73 ef		 jae	 SHORT $LL46@find
$LN45@find:
  00081	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  00084	74 34		 je	 SHORT $LN43@find
$LN44@find:
  00086	8a 0a		 mov	 cl, BYTE PTR [edx]
  00088	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0008a	75 27		 jne	 SHORT $LN47@find
  0008c	83 f8 fd	 cmp	 eax, -3			; fffffffdH
  0008f	74 29		 je	 SHORT $LN43@find
  00091	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  00094	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00097	75 1a		 jne	 SHORT $LN47@find
  00099	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  0009c	74 1c		 je	 SHORT $LN43@find
  0009e	8a 4a 02	 mov	 cl, BYTE PTR [edx+2]
  000a1	3a 4e 02	 cmp	 cl, BYTE PTR [esi+2]
  000a4	75 0d		 jne	 SHORT $LN47@find
  000a6	83 f8 ff	 cmp	 eax, -1
  000a9	74 0f		 je	 SHORT $LN43@find
  000ab	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  000ae	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  000b1	74 07		 je	 SHORT $LN43@find
$LN47@find:
  000b3	1b c0		 sbb	 eax, eax
  000b5	83 c8 01	 or	 eax, 1
  000b8	eb 02		 jmp	 SHORT $LN48@find
$LN43@find:
  000ba	33 c0		 xor	 eax, eax
$LN48@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  000bc	85 c0		 test	 eax, eax
  000be	74 2a		 je	 SHORT $LN38@find

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  000c0	8b 45 f8	 mov	 eax, DWORD PTR __Possible_matches_end$1$[ebp]
  000c3	47		 inc	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  000c4	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  000c7	2b c7		 sub	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  000c9	50		 push	 eax
  000ca	0f be 06	 movsx	 eax, BYTE PTR [esi]
  000cd	50		 push	 eax
  000ce	57		 push	 edi
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  000d5	8b f8		 mov	 edi, eax
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  000da	85 ff		 test	 edi, edi
  000dc	75 88		 jne	 SHORT $LL22@find
$LN37@find:
  000de	5f		 pop	 edi

; 3274 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3275 : 		}

  000df	5e		 pop	 esi
  000e0	83 c8 ff	 or	 eax, -1
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 08 00	 ret	 8
$LN38@find:

; 85   : 			return (_Match_try - _Haystack);

  000ea	2b 7d fc	 sub	 edi, DWORD PTR __Result$1$[ebp]

; 3273 : 		return (static_cast<size_type>(

  000ed	8b c7		 mov	 eax, edi
  000ef	5f		 pop	 edi

; 3274 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3275 : 		}

  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 08 00	 ret	 8
$LN24@find:
  000f8	5e		 pop	 esi
  000f9	83 c8 ff	 or	 eax, -1
  000fc	5b		 pop	 ebx
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3062 : 		return (this->_Get_data()._Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 3063 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00004	72 03		 jb	 SHORT $LN16@c_str

; 3040 : 		return (this->_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3041 : 		}

  00008	c3		 ret	 0
$LN16@c_str:

; 3040 : 		return (this->_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 3041 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2974 : 		{	// subscript immutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2977 : 		return (_My_data._Myptr()[_Off]);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]

; 1607 : 		if (_Large_string_engaged())

  0000a	72 02		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN16@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2977 : 		return (_My_data._Myptr()[_Off]);

  0000e	03 c1		 add	 eax, ecx

; 2978 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2967 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2970 : 		return (_My_data._Myptr()[_Off]);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]

; 1596 : 		if (_Large_string_engaged())

  0000a	72 02		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN16@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2970 : 		return (_My_data._Myptr()[_Off]);

  0000e	03 c1		 add	 eax, ecx

; 2971 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  00004	8b d1		 mov	 edx, ecx

; 1596 : 		if (_Large_string_engaged())

  00006	72 02		 jb	 SHORT $LN10@Unchecked_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
$LN10@Unchecked_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0000a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000d	03 c2		 add	 eax, edx

; 2877 : 		}

  0000f	c3		 ret	 0
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00004	72 03		 jb	 SHORT $LN16@Unchecked_

; 2865 : 		return (this->_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2866 : 		}

  00008	c3		 ret	 0
$LN16@Unchecked_:

; 2865 : 		return (this->_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 2866 : 		}

  0000b	c3		 ret	 0
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2614 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]

; 1622 : 		if (_Mysize < _Off)

  0000e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00011	3b cb		 cmp	 ecx, ebx
  00013	72 36		 jb	 SHORT $LN30@erase

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00015	8b c1		 mov	 eax, ecx
  00017	2b c3		 sub	 eax, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00019	3b c7		 cmp	 eax, edi
  0001b	0f 42 f8	 cmovb	 edi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0001e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  00022	8b c6		 mov	 eax, esi

; 1596 : 		if (_Large_string_engaged())

  00024	72 02		 jb	 SHORT $LN20@erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00026	8b 06		 mov	 eax, DWORD PTR [esi]
$LN20@erase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00028	2b cf		 sub	 ecx, edi
  0002a	8d 14 03	 lea	 edx, DWORD PTR [ebx+eax]

; 2622 : 		_My_data._Mysize = _New_size;

  0002d	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00030	2b cb		 sub	 ecx, ebx
  00032	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00033	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00034	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2624 : 		return (*this);

  00042	8b c6		 mov	 eax, esi
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx

; 2625 : 		}

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
$LN30@erase:

; 1624 : 			_Xran();

  0004b	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN32@erase:
$LN29@erase:
  00050	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2370 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2370 : 		{	// append [_Ptr, <null>)

  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00009	8b fa		 mov	 edi, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2370 : 		{	// append [_Ptr, <null>)

  0000b	8b d9		 mov	 ebx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0000d	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL30@append:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL30@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00017	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0001a	2b f9		 sub	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2350 : 		const size_type _Old_size = _My_data._Mysize;

  0001c	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  0001f	8b c6		 mov	 eax, esi
  00021	2b c1		 sub	 eax, ecx
  00023	3b f8		 cmp	 edi, eax
  00025	77 2b		 ja	 SHORT $LN9@append

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  0002d	8b c3		 mov	 eax, ebx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0002f	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00032	72 02		 jb	 SHORT $LN18@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00034	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN18@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00036	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0003a	52		 push	 edx
  0003b	56		 push	 esi
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00045	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00049	8b c3		 mov	 eax, ebx

; 2372 : 		}

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN9@append:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  00052	57		 push	 edi
  00053	52		 push	 edx
  00054	c6 45 08 00	 mov	 BYTE PTR $T5[ebp], 0
  00058	8b cb		 mov	 ecx, ebx
  0005a	ff 75 08	 push	 DWORD PTR $T5[ebp]
  0005d	57		 push	 edi
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>

; 2372 : 		}

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2319 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 2319 : 		{	// append _Right

  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00009	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2319 : 		{	// append _Right

  0000d	8b f9		 mov	 edi, ecx

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0000f	8b c8		 mov	 ecx, eax

; 1607 : 		if (_Large_string_engaged())

  00011	72 02		 jb	 SHORT $LN10@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN10@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00015	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00018	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  0001b	8b c6		 mov	 eax, esi
  0001d	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00020	2b c2		 sub	 eax, edx
  00022	3b d8		 cmp	 ebx, eax
  00024	77 2b		 ja	 SHORT $LN17@append

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  00026	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  00029	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  0002c	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0002e	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00031	72 02		 jb	 SHORT $LN26@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00033	8b 07		 mov	 eax, DWORD PTR [edi]
$LN26@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00035	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00036	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00039	51		 push	 ecx
  0003a	56		 push	 esi
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00044	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00048	8b c7		 mov	 eax, edi

; 2322 : 		}

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN17@append:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  00051	53		 push	 ebx
  00052	51		 push	 ecx
  00053	c6 45 08 00	 mov	 BYTE PTR $T5[ebp], 0
  00057	8b cf		 mov	 ecx, edi
  00059	ff 75 08	 push	 DWORD PTR $T5[ebp]
  0005c	53		 push	 ebx
  0005d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>

; 2322 : 		}

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
$T3 = -4						; size = 1
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2313 : 		{	// append 1 * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  00007	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 2992 : 		if (_Old_size < _My_data._Myres)

  0000a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000d	3b d1		 cmp	 edx, ecx
  0000f	73 23		 jae	 SHORT $LN4@operator

; 2993 : 			{
; 2994 : 			_My_data._Mysize = _Old_size + 1;

  00011	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00014	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00017	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00019	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  0001c	72 02		 jb	 SHORT $LN13@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
$LN13@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00020	8a 4d 08	 mov	 cl, BYTE PTR __Ch$[ebp]
  00023	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00026	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2315 : 		return (*this);

  0002b	8b c6		 mov	 eax, esi

; 2316 : 		}

  0002d	5e		 pop	 esi
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@operator:

; 3001 : 		_Reallocate_grow_by(1,

  00034	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00037	c6 45 fc 00	 mov	 BYTE PTR $T3[ebp], 0
  0003b	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0003e	51		 push	 ecx
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>

; 2315 : 		return (*this);

  00046	8b c6		 mov	 eax, esi

; 2316 : 		}

  00048	5e		 pop	 esi
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2308 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2308 : 		{	// append [_Ptr, <null>)

  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00009	8b fa		 mov	 edi, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2308 : 		{	// append [_Ptr, <null>)

  0000b	8b d9		 mov	 ebx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0000d	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL32@operator:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL32@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00017	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0001a	2b f9		 sub	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2350 : 		const size_type _Old_size = _My_data._Mysize;

  0001c	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  0001f	8b c6		 mov	 eax, esi
  00021	2b c1		 sub	 eax, ecx
  00023	3b f8		 cmp	 edi, eax
  00025	77 2b		 ja	 SHORT $LN11@operator

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  0002d	8b c3		 mov	 eax, ebx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0002f	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00032	72 02		 jb	 SHORT $LN20@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00034	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN20@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00036	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0003a	52		 push	 edx
  0003b	56		 push	 esi
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00045	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2309 : 		return (append(_Ptr));

  00049	8b c3		 mov	 eax, ebx

; 2310 : 		}

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN11@operator:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  00052	57		 push	 edi
  00053	52		 push	 edx
  00054	c6 45 08 00	 mov	 BYTE PTR $T5[ebp], 0
  00058	8b cb		 mov	 ecx, ebx
  0005a	ff 75 08	 push	 DWORD PTR $T5[ebp]
  0005d	57		 push	 edi
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>

; 2310 : 		}

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$dead$ = ecx

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00000	6a 05		 push	 5
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0000c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2282 : 		return (assign(_Ptr));
; 2283 : 		}

  00011	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2252 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2253 : 		if (this != _STD addressof(_Right))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 15		 je	 SHORT $LN27@operator

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0000d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00011	8b c8		 mov	 ecx, eax

; 1607 : 		if (_Large_string_engaged())

  00013	72 02		 jb	 SHORT $LN21@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN21@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00017	ff 70 10	 push	 DWORD PTR [eax+16]
  0001a	51		 push	 ecx
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN27@operator:

; 2268 : 			}
; 2269 : 
; 2270 : 		return (*this);

  00022	8b c6		 mov	 eax, esi

; 2271 : 		}

  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2245 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  00009	72 2d		 jb	 SHORT $LN27@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0000b	8b 16		 mov	 edx, DWORD PTR [esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0000d	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 1a		 jb	 SHORT $LN30@basic_stri

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00015	f6 c2 1f	 test	 dl, 31			; 0000001fH
  00018	75 31		 jne	 SHORT $_Invalid_parameter$49

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001a	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0001d	3b c2		 cmp	 eax, edx
  0001f	73 2a		 jae	 SHORT $_Invalid_parameter$49

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00021	2b d0		 sub	 edx, eax
  00023	83 fa 04	 cmp	 edx, 4
  00026	72 23		 jb	 SHORT $_Invalid_parameter$49

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00028	83 fa 23	 cmp	 edx, 35			; 00000023H
  0002b	77 1e		 ja	 SHORT $_Invalid_parameter$49

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002d	8b d0		 mov	 edx, eax
$LN30@basic_stri:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4
$LN27@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00038	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00046	c6 06 00	 mov	 BYTE PTR [esi], 0
  00049	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2247 : 		}

  0004a	c3		 ret	 0
$_Invalid_parameter$49:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN48@basic_stri:
$LN47@basic_stri:
  00051	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2085 : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 2086 : 		if (this != _STD addressof(_Right))

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 67		 je	 SHORT $LN93@operator

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0000e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00011	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  00014	72 2d		 jb	 SHORT $LN31@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00016	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00018	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00019	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001e	72 1a		 jb	 SHORT $LN34@operator

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00020	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00023	75 58		 jne	 SHORT $_Invalid_parameter$98

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00025	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00028	3b c1		 cmp	 eax, ecx
  0002a	73 51		 jae	 SHORT $_Invalid_parameter$98

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0002c	2b c8		 sub	 ecx, eax
  0002e	83 f9 04	 cmp	 ecx, 4
  00031	72 4a		 jb	 SHORT $_Invalid_parameter$98

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00033	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00036	77 45		 ja	 SHORT $_Invalid_parameter$98

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00038	8b c8		 mov	 ecx, eax
$LN34@operator:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00040	83 c4 04	 add	 esp, 4
$LN31@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00043	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0004a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00051	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00054	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00057	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0005a	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  0005f	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00064	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0006b	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00072	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN93@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2097 : 		return (*this);

  00075	5f		 pop	 edi
  00076	8b c6		 mov	 eax, esi
  00078	5e		 pop	 esi

; 2098 : 		}

  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
$_Invalid_parameter$98:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN97@operator:
$LN96@operator:
  00083	cc		 int	 3
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2054 : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 1576 : 		_Mysize(0),

  00006	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1577 : 		_Myres(0)

  0000d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00014	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00017	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0001a	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001f	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00024	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0002b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00032	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2056 : 		}

  00035	8b c1		 mov	 eax, ecx
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
__Ch$dead$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1991 : 		{	// construct from _Count * _Ch

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1993 : 		assign(_Count, _Ch);

  00003	83 ec 08	 sub	 esp, 8

; 3698 : 		_My_data._Mysize = 0;

  00006	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00014	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1993 : 		assign(_Count, _Ch);

  00017	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1994 : 		}

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1977 : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1977 : 		{	// construct from [_Ptr, <null>)

  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0000f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00016	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0001d	c6 06 00	 mov	 BYTE PTR [esi], 0
$LL30@basic_stri:

; 480  : 		return (_CSTD strlen(_First));

  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL30@basic_stri
  00027	2b c7		 sub	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00029	8b ce		 mov	 ecx, esi
  0002b	50		 push	 eax
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1978 : 		_Tidy_init();
; 1979 : 		assign(_Ptr);
; 1980 : 		}

  00032	5f		 pop	 edi
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1962 : 		{	// construct from [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1964 : 		assign(_Ptr, _Count);

  00004	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3698 : 		_My_data._Mysize = 0;

  0000c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00013	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0001a	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1964 : 		assign(_Ptr, _Count);

  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1965 : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3698 : 		_My_data._Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1938 : 		}

  00007	8b c1		 mov	 eax, ecx

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00009	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1938 : 		}

  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__New_capacity$1$ = -4					; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1924 : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi
  00009	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]

; 1576 : 		_Mysize(0),

  0000c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1577 : 		_Myres(0)

  00013	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0001a	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 2186 : 		const size_type _Right_size = _Right_data._Mysize;

  0001e	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]

; 1607 : 		if (_Large_string_engaged())

  00021	72 02		 jb	 SHORT $LN39@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00023	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN39@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2188 : 		if (_Right_size < this->_BUF_SIZE)

  00025	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00028	73 1b		 jae	 SHORT $LN24@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0002a	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1926 : 		}

  0002d	5f		 pop	 edi
  0002e	8b c6		 mov	 eax, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00030	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2201 : 		_My_data._Mysize = _Right_size;

  00033	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 1926 : 		}

  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN24@basic_stri:

; 2197 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  00045	8b c3		 mov	 eax, ebx
  00047	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  0004c	83 c8 0f	 or	 eax, 15			; 0000000fH
  0004f	3b c1		 cmp	 eax, ecx
  00051	0f 47 c1	 cmova	 eax, ecx
  00054	89 45 fc	 mov	 DWORD PTR __New_capacity$1$[ebp], eax

; 2198 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  00057	83 c0 01	 add	 eax, 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  0005a	75 04		 jne	 SHORT $LN81@basic_stri

; 53   : 		{
; 54   : 		return (_Ptr);

  0005c	33 d2		 xor	 edx, edx
  0005e	eb 3d		 jmp	 SHORT $LN80@basic_stri
$LN81@basic_stri:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00060	32 c9		 xor	 cl, cl
  00062	74 06		 je	 SHORT $LN82@basic_stri

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN109@basic_stri:
$LN82@basic_stri:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0006a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0006f	72 21		 jb	 SHORT $LN83@basic_stri

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00071	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00074	3b c8		 cmp	 ecx, eax
  00076	77 06		 ja	 SHORT $LN84@basic_stri

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN110@basic_stri:
$LN84@basic_stri:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00084	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00087	8d 50 23	 lea	 edx, DWORD PTR [eax+35]
  0008a	83 e2 e0	 and	 edx, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0008d	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  00090	eb 0b		 jmp	 SHORT $LN80@basic_stri
$LN83@basic_stri:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00098	83 c4 04	 add	 esp, 4

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);

  0009b	8b d0		 mov	 edx, eax
$LN80@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2200 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  0009d	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000a0	89 16		 mov	 DWORD PTR [esi], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000a2	51		 push	 ecx
  000a3	57		 push	 edi
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2202 : 		_My_data._Myres = _New_capacity;

  000aa	8b 45 fc	 mov	 eax, DWORD PTR __New_capacity$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2202 : 		_My_data._Myres = _New_capacity;

  000b0	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1926 : 		}

  000b3	8b c6		 mov	 eax, esi

; 2201 : 		_My_data._Mysize = _Right_size;

  000b5	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 1926 : 		}

  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c2 04 00	 ret	 4
$LN108@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 1380 : 		{	// close the C stream

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 361  : 		if (_Myfile == 0)

  00005	83 7f 64 00	 cmp	 DWORD PTR [edi+100], 0
  00009	75 04		 jne	 SHORT $LN5@close

; 362  : 			_Ans = 0;

  0000b	33 db		 xor	 ebx, ebx

; 363  : 		else

  0000d	eb 25		 jmp	 SHORT $LN8@close
$LN5@close:

; 364  : 			{	// put any homing sequence and close file
; 365  : 			if (!_Endwrite())

  0000f	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00012	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 366  : 				_Ans = 0;
; 367  : 			if (fclose(_Myfile) != 0)

  00017	ff 77 64	 push	 DWORD PTR [edi+100]
  0001a	33 c9		 xor	 ecx, ecx
  0001c	8d 5f 18	 lea	 ebx, DWORD PTR [edi+24]
  0001f	84 c0		 test	 al, al
  00021	0f 44 d9	 cmove	 ebx, ecx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0002a	33 c9		 xor	 ecx, ecx
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	0f 45 d9	 cmovne	 ebx, ecx
$LN8@close:

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00034	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00037	c6 47 60 00	 mov	 BYTE PTR [edi+96], 0
  0003b	c6 47 55 00	 mov	 BYTE PTR [edi+85], 0
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;
; 652  : 		_State = _Stinit;

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  0004a	89 47 58	 mov	 DWORD PTR [edi+88], eax
  0004d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  00052	c7 47 64 00 00
	00 00		 mov	 DWORD PTR [edi+100], 0
  00059	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  0005c	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0

; 1381 : 		if (_Filebuffer.close() == 0)

  00063	85 db		 test	 ebx, ebx
  00065	75 10		 jne	 SHORT $LN2@close

; 1382 : 			_Myios::setstate(ios_base::failbit);

  00067	8b 07		 mov	 eax, DWORD PTR [edi]
  00069	53		 push	 ebx
  0006a	6a 02		 push	 2
  0006c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006f	03 cf		 add	 ecx, edi
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN2@close:

; 1383 : 	}

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	c3		 ret	 0
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
_TEXT	SEGMENT
__Filename$dead$ = 8					; size = 4
__Mode$ = 12						; size = 4
__Prot$dead$ = 16					; size = 4
?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 1358 : 		{	// open a C stream with specified mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00004	51		 push	 ecx
  00005	ff 75 0c	 push	 DWORD PTR __Mode$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  0000f	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00012	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00017	85 c0		 test	 eax, eax

; 1360 : 			_Myios::setstate(ios_base::failbit);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	6a 00		 push	 0
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	75 0f		 jne	 SHORT $LN2@open
  00022	6a 02		 push	 2
  00024	03 ce		 add	 ecx, esi
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1363 : 		}

  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@open:

; 1361 : 		else
; 1362 : 			_Myios::clear();	// added with C++11

  00031	6a 00		 push	 0
  00033	03 ce		 add	 ecx, esi
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1363 : 		}

  0003b	5e		 pop	 esi
  0003c	5d		 pop	 ebp
  0003d	c2 0c 00	 ret	 12			; 0000000cH
?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1342 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 88	 mov	 eax, DWORD PTR [esi-120]

; 1343 : 		}

  00006	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 88 00
	00 00 00	 mov	 DWORD PTR [eax+esi-120], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 88	 mov	 eax, DWORD PTR [esi-120]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 88	 lea	 eax, DWORD PTR [edx-120]
  0001d	89 44 32 84	 mov	 DWORD PTR [edx+esi-124], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  00029	5e		 pop	 esi
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$GSCopy$ = -20					; size = 4
$T1 = -16						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_$initVBases$dead$ = 8					; size = 4
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1196 : 		{	// construct unopened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00033	8d 4f 78	 lea	 ecx, DWORD PTR [edi+120]
  00036	89 7d ec	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00039	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0003f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  0004c	6a 00		 push	 0
  0004e	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00058	56		 push	 esi
  00059	8b cf		 mov	 ecx, edi
  0005b	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00068	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0006f	8b 07		 mov	 eax, DWORD PTR [edi]
  00071	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00074	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  0007b	8b 07		 mov	 eax, DWORD PTR [edi]
  0007d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00080	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  00083	8d 41 88	 lea	 eax, DWORD PTR [ecx-120]
  00086	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax

; 155  : 		: _Mysb()

  0008a	8b ce		 mov	 ecx, esi
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00092	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00096	8b ce		 mov	 ecx, esi

; 156  : 		{	// construct from pointer to C stream

  00098	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 625  : 		_Closef = _Which == _Openfl;

  0009e	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0

; 626  : 		_Wrotesome = false;

  000a2	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;
; 652  : 		_State = _Stinit;

  000ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 1197 : 		}

  000b2	8b c7		 mov	 eax, edi

; 652  : 		_State = _Stinit;

  000b4	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  000b7	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000bd	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  000c4	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c7	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 1197 : 		}

  000ce	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d8	59		 pop	 ecx
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 10 00 00
	00		 je	 $LN5@basic_fstr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00013	83 c1 78	 add	 ecx, 120		; 00000078H
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_fstr:
  0001c	c3		 ret	 0
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1:
  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00020	83 c1 20	 add	 ecx, 32			; 00000020H
  00023	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3:
  00029	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00032	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00036	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00039	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
_TEXT	SEGMENT
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$dead$ = 16					; size = 4
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 1137 : 		{	// open a C stream with specified mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Mode$[ebp]
  00006	56		 push	 esi
  00007	51		 push	 ecx
  00008	8b f1		 mov	 esi, ecx
  0000a	83 c8 02	 or	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Filename$[ebp]
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00019	85 c0		 test	 eax, eax

; 1139 : 			_Myios::setstate(ios_base::failbit);

  0001b	8b 06		 mov	 eax, DWORD PTR [esi]
  0001d	6a 00		 push	 0
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	75 0f		 jne	 SHORT $LN2@open
  00024	6a 02		 push	 2
  00026	03 ce		 add	 ecx, esi
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1142 : 		}

  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
$LN2@open:

; 1140 : 		else
; 1141 : 			_Myios::clear();	// added with C++11

  00033	6a 00		 push	 0
  00035	03 ce		 add	 ecx, esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1142 : 		}

  0003d	5e		 pop	 esi
  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1121 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 98	 mov	 eax, DWORD PTR [esi-104]

; 1122 : 		}

  00006	8d 4e 9c	 lea	 ecx, DWORD PTR [esi-100]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  0001d	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00029	5e		 pop	 esi
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$GSCopy$ = -20					; size = 4
$T1 = -16						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_$initVBases$dead$ = 8					; size = 4
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 975  : 		{	// construct unopened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00033	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]
  00036	89 7d ec	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00039	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00053	56		 push	 esi
  00054	8b cf		 mov	 ecx, edi
  00056	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00063	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0006a	8b 07		 mov	 eax, DWORD PTR [edi]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00076	8b 07		 mov	 eax, DWORD PTR [edi]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  0007e	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00081	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax

; 155  : 		: _Mysb()

  00085	8b ce		 mov	 ecx, esi
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0008d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00091	8b ce		 mov	 ecx, esi

; 156  : 		{	// construct from pointer to C stream

  00093	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 625  : 		_Closef = _Which == _Openfl;

  00099	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0

; 626  : 		_Wrotesome = false;

  0009d	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;
; 652  : 		_State = _Stinit;

  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 976  : 		}

  000ad	8b c7		 mov	 eax, edi

; 652  : 		_State = _Stinit;

  000af	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  000b2	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000b8	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  000bf	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c2	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 976  : 		}

  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 10 00 00
	00		 je	 $LN5@basic_ofst
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_ofst:
  0001c	c3		 ret	 0
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1:
  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00020	83 c1 08	 add	 ecx, 8
  00023	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3:
  00029	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00032	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00036	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00039	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
_TEXT	SEGMENT
__Filename$dead$ = 8					; size = 4
__Mode$dead$ = 12					; size = 4
__Prot$dead$ = 16					; size = 4
?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 921  : 		{	// open a C stream with specified mode

  00000	56		 push	 esi

; 922  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00001	51		 push	 ecx
  00002	8b f1		 mov	 esi, ecx
  00004	6a 01		 push	 1
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COFBHHKL@setting?4txt?$AA@
  0000b	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  0000e	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00013	85 c0		 test	 eax, eax

; 923  : 			_Myios::setstate(ios_base::failbit);

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	6a 00		 push	 0
  00019	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001c	75 0e		 jne	 SHORT $LN2@open
  0001e	6a 02		 push	 2
  00020	03 ce		 add	 ecx, esi
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 926  : 		}

  00028	5e		 pop	 esi
  00029	c2 0c 00	 ret	 12			; 0000000cH
$LN2@open:

; 924  : 		else
; 925  : 			_Myios::clear();	// added with C++11

  0002c	6a 00		 push	 0
  0002e	03 ce		 add	 ecx, esi
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 926  : 		}

  00036	5e		 pop	 esi
  00037	c2 0c 00	 ret	 12			; 0000000cH
?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 905  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 90	 mov	 eax, DWORD PTR [esi-112]

; 906  : 		}

  00006	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 90 00
	00 00 00	 mov	 DWORD PTR [eax+esi-112], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 90	 mov	 eax, DWORD PTR [esi-112]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 90	 lea	 eax, DWORD PTR [edx-112]
  0001d	89 44 32 8c	 mov	 DWORD PTR [edx+esi-116], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  00029	5e		 pop	 esi
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$GSCopy$ = -20					; size = 4
$T1 = -16						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_$initVBases$dead$ = 8					; size = 4
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 759  : 		{	// construct unopened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00033	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  00036	89 7d ec	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00039	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00053	56		 push	 esi
  00054	8b cf		 mov	 ecx, edi
  00056	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00063	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0006a	8b 07		 mov	 eax, DWORD PTR [edi]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00076	8b 07		 mov	 eax, DWORD PTR [edi]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  0007e	8d 41 90	 lea	 eax, DWORD PTR [ecx-112]
  00081	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax

; 155  : 		: _Mysb()

  00085	8b ce		 mov	 ecx, esi
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0008d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00091	8b ce		 mov	 ecx, esi

; 156  : 		{	// construct from pointer to C stream

  00093	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 625  : 		_Closef = _Which == _Openfl;

  00099	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0

; 626  : 		_Wrotesome = false;

  0009d	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;
; 652  : 		_State = _Stinit;

  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 760  : 		}

  000ad	8b c7		 mov	 eax, edi

; 652  : 		_State = _Stinit;

  000af	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  000b2	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000b8	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  000bf	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c2	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 760  : 		}

  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 10 00 00
	00		 je	 $LN5@basic_ifst
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00013	83 c1 70	 add	 ecx, 112		; 00000070H
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_ifst:
  0001c	c3		 ret	 0
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1:
  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00020	83 c1 18	 add	 ecx, 24			; 00000018H
  00023	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3:
  00029	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00032	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00036	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00039	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 617  : 		{	// set locale to argument (capture nontrivial codecvt facet)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 618  : 		_Initcvt(&_USE(_Loc, _Cvt));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00009	57		 push	 edi
  0000a	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  0000f	8b f8		 mov	 edi, eax

; 699  : 		if (_Newpcvt->always_noconv())

  00011	8b cf		 mov	 ecx, edi
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
  00019	84 c0		 test	 al, al
  0001b	74 0d		 je	 SHORT $LN4@imbue

; 619  : 		}

  0001d	5f		 pop	 edi

; 700  : 			_Pcvt = 0;	// nothing to do

  0001e	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 619  : 		}

  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN4@imbue:

; 704  : 			_Mysb::_Init();	// reset any buffering

  0002a	8b ce		 mov	 ecx, esi
  0002c	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 619  : 		}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 610  : 		{	// synchronize C stream with external file

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 611  : 		return (_Myfile == 0

  00003	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00007	74 21		 je	 SHORT $LN3@sync
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	6a ff		 push	 -1
  0000d	ff 50 0c	 call	 DWORD PTR [eax+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  00010	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 611  : 		return (_Myfile == 0

  00013	74 15		 je	 SHORT $LN3@sync
  00015	ff 76 4c	 push	 DWORD PTR [esi+76]
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	79 05		 jns	 SHORT $LN3@sync
  00025	83 c8 ff	 or	 eax, -1

; 612  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 613  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 614  : 		}

  00028	5e		 pop	 esi
  00029	c3		 ret	 0
$LN3@sync:

; 611  : 		return (_Myfile == 0

  0002a	33 c0		 xor	 eax, eax

; 612  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 613  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 614  : 		}

  0002c	5e		 pop	 esi
  0002d	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
_TEXT	SEGMENT
__Nr$1 = -16						; size = 4
__Pn$2 = -12						; size = 4
__Pb$3 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 8
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 597  : 		{	// offer _Buffer to C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx
  00016	57		 push	 edi

; 598  : 		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,

  00017	8b 7e 4c	 mov	 edi, DWORD PTR [esi+76]
  0001a	85 ff		 test	 edi, edi
  0001c	0f 84 b8 00 00
	00		 je	 $LN4@setbuf
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	85 d2		 test	 edx, edx
  00027	75 0e		 jne	 SHORT $LN6@setbuf
  00029	8b c1		 mov	 eax, ecx
  0002b	0b 45 10	 or	 eax, DWORD PTR __Count$[ebp+4]
  0002e	75 07		 jne	 SHORT $LN6@setbuf
  00030	b8 04 00 00 00	 mov	 eax, 4
  00035	eb 02		 jmp	 SHORT $LN7@setbuf
$LN6@setbuf:
  00037	33 c0		 xor	 eax, eax
$LN7@setbuf:
  00039	51		 push	 ecx
  0003a	50		 push	 eax
  0003b	52		 push	 edx
  0003c	57		 push	 edi
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setvbuf
  00043	83 c4 10	 add	 esp, 16			; 00000010H
  00046	85 c0		 test	 eax, eax
  00048	0f 85 8c 00 00
	00		 jne	 $LN4@setbuf

; 599  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 600  : 			(size_t)_Count * sizeof (_Elem)) != 0)
; 601  : 			return (0);	// failed
; 602  : 		else
; 603  : 			{	// new buffer, reinitialize pointers
; 604  : 			_Init(_Myfile, _Openfl);

  0004e	8b 7e 4c	 mov	 edi, DWORD PTR [esi+76]

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00051	8b ce		 mov	 ecx, esi
  00053	c6 46 48 01	 mov	 BYTE PTR [esi+72], 1
  00057	88 46 3d	 mov	 BYTE PTR [esi+61], al
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)

  00060	85 ff		 test	 edi, edi
  00062	74 46		 je	 SHORT $LN9@setbuf

; 641  : 			::_get_stream_buffer_pointers(

  00064	8d 45 f0	 lea	 eax, DWORD PTR __Nr$1[ebp]
  00067	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Pb$3[ebp], 0
  0006e	50		 push	 eax
  0006f	8d 45 f4	 lea	 eax, DWORD PTR __Pn$2[ebp]
  00072	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Pn$2[ebp], 0
  00079	50		 push	 eax
  0007a	8d 45 f8	 lea	 eax, DWORD PTR __Pb$3[ebp]
  0007d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Nr$1[ebp], 0
  00084	50		 push	 eax
  00085	57		 push	 edi
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___get_stream_buffer_pointers
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 331  : 		_IGfirst = _Gf;

  0008c	8b 45 f8	 mov	 eax, DWORD PTR __Pb$3[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 641  : 			::_get_stream_buffer_pointers(

  0008f	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 335  : 		_IGcount = _Gc;

  00092	8b 4d f0	 mov	 ecx, DWORD PTR __Nr$1[ebp]
  00095	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00098	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0009b	8b 45 f4	 mov	 eax, DWORD PTR __Pn$2[ebp]
  0009e	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  000a1	89 46 20	 mov	 DWORD PTR [esi+32], eax
  000a4	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx

; 336  : 		_IPcount = _Pc;

  000a7	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
$LN9@setbuf:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 652  : 		_State = _Stinit;

  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 605  : 			return (this);

  000b0	8b c6		 mov	 eax, esi

; 651  : 		_Myfile = _File;

  000b2	89 7e 4c	 mov	 DWORD PTR [esi+76], edi

; 652  : 		_State = _Stinit;

  000b5	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  000b8	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4

; 606  : 			}
; 607  : 		}

  000be	5f		 pop	 edi

; 652  : 		_State = _Stinit;

  000bf	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c2	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 606  : 			}
; 607  : 		}

  000c9	5e		 pop	 esi
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cd	33 cd		 xor	 ecx, ebp
  000cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 0c 00	 ret	 12			; 0000000cH
$LN4@setbuf:
  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	33 c0		 xor	 eax, eax
  000df	5f		 pop	 edi
  000e0	33 cd		 xor	 ecx, ebp
  000e2	5e		 pop	 esi
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__Off$2$ = -20						; size = 4
__Fileposition$ = -16					; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 579  : 		{	// change position to _Pos

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 10	 mov	 DWORD PTR __$ArrayPad$[esp+20], eax

; 580  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);

  00014	8b 45 14	 mov	 eax, DWORD PTR __Pos$[ebp+8]
  00017	53		 push	 ebx

; 581  : 		off_type _Off = static_cast<off_type>(_Pos) - static_cast<off_type>(_Fileposition);

  00018	8b 5d 0c	 mov	 ebx, DWORD PTR __Pos$[ebp]
  0001b	56		 push	 esi
  0001c	8b f1		 mov	 esi, ecx
  0001e	89 44 24 0c	 mov	 DWORD PTR __Fileposition$[esp+28], eax
  00022	8b 45 18	 mov	 eax, DWORD PTR __Pos$[ebp+12]
  00025	89 44 24 10	 mov	 DWORD PTR __Fileposition$[esp+32], eax
  00029	8b 45 10	 mov	 eax, DWORD PTR __Pos$[ebp+4]

; 582  : 
; 583  : 		if (_Myfile == 0 || !_Endwrite()
; 584  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 585  : 			|| (_Off != 0 && _fseeki64(_Myfile, _Off, SEEK_CUR) != 0)
; 586  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  0002c	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00030	57		 push	 edi
  00031	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00034	89 44 24 0c	 mov	 DWORD PTR __Off$2$[esp+32], eax
  00038	0f 84 91 00 00
	00		 je	 $LN3@seekpos
  0003e	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00043	84 c0		 test	 al, al
  00045	0f 84 84 00 00
	00		 je	 $LN3@seekpos
  0004b	8d 44 24 10	 lea	 eax, DWORD PTR __Fileposition$[esp+32]
  0004f	50		 push	 eax
  00050	ff 76 4c	 push	 DWORD PTR [esi+76]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fsetpos
  00059	83 c4 08	 add	 esp, 8
  0005c	85 c0		 test	 eax, eax
  0005e	75 6f		 jne	 SHORT $LN3@seekpos
  00060	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$2$[esp+32]
  00064	8b c3		 mov	 eax, ebx
  00066	0b c1		 or	 eax, ecx
  00068	74 14		 je	 SHORT $LN4@seekpos
  0006a	6a 01		 push	 1
  0006c	51		 push	 ecx
  0006d	53		 push	 ebx
  0006e	ff 76 4c	 push	 DWORD PTR [esi+76]
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___fseeki64
  00077	83 c4 10	 add	 esp, 16			; 00000010H
  0007a	85 c0		 test	 eax, eax
  0007c	75 51		 jne	 SHORT $LN3@seekpos
$LN4@seekpos:
  0007e	8d 44 24 10	 lea	 eax, DWORD PTR __Fileposition$[esp+32]
  00082	50		 push	 eax
  00083	ff 76 4c	 push	 DWORD PTR [esi+76]
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetpos
  0008c	83 c4 08	 add	 esp, 8
  0008f	85 c0		 test	 eax, eax
  00091	75 3c		 jne	 SHORT $LN3@seekpos

; 587  : 			return (pos_type(_BADOFF));	// report failure
; 588  : 
; 589  : 		_State = _POS_TYPE_TO_STATE(_Pos);

  00093	8b 45 1c	 mov	 eax, DWORD PTR __Pos$[ebp+16]

; 590  : 
; 591  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

  00096	8b ce		 mov	 ecx, esi
  00098	89 46 40	 mov	 DWORD PTR [esi+64], eax
  0009b	8b 45 20	 mov	 eax, DWORD PTR __Pos$[ebp+20]
  0009e	89 46 44	 mov	 DWORD PTR [esi+68], eax
  000a1	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 592  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000a6	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  000a9	8b 76 44	 mov	 esi, DWORD PTR [esi+68]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 45   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  000ac	8b 4c 24 10	 mov	 ecx, DWORD PTR __Fileposition$[esp+32]
  000b0	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  000b3	8b 4c 24 14	 mov	 ecx, DWORD PTR __Fileposition$[esp+36]
  000b7	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  000bd	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  000c4	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  000c7	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000ca	89 77 14	 mov	 DWORD PTR [edi+20], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 592  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000cd	eb 26		 jmp	 SHORT $LN16@seekpos
$LN3@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  000cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?_BADOFF@std@@3_JB
  000d5	0f 57 c0	 xorps	 xmm0, xmm0
  000d8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000da	89 07		 mov	 DWORD PTR [edi], eax
  000dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000df	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000e2	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  000e9	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  000f0	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
$LN16@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 594  : 		}

  000f5	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  000f9	8b c7		 mov	 eax, edi
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	33 cc		 xor	 ecx, esp
  00100	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
__Off$2$ = -20						; size = 4
__Fileposition$ = -16					; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 557  : 		{	// change position by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 10	 mov	 DWORD PTR __$ArrayPad$[esp+20], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  0001c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 562  : 			&& _Pcvt == 0)	// not converting

  0001f	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  00022	39 08		 cmp	 DWORD PTR [eax], ecx
  00024	75 1a		 jne	 SHORT $LN21@seekoff
  00026	83 7d 14 01	 cmp	 DWORD PTR __Way$[ebp], 1
  0002a	75 14		 jne	 SHORT $LN21@seekoff
  0002c	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00030	75 0e		 jne	 SHORT $LN21@seekoff

; 563  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

  00032	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
  00035	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp+4]
  00038	83 c3 ff	 add	 ebx, -1
  0003b	83 d0 ff	 adc	 eax, -1
  0003e	eb 06		 jmp	 SHORT $LN23@seekoff
$LN21@seekoff:

; 562  : 			&& _Pcvt == 0)	// not converting

  00040	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp+4]
  00043	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
$LN23@seekoff:

; 564  : 
; 565  : 		if (_Myfile == 0 || !_Endwrite()
; 566  : 			|| ((_Off != 0 || _Way != ios_base::cur)
; 567  : 				&& _fseeki64(_Myfile, _Off, _Way) != 0)
; 568  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  00046	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0004a	89 44 24 0c	 mov	 DWORD PTR __Off$2$[esp+32], eax
  0004e	0f 84 90 00 00
	00		 je	 $LN4@seekoff
  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0005b	84 c0		 test	 al, al
  0005d	0f 84 81 00 00
	00		 je	 $LN4@seekoff
  00063	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$2$[esp+32]
  00067	8b c3		 mov	 eax, ebx
  00069	0b c1		 or	 eax, ecx
  0006b	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  0006e	75 05		 jne	 SHORT $LN6@seekoff
  00070	83 f8 01	 cmp	 eax, 1
  00073	74 13		 je	 SHORT $LN5@seekoff
$LN6@seekoff:
  00075	50		 push	 eax
  00076	51		 push	 ecx
  00077	53		 push	 ebx
  00078	ff 76 4c	 push	 DWORD PTR [esi+76]
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___fseeki64
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	85 c0		 test	 eax, eax
  00086	75 5c		 jne	 SHORT $LN4@seekoff
$LN5@seekoff:
  00088	8d 44 24 10	 lea	 eax, DWORD PTR __Fileposition$[esp+32]
  0008c	50		 push	 eax
  0008d	ff 76 4c	 push	 DWORD PTR [esi+76]
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetpos
  00096	83 c4 08	 add	 esp, 8
  00099	85 c0		 test	 eax, eax
  0009b	75 47		 jne	 SHORT $LN4@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0009d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  000a0	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  000a3	39 08		 cmp	 DWORD PTR [eax], ecx
  000a5	75 14		 jne	 SHORT $LN13@seekoff

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  000a7	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  000aa	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  000ad	2b d1		 sub	 edx, ecx
  000af	89 08		 mov	 DWORD PTR [eax], ecx
  000b1	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000b4	89 08		 mov	 DWORD PTR [eax], ecx
  000b6	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000b9	89 10		 mov	 DWORD PTR [eax], edx
$LN13@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 572  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000bb	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  000be	8b 76 44	 mov	 esi, DWORD PTR [esi+68]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 45   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  000c1	8b 4c 24 10	 mov	 ecx, DWORD PTR __Fileposition$[esp+32]
  000c5	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  000c8	8b 4c 24 14	 mov	 ecx, DWORD PTR __Fileposition$[esp+36]
  000cc	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  000d2	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  000d9	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  000dc	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000df	89 77 14	 mov	 DWORD PTR [edi+20], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 572  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000e2	eb 26		 jmp	 SHORT $LN24@seekoff
$LN4@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?_BADOFF@std@@3_JB
  000ea	0f 57 c0	 xorps	 xmm0, xmm0
  000ed	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ef	89 07		 mov	 DWORD PTR [edi], eax
  000f1	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000f4	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000f7	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  000fe	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00105	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
$LN24@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 574  : 		}

  0010a	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  0010e	8b c7		 mov	 eax, edi
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	33 cc		 xor	 ecx, esp
  00115	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
$T16 = -56						; size = 1
__Dest$58 = -52						; size = 4
__Src$59 = -48						; size = 4
__Str$60 = -44						; size = 24
__Ch$61 = -17						; size = 1
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 490  : 		{	// get an element from stream, point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  0002d	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 492  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00032	85 c9		 test	 ecx, ecx
  00034	74 23		 je	 SHORT $LN10@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00036	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00039	8b 32		 mov	 esi, DWORD PTR [edx]
  0003b	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 492  : 			&& _Mysb::gptr() < _Mysb::egptr())

  0003e	3b c8		 cmp	 ecx, eax
  00040	73 17		 jae	 SHORT $LN10@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 270  : 		--*_IGcount;

  00042	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00045	89 02		 mov	 DWORD PTR [edx], eax

; 271  : 		return ((*_IGnext)++);

  00047	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0004f	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  00051	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 493  : 			return (_Traits::to_int_type(

  00054	e9 d4 01 00 00	 jmp	 $LN14@uflow
$LN10@uflow:

; 494  : 				*_Mysb::_Gninc()));	// return buffered
; 495  : 		else if (_Myfile == 0)

  00059	83 7f 4c 00	 cmp	 DWORD PTR [edi+76], 0
  0005d	75 08		 jne	 SHORT $LN12@uflow
$LN23@uflow:

; 496  : 			return (_Traits::eof());	// no open C stream, fail

  0005f	83 c8 ff	 or	 eax, -1
  00062	e9 c6 01 00 00	 jmp	 $LN14@uflow
$LN12@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00067	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  0006a	8d 47 3c	 lea	 eax, DWORD PTR [edi+60]
  0006d	39 06		 cmp	 DWORD PTR [esi], eax
  0006f	75 14		 jne	 SHORT $LN44@uflow

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00071	8b 57 54	 mov	 edx, DWORD PTR [edi+84]
  00074	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00077	2b d1		 sub	 edx, ecx
  00079	89 0e		 mov	 DWORD PTR [esi], ecx
  0007b	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0007e	89 08		 mov	 DWORD PTR [eax], ecx
  00080	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00083	89 10		 mov	 DWORD PTR [eax], edx
$LN44@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 498  : 		if (_Pcvt == 0)

  00085	83 7f 38 00	 cmp	 DWORD PTR [edi+56], 0
  00089	75 19		 jne	 SHORT $LN13@uflow

; 49   : 	if ((_Meta = fgetc(_File)) == EOF)

  0008b	ff 77 4c	 push	 DWORD PTR [edi+76]
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00094	83 c4 04	 add	 esp, 4
  00097	83 f8 ff	 cmp	 eax, -1
  0009a	74 c3		 je	 SHORT $LN23@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  0009c	0f b6 c0	 movzx	 eax, al

; 538  : 		}

  0009f	e9 89 01 00 00	 jmp	 $LN14@uflow
$LN13@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  000a4	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Str$60[ebp+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000ab	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR __Str$60[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000b2	c6 45 d4 00	 mov	 BYTE PTR __Str$60[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 506  : 			string _Str;

  000b6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 507  : 
; 508  : 			for (; ; )
; 509  : 				{	// get using codecvt facet
; 510  : 				_Elem _Ch, *_Dest;
; 511  : 				const char *_Src;
; 512  : 				int _Nleft;
; 513  : 				int _Meta = fgetc(_Myfile);

  000bd	ff 77 4c	 push	 DWORD PTR [edi+76]
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  000c6	8b d8		 mov	 ebx, eax
  000c8	83 c4 04	 add	 esp, 4

; 514  : 
; 515  : 				if (_Meta == EOF)

  000cb	83 fb ff	 cmp	 ebx, -1
  000ce	0f 84 11 01 00
	00		 je	 $LN361@uflow
$LL2@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  000d4	8b 55 e8	 mov	 edx, DWORD PTR __Str$60[ebp+20]
  000d7	8b c2		 mov	 eax, edx
  000d9	8b 4d e4	 mov	 ecx, DWORD PTR __Str$60[ebp+16]
  000dc	2b c1		 sub	 eax, ecx
  000de	8b f1		 mov	 esi, ecx
  000e0	83 f8 01	 cmp	 eax, 1
  000e3	72 26		 jb	 SHORT $LN87@uflow

; 2379 : 			{
; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  000e5	41		 inc	 ecx

; 1595 : 		value_type * _Result = _Bx._Buf;

  000e6	8d 45 d4	 lea	 eax, DWORD PTR __Str$60[ebp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000e9	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  000ec	89 4d e4	 mov	 DWORD PTR __Str$60[ebp+16], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000ef	0f be cb	 movsx	 ecx, bl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1596 : 		if (_Large_string_engaged())

  000f2	0f 43 45 d4	 cmovae	 eax, DWORD PTR __Str$60[ebp]

; 2382 : 			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  000f6	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000f9	0f b6 c1	 movzx	 eax, cl
  000fc	66 c1 e1 08	 shl	 cx, 8
  00100	66 0b c8	 or	 cx, ax
  00103	88 0a		 mov	 BYTE PTR [edx], cl

; 517  : 		_Left = _Right;

  00105	c6 42 01 00	 mov	 BYTE PTR [edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2384 : 			return (*this);

  00109	eb 14		 jmp	 SHORT $LN86@uflow
$LN87@uflow:

; 2385 : 			}
; 2386 : 
; 2387 : 		return (_Reallocate_grow_by(_Count,

  0010b	53		 push	 ebx
  0010c	6a 01		 push	 1
  0010e	c6 45 c8 00	 mov	 BYTE PTR $T16[ebp], 0
  00112	8d 4d d4	 lea	 ecx, DWORD PTR __Str$60[ebp]
  00115	ff 75 c8	 push	 DWORD PTR $T16[ebp]
  00118	6a 01		 push	 1
  0011a	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN86@uflow:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0011f	83 7d e8 10	 cmp	 DWORD PTR __Str$60[ebp+20], 16 ; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 519  : 				switch (_Pcvt->in(_State,

  00123	8d 45 cc	 lea	 eax, DWORD PTR __Dest$58[ebp]
  00126	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00129	8d 75 d4	 lea	 esi, DWORD PTR __Str$60[ebp]

; 1596 : 		if (_Large_string_engaged())

  0012c	0f 43 75 d4	 cmovae	 esi, DWORD PTR __Str$60[ebp]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00130	8d 55 d4	 lea	 edx, DWORD PTR __Str$60[ebp]

; 1596 : 		if (_Large_string_engaged())

  00133	0f 43 55 d4	 cmovae	 edx, DWORD PTR __Str$60[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 519  : 				switch (_Pcvt->in(_State,

  00137	50		 push	 eax
  00138	8d 45 f0	 lea	 eax, DWORD PTR __Ch$61[ebp+1]
  0013b	50		 push	 eax
  0013c	8d 45 ef	 lea	 eax, DWORD PTR __Ch$61[ebp]
  0013f	50		 push	 eax
  00140	8d 45 d0	 lea	 eax, DWORD PTR __Src$59[ebp]
  00143	50		 push	 eax
  00144	8b 45 e4	 mov	 eax, DWORD PTR __Str$60[ebp+16]
  00147	03 c6		 add	 eax, esi
  00149	50		 push	 eax
  0014a	52		 push	 edx
  0014b	8d 47 40	 lea	 eax, DWORD PTR [edi+64]
  0014e	50		 push	 eax
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
  00155	85 c0		 test	 eax, eax
  00157	0f 88 88 00 00
	00		 js	 $LN361@uflow
  0015d	83 f8 01	 cmp	 eax, 1
  00160	7e 45		 jle	 SHORT $LN16@uflow
  00162	83 f8 03	 cmp	 eax, 3
  00165	75 7e		 jne	 SHORT $LN361@uflow

; 534  : 							(size_t)(_Src - &*_Str.begin()));
; 535  : 					break;
; 536  : 
; 537  : 				case codecvt_base::noconv:
; 538  : 					if (_Str.size() < sizeof (_Elem))

  00167	83 7d e4 01	 cmp	 DWORD PTR __Str$60[ebp+16], 1
  0016b	72 61		 jb	 SHORT $LN18@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0016d	83 7d e8 10	 cmp	 DWORD PTR __Str$60[ebp+20], 16 ; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  00171	8d 45 d4	 lea	 eax, DWORD PTR __Str$60[ebp]

; 1596 : 		if (_Large_string_engaged())

  00174	8b 4d d4	 mov	 ecx, DWORD PTR __Str$60[ebp]
  00177	0f 82 cc 00 00
	00		 jb	 $LN369@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0017d	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  0017f	85 c9		 test	 ecx, ecx
  00181	0f 85 c2 00 00
	00		 jne	 $LN369@uflow

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  00187	88 4d ef	 mov	 BYTE PTR __Ch$61[ebp], cl

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00190	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  0019c	8a 45 ef	 mov	 al, BYTE PTR __Ch$61[ebp]
  0019f	8b 4d d4	 mov	 ecx, DWORD PTR __Str$60[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  001a2	0f b6 f0	 movzx	 esi, al
  001a5	eb 44		 jmp	 SHORT $LN310@uflow
$LN16@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 525  : 					if (_Dest != &_Ch)

  001a7	8d 45 ef	 lea	 eax, DWORD PTR __Ch$61[ebp]
  001aa	39 45 cc	 cmp	 DWORD PTR __Dest$58[ebp], eax
  001ad	0f 85 a0 00 00
	00		 jne	 $LN363@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001b3	83 7d e8 10	 cmp	 DWORD PTR __Str$60[ebp+20], 16 ; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  001b7	8d 4d d4	 lea	 ecx, DWORD PTR __Str$60[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 533  : 						_Str.erase((size_t)0,	// partial, discard used input

  001ba	8b 45 d0	 mov	 eax, DWORD PTR __Src$59[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1596 : 		if (_Large_string_engaged())

  001bd	0f 43 4d d4	 cmovae	 ecx, DWORD PTR __Str$60[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 533  : 						_Str.erase((size_t)0,	// partial, discard used input

  001c1	2b c1		 sub	 eax, ecx
  001c3	8d 4d d4	 lea	 ecx, DWORD PTR __Str$60[ebp]
  001c6	50		 push	 eax
  001c7	6a 00		 push	 0
  001c9	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
$LN18@uflow:

; 507  : 
; 508  : 			for (; ; )
; 509  : 				{	// get using codecvt facet
; 510  : 				_Elem _Ch, *_Dest;
; 511  : 				const char *_Src;
; 512  : 				int _Nleft;
; 513  : 				int _Meta = fgetc(_Myfile);

  001ce	ff 77 4c	 push	 DWORD PTR [edi+76]
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  001d7	8b d8		 mov	 ebx, eax
  001d9	83 c4 04	 add	 esp, 4

; 514  : 
; 515  : 				if (_Meta == EOF)

  001dc	83 fb ff	 cmp	 ebx, -1
  001df	0f 85 ef fe ff
	ff		 jne	 $LL2@uflow
$LN361@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 552  : 		return (EOF);

  001e5	8b 4d d4	 mov	 ecx, DWORD PTR __Str$60[ebp]
  001e8	83 ce ff	 or	 esi, -1
$LN310@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001eb	8b 45 e8	 mov	 eax, DWORD PTR __Str$60[ebp+20]
  001ee	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  001f1	72 38		 jb	 SHORT $LN339@uflow

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001f3	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  001f4	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001f9	72 27		 jb	 SHORT $LN342@uflow

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  001fb	f6 45 d4 1f	 test	 BYTE PTR __Str$60[ebp], 31 ; 0000001fH
  001ff	0f 85 93 00 00
	00		 jne	 $_Invalid_parameter$378

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00205	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00208	3b c1		 cmp	 eax, ecx
  0020a	0f 83 88 00 00
	00		 jae	 $_Invalid_parameter$378

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00210	2b c8		 sub	 ecx, eax
  00212	83 f9 04	 cmp	 ecx, 4
  00215	0f 82 7d 00 00
	00		 jb	 $_Invalid_parameter$378

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  0021b	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0021e	77 78		 ja	 SHORT $_Invalid_parameter$378

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00220	8b c8		 mov	 ecx, eax
$LN342@uflow:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00222	51		 push	 ecx
  00223	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00228	83 c4 04	 add	 esp, 4
$LN339@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 547  : 					return (_Traits::eof());	// conversion failed

  0022b	8b c6		 mov	 eax, esi
$LN14@uflow:

; 551  : 		}

  0022d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00230	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00237	59		 pop	 ecx
  00238	5f		 pop	 edi
  00239	5e		 pop	 esi
  0023a	5b		 pop	 ebx
  0023b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023e	33 cd		 xor	 ecx, ebp
  00240	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00245	8b e5		 mov	 esp, ebp
  00247	5d		 pop	 ebp
  00248	c3		 ret	 0
$LN369@uflow:
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h

; 59   :         memcpy(_Destination, _Source, _SourceSize);

  00249	8a 00		 mov	 al, BYTE PTR [eax]
  0024b	88 45 ef	 mov	 BYTE PTR __Ch$61[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  0024e	0f b6 f0	 movzx	 esi, al
  00251	eb 98		 jmp	 SHORT $LN310@uflow
$LN363@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00253	83 7d e8 10	 cmp	 DWORD PTR __Str$60[ebp+20], 16 ; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  00257	8d 45 d4	 lea	 eax, DWORD PTR __Str$60[ebp]

; 1596 : 		if (_Large_string_engaged())

  0025a	8b 4d d4	 mov	 ecx, DWORD PTR __Str$60[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 527  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  0025d	8b 75 e4	 mov	 esi, DWORD PTR __Str$60[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1596 : 		if (_Large_string_engaged())

  00260	0f 43 c1	 cmovae	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 527  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  00263	8b 55 d0	 mov	 edx, DWORD PTR __Src$59[ebp]
  00266	2b f2		 sub	 esi, edx
  00268	03 f0		 add	 esi, eax

; 528  : 						for (; 0 < _Nleft; )

  0026a	85 f6		 test	 esi, esi
  0026c	7e 21		 jle	 SHORT $LN8@uflow
  0026e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__ungetc
$LL7@uflow:

; 529  : 							ungetc(_Src[--_Nleft], _Myfile);

  00274	ff 77 4c	 push	 DWORD PTR [edi+76]
  00277	0f be 44 16 ff	 movsx	 eax, BYTE PTR [esi+edx-1]
  0027c	4e		 dec	 esi
  0027d	50		 push	 eax
  0027e	ff d3		 call	 ebx
  00280	83 c4 08	 add	 esp, 8
  00283	85 f6		 test	 esi, esi
  00285	7e 05		 jle	 SHORT $LN374@uflow

; 528  : 						for (; 0 < _Nleft; )

  00287	8b 55 d0	 mov	 edx, DWORD PTR __Src$59[ebp]
  0028a	eb e8		 jmp	 SHORT $LL7@uflow
$LN374@uflow:
  0028c	8b 4d d4	 mov	 ecx, DWORD PTR __Str$60[ebp]
$LN8@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  0028f	0f b6 75 ef	 movzx	 esi, BYTE PTR __Ch$61[ebp]
  00293	e9 53 ff ff ff	 jmp	 $LN310@uflow
$_Invalid_parameter$378:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00298	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN377@uflow:
$LN376@uflow:
  0029e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Str$60[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 475  : 		{	// get an element from stream, but don't point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00003	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 478  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	85 c9		 test	 ecx, ecx
  0000a	74 10		 je	 SHORT $LN2@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0000c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	03 c1		 add	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 478  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00013	3b c8		 cmp	 ecx, eax
  00015	73 05		 jae	 SHORT $LN2@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  00017	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 487  : 		}

  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
$LN2@underflow:

; 480  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8b ce		 mov	 ecx, esi
  00020	57		 push	 edi
  00021	ff 50 1c	 call	 DWORD PTR [eax+28]
  00024	8b f8		 mov	 edi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  00026	83 ff ff	 cmp	 edi, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 480  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  00029	75 05		 jne	 SHORT $LN4@underflow

; 481  : 			return (_Meta);	// uflow failed, return EOF

  0002b	5f		 pop	 edi
  0002c	0b c0		 or	 eax, eax

; 487  : 		}

  0002e	5e		 pop	 esi
  0002f	c3		 ret	 0
$LN4@underflow:

; 482  : 		else
; 483  : 			{	// get a char, don't point past it
; 484  : 			pbackfail(_Meta);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b ce		 mov	 ecx, esi
  00034	57		 push	 edi
  00035	ff 50 10	 call	 DWORD PTR [eax+16]

; 485  : 			return (_Meta);

  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi

; 487  : 		}

  0003b	5e		 pop	 esi
  0003c	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 450  : 		{	// put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 453  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  0000a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 453  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 2e		 je	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00013	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 453  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00016	39 08		 cmp	 DWORD PTR [eax], ecx
  00018	73 27		 jae	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  0001a	83 fb ff	 cmp	 ebx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 453  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001d	74 08		 je	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  0001f	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]

; 542  : 		return (_Left == _Right);

  00023	3b c3		 cmp	 eax, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 453  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00025	75 1a		 jne	 SHORT $LN2@pbackfail
$LN4@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 264  : 		++*_IGcount;

  00027	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0002a	ff 00		 inc	 DWORD PTR [eax]

; 265  : 		return (--*_IGnext);

  0002c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0002f	ff 08		 dec	 DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 547  : 		return (_Meta != eof() ? _Meta : !eof());

  00031	33 c0		 xor	 eax, eax
  00033	83 fb ff	 cmp	 ebx, -1
  00036	0f 44 d8	 cmove	 ebx, eax
$LN79@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 472  : 	}

  00039	5e		 pop	 esi
  0003a	8b c3		 mov	 eax, ebx
  0003c	5b		 pop	 ebx
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN2@pbackfail:

; 460  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  00041	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00044	85 c0		 test	 eax, eax
  00046	74 5d		 je	 SHORT $LN7@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  00048	83 fb ff	 cmp	 ebx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 460  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  0004b	74 58		 je	 SHORT $LN7@pbackfail

; 461  : 			return (_Traits::eof());	// no open C stream or EOF, fail
; 462  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  0004d	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00051	75 13		 jne	 SHORT $LN8@pbackfail

; 117  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  00053	50		 push	 eax
  00054	0f b6 cb	 movzx	 ecx, bl
  00057	51		 push	 ecx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ungetc
  0005e	83 c4 08	 add	 esp, 8
  00061	83 f8 ff	 cmp	 eax, -1

; 461  : 			return (_Traits::eof());	// no open C stream or EOF, fail
; 462  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  00064	75 d3		 jne	 SHORT $LN79@pbackfail
$LN8@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00066	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 464  : 		else if (_Mysb::gptr() != &_Mychar)

  00069	8d 56 3c	 lea	 edx, DWORD PTR [esi+60]
  0006c	39 11		 cmp	 DWORD PTR [ecx], edx
  0006e	74 35		 je	 SHORT $LN7@pbackfail

; 466  : 			_Mychar = _Traits::to_char_type(_Meta);

  00070	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00071	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 466  : 			_Mychar = _Traits::to_char_type(_Meta);

  00074	88 1a		 mov	 BYTE PTR [edx], bl

; 724  : 		if (_Mysb::eback() != &_Mychar)

  00076	8b 07		 mov	 eax, DWORD PTR [edi]
  00078	3b c2		 cmp	 eax, edx
  0007a	74 0d		 je	 SHORT $LN66@pbackfail

; 725  : 			{	// save current get buffer
; 726  : 			_Set_eback = _Mysb::eback();

  0007c	89 46 50	 mov	 DWORD PTR [esi+80], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0007f	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00082	8b 00		 mov	 eax, DWORD PTR [eax]
  00084	03 01		 add	 eax, DWORD PTR [ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 727  : 			_Set_egptr = _Mysb::egptr();

  00086	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN66@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00089	89 17		 mov	 DWORD PTR [edi], edx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008b	8b ce		 mov	 ecx, esi
  0008d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00090	2b ca		 sub	 ecx, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 468  : 			return (_Meta);

  00092	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00093	83 c1 3d	 add	 ecx, 61			; 0000003dH
  00096	89 10		 mov	 DWORD PTR [eax], edx
  00098	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 472  : 	}

  0009b	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0009c	89 08		 mov	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 468  : 			return (_Meta);

  0009e	8b c3		 mov	 eax, ebx

; 472  : 	}

  000a0	5b		 pop	 ebx
  000a1	5d		 pop	 ebp
  000a2	c2 04 00	 ret	 4
$LN7@pbackfail:
  000a5	5e		 pop	 esi
  000a6	83 c8 ff	 or	 eax, -1
  000a9	5b		 pop	 ebx
  000aa	5d		 pop	 ebp
  000ab	c2 04 00	 ret	 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
$T46 = -56						; size = 1
__Src$55 = -52						; size = 4
__Dest$56 = -48						; size = 4
__Str$57 = -44						; size = 24
__Ch$58 = -17						; size = 1
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Meta$ = 8						; size = 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 389  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx

; 390  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0002d	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  00030	83 fb ff	 cmp	 ebx, -1
  00033	75 07		 jne	 SHORT $LN7@overflow

; 391  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  00035	33 c0		 xor	 eax, eax
  00037	e9 01 02 00 00	 jmp	 $LN13@overflow
$LN7@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  0003c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 393  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00041	85 c9		 test	 ecx, ecx
  00043	74 24		 je	 SHORT $LN9@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00045	8b 57 30	 mov	 edx, DWORD PTR [edi+48]
  00048	8b 32		 mov	 esi, DWORD PTR [edx]
  0004a	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 393  : 			&& _Mysb::pptr() < _Mysb::epptr())

  0004d	3b c8		 cmp	 ecx, eax
  0004f	73 18		 jae	 SHORT $LN9@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 307  : 		--*_IPcount;

  00051	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00054	89 02		 mov	 DWORD PTR [edx], eax

; 308  : 		return ((*_IPnext)++);

  00056	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 396  : 			return (_Meta);

  00060	8b c3		 mov	 eax, ebx
  00062	88 1a		 mov	 BYTE PTR [edx], bl
  00064	e9 d4 01 00 00	 jmp	 $LN13@overflow
$LN9@overflow:

; 397  : 			}
; 398  : 		else if (_Myfile == 0)

  00069	83 7f 4c 00	 cmp	 DWORD PTR [edi+76], 0
  0006d	75 08		 jne	 SHORT $LN11@overflow

; 399  : 			return (_Traits::eof());	// no open C stream, fail

  0006f	83 c8 ff	 or	 eax, -1
  00072	e9 c6 01 00 00	 jmp	 $LN13@overflow
$LN11@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00077	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  0007a	8d 47 3c	 lea	 eax, DWORD PTR [edi+60]
  0007d	39 06		 cmp	 DWORD PTR [esi], eax
  0007f	75 14		 jne	 SHORT $LN65@overflow

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00081	8b 57 54	 mov	 edx, DWORD PTR [edi+84]
  00084	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00087	2b d1		 sub	 edx, ecx
  00089	89 0e		 mov	 DWORD PTR [esi], ecx
  0008b	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0008e	89 08		 mov	 DWORD PTR [eax], ecx
  00090	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00093	89 10		 mov	 DWORD PTR [eax], edx
$LN65@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 401  : 		if (_Pcvt == 0)

  00095	83 7f 38 00	 cmp	 DWORD PTR [edi+56], 0
  00099	75 1f		 jne	 SHORT $LN12@overflow

; 93   : 	return (fputc(_Byte, _File) != EOF);

  0009b	ff 77 4c	 push	 DWORD PTR [edi+76]
  0009e	0f be c3	 movsx	 eax, bl
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputc

; 402  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)

  000a8	83 c9 ff	 or	 ecx, -1

; 93   : 	return (fputc(_Byte, _File) != EOF);

  000ab	83 c4 08	 add	 esp, 8
  000ae	3b c1		 cmp	 eax, ecx

; 402  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)

  000b0	0f 45 cb	 cmovne	 ecx, ebx
  000b3	8b c1		 mov	 eax, ecx
  000b5	e9 83 01 00 00	 jmp	 $LN13@overflow
$LN12@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1993 : 		assign(_Count, _Ch);

  000ba	83 ec 08	 sub	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 532  : 		return ((_Elem)_Meta);

  000bd	88 5d ef	 mov	 BYTE PTR __Ch$58[ebp], bl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1993 : 		assign(_Count, _Ch);

  000c0	8d 4d d4	 lea	 ecx, DWORD PTR __Str$57[ebp]

; 3698 : 		_My_data._Mysize = 0;

  000c3	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Str$57[ebp+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000ca	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR __Str$57[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000d1	c6 45 d4 00	 mov	 BYTE PTR __Str$57[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1993 : 		assign(_Count, _Ch);

  000d5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 411  : 			string _Str(_STRING_INC, '\0');

  000da	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
$LN341@overflow:
  000e1	8b 75 e8	 mov	 esi, DWORD PTR __Str$57[ebp+20]
  000e4	8d 5f 40	 lea	 ebx, DWORD PTR [edi+64]
  000e7	8b 45 d4	 mov	 eax, DWORD PTR __Str$57[ebp]
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL2@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000f0	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  000f3	8d 55 d4	 lea	 edx, DWORD PTR __Str$57[ebp]
  000f6	8d 4d d4	 lea	 ecx, DWORD PTR __Str$57[ebp]

; 1596 : 		if (_Large_string_engaged())

  000f9	0f 43 c8	 cmovae	 ecx, eax
  000fc	0f 43 d0	 cmovae	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 413  : 				switch (_Pcvt->out(_State,

  000ff	8d 45 d0	 lea	 eax, DWORD PTR __Dest$56[ebp]
  00102	50		 push	 eax
  00103	8b 45 e4	 mov	 eax, DWORD PTR __Str$57[ebp+16]
  00106	03 c2		 add	 eax, edx
  00108	50		 push	 eax
  00109	51		 push	 ecx
  0010a	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  0010d	8d 45 cc	 lea	 eax, DWORD PTR __Src$55[ebp]
  00110	50		 push	 eax
  00111	8d 45 f0	 lea	 eax, DWORD PTR __Ch$58[ebp+1]
  00114	50		 push	 eax
  00115	8d 45 ef	 lea	 eax, DWORD PTR __Ch$58[ebp]
  00118	50		 push	 eax
  00119	53		 push	 ebx
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
  00120	85 c0		 test	 eax, eax
  00122	0f 88 d6 00 00
	00		 js	 $LN22@overflow
  00128	83 f8 01	 cmp	 eax, 1
  0012b	0f 8f a4 00 00
	00		 jg	 $LN334@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00131	8b 75 e8	 mov	 esi, DWORD PTR __Str$57[ebp+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00134	8d 4d d4	 lea	 ecx, DWORD PTR __Str$57[ebp]

; 1596 : 		if (_Large_string_engaged())

  00137	8b 45 d4	 mov	 eax, DWORD PTR __Str$57[ebp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0013a	83 fe 10	 cmp	 esi, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 420  : 					size_t _Count = _Dest - &*_Str.begin();

  0013d	8b 5d d0	 mov	 ebx, DWORD PTR __Dest$56[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1596 : 		if (_Large_string_engaged())

  00140	0f 43 c8	 cmovae	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 420  : 					size_t _Count = _Dest - &*_Str.begin();

  00143	2b d9		 sub	 ebx, ecx

; 421  : 					if (0 < _Count && _Count !=

  00145	74 27		 je	 SHORT $LN15@overflow
  00147	ff 77 4c	 push	 DWORD PTR [edi+76]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0014a	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  0014d	8d 4d d4	 lea	 ecx, DWORD PTR __Str$57[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 421  : 					if (0 < _Count && _Count !=

  00150	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1596 : 		if (_Large_string_engaged())

  00151	0f 43 c8	 cmovae	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 421  : 					if (0 < _Count && _Count !=

  00154	6a 01		 push	 1
  00156	51		 push	 ecx
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0015d	8b 75 e8	 mov	 esi, DWORD PTR __Str$57[ebp+20]
  00160	83 c4 10	 add	 esp, 16			; 00000010H
  00163	3b d8		 cmp	 ebx, eax
  00165	8b 45 d4	 mov	 eax, DWORD PTR __Str$57[ebp]
  00168	0f 85 96 00 00
	00		 jne	 $LN335@overflow
$LN15@overflow:

; 422  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 423  : 						return (_Traits::eof());	// write failed
; 424  : 
; 425  : 					_Wrotesome = true;	// write succeeded
; 426  : 					if (_Src != &_Ch)

  0016e	8d 4d ef	 lea	 ecx, DWORD PTR __Ch$58[ebp]
  00171	c6 47 3d 01	 mov	 BYTE PTR [edi+61], 1
  00175	39 4d cc	 cmp	 DWORD PTR __Src$55[ebp], ecx
  00178	75 56		 jne	 SHORT $LN336@overflow

; 427  : 						return (_Meta);	// converted whole element
; 428  : 
; 429  : 					if (0 < _Count)

  0017a	85 db		 test	 ebx, ebx
  0017c	8d 5f 40	 lea	 ebx, DWORD PTR [edi+64]
  0017f	0f 85 6b ff ff
	ff		 jne	 $LL2@overflow

; 430  : 						;
; 431  : 					else if (_Str.size() < 4 * _STRING_INC)

  00185	8b 55 e4	 mov	 edx, DWORD PTR __Str$57[ebp+16]
  00188	83 fa 20	 cmp	 edx, 32			; 00000020H
  0018b	73 77		 jae	 SHORT $LN335@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  0018d	8b ce		 mov	 ecx, esi
  0018f	8b da		 mov	 ebx, edx
  00191	2b ca		 sub	 ecx, edx
  00193	83 f9 08	 cmp	 ecx, 8

; 1595 : 		value_type * _Result = _Bx._Buf;

  00196	8d 4d d4	 lea	 ecx, DWORD PTR __Str$57[ebp]

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  00199	72 1e		 jb	 SHORT $LN254@overflow

; 2379 : 			{
; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  0019b	83 c2 08	 add	 edx, 8
  0019e	0f 57 c0	 xorps	 xmm0, xmm0

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001a1	83 fe 10	 cmp	 esi, 16			; 00000010H

; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  001a4	89 55 e4	 mov	 DWORD PTR __Str$57[ebp+16], edx

; 1596 : 		if (_Large_string_engaged())

  001a7	0f 43 c8	 cmovae	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  001aa	66 0f d6 04 19	 movq	 QWORD PTR [ecx+ebx], xmm0

; 517  : 		_Left = _Right;

  001af	c6 44 19 08 00	 mov	 BYTE PTR [ecx+ebx+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2384 : 			return (*this);

  001b4	e9 28 ff ff ff	 jmp	 $LN341@overflow
$LN254@overflow:

; 2385 : 			}
; 2386 : 
; 2387 : 		return (_Reallocate_grow_by(_Count,

  001b9	6a 00		 push	 0
  001bb	6a 08		 push	 8
  001bd	c6 45 c8 00	 mov	 BYTE PTR $T46[ebp], 0
  001c1	ff 75 c8	 push	 DWORD PTR $T46[ebp]
  001c4	6a 08		 push	 8
  001c6	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 444  : 				}

  001cb	e9 11 ff ff ff	 jmp	 $LN341@overflow
$LN336@overflow:
  001d0	8b 7d 08	 mov	 edi, DWORD PTR __Meta$[ebp]
  001d3	eb 32		 jmp	 SHORT $LN284@overflow
$LN334@overflow:

; 413  : 				switch (_Pcvt->out(_State,

  001d5	83 f8 03	 cmp	 eax, 3
  001d8	75 24		 jne	 SHORT $LN22@overflow

; 93   : 	return (fputc(_Byte, _File) != EOF);

  001da	ff 77 4c	 push	 DWORD PTR [edi+76]
  001dd	0f be 45 ef	 movsx	 eax, BYTE PTR __Ch$58[ebp]
  001e1	50		 push	 eax
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputc

; 432  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 433  : 					else
; 434  : 						return (_Traits::eof());	// conversion failed
; 435  : 					break;
; 436  : 					}
; 437  : 
; 438  : 				case codecvt_base::noconv:
; 439  : 					return (_Fputc(_Ch, _Myfile) ? _Meta

  001e8	8b 75 e8	 mov	 esi, DWORD PTR __Str$57[ebp+20]
  001eb	83 c9 ff	 or	 ecx, -1

; 93   : 	return (fputc(_Byte, _File) != EOF);

  001ee	83 c4 08	 add	 esp, 8
  001f1	3b c1		 cmp	 eax, ecx

; 432  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 433  : 					else
; 434  : 						return (_Traits::eof());	// conversion failed
; 435  : 					break;
; 436  : 					}
; 437  : 
; 438  : 				case codecvt_base::noconv:
; 439  : 					return (_Fputc(_Ch, _Myfile) ? _Meta

  001f3	8b 45 d4	 mov	 eax, DWORD PTR __Str$57[ebp]
  001f6	0f 45 4d 08	 cmovne	 ecx, DWORD PTR __Meta$[ebp]
  001fa	8b f9		 mov	 edi, ecx
  001fc	eb 09		 jmp	 SHORT $LN284@overflow
$LN22@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 552  : 		return (EOF);

  001fe	8b 75 e8	 mov	 esi, DWORD PTR __Str$57[ebp+20]
  00201	8b 45 d4	 mov	 eax, DWORD PTR __Str$57[ebp]
$LN335@overflow:
  00204	83 cf ff	 or	 edi, -1
$LN284@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00207	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  0020a	72 2f		 jb	 SHORT $LN313@overflow

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0020c	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0020f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00215	72 1b		 jb	 SHORT $LN316@overflow

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00217	f6 45 d4 1f	 test	 BYTE PTR __Str$57[ebp], 31 ; 0000001fH
  0021b	75 3e		 jne	 SHORT $_Invalid_parameter$343

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0021d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00220	3b c8		 cmp	 ecx, eax
  00222	73 37		 jae	 SHORT $_Invalid_parameter$343

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00224	2b c1		 sub	 eax, ecx
  00226	83 f8 04	 cmp	 eax, 4
  00229	72 30		 jb	 SHORT $_Invalid_parameter$343

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  0022b	83 f8 23	 cmp	 eax, 35			; 00000023H
  0022e	77 2b		 ja	 SHORT $_Invalid_parameter$343

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00230	8b c1		 mov	 eax, ecx
$LN316@overflow:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00238	83 c4 04	 add	 esp, 4
$LN313@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 443  : 					return (_Traits::eof());	// conversion failed

  0023b	8b c7		 mov	 eax, edi
$LN13@overflow:

; 446  : 	}

  0023d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00240	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00247	59		 pop	 ecx
  00248	5f		 pop	 edi
  00249	5e		 pop	 esi
  0024a	5b		 pop	 ebx
  0024b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024e	33 cd		 xor	 ecx, ebp
  00250	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00255	8b e5		 mov	 esp, ebp
  00257	5d		 pop	 ebp
  00258	c2 04 00	 ret	 4
$_Invalid_parameter$343:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN342@overflow:
$LN340@overflow:
  00261	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Str$57[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 382  : 		if (_Myfile)

  00000	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00003	85 c0		 test	 eax, eax
  00005	74 08		 je	 SHORT $LN2@Unlock

; 383  : 			_CSTD _unlock_file(_Myfile);

  00007	50		 push	 eax
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___unlock_file
  0000e	59		 pop	 ecx
$LN2@Unlock:

; 384  : 		}

  0000f	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 376  : 		if (_Myfile)

  00000	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00003	85 c0		 test	 eax, eax
  00005	74 08		 je	 SHORT $LN2@Lock

; 377  : 			_CSTD _lock_file(_Myfile);

  00007	50		 push	 eax
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___lock_file
  0000e	59		 pop	 ecx
$LN2@Lock:

; 378  : 		}

  0000f	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 161  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 162  : 		if (_Myfile != 0)

  00026	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00030	74 1e		 je	 SHORT $LN6@basic_file
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00032	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  00035	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  00038	39 07		 cmp	 DWORD PTR [edi], eax
  0003a	75 14		 jne	 SHORT $LN6@basic_file

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0003c	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  0003f	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00042	2b d1		 sub	 edx, ecx
  00044	89 0f		 mov	 DWORD PTR [edi], ecx
  00046	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
  0004b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0004e	89 10		 mov	 DWORD PTR [eax], edx
$LN6@basic_file:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 164  : 		if (_Closef)

  00050	80 7e 48 00	 cmp	 BYTE PTR [esi+72], 0
  00054	74 47		 je	 SHORT $LN3@basic_file

; 361  : 		if (_Myfile == 0)

  00056	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0005a	74 13		 je	 SHORT $LN16@basic_file

; 362  : 			_Ans = 0;
; 363  : 		else
; 364  : 			{	// put any homing sequence and close file
; 365  : 			if (!_Endwrite())

  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 366  : 				_Ans = 0;
; 367  : 			if (fclose(_Myfile) != 0)

  00063	ff 76 4c	 push	 DWORD PTR [esi+76]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0006c	83 c4 04	 add	 esp, 4
$LN16@basic_file:

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  0006f	8b ce		 mov	 ecx, esi
  00071	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0
  00075	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;
; 652  : 		_State = _Stinit;

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  00084	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00087	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  0008c	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  00093	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  00096	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
$LN3@basic_file:

; 165  : 			close();
; 166  : 		}

  0009d	8b ce		 mov	 ecx, esi
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  000a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000af	59		 pop	 ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 646  : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 647  : 		return (_Stringbuffer.str());

  00003	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00006	83 c1 18	 add	 ecx, 24			; 00000018H
  00009	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 648  : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 637  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 98	 mov	 eax, DWORD PTR [esi-104]

; 638  : 		}

  00006	8d 4e b0	 lea	 ecx, DWORD PTR [esi-80]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00014	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  0001d	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00026	8d 4e b8	 lea	 ecx, DWORD PTR [esi-72]
  00029	5e		 pop	 esi
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$dead$ = 8					; size = 4
_$initVBases$dead$ = 12					; size = 4
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 593  : 		{	// construct empty character buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00033	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]
  00036	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0003c	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00049	6a 00		 push	 0
  0004b	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	56		 push	 esi
  00056	8b cf		 mov	 ecx, edi
  00058	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00065	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0006c	8b 07		 mov	 eax, DWORD PTR [edi]
  0006e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00071	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00078	8b 07		 mov	 eax, DWORD PTR [edi]
  0007a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  00080	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00083	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax

; 30   : 		{	// construct empty character buffer from mode

  00087	8b ce		 mov	 ecx, esi
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0008f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 594  : 		}

  00095	8b c7		 mov	 eax, edi

; 311  : 		_Seekhigh = 0;

  00097	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 312  : 		_Mystate = _State;

  0009e	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0

; 594  : 		}

  000a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000af	59		 pop	 ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 10 00 00
	00		 je	 $LN5@basic_stri
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_stri:
  0001c	c3		 ret	 0
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1:
  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	83 c1 20	 add	 ecx, 32			; 00000020H
  00023	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3:
  00029	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
  00032	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00036	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00039	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
tv403 = -16						; size = 4
tv404 = -12						; size = 4
tv419 = -8						; size = 4
___$ReturnUdt$GSCopy$1$ = -4				; size = 4
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 24
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT
; _this$ = ecx

; 276  : 		{	// change position to _Pos, according to _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000c	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 66   : 		return (_Myoff + _Fpos);

  0000d	8b 5d 10	 mov	 ebx, DWORD PTR __Ptr$[ebp+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

  00010	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 66   : 		return (_Myoff + _Fpos);

  00011	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00014	03 75 14	 add	 esi, DWORD PTR __Ptr$[ebp+8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

  00017	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 66   : 		return (_Myoff + _Fpos);

  00018	13 5d 18	 adc	 ebx, DWORD PTR __Ptr$[ebp+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

  0001b	8b f9		 mov	 edi, ecx
  0001d	89 44 24 1c	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+32], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00021	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	85 c0		 test	 eax, eax
  00028	74 08		 je	 SHORT $LN2@seekpos
  0002a	39 47 38	 cmp	 DWORD PTR [edi+56], eax
  0002d	73 03		 jae	 SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  0002f	89 47 38	 mov	 DWORD PTR [edi+56], eax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003c	89 4c 24 10	 mov	 DWORD PTR tv403[esp+32], ecx
  00040	89 44 24 14	 mov	 DWORD PTR tv404[esp+32], eax
  00044	3b f1		 cmp	 esi, ecx
  00046	75 08		 jne	 SHORT $LN55@seekpos
  00048	3b d8		 cmp	 ebx, eax
  0004a	0f 84 ba 00 00
	00		 je	 $LN11@seekpos
$LN55@seekpos:

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  00050	8b 55 24	 mov	 edx, DWORD PTR __Mode$[ebp]
  00053	f6 c2 01	 test	 dl, 1
  00056	74 6f		 je	 SHORT $LN5@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00058	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	89 44 24 18	 mov	 DWORD PTR tv419[esp+32], eax
  00061	85 c0		 test	 eax, eax
  00063	74 5e		 je	 SHORT $LN60@seekpos

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00065	85 db		 test	 ebx, ebx
  00067	7c 54		 jl	 SHORT $LN7@seekpos
  00069	7f 04		 jg	 SHORT $LN56@seekpos
  0006b	85 f6		 test	 esi, esi
  0006d	72 4e		 jb	 SHORT $LN7@seekpos
$LN56@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0006f	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00072	8b 08		 mov	 ecx, DWORD PTR [eax]
  00074	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00077	2b c1		 sub	 eax, ecx
  00079	99		 cdq
  0007a	3b da		 cmp	 ebx, edx
  0007c	7f 3b		 jg	 SHORT $LN64@seekpos
  0007e	7c 04		 jl	 SHORT $LN57@seekpos
  00080	3b f0		 cmp	 esi, eax
  00082	77 35		 ja	 SHORT $LN64@seekpos
$LN57@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 246  : 		*_IGcount -= _Off;

  00084	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  00087	2b 4c 24 18	 sub	 ecx, DWORD PTR tv419[esp+32]
  0008b	03 ce		 add	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 246  : 		*_IGcount -= _Off;

  0008d	29 08		 sub	 DWORD PTR [eax], ecx

; 247  : 		*_IGnext += _Off;

  0008f	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00092	01 08		 add	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  00094	f6 45 24 02	 test	 BYTE PTR __Mode$[ebp], 2
  00098	74 70		 je	 SHORT $LN11@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  0009a	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  0009d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000a0	74 68		 je	 SHORT $LN11@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  000a2	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000a5	8b 08		 mov	 ecx, DWORD PTR [eax]

; 226  : 		return (*_IGnext);

  000a7	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]

; 259  : 		return (*_IPnext + *_IPcount);

  000aa	03 0a		 add	 ecx, DWORD PTR [edx]

; 226  : 		return (*_IGnext);

  000ac	8b 00		 mov	 eax, DWORD PTR [eax]

; 302  : 		*_IPcount = (int)(_Last - _Next);

  000ae	2b c8		 sub	 ecx, eax
  000b0	89 02		 mov	 DWORD PTR [edx], eax
  000b2	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000b5	89 08		 mov	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 292  : 			else

  000b7	eb 51		 jmp	 SHORT $LN11@seekpos
$LN64@seekpos:

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000b9	8b 4c 24 10	 mov	 ecx, DWORD PTR tv403[esp+32]
$LN7@seekpos:

; 293  : 				_Off = _BADOFF;

  000bd	8b 5c 24 14	 mov	 ebx, DWORD PTR tv404[esp+32]
  000c1	eb 45		 jmp	 SHORT $LN65@seekpos
$LN60@seekpos:

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  000c3	8b 44 24 14	 mov	 eax, DWORD PTR tv404[esp+32]
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  000c7	f6 c2 02	 test	 dl, 2
  000ca	74 3a		 je	 SHORT $LN10@seekpos
  000cc	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  000cf	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000d2	74 32		 je	 SHORT $LN10@seekpos

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000d4	85 db		 test	 ebx, ebx
  000d6	7c e5		 jl	 SHORT $LN7@seekpos
  000d8	7f 04		 jg	 SHORT $LN58@seekpos
  000da	85 f6		 test	 esi, esi
  000dc	72 df		 jb	 SHORT $LN7@seekpos
$LN58@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000de	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  000e6	2b c1		 sub	 eax, ecx
  000e8	99		 cdq
  000e9	3b da		 cmp	 ebx, edx
  000eb	7f cc		 jg	 SHORT $LN64@seekpos
  000ed	7c 04		 jl	 SHORT $LN59@seekpos
  000ef	3b f0		 cmp	 esi, eax
  000f1	77 c6		 ja	 SHORT $LN64@seekpos
$LN59@seekpos:

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000f3	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000f6	2b 08		 sub	 ecx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 287  : 		*_IPcount -= _Off;

  000f8	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000fb	03 ce		 add	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 287  : 		*_IPcount -= _Off;

  000fd	29 08		 sub	 DWORD PTR [eax], ecx

; 288  : 		*_IPnext += _Off;

  000ff	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00102	01 08		 add	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 300  : 			else

  00104	eb 04		 jmp	 SHORT $LN11@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  00106	8b d8		 mov	 ebx, eax
$LN65@seekpos:
  00108	8b f1		 mov	 esi, ecx
$LN11@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  0010a	8b 44 24 1c	 mov	 eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+32]
  0010e	0f 57 c0	 xorps	 xmm0, xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 306  : 		}

  00111	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  00112	89 30		 mov	 DWORD PTR [eax], esi
  00114	89 58 04	 mov	 DWORD PTR [eax+4], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 306  : 		}

  00117	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  00118	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0011f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00126	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 306  : 		}

  0012b	5b		 pop	 ebx
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv486 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
tv480 = 24						; size = 4
__Which$ = 24						; size = 4
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT
; _this$ = ecx

; 227  : 		{	// change position by _Off, according to _Way, _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi
  00008	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00009	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
  0000e	85 c0		 test	 eax, eax
  00010	74 08		 je	 SHORT $LN2@seekoff
  00012	39 43 38	 cmp	 DWORD PTR [ebx+56], eax
  00015	73 03		 jae	 SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00017	89 43 38	 mov	 DWORD PTR [ebx+56], eax
$LN2@seekoff:

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  0001a	8b 4d 18	 mov	 ecx, DWORD PTR __Which$[ebp]
  0001d	f6 c1 01	 test	 cl, 1
  00020	0f 84 d0 00 00
	00		 je	 $LN3@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00026	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  00029	8b 30		 mov	 esi, DWORD PTR [eax]
  0002b	89 75 fc	 mov	 DWORD PTR tv486[ebp], esi
  0002e	85 f6		 test	 esi, esi
  00030	0f 84 c0 00 00
	00		 je	 $LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

  00036	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00039	83 f8 02	 cmp	 eax, 2
  0003c	75 15		 jne	 SHORT $LN5@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0003e	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  00041	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00044	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00047	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0004a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004c	99		 cdq
  0004d	03 f0		 add	 esi, eax
  0004f	13 fa		 adc	 edi, edx

; 235  : 			else if (_Way == ios_base::cur

  00051	eb 35		 jmp	 SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

  00053	83 f8 01	 cmp	 eax, 1
  00056	75 19		 jne	 SHORT $LN7@seekoff
  00058	f6 c1 02	 test	 cl, 2
  0005b	75 18		 jne	 SHORT $LN74@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0005d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

  00060	8b c6		 mov	 eax, esi
  00062	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00065	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00068	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006a	99		 cdq
  0006b	03 f0		 add	 esi, eax
  0006d	13 fa		 adc	 edi, edx
  0006f	eb 17		 jmp	 SHORT $LN9@seekoff
$LN7@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

  00071	85 c0		 test	 eax, eax
  00073	74 0d		 je	 SHORT $LN79@seekoff
$LN74@seekoff:

; 239  : 				_Off = _BADOFF;

  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?_BADOFF@std@@3_JB
  0007b	8b 37		 mov	 esi, DWORD PTR [edi]
  0007d	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00080	eb 06		 jmp	 SHORT $LN9@seekoff
$LN79@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

  00082	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00085	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN9@seekoff:

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00088	85 ff		 test	 edi, edi
  0008a	0f 8c 01 01 00
	00		 jl	 $LN10@seekoff
  00090	7f 08		 jg	 SHORT $LN75@seekoff
  00092	85 f6		 test	 esi, esi
  00094	0f 82 f7 00 00
	00		 jb	 $LN10@seekoff
$LN75@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0009a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0009d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009f	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  000a2	2b c1		 sub	 eax, ecx
  000a4	99		 cdq
  000a5	3b fa		 cmp	 edi, edx
  000a7	0f 8f e4 00 00
	00		 jg	 $LN10@seekoff
  000ad	7c 08		 jl	 SHORT $LN76@seekoff
  000af	3b f0		 cmp	 esi, eax
  000b1	0f 87 da 00 00
	00		 ja	 $LN10@seekoff
$LN76@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 246  : 		*_IGcount -= _Off;

  000b7	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  000ba	2b 4d fc	 sub	 ecx, DWORD PTR tv486[ebp]
  000bd	03 ce		 add	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 246  : 		*_IGcount -= _Off;

  000bf	29 08		 sub	 DWORD PTR [eax], ecx

; 247  : 		*_IGnext += _Off;

  000c1	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000c4	01 08		 add	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000c6	f6 45 18 02	 test	 BYTE PTR __Which$[ebp], 2
  000ca	0f 84 cb 00 00
	00		 je	 $LN22@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  000d0	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000d3	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000d6	0f 84 bf 00 00
	00		 je	 $LN22@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  000dc	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000df	8b 08		 mov	 ecx, DWORD PTR [eax]

; 226  : 		return (*_IGnext);

  000e1	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]

; 259  : 		return (*_IPnext + *_IPcount);

  000e4	03 0a		 add	 ecx, DWORD PTR [edx]

; 226  : 		return (*_IGnext);

  000e6	8b 00		 mov	 eax, DWORD PTR [eax]

; 302  : 		*_IPcount = (int)(_Last - _Next);

  000e8	2b c8		 sub	 ecx, eax
  000ea	89 02		 mov	 DWORD PTR [edx], eax
  000ec	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000ef	89 08		 mov	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 248  : 			else

  000f1	e9 a5 00 00 00	 jmp	 $LN22@seekoff
$LN3@seekoff:

; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000f6	f6 c1 02	 test	 cl, 2
  000f9	0f 84 86 00 00
	00		 je	 $LN13@seekoff
  000ff	8b 12		 mov	 edx, DWORD PTR [edx]
  00101	89 55 18	 mov	 DWORD PTR tv480[ebp], edx
  00104	85 d2		 test	 edx, edx
  00106	74 7d		 je	 SHORT $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

  00108	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  0010b	83 f8 02	 cmp	 eax, 2
  0010e	75 15		 jne	 SHORT $LN15@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00110	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  00113	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00116	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00119	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0011c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0011e	99		 cdq
  0011f	03 f0		 add	 esi, eax
  00121	13 fa		 adc	 edi, edx
  00123	eb 30		 jmp	 SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

  00125	83 f8 01	 cmp	 eax, 1
  00128	75 14		 jne	 SHORT $LN17@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0012a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

  0012d	8b c2		 mov	 eax, edx
  0012f	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00132	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00135	2b 01		 sub	 eax, DWORD PTR [ecx]
  00137	99		 cdq
  00138	03 f0		 add	 esi, eax
  0013a	13 fa		 adc	 edi, edx
  0013c	eb 17		 jmp	 SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

  0013e	85 c0		 test	 eax, eax
  00140	74 0d		 je	 SHORT $LN80@seekoff

; 258  : 				_Off = _BADOFF;

  00142	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?_BADOFF@std@@3_JB
  00148	8b 37		 mov	 esi, DWORD PTR [edi]
  0014a	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  0014d	eb 06		 jmp	 SHORT $LN19@seekoff
$LN80@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

  0014f	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00152	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN19@seekoff:

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00155	85 ff		 test	 edi, edi
  00157	7c 38		 jl	 SHORT $LN10@seekoff
  00159	7f 04		 jg	 SHORT $LN77@seekoff
  0015b	85 f6		 test	 esi, esi
  0015d	72 32		 jb	 SHORT $LN10@seekoff
$LN77@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0015f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00162	8b 08		 mov	 ecx, DWORD PTR [eax]
  00164	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00167	2b c1		 sub	 eax, ecx
  00169	99		 cdq
  0016a	3b fa		 cmp	 edi, edx
  0016c	7f 23		 jg	 SHORT $LN10@seekoff
  0016e	7c 04		 jl	 SHORT $LN78@seekoff
  00170	3b f0		 cmp	 esi, eax
  00172	77 1d		 ja	 SHORT $LN10@seekoff
$LN78@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 287  : 		*_IPcount -= _Off;

  00174	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

  00177	2b 4d 18	 sub	 ecx, DWORD PTR tv480[ebp]
  0017a	03 ce		 add	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 287  : 		*_IPcount -= _Off;

  0017c	29 08		 sub	 DWORD PTR [eax], ecx

; 288  : 		*_IPnext += _Off;

  0017e	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00181	01 08		 add	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 263  : 			else

  00183	eb 16		 jmp	 SHORT $LN22@seekoff
$LN13@seekoff:

; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

  00185	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00188	8b c6		 mov	 eax, esi
  0018a	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0018d	0b c7		 or	 eax, edi
  0018f	74 0a		 je	 SHORT $LN22@seekoff
$LN10@seekoff:

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  00191	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
  00196	8b 30		 mov	 esi, DWORD PTR [eax]
  00198	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
$LN22@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  0019b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0019e	0f 57 c0	 xorps	 xmm0, xmm0
  001a1	89 78 04	 mov	 DWORD PTR [eax+4], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 271  : 		return (pos_type(_Off));

  001a4	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  001a5	89 30		 mov	 DWORD PTR [eax], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 271  : 		return (pos_type(_Off));

  001a7	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  001a8	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  001af	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  001b6	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 271  : 		return (pos_type(_Off));

  001bb	5b		 pop	 ebx

; 272  : 		}

  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT
; _this$ = ecx

; 207  : 		{	// get an element from stream, but don't point past it

  00000	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00001	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 208  : 		if (_Mysb::gptr() == 0)

  00004	8b 16		 mov	 edx, DWORD PTR [esi]
  00006	85 d2		 test	 edx, edx
  00008	75 05		 jne	 SHORT $LN2@underflow

; 209  : 			return (_Traits::eof());	// no character buffer, fail

  0000a	83 c8 ff	 or	 eax, -1

; 222  : 		}

  0000d	5e		 pop	 esi
  0000e	c3		 ret	 0
$LN2@underflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0000f	57		 push	 edi
  00010	8b 79 2c	 mov	 edi, DWORD PTR [ecx+44]
  00013	8b 07		 mov	 eax, DWORD PTR [edi]
  00015	03 c2		 add	 eax, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

  00017	3b d0		 cmp	 edx, eax
  00019	73 06		 jae	 SHORT $LN4@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  0001b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0001e	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 222  : 		}

  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
$LN4@underflow:

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  00021	f6 41 3c 04	 test	 BYTE PTR [ecx+60], 4
  00025	75 2c		 jne	 SHORT $LN8@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00027	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	85 c0		 test	 eax, eax
  0002e	74 23		 je	 SHORT $LN8@underflow
  00030	3b c2		 cmp	 eax, edx
  00032	77 05		 ja	 SHORT $LN6@underflow
  00034	39 51 38	 cmp	 DWORD PTR [ecx+56], edx
  00037	76 1a		 jbe	 SHORT $LN8@underflow
$LN6@underflow:

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

  00039	39 41 38	 cmp	 DWORD PTR [ecx+56], eax
  0003c	73 03		 jae	 SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

  0003e	89 41 38	 mov	 DWORD PTR [ecx+56], eax
$LN9@underflow:

; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

  00041	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00044	2b 06		 sub	 eax, DWORD PTR [esi]
  00046	89 07		 mov	 DWORD PTR [edi], eax

; 226  : 		return (*_IGnext);

  00048	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0004b	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 222  : 		}

  0004c	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  0004d	8b 00		 mov	 eax, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  0004f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 222  : 		}

  00052	c3		 ret	 0
$LN8@underflow:
  00053	5f		 pop	 edi

; 214  : 			return (_Traits::eof());	// can't read, fail

  00054	83 c8 ff	 or	 eax, -1

; 222  : 		}

  00057	5e		 pop	 esi
  00058	c3		 ret	 0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT
; _this$ = ecx

; 190  : 		{	// put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00003	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 190  : 		{	// put an element back to stream

  00006	56		 push	 esi

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00007	8b 30		 mov	 esi, DWORD PTR [eax]
  00009	85 f6		 test	 esi, esi
  0000b	74 3f		 je	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0000d	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00010	3b 30		 cmp	 esi, DWORD PTR [eax]
  00012	76 38		 jbe	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  00014	8b 55 08	 mov	 edx, DWORD PTR __Meta$[ebp]
  00017	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001a	74 0b		 je	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 522  : 		return (_Left == _Right);

  0001c	3a 56 ff	 cmp	 dl, BYTE PTR [esi-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001f	74 06		 je	 SHORT $LN2@pbackfail
  00021	f6 41 3c 02	 test	 BYTE PTR [ecx+60], 2
  00025	75 25		 jne	 SHORT $LN4@pbackfail
$LN2@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 246  : 		*_IGcount -= _Off;

  00027	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0002a	ff 00		 inc	 DWORD PTR [eax]

; 247  : 		*_IGnext += _Off;

  0002c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0002f	ff 08		 dec	 DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  00031	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

  00034	74 07		 je	 SHORT $LN5@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00036	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

  0003b	88 11		 mov	 BYTE PTR [ecx], dl
$LN5@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 547  : 		return (_Meta != eof() ? _Meta : !eof());

  0003d	33 c0		 xor	 eax, eax
  0003f	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 204  : 		}

  00042	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 547  : 		return (_Meta != eof() ? _Meta : !eof());

  00043	0f 44 d0	 cmove	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 202  : 			return (_Traits::not_eof(_Meta));

  00046	8b c2		 mov	 eax, edx

; 204  : 		}

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

  0004c	83 c8 ff	 or	 eax, -1

; 204  : 		}

  0004f	5e		 pop	 esi
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
tv731 = -8						; size = 4
__Newsize$1$ = -8					; size = 4
__Oldptr$1$ = -4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT
; _this$ = ecx

; 120  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 121  : 		if (_Mystate & _Constant)

  00009	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0000c	a8 02		 test	 al, 2
  0000e	74 0a		 je	 SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

  00010	83 c8 ff	 or	 eax, -1

; 187  : 		}

  00013	5e		 pop	 esi
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN4@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  0001a	53		 push	 ebx
  0001b	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  0001e	83 fb ff	 cmp	 ebx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00021	75 0a		 jne	 SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  00023	5b		 pop	 ebx
  00024	33 c0		 xor	 eax, eax

; 187  : 		}

  00026	5e		 pop	 esi
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN6@overflow:

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  0002d	57		 push	 edi
  0002e	a8 08		 test	 al, 8
  00030	74 23		 je	 SHORT $LN7@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00032	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  00035	8b 10		 mov	 edx, DWORD PTR [eax]
  00037	85 d2		 test	 edx, edx
  00039	74 1a		 je	 SHORT $LN7@overflow
  0003b	8b 7e 38	 mov	 edi, DWORD PTR [esi+56]
  0003e	3b d7		 cmp	 edx, edi
  00040	73 13		 jae	 SHORT $LN7@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00042	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]

; 301  : 		*_IPnext = _Next;

  00047	8b 46 20	 mov	 eax, DWORD PTR [esi+32]

; 259  : 		return (*_IPnext + *_IPcount);

  0004a	03 ca		 add	 ecx, edx

; 302  : 		*_IPcount = (int)(_Last - _Next);

  0004c	2b cf		 sub	 ecx, edi
  0004e	89 38		 mov	 DWORD PTR [eax], edi
  00050	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@overflow:

; 236  : 		return (*_IPnext);

  00055	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00058	8b 38		 mov	 edi, DWORD PTR [eax]
  0005a	85 ff		 test	 edi, edi
  0005c	74 2f		 je	 SHORT $LN115@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  0005e	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00061	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00063	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00066	3b f8		 cmp	 edi, eax
  00068	73 1a		 jae	 SHORT $LN20@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 307  : 		--*_IPcount;

  0006a	49		 dec	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 134  : 			return (_Meta);

  0006b	8b c3		 mov	 eax, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 307  : 		--*_IPcount;

  0006d	89 0a		 mov	 DWORD PTR [edx], ecx

; 308  : 		return ((*_IPnext)++);

  0006f	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00072	5f		 pop	 edi
  00073	8b 32		 mov	 esi, DWORD PTR [edx]
  00075	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00078	89 0a		 mov	 DWORD PTR [edx], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  0007a	88 1e		 mov	 BYTE PTR [esi], bl
  0007c	5b		 pop	 ebx

; 187  : 		}

  0007d	5e		 pop	 esi
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
$LN20@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00084	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00087	2b 38		 sub	 edi, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

  00089	03 f9		 add	 edi, ecx
  0008b	eb 02		 jmp	 SHORT $LN21@overflow
$LN115@overflow:
  0008d	33 ff		 xor	 edi, edi
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

  0008f	8b cf		 mov	 ecx, edi
  00091	d1 e9		 shr	 ecx, 1
  00093	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00096	73 07		 jae	 SHORT $LN22@overflow
  00098	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009d	eb 04		 jmp	 SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  0009f	85 c9		 test	 ecx, ecx
  000a1	74 13		 je	 SHORT $LN127@overflow
$LL2@overflow:
  000a3	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000a8	2b c1		 sub	 eax, ecx
  000aa	3b c7		 cmp	 eax, edi
  000ac	73 04		 jae	 SHORT $LN122@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

  000ae	d1 e9		 shr	 ecx, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000b0	75 f1		 jne	 SHORT $LL2@overflow
$LN122@overflow:

; 146  : 			if (_Inc == 0)

  000b2	85 c9		 test	 ecx, ecx
  000b4	75 0c		 jne	 SHORT $LN10@overflow
$LN127@overflow:
  000b6	5f		 pop	 edi
  000b7	5b		 pop	 ebx

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

  000b8	83 c8 ff	 or	 eax, -1

; 187  : 		}

  000bb	5e		 pop	 esi
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 04 00	 ret	 4
$LN10@overflow:

; 148  : 
; 149  : 			_Newsize += _Inc;

  000c2	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 151  : 			_Elem *_Newptr = _Unfancy(_Al.allocate(_Newsize));

  000c5	50		 push	 eax
  000c6	89 45 f8	 mov	 DWORD PTR __Newsize$1$[ebp], eax
  000c9	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000ce	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 151  : 			_Elem *_Newptr = _Unfancy(_Al.allocate(_Newsize));

  000d1	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000d3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000d5	89 4d fc	 mov	 DWORD PTR __Oldptr$1$[ebp], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 154  : 			if (0 < _Oldsize)

  000d8	85 ff		 test	 edi, edi
  000da	74 12		 je	 SHORT $LN129@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000dc	57		 push	 edi
  000dd	51		 push	 ecx
  000de	53		 push	 ebx
  000df	e8 00 00 00 00	 call	 _memcpy
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR __Oldptr$1$[ebp]
  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 157  : 			if (_Oldsize == 0)

  000ea	85 ff		 test	 edi, edi
  000ec	75 3d		 jne	 SHORT $LN12@overflow
$LN129@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 293  : 		*_IPfirst = _First;

  000ee	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 295  : 		*_IPcount = (int)(_Last - _First);

  000f1	8b 55 f8	 mov	 edx, DWORD PTR __Newsize$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 159  : 				_Seekhigh = _Newptr;

  000f4	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 293  : 		*_IPfirst = _First;

  000f7	89 18		 mov	 DWORD PTR [eax], ebx

; 294  : 		*_IPnext = _First;

  000f9	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000fc	89 18		 mov	 DWORD PTR [eax], ebx

; 295  : 		*_IPcount = (int)(_Last - _First);

  000fe	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00101	89 10		 mov	 DWORD PTR [eax], edx

; 252  : 		*_IGfirst = _First;

  00103	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 161  : 				if (_Mystate & _Noread)

  00106	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  0010a	89 18		 mov	 DWORD PTR [eax], ebx

; 253  : 		*_IGnext = _Next;

  0010c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 161  : 				if (_Mystate & _Noread)

  0010f	74 0d		 je	 SHORT $LN14@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 253  : 		*_IGnext = _Next;

  00111	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00117	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0011a	89 18		 mov	 DWORD PTR [eax], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 163  : 				else

  0011c	eb 74		 jmp	 SHORT $LN17@overflow
$LN14@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 253  : 		*_IGnext = _Next;

  0011e	89 18		 mov	 DWORD PTR [eax], ebx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00120	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00123	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 166  : 			else

  00129	eb 67		 jmp	 SHORT $LN17@overflow
$LN12@overflow:

; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

  0012b	8b c3		 mov	 eax, ebx
  0012d	2b c1		 sub	 eax, ecx
  0012f	01 46 38	 add	 DWORD PTR [esi+56], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00132	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00135	8b 10		 mov	 edx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  00137	8b c3		 mov	 eax, ebx
  00139	2b 45 fc	 sub	 eax, DWORD PTR __Oldptr$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  0013c	2b d1		 sub	 edx, ecx

; 231  : 		return (*_IPfirst);

  0013e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  00141	03 d3		 add	 edx, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 300  : 		*_IPfirst = _First;

  00143	01 01		 add	 DWORD PTR [ecx], eax

; 302  : 		*_IPcount = (int)(_Last - _Next);

  00145	8b cb		 mov	 ecx, ebx
  00147	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0014a	2b ca		 sub	 ecx, edx
  0014c	03 4d f8	 add	 ecx, DWORD PTR __Newsize$1$[ebp]
  0014f	89 10		 mov	 DWORD PTR [eax], edx
  00151	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00154	89 08		 mov	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 172  : 				if (_Mystate & _Noread)

  00156	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  0015a	74 15		 je	 SHORT $LN16@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  0015c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0015f	89 18		 mov	 DWORD PTR [eax], ebx

; 253  : 		*_IGnext = _Next;

  00161	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00164	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0016a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0016d	89 18		 mov	 DWORD PTR [eax], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 174  : 				else

  0016f	eb 21		 jmp	 SHORT $LN17@overflow
$LN16@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00171	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00174	8b 10		 mov	 edx, DWORD PTR [eax]

; 226  : 		return (*_IGnext);

  00176	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00179	8b 08		 mov	 ecx, DWORD PTR [eax]

; 252  : 		*_IGfirst = _First;

  0017b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 226  : 		return (*_IGnext);

  0017e	2b 4d fc	 sub	 ecx, DWORD PTR __Oldptr$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 175  : 					_Mysb::setg(_Newptr,

  00181	03 cb		 add	 ecx, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00183	2b d1		 sub	 edx, ecx
  00185	89 18		 mov	 DWORD PTR [eax], ebx
  00187	42		 inc	 edx
  00188	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0018b	89 08		 mov	 DWORD PTR [eax], ecx
  0018d	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00190	89 10		 mov	 DWORD PTR [eax], edx
$LN17@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 180  : 			if (_Mystate & _Allocated)

  00192	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  00196	74 09		 je	 SHORT $LN18@overflow

; 181  : 				_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Oldptr), _Oldsize);

  00198	57		 push	 edi
  00199	ff 75 fc	 push	 DWORD PTR __Oldptr$1$[ebp]
  0019c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
$LN18@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 307  : 		--*_IPcount;

  001a1	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 182  : 			_Mystate |= _Allocated;

  001a4	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  001a8	5f		 pop	 edi
  001a9	5b		 pop	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 307  : 		--*_IPcount;

  001aa	ff 08		 dec	 DWORD PTR [eax]

; 308  : 		return ((*_IPnext)++);

  001ac	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 187  : 		}

  001af	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 308  : 		return ((*_IPnext)++);

  001b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b2	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  001b5	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  001b7	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  001ba	88 02		 mov	 BYTE PTR [edx], al

; 187  : 		}

  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c2 04 00	 ret	 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 75   : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 338  : 		if (_Mystate & _Allocated)

  00003	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1

; 75   : 		{	// destroy the object

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 338  : 		if (_Mystate & _Allocated)

  0000d	74 4d		 je	 SHORT $LN25@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  0000f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	85 c9		 test	 ecx, ecx
  00016	74 09		 je	 SHORT $LN6@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00018	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	03 d1		 add	 edx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  0001f	eb 0a		 jmp	 SHORT $LN7@basic_stri
$LN6@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00021	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00024	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	03 11		 add	 edx, DWORD PTR [ecx]
$LN7@basic_stri:

; 221  : 		return (*_IGfirst);

  0002b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00030	2b d0		 sub	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00032	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00038	72 19		 jb	 SHORT $LN28@basic_stri

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0003a	a8 1f		 test	 al, 31			; 0000001fH
  0003c	75 68		 jne	 SHORT $_Invalid_parameter$48

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0003e	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00041	3b c8		 cmp	 ecx, eax
  00043	73 61		 jae	 SHORT $_Invalid_parameter$48

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00045	2b c1		 sub	 eax, ecx
  00047	83 f8 04	 cmp	 eax, 4
  0004a	72 5a		 jb	 SHORT $_Invalid_parameter$48

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  0004c	83 f8 23	 cmp	 eax, 35			; 00000023H
  0004f	77 55		 ja	 SHORT $_Invalid_parameter$48

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00051	8b c1		 mov	 eax, ecx
$LN28@basic_stri:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00059	83 c4 04	 add	 esp, 4
$LN25@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  0005c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 77   : 		}

  0005f	8b ce		 mov	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00061	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 253  : 		*_IGnext = _Next;

  00067	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0006a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00070	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00073	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 293  : 		*_IPfirst = _First;

  00079	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0007c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 294  : 		*_IPnext = _First;

  00082	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00085	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 295  : 		*_IPcount = (int)(_Last - _First);

  0008b	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0008e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

  00094	83 66 3c fe	 and	 DWORD PTR [esi+60], -2	; fffffffeH
  00098	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 77   : 		}

  0009f	5e		 pop	 esi
  000a0	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
$_Invalid_parameter$48:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN47@basic_stri:
$LN46@basic_stri:
  000ac	cc		 int	 3
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$dead$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1342 : 		{	// destroy the object

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 88	 mov	 eax, DWORD PTR [esi-120]
  00009	57		 push	 edi
  0000a	8d 7e 88	 lea	 edi, DWORD PTR [esi-120]

; 1343 : 		}

  0000d	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	c7 44 30 88 00
	00 00 00	 mov	 DWORD PTR [eax+esi-120], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  0001b	8b 07		 mov	 eax, DWORD PTR [edi]
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	8d 42 88	 lea	 eax, DWORD PTR [edx-120]
  00023	89 44 32 84	 mov	 DWORD PTR [edx+esi-124], eax
  00027	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0002c	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00035	8b ce		 mov	 ecx, esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0003d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00041	74 0e		 je	 SHORT $LN10@scalar
  00043	68 c0 00 00 00	 push	 192			; 000000c0H
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1121 : 		{	// destroy the object

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00009	57		 push	 edi
  0000a	8d 7e 98	 lea	 edi, DWORD PTR [esi-104]

; 1122 : 		}

  0000d	8d 4e 9c	 lea	 ecx, DWORD PTR [esi-100]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  0001b	8b 07		 mov	 eax, DWORD PTR [edi]
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  00023	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00027	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0002c	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00035	8b ce		 mov	 ecx, esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0003d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00041	74 0e		 je	 SHORT $LN10@scalar
  00043	68 b0 00 00 00	 push	 176			; 000000b0H
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 905  : 		{	// destroy the object

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 90	 mov	 eax, DWORD PTR [esi-112]
  00009	57		 push	 edi
  0000a	8d 7e 90	 lea	 edi, DWORD PTR [esi-112]

; 906  : 		}

  0000d	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	c7 44 30 90 00
	00 00 00	 mov	 DWORD PTR [eax+esi-112], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  0001b	8b 07		 mov	 eax, DWORD PTR [edi]
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	8d 42 90	 lea	 eax, DWORD PTR [edx-112]
  00023	89 44 32 8c	 mov	 DWORD PTR [edx+esi-116], eax
  00027	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0002c	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00035	8b ce		 mov	 ecx, esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0003d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00041	74 0e		 je	 SHORT $LN10@scalar
  00043	68 b8 00 00 00	 push	 184			; 000000b8H
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 58		 push	 88			; 00000058H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		{	// destroy the object

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00009	57		 push	 edi
  0000a	8d 7e 98	 lea	 edi, DWORD PTR [esi-104]

; 638  : 		}

  0000d	8d 4e b0	 lea	 ecx, DWORD PTR [esi-80]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0001b	8b 07		 mov	 eax, DWORD PTR [edi]
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  00023	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00027	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  0002c	8d 4e b8	 lea	 ecx, DWORD PTR [esi-72]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00035	8b ce		 mov	 ecx, esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0003d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00041	74 0e		 je	 SHORT $LN10@scalar
  00043	68 b0 00 00 00	 push	 176			; 000000b0H
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 44		 push	 68			; 00000044H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$dead$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$dead$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z PROC	; std::pointer_traits<char *>::pointer_to, COMDAT
; __Val$ = ecx

; 323  : 		return (_STD addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 324  : 		}

  00002	c3		 ret	 0
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ENDP	; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0?$uniform_int@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0?$uniform_int@H@std@@QAE@HH@Z PROC			; std::uniform_int<int>::uniform_int<int>, COMDAT
; _this$ = ecx

; 2267 : 		{	// construct from parameters

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2256 : 			_Min = _Min0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Min0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 2257 : 			_Max = _Max0;

  00008	8b 45 0c	 mov	 eax, DWORD PTR __Max0$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2268 : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0?$uniform_int@H@std@@QAE@HH@Z ENDP			; std::uniform_int<int>::uniform_int<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ
_TEXT	SEGMENT
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper, COMDAT
; _this$ = ecx

; 1424 : 		{	// compute values for the upper half of the history array

  00000	56		 push	 esi

; 1425 : 		int _Ix;
; 1426 : 		for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix)

  00001	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00004	be 70 02 00 00	 mov	 esi, 624		; 00000270H
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@Refill_upp:

; 1427 : 			{	// fill in values
; 1428 : 			_Ty _Tmp = (this->_Ax[_Ix - _Nx] & _HMSK)
; 1429 : 				| (this->_Ax[_Ix - _Nx + 1] & _LMSK);

  00010	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00013	8d 40 04	 lea	 eax, DWORD PTR [eax+4]
  00016	33 50 fc	 xor	 edx, DWORD PTR [eax-4]
  00019	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  0001f	33 50 f8	 xor	 edx, DWORD PTR [eax-8]

; 1430 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00022	8b ca		 mov	 ecx, edx
  00024	80 e1 01	 and	 cl, 1
  00027	0f b6 c9	 movzx	 ecx, cl
  0002a	f7 d9		 neg	 ecx
  0002c	1b c9		 sbb	 ecx, ecx
  0002e	d1 ea		 shr	 edx, 1
  00030	81 e1 df b0 08
	99		 and	 ecx, -1727483681	; 9908b0dfH
  00036	33 88 2c 06 00
	00		 xor	 ecx, DWORD PTR [eax+1580]
  0003c	33 ca		 xor	 ecx, edx
  0003e	89 88 b8 09 00
	00		 mov	 DWORD PTR [eax+2488], ecx
  00044	83 ee 01	 sub	 esi, 1
  00047	75 c7		 jne	 SHORT $LL4@Refill_upp

; 1431 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1432 : 			}
; 1433 : 		}

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ
_TEXT	SEGMENT
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower, COMDAT
; _this$ = ecx

; 1399 : 		{	// compute values for the lower half of the history array

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1400 : 		int _Ix;
; 1401 : 		for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix)

  00005	bb e3 00 00 00	 mov	 ebx, 227		; 000000e3H
  0000a	8d b7 c4 09 00
	00		 lea	 esi, DWORD PTR [edi+2500]
$LL4@Refill_low:

; 1402 : 			{	// fill in lower region
; 1403 : 			_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK)
; 1404 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00010	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00013	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00016	33 4e fc	 xor	 ecx, DWORD PTR [esi-4]
  00019	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0001f	33 4e fc	 xor	 ecx, DWORD PTR [esi-4]

; 1405 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00022	8b c1		 mov	 eax, ecx
  00024	24 01		 and	 al, 1
  00026	0f b6 c0	 movzx	 eax, al
  00029	f7 d8		 neg	 eax
  0002b	1b c0		 sbb	 eax, eax
  0002d	d1 e9		 shr	 ecx, 1
  0002f	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00034	33 86 30 06 00
	00		 xor	 eax, DWORD PTR [esi+1584]
  0003a	33 c1		 xor	 eax, ecx
  0003c	89 86 3c f6 ff
	ff		 mov	 DWORD PTR [esi-2500], eax
  00042	83 eb 01	 sub	 ebx, 1
  00045	75 c9		 jne	 SHORT $LL4@Refill_low

; 1406 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];
; 1407 : 			}
; 1408 : 
; 1409 : 		for (; _Ix < _Nx - 1; ++_Ix)

  00047	8d b7 50 0d 00
	00		 lea	 esi, DWORD PTR [edi+3408]
  0004d	bb 8c 01 00 00	 mov	 ebx, 396		; 0000018cH
$LL7@Refill_low:

; 1410 : 			{	// fill in upper region (avoids modulus operation)
; 1411 : 			_Ty _Tmp = (this->_Ax[_Ix +_Nx] & _HMSK)
; 1412 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00052	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00055	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00058	33 4e fc	 xor	 ecx, DWORD PTR [esi-4]
  0005b	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  00061	33 4e fc	 xor	 ecx, DWORD PTR [esi-4]

; 1413 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00064	8b c1		 mov	 eax, ecx
  00066	24 01		 and	 al, 1
  00068	0f b6 c0	 movzx	 eax, al
  0006b	f7 d8		 neg	 eax
  0006d	1b c0		 sbb	 eax, eax
  0006f	d1 e9		 shr	 ecx, 1
  00071	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00076	33 86 b0 f2 ff
	ff		 xor	 eax, DWORD PTR [esi-3408]
  0007c	33 c1		 xor	 eax, ecx
  0007e	89 86 3c f6 ff
	ff		 mov	 DWORD PTR [esi-2500], eax
  00084	83 eb 01	 sub	 ebx, 1
  00087	75 c9		 jne	 SHORT $LL7@Refill_low

; 1414 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1415 : 			}
; 1416 : 
; 1417 : 		_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

  00089	8b 8f 80 13 00
	00		 mov	 ecx, DWORD PTR [edi+4992]
  0008f	33 4f 04	 xor	 ecx, DWORD PTR [edi+4]
  00092	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  00098	33 8f 80 13 00
	00		 xor	 ecx, DWORD PTR [edi+4992]

; 1418 : 		this->_Ax[_Ix] = (_Tmp >> 1)

  0009e	8b c1		 mov	 eax, ecx
  000a0	24 01		 and	 al, 1
  000a2	0f b6 c0	 movzx	 eax, al
  000a5	f7 d8		 neg	 eax
  000a7	1b c0		 sbb	 eax, eax
  000a9	d1 e9		 shr	 ecx, 1
  000ab	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  000b0	33 87 34 06 00
	00		 xor	 eax, DWORD PTR [edi+1588]
  000b6	33 c1		 xor	 eax, ecx
  000b8	89 87 c0 09 00
	00		 mov	 DWORD PTR [edi+2496], eax

; 1419 : 			^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];
; 1420 : 		this->_Idx = 0;

  000be	89 1f		 mov	 DWORD PTR [edi], ebx
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx

; 1421 : 		}

  000c3	c3		 ret	 0
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
__Dxarg$dead$ = 12					; size = 4
__Fxarg$dead$ = 16					; size = 4
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>, COMDAT
; _this$ = ecx

; 1322 : 		{	// construct with specified seed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1337 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00003	8b 55 08	 mov	 edx, DWORD PTR __X0$[ebp]

; 1322 : 		{	// construct with specified seed

  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	c7 81 84 13 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+4996], -1
  00012	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]

; 1337 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00015	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1321 : 		: _Dxval(_Dxarg)

  00018	be 01 00 00 00	 mov	 esi, 1
  0001d	0f 1f 00	 npad	 3
$LL6@mersenne_t:

; 1339 : 			_Prev = this->_Ax[_Ix] =

  00020	8b c2		 mov	 eax, edx
  00022	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00025	c1 e8 1e	 shr	 eax, 30			; 0000001eH
  00028	33 c2		 xor	 eax, edx
  0002a	69 d0 65 89 07
	6c		 imul	 edx, eax, 1812433253
  00030	03 d6		 add	 edx, esi
  00032	46		 inc	 esi
  00033	89 57 fc	 mov	 DWORD PTR [edi-4], edx
  00036	81 fe 70 02 00
	00		 cmp	 esi, 624		; 00000270H
  0003c	7c e2		 jl	 SHORT $LL6@mersenne_t

; 1323 : 		seed(_X0, _Fxarg);
; 1324 : 		}

  0003e	5f		 pop	 edi

; 1341 : 		this->_Idx = _Nx;

  0003f	c7 01 70 02 00
	00		 mov	 DWORD PTR [ecx], 624	; 00000270H

; 1323 : 		seed(_X0, _Fxarg);
; 1324 : 		}

  00045	8b c1		 mov	 eax, ecx
  00047	5e		 pop	 esi
  00048	5d		 pop	 ebp
  00049	c2 0c 00	 ret	 12			; 0000000cH
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 141  : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 142  : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 129  : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 130  :  #if _HAS_EXCEPTIONS
; 131  : 			if (!_STD uncaught_exception())

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  0002b	84 c0		 test	 al, al
  0002d	75 08		 jne	 SHORT $LN2@sentry

; 132  : 				this->_Myostr._Osfx();

  0002f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 105  : 			{	// destroy after unlocking

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 106  : 			if (_Myostr.rdbuf() != 0)

  0003e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  00049	85 c9		 test	 ecx, ecx
  0004b	74 05		 je	 SHORT $LN5@sentry

; 107  : 				_Myostr.rdbuf()->_Unlock();

  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@sentry:

; 133  : 
; 134  :  #else /* _HAS_EXCEPTIONS */
; 135  : 			this->_Myostr._Osfx();
; 136  :  #endif /* _HAS_EXCEPTIONS */
; 137  : 			}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 122  : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 98   : 			: _Myostr(_Ostr)

  0002a	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  0002d	89 37		 mov	 DWORD PTR [edi], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

  00038	85 c9		 test	 ecx, ecx
  0003a	74 05		 je	 SHORT $LN6@sentry

; 101  : 				_Myostr.rdbuf()->_Lock();

  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN6@sentry:

; 102  : 			}
; 103  : 
; 104  : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 105  : 			{	// destroy after unlocking
; 106  : 			if (_Myostr.rdbuf() != 0)
; 107  : 				_Myostr.rdbuf()->_Unlock();
; 108  : 			}
; 109  : 
; 110  : 		_Myt& _Myostr;	// the output stream, for _Unlock call at destruction
; 111  : 
; 112  : 	private:
; 113  : 		_Sentry_base& operator=(const _Sentry_base&);
; 114  : 		};
; 115  : 
; 116  : 	class sentry
; 117  : 		: public _Sentry_base
; 118  : 		{	// stores thread lock and state of stream
; 119  : 	public:
; 120  : 		explicit __CLR_OR_THIS_CALL sentry(_Myt& _Ostr)
; 121  : 			: _Sentry_base(_Ostr)

  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 314  : 		return (_Mystate);

  00048	8b 06		 mov	 eax, DWORD PTR [esi]
  0004a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 338  : 		return (rdstate() == goodbit);

  0004d	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00052	75 12		 jne	 SHORT $LN2@sentry
  00054	8b 4c 30 3c	 mov	 ecx, DWORD PTR [eax+esi+60]
  00058	85 c9		 test	 ecx, ecx
  0005a	74 0a		 je	 SHORT $LN2@sentry
  0005c	3b ce		 cmp	 ecx, esi
  0005e	74 06		 je	 SHORT $LN2@sentry

; 124  : 				_Ostr.tie()->flush();

  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN2@sentry:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 338  : 		return (rdstate() == goodbit);

  00066	8b 06		 mov	 eax, DWORD PTR [esi]
  00068	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006b	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00070	0f 94 c0	 sete	 al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 125  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00073	88 47 04	 mov	 BYTE PTR [edi+4], al

; 126  : 			}

  00076	8b c7		 mov	 eax, edi
  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 1433 : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1434 : 		}

  00002	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$dead$ = ecx

; 1654 : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 1642 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00003	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00006	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Size$[ebp]
  0000c	3b c8		 cmp	 ecx, eax
  0000e	0f 42 c1	 cmovb	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1644 : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 1621 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1622 : 		if (_Mysize < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN5@Check_offs

; 1625 : 			}
; 1626 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN5@Check_offs:

; 1623 : 			{
; 1624 : 			_Xran();

  0000f	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN7@Check_offs:
$LN4@Check_offs:
  00014	cc		 int	 3
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	0f 93 c0	 setae	 al

; 1618 : 		}

  00007	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;
; 1607 : 		if (_Large_string_engaged())

  00004	72 03		 jb	 SHORT $LN8@Myptr

; 1608 : 			{
; 1609 : 			_Result = _Unfancy(_Bx._Ptr);
; 1610 : 			}
; 1611 : 
; 1612 : 		return (_Result);

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1613 : 		}

  00008	c3		 ret	 0
$LN8@Myptr:

; 1608 : 			{
; 1609 : 			_Result = _Unfancy(_Bx._Ptr);
; 1610 : 			}
; 1611 : 
; 1612 : 		return (_Result);

  00009	8b c1		 mov	 eax, ecx

; 1613 : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;
; 1596 : 		if (_Large_string_engaged())

  00004	72 03		 jb	 SHORT $LN8@Myptr

; 1597 : 			{
; 1598 : 			_Result = _Unfancy(_Bx._Ptr);
; 1599 : 			}
; 1600 : 
; 1601 : 		return (_Result);

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1602 : 		}

  00008	c3		 ret	 0
$LN8@Myptr:

; 1597 : 			{
; 1598 : 			_Result = _Unfancy(_Bx._Ptr);
; 1599 : 			}
; 1600 : 
; 1601 : 		return (_Result);

  00009	8b c1		 mov	 eax, ecx

; 1602 : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 872  : 		return (_Al);

  00000	8b c1		 mov	 eax, ecx

; 873  : 		}

  00002	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1840 : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 1841 : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1835 : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 1836 : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1830 : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 1831 : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1825 : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 1826 : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 1815 : 		_Get_data()._Orphan_all();
; 1816 : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$dead$ = ecx

; 1720 : 		_Pocma(_Getal(), _Al);
; 1721 : 		}

  00000	c2 04 00	 ret	 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT
; _this$dead$ = ecx

; 1715 : 		_Pocca(_Getal(), _Al);
; 1716 : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1576 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1703 : 		}

  00007	8b c1		 mov	 eax, ecx

; 1577 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1703 : 		}

  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3706 : 		{	// initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3707 : 		this->_Orphan_all();
; 3708 : 		auto& _My_data = this->_Get_data();
; 3709 : 		if (_My_data._Large_string_engaged())

  00009	72 2d		 jb	 SHORT $LN25@Tidy_deall
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0000b	8b 16		 mov	 edx, DWORD PTR [esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0000d	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 1a		 jb	 SHORT $LN28@Tidy_deall

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00015	f6 c2 1f	 test	 dl, 31			; 0000001fH
  00018	75 31		 jne	 SHORT $_Invalid_parameter$46

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001a	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0001d	3b c2		 cmp	 eax, edx
  0001f	73 2a		 jae	 SHORT $_Invalid_parameter$46

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00021	2b d0		 sub	 edx, eax
  00023	83 fa 04	 cmp	 edx, 4
  00026	72 23		 jb	 SHORT $_Invalid_parameter$46

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00028	83 fa 23	 cmp	 edx, 35			; 00000023H
  0002b	77 1e		 ja	 SHORT $_Invalid_parameter$46

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002d	8b d0		 mov	 edx, eax
$LN28@Tidy_deall:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4
$LN25@Tidy_deall:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00038	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00046	c6 06 00	 mov	 BYTE PTR [esi], 0
  00049	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3722 : 		}

  0004a	c3		 ret	 0
$_Invalid_parameter$46:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN45@Tidy_deall:
$LN44@Tidy_deall:
  00051	cc		 int	 3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3697 : 		auto& _My_data = this->_Get_data();
; 3698 : 		_My_data._Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00007	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0000e	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3703 : 		}

  00011	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$dead$ = 8					; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 3691 : 		auto& _My_data = this->_Get_data();
; 3692 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00004	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1596 : 		if (_Large_string_engaged())

  0000b	72 08		 jb	 SHORT $LN19@Eos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3693 : 		}

  00012	c2 04 00	 ret	 4
$LN19@Eos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3693 : 		}

  00018	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small, COMDAT
; _this$ = ecx

; 3676 : 		{	// release any held storage and return to small string mode

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 3677 : 			// pre: *this is in large string mode
; 3678 : 			// pre: this is small enough to return to small string mode
; 3679 : 		auto& _My_data = this->_Get_data();
; 3680 : 		_My_data._Orphan_all();
; 3681 : 		const pointer _Ptr = _My_data._Bx._Ptr;
; 3682 : 		auto& _Al = this->_Getal();
; 3683 : 		_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3684 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00004	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00007	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00009	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0000a	50		 push	 eax
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3685 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00012	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3685 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00018	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00019	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001e	72 1a		 jb	 SHORT $LN33@Become_sma

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00020	f6 c3 1f	 test	 bl, 31			; 0000001fH
  00023	75 28		 jne	 SHORT $_Invalid_parameter$48

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00025	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00028	3b c3		 cmp	 eax, ebx
  0002a	73 21		 jae	 SHORT $_Invalid_parameter$48

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0002c	2b d8		 sub	 ebx, eax
  0002e	83 fb 04	 cmp	 ebx, 4
  00031	72 1a		 jb	 SHORT $_Invalid_parameter$48

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00033	83 fb 23	 cmp	 ebx, 35			; 00000023H
  00036	77 15		 ja	 SHORT $_Invalid_parameter$48

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00038	8b d8		 mov	 ebx, eax
$LN33@Become_sma:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0003a	53		 push	 ebx
  0003b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00040	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3686 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00043	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 3687 : 		}

  0004c	c3		 ret	 0
$_Invalid_parameter$48:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN47@Become_sma:
$LN46@Become_sma:
  00053	cc		 int	 3
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$dead$ = ecx

; 3583 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3584 : 		return (static_cast<allocator_type>(this->_Getal()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3585 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 3067 : 		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
; 3068 : 		const size_type _Storage_max = // can always store small string
; 3069 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));
; 3070 : 		return (_Min_value(

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 3071 : 			static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3072 : 			_Storage_max - 1 // -1 is for null terminator and/or npos
; 3073 : 			));
; 3074 : 
; 3075 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 32   : 	return (_Left < _Right ? _Right : _Left);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 02		 cmp	 eax, DWORD PTR [edx]
  00004	0f 42 ca	 cmovb	 ecx, edx
  00007	8b c1		 mov	 eax, ecx

; 33   : 	}

  00009	c3		 ret	 0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
$T3 = -4						; size = 1
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 2989 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2990 : 		auto& _My_data = this->_Get_data();
; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]

; 2992 : 		if (_Old_size < _My_data._Myres)

  00007	3b 51 14	 cmp	 edx, DWORD PTR [ecx+20]
  0000a	73 1f		 jae	 SHORT $LN2@push_back

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0000c	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2993 : 			{
; 2994 : 			_My_data._Mysize = _Old_size + 1;

  00010	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00013	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1596 : 		if (_Large_string_engaged())

  00016	72 02		 jb	 SHORT $LN11@push_back
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN11@push_back:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0001a	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  0001d	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00020	c6 44 11 01 00	 mov	 BYTE PTR [ecx+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3008 : 		}

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN2@push_back:

; 2995 : 			_Elem * const _Ptr = _My_data._Myptr();
; 2996 : 			_Traits::assign(_Ptr[_Old_size], _Ch);
; 2997 : 			_Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 2998 : 			return;
; 2999 : 			}
; 3000 : 
; 3001 : 		_Reallocate_grow_by(1,

  0002b	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0002e	c6 45 fc 00	 mov	 BYTE PTR $T3[ebp], 0
  00032	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>

; 3008 : 		}

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z PROC ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator(), COMDAT
; _this$dead$ = ecx

; 3003 : 				const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Old_ptr$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Old_size$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR __New_ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0000e	56		 push	 esi
  0000f	50		 push	 eax
  00010	57		 push	 edi
  00011	e8 00 00 00 00	 call	 _memcpy

; 517  : 		_Left = _Right;

  00016	8a 45 14	 mov	 al, BYTE PTR __Ch$[ebp]

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  0001c	88 04 3e	 mov	 BYTE PTR [esi+edi], al
  0001f	c6 44 3e 01 00	 mov	 BYTE PTR [esi+edi+1], 0
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3007 : 			}, _Ch);

  00026	5d		 pop	 ebp
  00027	c2 10 00	 ret	 16			; 00000010H
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ENDP ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 2840 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1214 : 		: _Ptr(_Parg)

  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1596 : 		if (_Large_string_engaged())

  0000a	72 02		 jb	 SHORT $LN28@begin
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN28@begin:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1214 : 		: _Ptr(_Parg)

  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 2841 : 		auto _My_data = _STD addressof(this->_Get_data());
; 2842 : 		return (iterator(_Refancy<pointer>(_My_data->_Myptr()), _My_data));
; 2843 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__New_capacity$1$ = -4					; size = 4
__Count$dead$ = 8					; size = 4
__Ch$dead$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2456 : 		{	// assign _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 2457 : 		auto& _My_data = this->_Get_data();
; 2458 : 		if (_Count <= _My_data._Myres)

  00008	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  0000b	83 fb 08	 cmp	 ebx, 8
  0000e	72 25		 jb	 SHORT $LN2@assign

; 1595 : 		value_type * _Result = _Bx._Buf;

  00010	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00012	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00015	72 02		 jb	 SHORT $LN11@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
$LN11@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2461 : 			_My_data._Mysize = _Count;

  00019	c7 46 10 08 00
	00 00		 mov	 DWORD PTR [esi+16], 8
  00020	0f 57 c0	 xorps	 xmm0, xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00023	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0

; 517  : 		_Left = _Right;

  00027	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2467 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

  0002b	8b c6		 mov	 eax, esi

; 2471 : 		}

  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN2@assign:

; 3598 : 		if (_Old > _Max - _Old / 2)

  00035	8b cb		 mov	 ecx, ebx
  00037	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0003c	d1 e9		 shr	 ecx, 1
  0003e	2b c1		 sub	 eax, ecx
  00040	57		 push	 edi
  00041	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  00046	3b d8		 cmp	 ebx, eax
  00048	76 07		 jbe	 SHORT $LN57@assign

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);

  0004a	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  0004f	eb 09		 jmp	 SHORT $LN149@assign
$LN57@assign:

; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00051	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00054	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00057	0f 47 f8	 cmova	 edi, eax
$LN149@assign:

; 3620 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0005a	33 c9		 xor	 ecx, ecx

; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0005c	89 7d fc	 mov	 DWORD PTR __New_capacity$1$[ebp], edi

; 3620 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0005f	8b c7		 mov	 eax, edi
  00061	83 c0 01	 add	 eax, 1
  00064	0f 92 c1	 setb	 cl
  00067	f7 d9		 neg	 ecx
  00069	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  0006b	75 04		 jne	 SHORT $LN98@assign

; 53   : 		{
; 54   : 		return (_Ptr);

  0006d	33 ff		 xor	 edi, edi
  0006f	eb 3e		 jmp	 SHORT $LN97@assign
$LN98@assign:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00071	32 c0		 xor	 al, al
  00073	74 06		 je	 SHORT $LN99@assign

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN151@assign:
$LN99@assign:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0007b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00081	72 21		 jb	 SHORT $LN100@assign

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00083	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00086	3b c1		 cmp	 eax, ecx
  00088	77 06		 ja	 SHORT $LN101@assign

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN152@assign:
$LN101@assign:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00096	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00099	8d 78 23	 lea	 edi, DWORD PTR [eax+35]
  0009c	83 e7 e0	 and	 edi, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0009f	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  000a2	eb 0b		 jmp	 SHORT $LN97@assign
$LN100@assign:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000aa	83 c4 04	 add	 esp, 4

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);

  000ad	8b f8		 mov	 edi, eax
$LN97@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3623 : 		_My_data._Myres = _New_capacity;

  000af	8b 45 fc	 mov	 eax, DWORD PTR __New_capacity$1$[ebp]
  000b2	0f 57 c0	 xorps	 xmm0, xmm0

; 3621 : 		_My_data._Orphan_all();
; 3622 : 		_My_data._Mysize = _New_size;

  000b5	c7 46 10 08 00
	00 00		 mov	 DWORD PTR [esi+16], 8

; 3623 : 		_My_data._Myres = _New_capacity;

  000bc	89 46 14	 mov	 DWORD PTR [esi+20], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000bf	66 0f d6 07	 movq	 QWORD PTR [edi], xmm0

; 517  : 		_Left = _Right;

  000c3	c6 47 08 00	 mov	 BYTE PTR [edi+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3625 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000c7	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000ca	72 31		 jb	 SHORT $LN25@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  000cc	8b 06		 mov	 eax, DWORD PTR [esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3627 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000ce	43		 inc	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000cf	32 c9		 xor	 cl, cl
  000d1	75 37		 jne	 SHORT $_Invalid_parameter$154

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000d3	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  000d9	72 19		 jb	 SHORT $LN125@assign

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000db	a8 1f		 test	 al, 31			; 0000001fH
  000dd	75 2b		 jne	 SHORT $_Invalid_parameter$154

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000df	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000e2	3b c8		 cmp	 ecx, eax
  000e4	73 24		 jae	 SHORT $_Invalid_parameter$154

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000e6	2b c1		 sub	 eax, ecx
  000e8	83 f8 04	 cmp	 eax, 4
  000eb	72 1d		 jb	 SHORT $_Invalid_parameter$154

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  000ed	83 f8 23	 cmp	 eax, 35			; 00000023H
  000f0	77 18		 ja	 SHORT $_Invalid_parameter$154

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000f2	8b c1		 mov	 eax, ecx
$LN125@assign:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000fa	83 c4 04	 add	 esp, 4
$LN25@assign:

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000fd	89 3e		 mov	 DWORD PTR [esi], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2467 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

  000ff	8b c6		 mov	 eax, esi
  00101	5f		 pop	 edi

; 2471 : 		}

  00102	5e		 pop	 esi
  00103	5b		 pop	 ebx
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c2 08 00	 ret	 8
$_Invalid_parameter$154:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN153@assign:
$LN150@assign:
  00110	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBE@QADID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
__Ch$dead$ = 16						; size = 1
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBE@QADID@Z PROC ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator(), COMDAT
; _this$dead$ = ecx

; 2467 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00003	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0

; 517  : 		_Left = _Right;

  0000d	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2470 : 			}, _Ch));

  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBE@QADID@Z ENDP ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2451 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2451 : 		{	// assign [_Ptr, <null>)

  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL8@assign:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL8@assign
  00017	2b c7		 sub	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00019	8b ce		 mov	 ecx, esi
  0001b	50		 push	 eax
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 2453 : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -12						; size = 4
__Ptr$GSCopy$1$ = -8					; size = 4
__New_capacity$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2433 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 45 f8	 mov	 DWORD PTR __Ptr$GSCopy$1$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]

; 2434 : 		auto& _My_data = this->_Get_data();
; 2435 : 		if (_Count <= _My_data._Myres)

  00014	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00017	89 4d f4	 mov	 DWORD PTR __Old$1$[ebp], ecx
  0001a	3b f9		 cmp	 edi, ecx
  0001c	77 27		 ja	 SHORT $LN2@assign

; 1595 : 		value_type * _Result = _Bx._Buf;

  0001e	8b de		 mov	 ebx, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00023	72 02		 jb	 SHORT $LN11@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00025	8b 1e		 mov	 ebx, DWORD PTR [esi]
$LN11@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  0002a	89 7e 10	 mov	 DWORD PTR [esi+16], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00036	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0003a	8b c6		 mov	 eax, esi

; 2448 : 		}

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
$LN2@assign:

; 3611 : 		if (_New_size > max_size())

  00045	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  0004b	0f 87 ef 00 00
	00		 ja	 $LN149@assign

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00051	8b df		 mov	 ebx, edi
  00053	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 3592 : 		if (_Masked > _Max)

  00056	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  0005c	76 07		 jbe	 SHORT $LN56@assign

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);

  0005e	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00063	eb 1e		 jmp	 SHORT $LN148@assign
$LN56@assign:

; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  00065	8b d1		 mov	 edx, ecx
  00067	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0006c	d1 ea		 shr	 edx, 1
  0006e	2b c2		 sub	 eax, edx
  00070	3b c8		 cmp	 ecx, eax
  00072	76 07		 jbe	 SHORT $LN57@assign

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);

  00074	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00079	eb 08		 jmp	 SHORT $LN148@assign
$LN57@assign:

; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0007b	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0007e	3b d8		 cmp	 ebx, eax
  00080	0f 42 d8	 cmovb	 ebx, eax
$LN148@assign:

; 3620 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00083	33 c9		 xor	 ecx, ecx

; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00085	89 5d fc	 mov	 DWORD PTR __New_capacity$1$[ebp], ebx

; 3620 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00088	8b c3		 mov	 eax, ebx
  0008a	83 c0 01	 add	 eax, 1
  0008d	0f 92 c1	 setb	 cl
  00090	f7 d9		 neg	 ecx
  00092	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  00094	75 04		 jne	 SHORT $LN98@assign

; 53   : 		{
; 54   : 		return (_Ptr);

  00096	33 db		 xor	 ebx, ebx
  00098	eb 3e		 jmp	 SHORT $LN97@assign
$LN98@assign:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  0009a	32 c0		 xor	 al, al
  0009c	74 06		 je	 SHORT $LN99@assign

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN151@assign:
$LN99@assign:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  000a4	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000aa	72 21		 jb	 SHORT $LN100@assign

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  000ac	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  000af	3b c1		 cmp	 eax, ecx
  000b1	77 06		 ja	 SHORT $LN101@assign

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN152@assign:
$LN101@assign:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000bf	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  000c2	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000c5	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000c8	89 43 fc	 mov	 DWORD PTR [ebx-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  000cb	eb 0b		 jmp	 SHORT $LN97@assign
$LN100@assign:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000d3	83 c4 04	 add	 esp, 4

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);

  000d6	8b d8		 mov	 ebx, eax
$LN97@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3623 : 		_My_data._Myres = _New_capacity;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR __New_capacity$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000db	57		 push	 edi
  000dc	ff 75 f8	 push	 DWORD PTR __Ptr$GSCopy$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3622 : 		_My_data._Mysize = _New_size;

  000df	89 7e 10	 mov	 DWORD PTR [esi+16], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000e2	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3623 : 		_My_data._Myres = _New_capacity;

  000e3	89 46 14	 mov	 DWORD PTR [esi+20], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000e6	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3625 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000eb	8b 45 f4	 mov	 eax, DWORD PTR __Old$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  000f1	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3625 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000f5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000f8	72 33		 jb	 SHORT $LN25@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000fa	32 d2		 xor	 dl, dl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3627 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000fc	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  000ff	8b 06		 mov	 eax, DWORD PTR [esi]

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  00101	75 37		 jne	 SHORT $_Invalid_parameter$155

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00103	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00109	72 19		 jb	 SHORT $LN125@assign

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0010b	a8 1f		 test	 al, 31			; 0000001fH
  0010d	75 2b		 jne	 SHORT $_Invalid_parameter$155

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0010f	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00112	3b c8		 cmp	 ecx, eax
  00114	73 24		 jae	 SHORT $_Invalid_parameter$155

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00116	2b c1		 sub	 eax, ecx
  00118	83 f8 04	 cmp	 eax, 4
  0011b	72 1d		 jb	 SHORT $_Invalid_parameter$155

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  0011d	83 f8 23	 cmp	 eax, 35			; 00000023H
  00120	77 18		 ja	 SHORT $_Invalid_parameter$155

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00122	8b c1		 mov	 eax, ecx
$LN125@assign:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0012a	83 c4 04	 add	 esp, 4
$LN25@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2448 : 		}

  0012d	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0012e	89 1e		 mov	 DWORD PTR [esi], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00130	8b c6		 mov	 eax, esi

; 2448 : 		}

  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c2 08 00	 ret	 8
$_Invalid_parameter$155:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN153@assign:
$LN149@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3613 : 			_Xlen();	// result too long

  00140	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN154@assign:
$LN147@assign:
  00145	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$dead$ = ecx

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00007	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00018	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2447 : 			}, _Ptr));

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
$T3 = 8							; size = 1
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2375 : 		{	// append _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2376 : 		auto& _My_data = this->_Get_data();
; 2377 : 		const size_type _Old_size = _My_data._Mysize;
; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0000d	8b c2		 mov	 eax, edx
  0000f	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00012	2b c1		 sub	 eax, ecx
  00014	3b d8		 cmp	 ebx, eax
  00016	77 2f		 ja	 SHORT $LN2@append

; 2379 : 			{
; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  00018	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0001b	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  0001e	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00020	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00023	72 02		 jb	 SHORT $LN11@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00025	8b 07		 mov	 eax, DWORD PTR [edi]
$LN11@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2382 : 			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  00027	56		 push	 esi
  00028	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  0002b	0f be 45 0c	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0002f	53		 push	 ebx
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 _memset
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  0003a	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2384 : 			return (*this);

  0003e	8b c7		 mov	 eax, edi
  00040	5e		 pop	 esi

; 2388 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2389 : 				const size_type _Count, const _Elem _Ch) {
; 2390 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2392 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2393 : 			}, _Count, _Ch));
; 2394 : 		}

  00041	5f		 pop	 edi
  00042	5b		 pop	 ebx
  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN2@append:

; 2385 : 			}
; 2386 : 
; 2387 : 		return (_Reallocate_grow_by(_Count,

  00047	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  0004a	c6 45 08 00	 mov	 BYTE PTR $T3[ebp], 0
  0004e	8b cf		 mov	 ecx, edi
  00050	53		 push	 ebx
  00051	ff 75 08	 push	 DWORD PTR $T3[ebp]
  00054	53		 push	 ebx
  00055	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>

; 2388 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2389 : 				const size_type _Count, const _Elem _Ch) {
; 2390 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2392 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2393 : 			}, _Count, _Ch));
; 2394 : 		}

  0005a	5f		 pop	 edi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Count$ = 20						; size = 4
__Ch$ = 24						; size = 1
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z PROC ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator(), COMDAT
; _this$dead$ = ecx

; 2389 : 				const size_type _Count, const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2389 : 				const size_type _Count, const _Elem _Ch) {

  00007	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00008	8b 7d 10	 mov	 edi, DWORD PTR __Old_size$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00015	0f be 45 18	 movsx	 eax, BYTE PTR __Ch$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  00019	03 fe		 add	 edi, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  0001b	8b 75 14	 mov	 esi, DWORD PTR __Count$[ebp]
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 _memset
  00026	83 c4 18	 add	 esp, 24			; 00000018H

; 517  : 		_Left = _Right;

  00029	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2393 : 			}, _Count, _Ch));

  0002f	5d		 pop	 ebp
  00030	c2 14 00	 ret	 20			; 00000014H
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ENDP ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
$T3 = 12						; size = 1
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2348 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2349 : 		auto& _My_data = this->_Get_data();
; 2350 : 		const size_type _Old_size = _My_data._Mysize;
; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0000d	8b c2		 mov	 eax, edx
  0000f	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00012	2b c1		 sub	 eax, ecx
  00014	3b d8		 cmp	 ebx, eax
  00016	77 2e		 ja	 SHORT $LN2@append

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  00018	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0001b	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  0001e	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00020	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00023	72 02		 jb	 SHORT $LN11@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00025	8b 07		 mov	 eax, DWORD PTR [edi]
$LN11@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00027	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00028	53		 push	 ebx
  00029	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0002c	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0002f	56		 push	 esi
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00039	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  0003d	8b c7		 mov	 eax, edi
  0003f	5e		 pop	 esi

; 2361 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2362 : 				const _Elem * const _Ptr, const size_type _Count) {
; 2363 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2364 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2365 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2366 : 			}, _Ptr, _Count));
; 2367 : 		}

  00040	5f		 pop	 edi
  00041	5b		 pop	 ebx
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN2@append:

; 2358 : 			}
; 2359 : 
; 2360 : 		return (_Reallocate_grow_by(_Count,

  00046	53		 push	 ebx
  00047	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0004a	c6 45 0c 00	 mov	 BYTE PTR $T3[ebp], 0
  0004e	8b cf		 mov	 ecx, edi
  00050	ff 75 0c	 push	 DWORD PTR $T3[ebp]
  00053	53		 push	 ebx
  00054	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>

; 2361 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2362 : 				const _Elem * const _Ptr, const size_type _Count) {
; 2363 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2364 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2365 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2366 : 			}, _Ptr, _Count));
; 2367 : 		}

  00059	5f		 pop	 edi
  0005a	5b		 pop	 ebx
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$dead$ = ecx

; 2362 : 				const _Elem * const _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2362 : 				const _Elem * const _Ptr, const size_type _Count) {

  00007	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00008	8b 7d 10	 mov	 edi, DWORD PTR __Old_size$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2364 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00015	03 fe		 add	 edi, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00017	8b 75 18	 mov	 esi, DWORD PTR __Count$[ebp]
  0001a	56		 push	 esi
  0001b	ff 75 14	 push	 DWORD PTR __Ptr$[ebp]
  0001e	57		 push	 edi
  0001f	e8 00 00 00 00	 call	 _memcpy
  00024	83 c4 18	 add	 esp, 24			; 00000018H

; 517  : 		_Left = _Right;

  00027	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2366 : 			}, _Ptr, _Count));

  0002d	5d		 pop	 ebp
  0002e	c2 14 00	 ret	 20			; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2296 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 2296 : 		{	// append _Right

  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00009	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2296 : 		{	// append _Right

  0000d	8b f9		 mov	 edi, ecx

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0000f	8b c8		 mov	 ecx, eax

; 1607 : 		if (_Large_string_engaged())

  00011	72 02		 jb	 SHORT $LN12@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN12@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00015	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00018	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  0001b	8b c6		 mov	 eax, esi
  0001d	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00020	2b c2		 sub	 eax, edx
  00022	3b d8		 cmp	 ebx, eax
  00024	77 2b		 ja	 SHORT $LN19@operator

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  00026	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  00029	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  0002c	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0002e	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00031	72 02		 jb	 SHORT $LN28@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00033	8b 07		 mov	 eax, DWORD PTR [edi]
$LN28@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00035	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00036	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00039	51		 push	 ecx
  0003a	56		 push	 esi
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00044	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2297 : 		return (append(_Right));

  00048	8b c7		 mov	 eax, edi

; 2298 : 		}

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN19@operator:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  00051	53		 push	 ebx
  00052	51		 push	 ecx
  00053	c6 45 08 00	 mov	 BYTE PTR $T5[ebp], 0
  00057	8b cf		 mov	 ecx, edi
  00059	ff 75 08	 push	 DWORD PTR $T5[ebp]
  0005c	53		 push	 ebx
  0005d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>

; 2298 : 		}

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z
_TEXT	SEGMENT
__New_capacity$1$ = -4					; size = 4
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2181 : 		{	// assign by copying data stored in _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0000c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2182 : 			// pre: this != &_Right
; 2183 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2184 : 		auto& _My_data = this->_Get_data();
; 2185 : 		auto& _Right_data = _Right._Get_data();
; 2186 : 		const size_type _Right_size = _Right_data._Mysize;

  00010	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]

; 1607 : 		if (_Large_string_engaged())

  00013	72 02		 jb	 SHORT $LN17@Construct_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00015	8b 36		 mov	 esi, DWORD PTR [esi]
$LN17@Construct_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2188 : 		if (_Right_size < this->_BUF_SIZE)

  00017	83 fb 10	 cmp	 ebx, 16			; 00000010H
  0001a	73 19		 jae	 SHORT $LN2@Construct_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0001c	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  0001f	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2201 : 		_My_data._Mysize = _Right_size;

  00022	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
  00025	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 2203 : 		}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN2@Construct_:

; 2189 : 			{   // stay small, don't allocate
; 2190 : 			_Traits::copy(_My_data._Bx._Buf, _Right_ptr, this->_BUF_SIZE);
; 2191 : 			_My_data._Mysize = _Right_size;
; 2192 : 			_My_data._Myres = this->_BUF_SIZE - 1;
; 2193 : 			return;
; 2194 : 			}
; 2195 : 
; 2196 : 		auto& _Al = this->_Getal();
; 2197 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  00035	8b c3		 mov	 eax, ebx
  00037	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  0003c	83 c8 0f	 or	 eax, 15			; 0000000fH
  0003f	3b c1		 cmp	 eax, ecx
  00041	0f 47 c1	 cmova	 eax, ecx
  00044	89 45 fc	 mov	 DWORD PTR __New_capacity$1$[ebp], eax

; 2198 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  00047	83 c0 01	 add	 eax, 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  0004a	75 04		 jne	 SHORT $LN59@Construct_

; 53   : 		{
; 54   : 		return (_Ptr);

  0004c	33 d2		 xor	 edx, edx
  0004e	eb 3d		 jmp	 SHORT $LN58@Construct_
$LN59@Construct_:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00050	32 c9		 xor	 cl, cl
  00052	74 06		 je	 SHORT $LN60@Construct_

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN86@Construct_:
$LN60@Construct_:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0005a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0005f	72 21		 jb	 SHORT $LN61@Construct_

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00061	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00064	3b c8		 cmp	 ecx, eax
  00066	77 06		 ja	 SHORT $LN62@Construct_

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN87@Construct_:
$LN62@Construct_:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00074	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00077	8d 50 23	 lea	 edx, DWORD PTR [eax+35]
  0007a	83 e2 e0	 and	 edx, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0007d	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  00080	eb 0b		 jmp	 SHORT $LN58@Construct_
$LN61@Construct_:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00088	83 c4 04	 add	 esp, 4

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);

  0008b	8b d0		 mov	 edx, eax
$LN58@Construct_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2200 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  0008d	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00090	89 17		 mov	 DWORD PTR [edi], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00092	51		 push	 ecx
  00093	56		 push	 esi
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2202 : 		_My_data._Myres = _New_capacity;

  0009a	8b 45 fc	 mov	 eax, DWORD PTR __New_capacity$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2201 : 		_My_data._Mysize = _Right_size;

  000a0	89 5f 10	 mov	 DWORD PTR [edi+16], ebx

; 2202 : 		_My_data._Myres = _New_capacity;

  000a3	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 2203 : 		}

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 04 00	 ret	 4
$LN85@Construct_:
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2131 : 		{	// assign by stealing _Right's buffer, memcpy optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2132 : 			// pre: this != &_Right
; 2133 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2134 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2135 : 		auto& _Right_data = _Right._Get_data();
; 2136 : 
; 2137 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2138 : 		if (_Right_data._Large_string_engaged())
; 2139 : 			{	// take ownership of _Right's iterators along with its buffer
; 2140 : 			this->_Swap_all(_Right);
; 2141 : 			}
; 2142 : 		else
; 2143 : 			{
; 2144 : 			_Right._Orphan_all();
; 2145 : 			}
; 2146 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2147 : 
; 2148 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2149 : 			+ _Memcpy_move_offset;
; 2150 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2151 : 			+ _Memcpy_move_offset;
; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00009	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0000c	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00011	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00016	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0001d	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00024	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2154 : 		}

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents, COMDAT
; _this$ = ecx

; 2108 : 		{	// assign either as an rvalue or as an lvalue copy, allocators always equal optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00009	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0000c	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00011	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00016	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0001d	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00024	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2113 : 		}

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
__Roff$dead$ = 12					; size = 4
__Count$dead$ = 16					; size = 4
__Al$dead$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1955 : 		{	// construct from _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3698 : 		_My_data._Mysize = 0;

  00006	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00014	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  00017	a1 10 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0001c	83 f8 05	 cmp	 eax, 5
  0001f	72 32		 jb	 SHORT $LN53@basic_stri

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00021	83 c0 fb	 add	 eax, -5			; fffffffbH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00024	83 ca ff	 or	 edx, -1
  00027	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0002f	0f 42 d0	 cmovb	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00032	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00039	52		 push	 edx

; 1607 : 		if (_Large_string_engaged())

  0003a	0f 43 0d 00 00
	00 00		 cmovae	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00041	83 c1 05	 add	 ecx, 5
  00044	51		 push	 ecx
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1956 : 		_Tidy_init();
; 1957 : 		assign(_Right, _Roff, _Count);
; 1958 : 		}

  0004c	8b c6		 mov	 eax, esi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp
  00050	c2 10 00	 ret	 16			; 00000010H
$LN53@basic_stri:

; 1624 : 			_Xran();

  00053	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN55@basic_stri:
$LN52@basic_stri:
  00058	cc		 int	 3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT
; _this$ = ecx

; 723  : 		{	// set up putback area

  00000	8b d1		 mov	 edx, ecx
  00002	56		 push	 esi
  00003	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00004	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 724  : 		if (_Mysb::eback() != &_Mychar)

  00007	8d 72 3c	 lea	 esi, DWORD PTR [edx+60]
  0000a	8b 07		 mov	 eax, DWORD PTR [edi]
  0000c	3b c6		 cmp	 eax, esi
  0000e	74 10		 je	 SHORT $LN2@Set_back
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00010	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 726  : 			_Set_eback = _Mysb::eback();

  00013	89 42 50	 mov	 DWORD PTR [edx+80], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00016	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	03 01		 add	 eax, DWORD PTR [ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 727  : 			_Set_egptr = _Mysb::egptr();

  0001d	89 42 54	 mov	 DWORD PTR [edx+84], eax
$LN2@Set_back:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00020	89 37		 mov	 DWORD PTR [edi], esi

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  00022	8b ca		 mov	 ecx, edx
  00024	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00027	2b ce		 sub	 ecx, esi
  00029	83 c1 3d	 add	 ecx, 61			; 0000003dH
  0002c	5f		 pop	 edi
  0002d	89 30		 mov	 DWORD PTR [eax], esi
  0002f	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00032	5e		 pop	 esi
  00033	89 08		 mov	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 730  : 		}

  00035	c3		 ret	 0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; _this$ = ecx

; 717  : 		{	// restore buffer after putback

  00000	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00001	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  00004	8d 41 3c	 lea	 eax, DWORD PTR [ecx+60]
  00007	39 07		 cmp	 DWORD PTR [edi], eax
  00009	75 16		 jne	 SHORT $LN2@Reset_back

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0000b	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0000e	56		 push	 esi
  0000f	8b 71 54	 mov	 esi, DWORD PTR [ecx+84]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00012	89 17		 mov	 DWORD PTR [edi], edx

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  00014	2b f2		 sub	 esi, edx
  00016	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00019	89 10		 mov	 DWORD PTR [eax], edx
  0001b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi
$LN2@Reset_back:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 720  : 		}

  00021	5f		 pop	 edi
  00022	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
__Newpcvt$ = 8						; size = 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT
; _this$ = ecx

; 698  : 		{	// initialize codecvt pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 699  : 		if (_Newpcvt->always_noconv())

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Newpcvt$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b cf		 mov	 ecx, edi
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
  00012	84 c0		 test	 al, al
  00014	74 0d		 je	 SHORT $LN2@Initcvt

; 705  : 			}
; 706  : 		}

  00016	5f		 pop	 edi
  00017	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN2@Initcvt:

; 700  : 			_Pcvt = 0;	// nothing to do
; 701  : 		else
; 702  : 			{	// set up for nontrivial codecvt facet
; 703  : 			_Pcvt = _Newpcvt;
; 704  : 			_Mysb::_Init();	// reset any buffering

  00023	8b ce		 mov	 ecx, esi
  00025	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 705  : 			}
; 706  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
$T35 = -48						; size = 1
__Dest$42 = -44						; size = 4
__Str$43 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT
; _this$ = ecx

; 657  : 		{	// put shift to initial conversion state, as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx

; 658  : 		if (_Pcvt == 0 || !_Wrotesome)

  0002d	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00031	0f 84 62 01 00
	00		 je	 $LN9@Endwrite
  00037	80 7b 3d 00	 cmp	 BYTE PTR [ebx+61], 0
  0003b	0f 84 58 01 00
	00		 je	 $LN9@Endwrite

; 660  : 		else
; 661  : 			{	// may have to put
; 662  : 			const int _STRING_INC = 8;
; 663  : 			char *_Dest;
; 664  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

  00041	8b 03		 mov	 eax, DWORD PTR [ebx]
  00043	6a ff		 push	 -1
  00045	ff 50 0c	 call	 DWORD PTR [eax+12]
  00048	83 f8 ff	 cmp	 eax, -1
  0004b	75 07		 jne	 SHORT $LN10@Endwrite

; 665  : 				return (false);

  0004d	32 c0		 xor	 al, al
  0004f	e9 47 01 00 00	 jmp	 $LN8@Endwrite
$LN10@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1993 : 		assign(_Count, _Ch);

  00054	83 ec 08	 sub	 esp, 8

; 3698 : 		_My_data._Mysize = 0;

  00057	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$43[ebp+16], 0

; 1993 : 		assign(_Count, _Ch);

  0005e	8d 4d d8	 lea	 ecx, DWORD PTR __Str$43[ebp]

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00061	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Str$43[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00068	c6 45 d8 00	 mov	 BYTE PTR __Str$43[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1993 : 		assign(_Count, _Ch);

  0006c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 667  : 			string _Str(_STRING_INC, '\0');

  00071	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
$LN268@Endwrite:
  00078	8b 75 ec	 mov	 esi, DWORD PTR __Str$43[ebp+20]
  0007b	8d 7b 40	 lea	 edi, DWORD PTR [ebx+64]
  0007e	8b 45 d8	 mov	 eax, DWORD PTR __Str$43[ebp]
$LL2@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00081	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  00084	8d 55 d8	 lea	 edx, DWORD PTR __Str$43[ebp]
  00087	8d 4d d8	 lea	 ecx, DWORD PTR __Str$43[ebp]

; 1596 : 		if (_Large_string_engaged())

  0008a	0f 43 c8	 cmovae	 ecx, eax
  0008d	0f 43 d0	 cmovae	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 669  : 				switch (_Pcvt->unshift(_State,

  00090	8d 45 d4	 lea	 eax, DWORD PTR __Dest$42[ebp]
  00093	50		 push	 eax
  00094	8b 45 e8	 mov	 eax, DWORD PTR __Str$43[ebp+16]
  00097	03 c2		 add	 eax, edx
  00099	50		 push	 eax
  0009a	51		 push	 ecx
  0009b	8b 4b 38	 mov	 ecx, DWORD PTR [ebx+56]
  0009e	57		 push	 edi
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z
  000a5	83 e8 00	 sub	 eax, 0
  000a8	74 1b		 je	 SHORT $LN11@Endwrite
  000aa	83 e8 01	 sub	 eax, 1
  000ad	74 1a		 je	 SHORT $LN12@Endwrite

; 692  : 					return (false);	// conversion failed

  000af	8b 75 ec	 mov	 esi, DWORD PTR __Str$43[ebp+20]
  000b2	83 e8 02	 sub	 eax, 2
  000b5	8b 45 d8	 mov	 eax, DWORD PTR __Str$43[ebp]
  000b8	0f 84 9b 00 00
	00		 je	 $LN262@Endwrite
$LN261@Endwrite:
  000be	32 db		 xor	 bl, bl
  000c0	e9 96 00 00 00	 jmp	 $LN22@Endwrite
$LN11@Endwrite:

; 670  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 671  : 				{	// test result of homing conversion
; 672  : 				case codecvt_base::ok:
; 673  : 					_Wrotesome = false;	// homed successfully

  000c5	c6 43 3d 00	 mov	 BYTE PTR [ebx+61], 0
$LN12@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000c9	8b 75 ec	 mov	 esi, DWORD PTR __Str$43[ebp+20]

; 1595 : 		value_type * _Result = _Bx._Buf;

  000cc	8d 4d d8	 lea	 ecx, DWORD PTR __Str$43[ebp]

; 1596 : 		if (_Large_string_engaged())

  000cf	8b 45 d8	 mov	 eax, DWORD PTR __Str$43[ebp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000d2	83 fe 10	 cmp	 esi, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 677  : 					size_t _Count = _Dest - &*_Str.begin();

  000d5	8b 7d d4	 mov	 edi, DWORD PTR __Dest$42[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1596 : 		if (_Large_string_engaged())

  000d8	0f 43 c8	 cmovae	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 677  : 					size_t _Count = _Dest - &*_Str.begin();

  000db	2b f9		 sub	 edi, ecx

; 678  : 					if (0 < _Count && _Count !=

  000dd	74 23		 je	 SHORT $LN13@Endwrite
  000df	ff 73 4c	 push	 DWORD PTR [ebx+76]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000e2	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  000e5	8d 4d d8	 lea	 ecx, DWORD PTR __Str$43[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 678  : 					if (0 < _Count && _Count !=

  000e8	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1596 : 		if (_Large_string_engaged())

  000e9	0f 43 c8	 cmovae	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 678  : 					if (0 < _Count && _Count !=

  000ec	6a 01		 push	 1
  000ee	51		 push	 ecx
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  000f5	8b 75 ec	 mov	 esi, DWORD PTR __Str$43[ebp+20]
  000f8	83 c4 10	 add	 esp, 16			; 00000010H
  000fb	3b f8		 cmp	 edi, eax
  000fd	8b 45 d8	 mov	 eax, DWORD PTR __Str$43[ebp]
  00100	75 bc		 jne	 SHORT $LN261@Endwrite
$LN13@Endwrite:

; 679  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 680  : 						return (false);	// write failed
; 681  : 					if (!_Wrotesome)

  00102	80 7b 3d 00	 cmp	 BYTE PTR [ebx+61], 0
  00106	74 51		 je	 SHORT $LN262@Endwrite

; 683  : 					if (_Count == 0)

  00108	85 ff		 test	 edi, edi
  0010a	8d 7b 40	 lea	 edi, DWORD PTR [ebx+64]
  0010d	0f 85 6e ff ff
	ff		 jne	 $LL2@Endwrite
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2377 : 		const size_type _Old_size = _My_data._Mysize;

  00113	8b 55 e8	 mov	 edx, DWORD PTR __Str$43[ebp+16]

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  00116	8b ce		 mov	 ecx, esi
  00118	2b ca		 sub	 ecx, edx
  0011a	8b fa		 mov	 edi, edx
  0011c	83 f9 08	 cmp	 ecx, 8

; 1595 : 		value_type * _Result = _Bx._Buf;

  0011f	8d 4d d8	 lea	 ecx, DWORD PTR __Str$43[ebp]

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  00122	72 1e		 jb	 SHORT $LN192@Endwrite

; 2379 : 			{
; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  00124	83 c2 08	 add	 edx, 8
  00127	0f 57 c0	 xorps	 xmm0, xmm0

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0012a	83 fe 10	 cmp	 esi, 16			; 00000010H

; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  0012d	89 55 e8	 mov	 DWORD PTR __Str$43[ebp+16], edx

; 1596 : 		if (_Large_string_engaged())

  00130	0f 43 c8	 cmovae	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00133	66 0f d6 04 39	 movq	 QWORD PTR [ecx+edi], xmm0

; 517  : 		_Left = _Right;

  00138	c6 44 39 08 00	 mov	 BYTE PTR [ecx+edi+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2384 : 			return (*this);

  0013d	e9 36 ff ff ff	 jmp	 $LN268@Endwrite
$LN192@Endwrite:

; 2385 : 			}
; 2386 : 
; 2387 : 		return (_Reallocate_grow_by(_Count,

  00142	6a 00		 push	 0
  00144	6a 08		 push	 8
  00146	c6 45 d0 00	 mov	 BYTE PTR $T35[ebp], 0
  0014a	ff 75 d0	 push	 DWORD PTR $T35[ebp]
  0014d	6a 08		 push	 8
  0014f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 693  : 				}

  00154	e9 1f ff ff ff	 jmp	 $LN268@Endwrite
$LN262@Endwrite:

; 682  : 						return (true);

  00159	b3 01		 mov	 bl, 1
$LN22@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0015b	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3709 : 		if (_My_data._Large_string_engaged())

  0015e	72 2f		 jb	 SHORT $LN240@Endwrite

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00160	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00163	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00169	72 1b		 jb	 SHORT $LN243@Endwrite

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0016b	f6 45 d8 1f	 test	 BYTE PTR __Str$43[ebp], 31 ; 0000001fH
  0016f	75 22		 jne	 SHORT $_Invalid_parameter$270

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00171	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00174	3b c8		 cmp	 ecx, eax
  00176	73 1b		 jae	 SHORT $_Invalid_parameter$270

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00178	2b c1		 sub	 eax, ecx
  0017a	83 f8 04	 cmp	 eax, 4
  0017d	72 14		 jb	 SHORT $_Invalid_parameter$270

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  0017f	83 f8 23	 cmp	 eax, 35			; 00000023H
  00182	77 0f		 ja	 SHORT $_Invalid_parameter$270

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00184	8b c1		 mov	 eax, ecx
$LN243@Endwrite:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00186	50		 push	 eax
  00187	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0018c	83 c4 04	 add	 esp, 4
$LN240@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 692  : 					return (false);	// conversion failed

  0018f	8a c3		 mov	 al, bl
  00191	eb 08		 jmp	 SHORT $LN8@Endwrite
$_Invalid_parameter$270:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN269@Endwrite:
$LN9@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 659  : 			return (true);

  00199	b0 01		 mov	 al, 1
$LN8@Endwrite:

; 694  : 			}
; 695  : 		}

  0019b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0019e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a5	59		 pop	 ecx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi
  001a8	5b		 pop	 ebx
  001a9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ac	33 cd		 xor	 ecx, ebp
  001ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	c3		 ret	 0
$LN267@Endwrite:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Str$43[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__Nr$1 = -16						; size = 4
__Pn$2 = -12						; size = 4
__Pb$3 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__File$ = 8						; size = 4
__Which$ = 12						; size = 4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 622  : 		{	// initialize to C stream _File after {new, open, close}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 623  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 624  : 
; 625  : 		_Closef = _Which == _Openfl;

  00010	83 7d 0c 01	 cmp	 DWORD PTR __Which$[ebp], 1
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
  00017	0f 94 c0	 sete	 al
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR __File$[ebp]
  0001e	88 46 48	 mov	 BYTE PTR [esi+72], al

; 626  : 		_Wrotesome = false;

  00021	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)

  0002b	85 ff		 test	 edi, edi
  0002d	74 46		 je	 SHORT $LN2@Init

; 641  : 			::_get_stream_buffer_pointers(

  0002f	8d 45 f0	 lea	 eax, DWORD PTR __Nr$1[ebp]
  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Pb$3[ebp], 0
  00039	50		 push	 eax
  0003a	8d 45 f4	 lea	 eax, DWORD PTR __Pn$2[ebp]
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Pn$2[ebp], 0
  00044	50		 push	 eax
  00045	8d 45 f8	 lea	 eax, DWORD PTR __Pb$3[ebp]
  00048	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Nr$1[ebp], 0
  0004f	50		 push	 eax
  00050	57		 push	 edi
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___get_stream_buffer_pointers
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 331  : 		_IGfirst = _Gf;

  00057	8b 45 f8	 mov	 eax, DWORD PTR __Pb$3[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 641  : 			::_get_stream_buffer_pointers(

  0005a	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 331  : 		_IGfirst = _Gf;

  0005d	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 332  : 		_IPfirst = _Pf;

  00060	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 333  : 		_IGnext = _Gn;

  00063	8b 45 f4	 mov	 eax, DWORD PTR __Pn$2[ebp]
  00066	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 334  : 		_IPnext = _Pn;

  00069	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 335  : 		_IGcount = _Gc;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR __Nr$1[ebp]
  0006f	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 336  : 		_IPcount = _Pc;

  00072	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN2@Init:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 652  : 		_State = _Stinit;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet
; 654  : 		}

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007d	89 7e 4c	 mov	 DWORD PTR [esi+76], edi
  00080	33 cd		 xor	 ecx, ebp
  00082	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00085	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  0008a	5f		 pop	 edi
  0008b	89 46 44	 mov	 DWORD PTR [esi+68], eax
  0008e	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00095	5e		 pop	 esi
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 359  : 		{	// close the C stream

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi

; 360  : 		_Myt *_Ans = this;
; 361  : 		if (_Myfile == 0)

  00005	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00009	75 04		 jne	 SHORT $LN2@close

; 362  : 			_Ans = 0;

  0000b	33 ff		 xor	 edi, edi

; 363  : 		else

  0000d	eb 21		 jmp	 SHORT $LN5@close
$LN2@close:

; 364  : 			{	// put any homing sequence and close file
; 365  : 			if (!_Endwrite())

  0000f	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 366  : 				_Ans = 0;
; 367  : 			if (fclose(_Myfile) != 0)

  00014	ff 76 4c	 push	 DWORD PTR [esi+76]
  00017	33 c9		 xor	 ecx, ecx
  00019	8b fe		 mov	 edi, esi
  0001b	84 c0		 test	 al, al
  0001d	0f 44 f9	 cmove	 edi, ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00026	33 c9		 xor	 ecx, ecx
  00028	83 c4 04	 add	 esp, 4
  0002b	85 c0		 test	 eax, eax
  0002d	0f 45 f9	 cmovne	 edi, ecx
$LN5@close:

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00030	8b ce		 mov	 ecx, esi
  00032	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0
  00036	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 652  : 		_State = _Stinit;

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 368  : 				_Ans = 0;
; 369  : 			}
; 370  : 		_Init(0, _Closefl);
; 371  : 		return (_Ans);

  00046	8b c7		 mov	 eax, edi

; 652  : 		_State = _Stinit;

  00048	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  0004b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4

; 372  : 		}

  00051	5f		 pop	 edi

; 651  : 		_Myfile = _File;

  00052	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0

; 652  : 		_State = _Stinit;

  00059	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  0005c	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 372  : 		}

  00063	5e		 pop	 esi
  00064	59		 pop	 ecx
  00065	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
$T1 = -32						; size = 8
__Nr$5 = -28						; size = 4
__Pn$6 = -24						; size = 4
__Pb$7 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$dead$ = 16					; size = 4
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 275  : 		{	// open a C stream with specified mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f1		 mov	 esi, ecx

; 276  : 		_Filet *_File;
; 277  : 		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)

  0002c	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00030	8b 45 08	 mov	 eax, DWORD PTR __Filename$[ebp]
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR __Mode$[ebp]
  00036	0f 85 e6 00 00
	00		 jne	 $LN3@open
  0003c	6a 40		 push	 64			; 00000040H
  0003e	51		 push	 ecx
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z
  00046	8b f8		 mov	 edi, eax
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	85 ff		 test	 edi, edi
  0004d	0f 84 cf 00 00
	00		 je	 $LN3@open

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00053	8b ce		 mov	 ecx, esi
  00055	c6 46 48 01	 mov	 BYTE PTR [esi+72], 1
  00059	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 641  : 			::_get_stream_buffer_pointers(

  00063	8d 45 e4	 lea	 eax, DWORD PTR __Nr$5[ebp]
  00066	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Pb$7[ebp], 0
  0006d	50		 push	 eax
  0006e	8d 45 e8	 lea	 eax, DWORD PTR __Pn$6[ebp]
  00071	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Pn$6[ebp], 0
  00078	50		 push	 eax
  00079	8d 45 ec	 lea	 eax, DWORD PTR __Pb$7[ebp]
  0007c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Nr$5[ebp], 0
  00083	50		 push	 eax
  00084	57		 push	 edi
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___get_stream_buffer_pointers
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 331  : 		_IGfirst = _Gf;

  0008b	8b 45 ec	 mov	 eax, DWORD PTR __Pb$7[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 641  : 			::_get_stream_buffer_pointers(

  0008e	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 331  : 		_IGfirst = _Gf;

  00091	89 46 0c	 mov	 DWORD PTR [esi+12], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 281  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

  00094	8b ce		 mov	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 332  : 		_IPfirst = _Pf;

  00096	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 333  : 		_IGnext = _Gn;

  00099	8b 45 e8	 mov	 eax, DWORD PTR __Pn$6[ebp]
  0009c	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 334  : 		_IPnext = _Pn;

  0009f	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 335  : 		_IGcount = _Gc;

  000a2	8b 45 e4	 mov	 eax, DWORD PTR __Nr$5[ebp]
  000a5	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 336  : 		_IPcount = _Pc;

  000a8	89 46 30	 mov	 DWORD PTR [esi+48], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 652  : 		_State = _Stinit;

  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  000b0	89 46 40	 mov	 DWORD PTR [esi+64], eax
  000b3	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000b8	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 281  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

  000bb	8d 45 e0	 lea	 eax, DWORD PTR $T1[ebp]
  000be	50		 push	 eax

; 651  : 		_Myfile = _File;

  000bf	89 7e 4c	 mov	 DWORD PTR [esi+76], edi

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c2	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 281  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
  000cf	8b c8		 mov	 ecx, eax
  000d1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d8	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  000dd	8b f8		 mov	 edi, eax

; 699  : 		if (_Newpcvt->always_noconv())

  000df	8b cf		 mov	 ecx, edi
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
  000e7	84 c0		 test	 al, al
  000e9	74 09		 je	 SHORT $LN18@open

; 700  : 			_Pcvt = 0;	// nothing to do

  000eb	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 701  : 		else

  000f2	eb 0b		 jmp	 SHORT $LN19@open
$LN18@open:

; 702  : 			{	// set up for nontrivial codecvt facet
; 703  : 			_Pcvt = _Newpcvt;
; 704  : 			_Mysb::_Init();	// reset any buffering

  000f4	8b ce		 mov	 ecx, esi
  000f6	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
$LN19@open:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale

; 403  : 		{	// destroy the object

  000ff	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 404  : 		if (_Ptr != 0)

  00106	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp+4]
  00109	85 c9		 test	 ecx, ecx
  0010b	74 11		 je	 SHORT $LN30@open

; 405  : 			delete _Ptr->_Decref();

  0010d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0010f	ff 50 08	 call	 DWORD PTR [eax+8]
  00112	85 c0		 test	 eax, eax
  00114	74 08		 je	 SHORT $LN30@open
  00116	8b 10		 mov	 edx, DWORD PTR [eax]
  00118	8b c8		 mov	 ecx, eax
  0011a	6a 01		 push	 1
  0011c	ff 12		 call	 DWORD PTR [edx]
$LN30@open:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 282  : 		return (this);	// open succeeded

  0011e	8b c6		 mov	 eax, esi
  00120	eb 02		 jmp	 SHORT $LN1@open
$LN3@open:

; 278  : 			return (0);	// open failed

  00122	33 c0		 xor	 eax, eax
$LN1@open:

; 283  : 		}

  00124	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00127	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012e	59		 pop	 ecx
  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00134	33 cd		 xor	 ecx, ebp
  00136	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR $T1[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__File$dead$ = 8					; size = 4
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 156  : 		{	// construct from pointer to C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	89 75 ec	 mov	 DWORD PTR _this$GSCopy$[ebp], esi

; 155  : 		: _Mysb()

  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  0003b	8b ce		 mov	 ecx, esi

; 156  : 		{	// construct from pointer to C stream

  0003d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 625  : 		_Closef = _Which == _Openfl;

  00043	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0

; 626  : 		_Wrotesome = false;

  00047	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;
; 652  : 		_State = _Stinit;

  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 157  : 		_Init(_File, _Newfl);
; 158  : 		}

  00057	8b c6		 mov	 eax, esi

; 652  : 		_State = _Stinit;

  00059	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  0005c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  00062	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  00069	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  0006c	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 157  : 		_Init(_File, _Newfl);
; 158  : 		}

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 337  : 		{	// discard any allocated buffer and clear pointers

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 338  : 		if (_Mystate & _Allocated)

  00003	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  00007	74 4d		 je	 SHORT $LN23@Tidy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00009	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 09		 je	 SHORT $LN4@Tidy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00012	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00015	8b 10		 mov	 edx, DWORD PTR [eax]
  00017	03 d1		 add	 edx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00019	eb 0a		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0001b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001e	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	03 11		 add	 edx, DWORD PTR [ecx]
$LN5@Tidy:

; 221  : 		return (*_IGfirst);

  00025	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00028	8b 00		 mov	 eax, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  0002a	2b d0		 sub	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0002c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00032	72 19		 jb	 SHORT $LN26@Tidy

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00034	a8 1f		 test	 al, 31			; 0000001fH
  00036	75 61		 jne	 SHORT $_Invalid_parameter$45

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00038	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0003b	3b c8		 cmp	 ecx, eax
  0003d	73 5a		 jae	 SHORT $_Invalid_parameter$45

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0003f	2b c1		 sub	 eax, ecx
  00041	83 f8 04	 cmp	 eax, 4
  00044	72 53		 jb	 SHORT $_Invalid_parameter$45

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00046	83 f8 23	 cmp	 eax, 35			; 00000023H
  00049	77 4e		 ja	 SHORT $_Invalid_parameter$45

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004b	8b c1		 mov	 eax, ecx
$LN26@Tidy:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00053	83 c4 04	 add	 esp, 4
$LN23@Tidy:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00056	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 253  : 		*_IGnext = _Next;

  0005f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00062	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00068	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0006b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 293  : 		*_IPfirst = _First;

  00071	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00074	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 294  : 		*_IPnext = _First;

  0007a	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0007d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 295  : 		*_IPcount = (int)(_Last - _First);

  00083	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00086	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

  0008c	83 66 3c fe	 and	 DWORD PTR [esi+60], -2	; fffffffeH
  00090	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00097	5e		 pop	 esi

; 346  : 		}

  00098	c3		 ret	 0
$_Invalid_parameter$45:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN44@Tidy:
$LN43@Tidy:
  0009f	cc		 int	 3
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
__Nul$54 = -48						; size = 24
__Str$55 = -48						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 93   : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	83 ec 38	 sub	 esp, 56			; 00000038H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 34	 mov	 DWORD PTR __$ArrayPad$[esp+56], eax
  00014	8b d1		 mov	 edx, ecx
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	57		 push	 edi

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0001b	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  0001e	f6 c1 02	 test	 cl, 2
  00021	0f 85 90 00 00
	00		 jne	 $LN2@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00027	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 83 00 00
	00		 je	 $LN2@str

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00034	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00037	3b c8		 cmp	 ecx, eax
  00039	0f 42 c8	 cmovb	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 231  : 		return (*_IPfirst);

  0003c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
$LN321@str:
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00041	2b c8		 sub	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1964 : 		assign(_Ptr, _Count);

  00043	51		 push	 ecx
  00044	50		 push	 eax
  00045	8d 4c 24 18	 lea	 ecx, DWORD PTR __Str$55[esp+72]

; 3698 : 		_My_data._Mysize = 0;

  00049	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR __Str$55[esp+88], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00051	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR __Str$55[esp+92], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00059	c6 44 24 18 00	 mov	 BYTE PTR __Str$55[esp+72], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1964 : 		assign(_Ptr, _Count);

  0005e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00063	0f 10 44 24 10	 movups	 xmm0, XMMWORD PTR __Str$55[esp+64]

; 1576 : 		_Mysize(0),

  00068	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 98   : 			return (_Str);

  0006f	8d 4c 24 10	 lea	 ecx, DWORD PTR __Str$55[esp+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1577 : 		_Myres(0)

  00073	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0007a	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0007d	c6 44 24 10 00	 mov	 BYTE PTR __Str$55[esp+64], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00082	f3 0f 7e 44 24
	20		 movq	 xmm0, QWORD PTR __Str$55[esp+80]
  00088	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  0008d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR __Str$55[esp+80], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00095	c7 44 24 24 0f
	00 00 00	 mov	 DWORD PTR __Str$55[esp+84], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 98   : 			return (_Str);

  0009d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;
; 108  : 			return (_Nul);

  000a2	8b c6		 mov	 eax, esi

; 110  : 		}

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  000aa	33 cc		 xor	 ecx, esp
  000ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
$LN2@str:

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  000b7	f6 c1 04	 test	 cl, 4
  000ba	75 18		 jne	 SHORT $LN4@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  000bc	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  000bf	8b 38		 mov	 edi, DWORD PTR [eax]
  000c1	85 ff		 test	 edi, edi
  000c3	74 0f		 je	 SHORT $LN4@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  000c5	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000c8	8b 08		 mov	 ecx, DWORD PTR [eax]

; 221  : 		return (*_IGfirst);

  000ca	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]

; 241  : 		return (*_IGnext + *_IGcount);

  000cd	03 cf		 add	 ecx, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 103  : 			return (_Str);

  000cf	e9 6b ff ff ff	 jmp	 $LN321@str
$LN4@str:

; 110  : 		}

  000d4	8b 4c 24 3c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+64]
  000d8	8b c6		 mov	 eax, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000da	c6 44 24 10 00	 mov	 BYTE PTR __Nul$54[esp+64], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000df	0f 10 44 24 10	 movups	 xmm0, XMMWORD PTR __Nul$54[esp+64]

; 1576 : 		_Mysize(0),

  000e4	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1577 : 		_Myres(0)

  000eb	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000f2	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 3698 : 		_My_data._Mysize = 0;

  000f5	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR __Nul$54[esp+80], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000fd	c7 44 24 24 0f
	00 00 00	 mov	 DWORD PTR __Nul$54[esp+84], 15 ; 0000000fH

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00105	f3 0f 7e 44 24
	20		 movq	 xmm0, QWORD PTR __Nul$54[esp+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 110  : 		}

  0010b	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0010c	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 110  : 		}

  00111	5e		 pop	 esi
  00112	33 cc		 xor	 ecx, esp
  00114	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c2 04 00	 ret	 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$dead$ = 8					; size = 4
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}

  00035	8b c6		 mov	 eax, esi

; 311  : 		_Seekhigh = 0;

  00037	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 312  : 		_Mystate = _State;

  0003e	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0

; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}

  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004f	59		 pop	 ecx
  00050	5e		 pop	 esi
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$dead$ = ecx

; 945  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 08		 jne	 SHORT $LN4@allocate

; 53   : 		{
; 54   : 		return (_Ptr);

  0000a	33 c9		 xor	 ecx, ecx

; 946  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof(_Ty))));

  0000c	8b c1		 mov	 eax, ecx

; 947  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00012	32 c9		 xor	 cl, cl
  00014	74 06		 je	 SHORT $LN5@allocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN14@allocate:
$LN5@allocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00021	72 25		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00023	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00026	3b c8		 cmp	 ecx, eax
  00028	77 06		 ja	 SHORT $LN7@allocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN7@allocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00036	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00039	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  0003c	83 e1 e0	 and	 ecx, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003f	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 946  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof(_Ty))));

  00042	8b c1		 mov	 eax, ecx

; 947  : 		}

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN6@allocate:

; 93   : 	_Ptr = ::operator new(_User_size);

  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004e	83 c4 04	 add	 esp, 4

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);

  00051	8b c8		 mov	 ecx, eax

; 947  : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN13@allocate:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$dead$ = ecx

; 940  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0000d	72 19		 jb	 SHORT $LN6@deallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $_Invalid_parameter$20

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00016	3b c8		 cmp	 ecx, eax
  00018	73 1b		 jae	 SHORT $_Invalid_parameter$20

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 14		 jb	 SHORT $_Invalid_parameter$20

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 0f		 ja	 SHORT $_Invalid_parameter$20

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00026	8b c1		 mov	 eax, ecx
$LN6@deallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 942  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$_Invalid_parameter$20:

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN18@deallocate:
  0003b	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT
; _this$ = ecx

; 66   : 		return (_Myoff + _Fpos);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	03 01		 add	 eax, DWORD PTR [ecx]
  00005	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00008	13 51 04	 adc	 edx, DWORD PTR [ecx+4]

; 67   : 		}

  0000b	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::seekpos, COMDAT
; _this$ = ecx

; 61   : 		return (_Fpos);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]

; 62   : 		}

  00006	c3		 ret	 0
?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT
; _this$ = ecx

; 50   : 		{	// return conversion state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : 		return (_Mystate);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00009	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 52   : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
__State$ = 8						; size = 8
__Fileposition$ = 16					; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 46   : 		{	// construct with conversion state and C file position

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  00003	8b 45 10	 mov	 eax, DWORD PTR __Fileposition$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00009	8b 45 14	 mov	 eax, DWORD PTR __Fileposition$[ebp+4]
  0000c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0000f	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00012	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR __State$[ebp+4]
  00018	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 47   : 		}

  0001b	8b c1		 mov	 eax, ecx
  0001d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00023	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 41   : 		{	// construct with stream offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	89 01		 mov	 DWORD PTR [ecx], eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp+4]
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 42   : 		}

  00011	8b c1		 mov	 eax, ecx
  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00021	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0param_type@?$uniform_int@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0param_type@?$uniform_int@H@std@@QAE@HH@Z PROC	; std::uniform_int<int>::param_type::param_type, COMDAT
; _this$ = ecx

; 2227 : 		explicit param_type(result_type _Min0 = 0, result_type _Max0 = 9)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2256 : 			_Min = _Min0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Min0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 2257 : 			_Max = _Max0;

  00008	8b 45 0c	 mov	 eax, DWORD PTR __Max0$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2228 : 			{	// construct from parameters
; 2229 : 			_Init(_Min0, _Max0);
; 2230 : 			}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0param_type@?$uniform_int@H@std@@QAE@HH@Z ENDP	; std::uniform_int<int>::param_type::param_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
__Fx$dead$ = 12						; size = 4
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed, COMDAT
; _this$ = ecx

; 1336 : 		{	// set initial values from specified value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1337 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00003	8b 45 08	 mov	 eax, DWORD PTR __X0$[ebp]
  00006	ba 01 00 00 00	 mov	 edx, 1
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx
  0000f	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00012	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
$LL4@seed:

; 1338 : 		for (int _Ix = 1; _Ix < _Nx; ++_Ix)
; 1339 : 			_Prev = this->_Ax[_Ix] =

  00015	8b c8		 mov	 ecx, eax
  00017	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0001a	c1 e9 1e	 shr	 ecx, 30			; 0000001eH
  0001d	33 c8		 xor	 ecx, eax
  0001f	69 c1 65 89 07
	6c		 imul	 eax, ecx, 1812433253
  00025	03 c2		 add	 eax, edx
  00027	42		 inc	 edx
  00028	89 46 fc	 mov	 DWORD PTR [esi-4], eax
  0002b	81 fa 70 02 00
	00		 cmp	 edx, 624		; 00000270H
  00031	7c e2		 jl	 SHORT $LL4@seed

; 1340 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;
; 1341 : 		this->_Idx = _Nx;

  00033	c7 07 70 02 00
	00		 mov	 DWORD PTR [edi], 624	; 00000270H
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi

; 1342 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 105  : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 106  : 			if (_Myostr.rdbuf() != 0)

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 107  : 				_Myostr.rdbuf()->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 108  : 			}

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 98   : 			: _Myostr(_Ostr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]

; 99   : 			{	// lock the stream buffer, if there

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 100  : 			if (_Myostr.rdbuf() != 0)

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN8@Sentry_bas

; 101  : 				_Myostr.rdbuf()->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 102  : 			}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 344  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 339  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 324  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 319  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 1223 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1224 : 		_IDL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1225 : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 1226 : 		_IDL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1227 : 			" invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1228 : 		const auto _Contptr = _Mycont->_Myptr();
; 1229 : 		const auto _Rawptr = _Unfancy(_Ptr);
; 1230 : 		_IDL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1231 : 			"cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1232 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 1233 : 
; 1234 : 		_Analysis_assume_(_Ptr);
; 1235 : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1236 : 		}

  00002	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$dead$ = 12					; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 1426 : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1214 : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 1427 : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 1638 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
  0000b	cc		 int	 3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 867  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	83 c8 ff	 or	 eax, -1

; 868  : 		}

  00003	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
__Roff$dead$ = 12					; size = 4
__Count$dead$ = 16					; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2410 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1622 : 		if (_Mysize < _Off)

  00003	a1 10 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00008	83 f8 05	 cmp	 eax, 5
  0000b	72 2d		 jb	 SHORT $LN27@assign

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  0000d	83 c0 fb	 add	 eax, -5			; fffffffbH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00010	83 ca ff	 or	 edx, -1
  00013	83 f8 ff	 cmp	 eax, -1
  00016	0f 42 d0	 cmovb	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00019	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00020	b8 00 00 00 00	 mov	 eax, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1607 : 		if (_Large_string_engaged())

  00025	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2411 : 		auto& _Right_data = _Right._Get_data();
; 2412 : 		_Right_data._Check_offset(_Roff);
; 2413 : 		_Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0002c	52		 push	 edx
  0002d	83 c0 05	 add	 eax, 5
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2415 : 		}

  00036	5d		 pop	 ebp
  00037	c2 0c 00	 ret	 12			; 0000000cH
$LN27@assign:

; 1624 : 			_Xran();

  0003a	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN29@assign:
$LN26@assign:
  0003f	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z
_TEXT	SEGMENT
__Mode$dead$ = 8					; size = 4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT
; _this$dead$ = ecx

; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);

  00000	33 c0		 xor	 eax, eax

; 367  : 		}

  00002	c2 04 00	 ret	 4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
__State$ = 16						; size = 4
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init, COMDAT
; _this$ = ecx

; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 		_Seekhigh = 0;
; 312  : 		_Mystate = _State;

  00003	8b 45 10	 mov	 eax, DWORD PTR __State$[ebp]
  00006	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
  0000d	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}

  00010	5d		 pop	 ebp
  00011	c2 0c 00	 ret	 12			; 0000000cH
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 930  : 		{	// construct default allocator (do nothing)
; 931  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z PROC	; std::uniform_int<int>::param_type::_Init, COMDAT
; _this$ = ecx

; 2253 : 			{	// set internal state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2254 : 			_RNG_ASSERT(_Min0 <= _Max0,
; 2255 : 				"invalid min and max arguments for uniform_int");
; 2256 : 			_Min = _Min0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Min0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 2257 : 			_Max = _Max0;

  00008	8b 45 0c	 mov	 eax, DWORD PTR __Max0$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2258 : 			}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z ENDP	; std::uniform_int<int>::param_type::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$dead$ = 12					; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 1215 : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1214 : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 1216 : 		this->_Adopt(_Pstring);
; 1217 : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 12
__Psave$4 = -24						; size = 4
__Lock$5 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT
; __Loc$ = ecx

; 505  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  0002d	6a 00		 push	 0
  0002f	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave

; 509  : 
; 510  : 		size_t _Id = _Facet::id;

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  0004a	89 45 e8	 mov	 DWORD PTR __Psave$4[ebp], eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00053	8b f8		 mov	 edi, eax

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00055	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00058	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0005b	73 0c		 jae	 SHORT $LN15@use_facet
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 34 b9	 mov	 esi, DWORD PTR [ecx+edi*4]

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00063	85 f6		 test	 esi, esi
  00065	75 67		 jne	 SHORT $LN7@use_facet
  00067	eb 02		 jmp	 SHORT $LN19@use_facet
$LN15@use_facet:

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00069	33 f6		 xor	 esi, esi
$LN19@use_facet:

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0006b	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  0006f	74 11		 je	 SHORT $LN12@use_facet

; 434  : 			return (_Facptr);	// found facet or not transparent
; 435  : 		else
; 436  : 			{	// look in current locale
; 437  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 438  : 			return (_Id < _Ptr0->_Facetcount

  00077	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0007a	73 0a		 jae	 SHORT $LN20@use_facet
  0007c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007f	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN12@use_facet:

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 512  : 
; 513  : 		if (_Pf != 0)

  00082	85 f6		 test	 esi, esi
  00084	75 48		 jne	 SHORT $LN7@use_facet
$LN20@use_facet:

; 514  : 			;	// got facet from locale
; 515  : 		else if (_Psave != 0)

  00086	8b 75 e8	 mov	 esi, DWORD PTR __Psave$4[ebp]
  00089	85 f6		 test	 esi, esi
  0008b	75 41		 jne	 SHORT $LN7@use_facet

; 516  : 			_Pf = _Psave;	// lazy facet already allocated
; 517  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  0008d	8d 45 e8	 lea	 eax, DWORD PTR __Psave$4[ebp]
  00090	53		 push	 ebx
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00098	83 c4 08	 add	 esp, 8
  0009b	83 f8 ff	 cmp	 eax, -1
  0009e	75 15		 jne	 SHORT $LN6@use_facet

; 518  : 
; 519  :  #if _HAS_EXCEPTIONS
; 520  : 
; 521  : 			_THROW(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000a0	8d 4d dc	 lea	 ecx, DWORD PTR $T1[ebp]
  000a3	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000ad	8b c1		 mov	 eax, ecx
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN24@use_facet:
$LN6@use_facet:

; 522  : 
; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 			abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 
; 527  : 		else
; 528  : 			{	// queue up lazy facet for destruction
; 529  : 			_Pf = _Psave;

  000b5	8b 75 e8	 mov	 esi, DWORD PTR __Psave$4[ebp]

; 530  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 531  : 
; 532  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 533  : 			_Pfmod->_Incref();

  000b8	8b ce		 mov	 ecx, esi
  000ba	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
  000c0	8b 16		 mov	 edx, DWORD PTR [esi]
  000c2	ff 52 04	 call	 DWORD PTR [edx+4]

; 534  : 
; 535  :  #if defined(_M_CEE)
; 536  : 			_Facet_Register_m(_Pfmod);
; 537  : 
; 538  :  #else /* defined(_M_CEE) */
; 539  : 			_Facet_Register(_Pfmod);

  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000cb	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 540  :  #endif /* defined(_M_CEE) */
; 541  : 			}
; 542  : 
; 543  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000ce	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d7	8b c6		 mov	 eax, esi

; 544  : 	_END_LOCK()
; 545  : 	}	// end of use_facet body

  000d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e3	59		 pop	 ecx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
$LN22@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
__Pad$ = -48						; size = 8
__State$ = -36						; size = 4
__Val$1$ = -32						; size = 4
$T20 = -32						; size = 1
$T14 = -28						; size = 1
__Ostr$ = -24						; size = 4
__Count$2$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 772  : 	{	// insert NTBS into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b c2		 mov	 eax, edx
  0002d	89 45 e0	 mov	 DWORD PTR __Val$1$[ebp], eax
  00030	8b d9		 mov	 ebx, ecx
  00032	89 5d e8	 mov	 DWORD PTR __Ostr$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00035	8b c8		 mov	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 775  : 	ios_base::iostate _State = ios_base::goodbit;

  00037	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0003e	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL108@operator:
  00041	8a 01		 mov	 al, BYTE PTR [ecx]
  00043	41		 inc	 ecx
  00044	84 c0		 test	 al, al
  00046	75 f9		 jne	 SHORT $LL108@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 422  : 		return (_Wide);

  00048	8b 03		 mov	 eax, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0004a	2b ce		 sub	 ecx, esi
  0004c	89 4d ec	 mov	 DWORD PTR __Count$2$[ebp], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 422  : 		return (_Wide);

  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	8b 7c 18 24	 mov	 edi, DWORD PTR [eax+ebx+36]
  00056	8b 74 18 20	 mov	 esi, DWORD PTR [eax+ebx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 777  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  0005a	85 ff		 test	 edi, edi
  0005c	7c 17		 jl	 SHORT $LN17@operator
  0005e	7f 0e		 jg	 SHORT $LN110@operator
  00060	85 f6		 test	 esi, esi
  00062	74 11		 je	 SHORT $LN17@operator
  00064	85 ff		 test	 edi, edi
  00066	7c 0d		 jl	 SHORT $LN17@operator
  00068	7f 04		 jg	 SHORT $LN110@operator
  0006a	3b f1		 cmp	 esi, ecx
  0006c	76 07		 jbe	 SHORT $LN17@operator
$LN110@operator:
  0006e	2b f1		 sub	 esi, ecx
  00070	83 df 00	 sbb	 edi, 0
  00073	eb 0e		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00075	0f 57 c0	 xorps	 xmm0, xmm0
  00078	66 0f 13 45 d0	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  0007d	8b 7d d4	 mov	 edi, DWORD PTR __Pad$[ebp+4]
  00080	8b 75 d0	 mov	 esi, DWORD PTR __Pad$[ebp]
$LN18@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00083	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 98   : 			: _Myostr(_Ostr)

  00087	89 5d d0	 mov	 DWORD PTR __Ok$[ebp], ebx

; 99   : 			{	// lock the stream buffer, if there
; 100  : 			if (_Myostr.rdbuf() != 0)

  0008a	85 c9		 test	 ecx, ecx
  0008c	74 05		 je	 SHORT $LN38@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

  0008e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00090	ff 50 04	 call	 DWORD PTR [eax+4]
$LN38@operator:

; 121  : 			: _Sentry_base(_Ostr)

  00093	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 314  : 		return (_Mystate);

  0009a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 338  : 		return (rdstate() == goodbit);

  0009f	83 7c 18 0c 00	 cmp	 DWORD PTR [eax+ebx+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  000a4	75 12		 jne	 SHORT $LN34@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 79   : 		return (_Tiestr);

  000a6	8b 4c 18 3c	 mov	 ecx, DWORD PTR [eax+ebx+60]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  000aa	85 c9		 test	 ecx, ecx
  000ac	74 0a		 je	 SHORT $LN34@operator
  000ae	3b cb		 cmp	 ecx, ebx
  000b0	74 06		 je	 SHORT $LN34@operator

; 124  : 				_Ostr.tie()->flush();

  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN34@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 314  : 		return (_Mystate);

  000b8	8b 03		 mov	 eax, DWORD PTR [ebx]
  000ba	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 338  : 		return (rdstate() == goodbit);

  000bd	83 7c 19 0c 00	 cmp	 DWORD PTR [ecx+ebx+12], 0
  000c2	0f 94 c0	 sete	 al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 125  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  000c5	88 45 d4	 mov	 BYTE PTR __Ok$[ebp+4], al

; 778  : 		? 0 : _Ostr.width() - _Count;
; 779  : 	const typename _Myos::sentry _Ok(_Ostr);

  000c8	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 780  : 
; 781  : 	if (!_Ok)

  000cf	84 c0		 test	 al, al
  000d1	75 0a		 jne	 SHORT $LN8@operator

; 782  : 		_State |= ios_base::badbit;

  000d3	b9 04 00 00 00	 mov	 ecx, 4

; 783  : 	else

  000d8	e9 ea 00 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 784  : 		{	// state okay, insert
; 785  : 		_TRY_IO_BEGIN

  000dd	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 377  : 		return (_Fmtfl);

  000e1	8b 44 19 14	 mov	 eax, DWORD PTR [ecx+ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 786  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000e5	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000ea	83 f8 40	 cmp	 eax, 64			; 00000040H
  000ed	74 3a		 je	 SHORT $LN104@operator
  000ef	90		 npad	 1
$LL4@operator:

; 787  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000f0	85 ff		 test	 edi, edi
  000f2	7c 31		 jl	 SHORT $LN3@operator
  000f4	7f 04		 jg	 SHORT $LN111@operator
  000f6	85 f6		 test	 esi, esi
  000f8	74 2b		 je	 SHORT $LN3@operator
$LN111@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 112  : 		return (_Fillch);

  000fa	8b 03		 mov	 eax, DWORD PTR [ebx]
  000fc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ff	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 788  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00103	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 112  : 		return (_Fillch);

  00107	88 45 e4	 mov	 BYTE PTR $T14[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 788  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0010a	ff 75 e4	 push	 DWORD PTR $T14[ebp]
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00113	83 f8 ff	 cmp	 eax, -1
  00116	75 05		 jne	 SHORT $LN2@operator

; 789  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 790  : 					{	// insertion failed, quit
; 791  : 					_State |= ios_base::badbit;

  00118	8d 48 05	 lea	 ecx, DWORD PTR [eax+5]

; 792  : 					break;

  0011b	eb 6c		 jmp	 SHORT $LN6@operator
$LN2@operator:

; 787  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  0011d	83 c6 ff	 add	 esi, -1
  00120	83 d7 ff	 adc	 edi, -1
  00123	eb cb		 jmp	 SHORT $LL4@operator
$LN3@operator:

; 796  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  00125	33 c9		 xor	 ecx, ecx
  00127	75 60		 jne	 SHORT $LN6@operator
$LN104@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00129	8b 03		 mov	 eax, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 796  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  0012b	6a 00		 push	 0
  0012d	ff 75 ec	 push	 DWORD PTR __Count$2$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00130	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 796  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  00133	ff 75 e0	 push	 DWORD PTR __Val$1$[ebp]
  00136	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  00140	3b 45 ec	 cmp	 eax, DWORD PTR __Count$2$[ebp]
  00143	75 33		 jne	 SHORT $LN112@operator
  00145	85 d2		 test	 edx, edx
  00147	75 2f		 jne	 SHORT $LN112@operator
  00149	0f 1f 80 00 00
	00 00		 npad	 7
$LL114@operator:

; 797  : 			_State |= ios_base::badbit;
; 798  : 
; 799  : 		if (_State == ios_base::goodbit)
; 800  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00150	85 ff		 test	 edi, edi
  00152	7c 33		 jl	 SHORT $LN118@operator
  00154	7f 04		 jg	 SHORT $LN113@operator
  00156	85 f6		 test	 esi, esi
  00158	74 2d		 je	 SHORT $LN118@operator
$LN113@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 112  : 		return (_Fillch);

  0015a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0015c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0015f	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 801  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00163	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 112  : 		return (_Fillch);

  00167	88 45 e0	 mov	 BYTE PTR $T20[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 801  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0016a	ff 75 e0	 push	 DWORD PTR $T20[ebp]
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00173	83 f8 ff	 cmp	 eax, -1
  00176	75 07		 jne	 SHORT $LN5@operator
$LN112@operator:

; 802  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 803  : 					{	// insertion failed, quit
; 804  : 					_State |= ios_base::badbit;

  00178	b9 04 00 00 00	 mov	 ecx, 4

; 805  : 					break;

  0017d	eb 0a		 jmp	 SHORT $LN6@operator
$LN5@operator:

; 797  : 			_State |= ios_base::badbit;
; 798  : 
; 799  : 		if (_State == ios_base::goodbit)
; 800  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  0017f	83 c6 ff	 add	 esi, -1
  00182	83 d7 ff	 adc	 edi, -1
  00185	eb c9		 jmp	 SHORT $LL114@operator
$LN118@operator:
  00187	33 c9		 xor	 ecx, ecx
$LN6@operator:

; 806  : 					}
; 807  : 		_Ostr.width(0);

  00189	8b 03		 mov	 eax, DWORD PTR [ebx]
  0018b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  0018e	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  00196	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
  0019e	eb 20		 jmp	 SHORT $LN123@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 808  : 		_CATCH_IO_(_Ostr)

  001a0	8b 55 e8	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001a3	6a 01		 push	 1
  001a5	6a 04		 push	 4
  001a7	8b 02		 mov	 eax, DWORD PTR [edx]
  001a9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ac	03 ca		 add	 ecx, edx
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001b4	b8 00 00 00 00	 mov	 eax, $LN23@operator
  001b9	c3		 ret	 0
$LN23@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
  001ba	8b 5d e8	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  001bd	8b 4d dc	 mov	 ecx, DWORD PTR __State$[ebp]
$LN123@operator:
  001c0	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 809  : 		}
; 810  : 
; 811  : 	_Ostr.setstate(_State);

  001c7	8b 03		 mov	 eax, DWORD PTR [ebx]
  001c9	6a 00		 push	 0
  001cb	51		 push	 ecx
  001cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001cf	03 cb		 add	 ecx, ebx
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 129  : 			{	// destroy the object

  001d7	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 130  :  #if _HAS_EXCEPTIONS
; 131  : 			if (!_STD uncaught_exception())

  001de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 132  : 				this->_Myostr._Osfx();

  001e4	8b 75 d0	 mov	 esi, DWORD PTR __Ok$[ebp]
  001e7	84 c0		 test	 al, al
  001e9	75 08		 jne	 SHORT $LN87@operator
  001eb	8b ce		 mov	 ecx, esi
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN87@operator:

; 105  : 			{	// destroy after unlocking

  001f3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5

; 106  : 			if (_Myostr.rdbuf() != 0)

  001f7	8b 06		 mov	 eax, DWORD PTR [esi]
  001f9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001fc	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00200	85 c9		 test	 ecx, ecx
  00202	74 05		 je	 SHORT $LN115@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

  00204	8b 01		 mov	 eax, DWORD PTR [ecx]
  00206	ff 50 08	 call	 DWORD PTR [eax+8]
$LN115@operator:

; 812  : 	return (_Ostr);

  00209	8b c3		 mov	 eax, ebx

; 813  : 	}

  0020b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0020e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00215	59		 pop	 ecx
  00216	5f		 pop	 edi
  00217	5e		 pop	 esi
  00218	5b		 pop	 ebx
  00219	8b e5		 mov	 esp, ebp
  0021b	5d		 pop	 ebp
  0021c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$4:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 983  : 	{	// insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 984  : 	_Ostr.put(_Ostr.widen('\n'));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  00007	6a 0a		 push	 10			; 0000000aH
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	03 ce		 add	 ecx, esi
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00016	0f b6 c8	 movzx	 ecx, al
  00019	51		 push	 ecx
  0001a	8b ce		 mov	 ecx, esi
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 985  : 	_Ostr.flush();

  00022	8b ce		 mov	 ecx, esi
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 986  : 	return (_Ostr);

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi

; 987  : 	}

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 137  : 	{	// extract a string

  00000	51		 push	 ecx

; 138  : 	return (_STD move(_Istr) >> _Str);

  00001	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >

; 139  : 	}

  00006	59		 pop	 ecx
  00007	c3		 ret	 0
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z
_TEXT	SEGMENT
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z PROC ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 3956 : 	return (!(_Left == _Right));

  00000	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00005	34 01		 xor	 al, 1

; 3957 : 	}

  00007	c3		 ret	 0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z
_TEXT	SEGMENT
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 3925 : 	{	// test for string vs. NTCTS equality

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx
  00003	8b d1		 mov	 edx, ecx
  00005	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00006	8b fe		 mov	 edi, esi
  00008	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000b	0f 1f 44 00 00	 npad	 5
$LL30@operator:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL30@operator
  00017	2b f9		 sub	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00019	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0001d	8b ca		 mov	 ecx, edx

; 1607 : 		if (_Large_string_engaged())

  0001f	72 02		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN16@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3496 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00023	8b 52 10	 mov	 edx, DWORD PTR [edx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00026	3b d7		 cmp	 edx, edi
  00028	75 5b		 jne	 SHORT $LN24@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0002a	83 ea 04	 sub	 edx, 4
  0002d	72 12		 jb	 SHORT $LN33@operator
  0002f	90		 npad	 1
$LL34@operator:
  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	3b 06		 cmp	 eax, DWORD PTR [esi]
  00034	75 10		 jne	 SHORT $LN32@operator
  00036	83 c1 04	 add	 ecx, 4
  00039	83 c6 04	 add	 esi, 4
  0003c	83 ea 04	 sub	 edx, 4
  0003f	73 ef		 jae	 SHORT $LL34@operator
$LN33@operator:
  00041	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00044	74 34		 je	 SHORT $LN31@operator
$LN32@operator:
  00046	8a 01		 mov	 al, BYTE PTR [ecx]
  00048	3a 06		 cmp	 al, BYTE PTR [esi]
  0004a	75 27		 jne	 SHORT $LN35@operator
  0004c	83 fa fd	 cmp	 edx, -3			; fffffffdH
  0004f	74 29		 je	 SHORT $LN31@operator
  00051	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00054	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00057	75 1a		 jne	 SHORT $LN35@operator
  00059	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0005c	74 1c		 je	 SHORT $LN31@operator
  0005e	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00061	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00064	75 0d		 jne	 SHORT $LN35@operator
  00066	83 fa ff	 cmp	 edx, -1
  00069	74 0f		 je	 SHORT $LN31@operator
  0006b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0006e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00071	74 07		 je	 SHORT $LN31@operator
$LN35@operator:
  00073	1b c0		 sbb	 eax, eax
  00075	83 c8 01	 or	 eax, 1
  00078	eb 02		 jmp	 SHORT $LN36@operator
$LN31@operator:
  0007a	33 c0		 xor	 eax, eax
$LN36@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0007c	85 c0		 test	 eax, eax
  0007e	75 05		 jne	 SHORT $LN24@operator

; 3926 : 	return (_Left._Equal(_Right));
; 3927 : 	}

  00080	5f		 pop	 edi

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00081	b0 01		 mov	 al, 1

; 3926 : 	return (_Left._Equal(_Right));
; 3927 : 	}

  00083	5e		 pop	 esi
  00084	c3		 ret	 0
$LN24@operator:
  00085	5f		 pop	 edi

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00086	32 c0		 xor	 al, al

; 3926 : 	return (_Left._Equal(_Right));
; 3927 : 	}

  00088	5e		 pop	 esi
  00089	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??$?RVrandom_device@std@@@?$uniform_int@H@std@@QBEHAAVrandom_device@1@@Z
_TEXT	SEGMENT
__Umin$1$ = -12						; size = 4
tv383 = -8						; size = 4
__Index$1$ = -4						; size = 4
__Eng$dead$ = 8						; size = 4
??$?RVrandom_device@std@@@?$uniform_int@H@std@@QBEHAAVrandom_device@1@@Z PROC ; std::uniform_int<int>::operator()<std::random_device>, COMDAT
; _this$ = ecx

; 2311 : 		{	// return next value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2312 : 		return (_Eval(_Eng, _Par._Min, _Par._Max));

  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	53		 push	 ebx

; 2355 : 		const _Uty _Umin = _Adjust(_Uty(_Min));

  0000a	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0000c	81 eb 00 00 00
	80		 sub	 ebx, -2147483648	; 80000000H

; 2312 : 		return (_Eval(_Eng, _Par._Min, _Par._Max));

  00012	2b d3		 sub	 edx, ebx

; 2355 : 		const _Uty _Umin = _Adjust(_Uty(_Min));

  00014	89 5d f4	 mov	 DWORD PTR __Umin$1$[ebp], ebx

; 2356 : 		const _Uty _Umax = _Adjust(_Uty(_Max));
; 2357 : 
; 2358 : 		_Uty _Uret = 0;
; 2359 : 
; 2360 : 		if (_Umax - _Umin == _Uty(-1))

  00017	81 c2 00 00 00
	80		 add	 edx, -2147483648	; 80000000H
  0001d	89 55 f8	 mov	 DWORD PTR tv383[ebp], edx

; 2311 : 		{	// return next value

  00020	56		 push	 esi

; 2360 : 		if (_Umax - _Umin == _Uty(-1))

  00021	83 fa ff	 cmp	 edx, -1
  00024	75 1f		 jne	 SHORT $LN4@operator
  00026	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?_Random_device@std@@YAIXZ
  0002c	0f 1f 40 00	 npad	 4
$LL34@operator:

; 6442 : 		return (_Random_device());

  00030	ff d6		 call	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  00032	32 c9		 xor	 cl, cl
  00034	75 fa		 jne	 SHORT $LL34@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2313 : 		}

  00036	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  0003b	5e		 pop	 esi
  0003c	03 c3		 add	 eax, ebx
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN4@operator:

; 2363 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  00045	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
  00048	57		 push	 edi
  00049	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?_Random_device@std@@YAIXZ
  0004f	89 5d fc	 mov	 DWORD PTR __Index$1$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3502 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00052	eb 03		 jmp	 SHORT $LN44@operator
$LL92@operator:
  00054	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
$LN44@operator:

; 3487 : 			_Udiff _Ret = 0;	// random bits

  00057	33 c9		 xor	 ecx, ecx

; 3488 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00059	33 c0		 xor	 eax, eax

; 3489 : 
; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  0005b	85 d2		 test	 edx, edx
  0005d	74 10		 je	 SHORT $LN48@operator
  0005f	90		 npad	 1
$LL53@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  00060	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3530 : 			_Udiff _Val = _Ref() - (_Urng::min)();

  00062	8b c8		 mov	 ecx, eax

; 3532 : 			if (_Val <= _Bmask)

  00064	32 c0		 xor	 al, al
  00066	75 f8		 jne	 SHORT $LL53@operator

; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  00068	83 c8 ff	 or	 eax, -1
  0006b	32 d2		 xor	 dl, dl
  0006d	75 f1		 jne	 SHORT $LL53@operator
$LN48@operator:

; 3502 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  0006f	33 d2		 xor	 edx, edx
  00071	f7 f3		 div	 ebx
  00073	8b f0		 mov	 esi, eax
  00075	8b da		 mov	 ebx, edx
  00077	33 d2		 xor	 edx, edx
  00079	8b c1		 mov	 eax, ecx
  0007b	f7 75 fc	 div	 DWORD PTR __Index$1$[ebp]
  0007e	3b c6		 cmp	 eax, esi
  00080	72 07		 jb	 SHORT $LN78@operator
  00082	8b 55 f8	 mov	 edx, DWORD PTR tv383[ebp]
  00085	3b da		 cmp	 ebx, edx
  00087	75 cb		 jne	 SHORT $LL92@operator
$LN78@operator:

; 3503 : 				return (_Ret % _Index);

  00089	33 d2		 xor	 edx, edx
  0008b	8b c1		 mov	 eax, ecx
  0008d	f7 75 fc	 div	 DWORD PTR __Index$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2312 : 		return (_Eval(_Eng, _Par._Min, _Par._Max));

  00090	8b 45 f4	 mov	 eax, DWORD PTR __Umin$1$[ebp]
  00093	5f		 pop	 edi
  00094	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H

; 2313 : 		}

  00099	5e		 pop	 esi
  0009a	03 c2		 add	 eax, edx
  0009c	5b		 pop	 ebx
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
??$?RVrandom_device@std@@@?$uniform_int@H@std@@QBEHAAVrandom_device@1@@Z ENDP ; std::uniform_int<int>::operator()<std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -4					; size = 4
__Count$1$ = 8						; size = 4
$T24 = 8						; size = 1
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 3849 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b fa		 mov	 edi, edx
  00009	8b d9		 mov	 ebx, ecx

; 3850 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 3851 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  0000b	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0000e	89 5d fc	 mov	 DWORD PTR ___$ReturnUdt$[ebp], ebx
  00011	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00014	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00017	2b c6		 sub	 eax, esi
  00019	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0001c	89 4d 08	 mov	 DWORD PTR __Count$1$[ebp], ecx
  0001f	3b c8		 cmp	 ecx, eax
  00021	76 4a		 jbe	 SHORT $LN4@operator
  00023	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00026	2b c1		 sub	 eax, ecx
  00028	3b c6		 cmp	 eax, esi
  0002a	72 41		 jb	 SHORT $LN4@operator

; 3853 : 	else
; 3854 : 		return (_STD move(_Right.insert(0, _Left)));

  0002c	57		 push	 edi
  0002d	51		 push	 ecx
  0002e	8b ca		 mov	 ecx, edx
  00030	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1576 : 		_Mysize(0),

  00035	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 1577 : 		_Myres(0)

  0003c	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0

; 3855 : 	}

  00043	5f		 pop	 edi

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00044	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]

; 3855 : 	}

  00047	5e		 pop	 esi

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00048	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  0004b	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00050	66 0f d6 43 10	 movq	 QWORD PTR [ebx+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00055	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0005c	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00063	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3852 : 		return (_STD move(_Left.append(_Right)));

  00066	8b c3		 mov	 eax, ebx

; 3855 : 	}

  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN4@operator:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0006d	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00071	72 02		 jb	 SHORT $LN71@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00073	8b 12		 mov	 edx, DWORD PTR [edx]
$LN71@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00075	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00078	2b c6		 sub	 eax, esi
  0007a	3b c8		 cmp	 ecx, eax
  0007c	77 27		 ja	 SHORT $LN78@operator

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  0007e	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00081	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00084	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00086	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 1596 : 		if (_Large_string_engaged())

  0008a	72 02		 jb	 SHORT $LN87@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0008c	8b 07		 mov	 eax, DWORD PTR [edi]
$LN87@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0008e	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0008f	03 f0		 add	 esi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00091	52		 push	 edx
  00092	56		 push	 esi
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 517  : 		_Left = _Right;

  00099	8b 45 08	 mov	 eax, DWORD PTR __Count$1$[ebp]

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  0009f	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  000a3	eb 13		 jmp	 SHORT $LN77@operator
$LN78@operator:

; 2358 : 			}
; 2359 : 
; 2360 : 		return (_Reallocate_grow_by(_Count,

  000a5	51		 push	 ecx
  000a6	52		 push	 edx
  000a7	c6 45 08 00	 mov	 BYTE PTR $T24[ebp], 0
  000ab	ff 75 08	 push	 DWORD PTR $T24[ebp]
  000ae	51		 push	 ecx
  000af	8b cf		 mov	 ecx, edi
  000b1	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  000b6	8b f8		 mov	 edi, eax
$LN77@operator:

; 1576 : 		_Mysize(0),

  000b8	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 3852 : 		return (_STD move(_Left.append(_Right)));

  000bf	8b c3		 mov	 eax, ebx

; 1577 : 		_Myres(0)

  000c1	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000c8	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  000cb	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  000ce	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  000d3	66 0f d6 43 10	 movq	 QWORD PTR [ebx+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  000d8	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000df	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000e6	c6 07 00	 mov	 BYTE PTR [edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3855 : 	}

  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -4					; size = 4
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$dead$ = edx

; 3829 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3830 : 	return (_STD move(_Right.insert(0, _Left)));

  00005	68 00 00 00 00	 push	 OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0000a	8b f1		 mov	 esi, ecx
  0000c	51		 push	 ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00010	89 75 fc	 mov	 DWORD PTR ___$ReturnUdt$[ebp], esi
  00013	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1576 : 		_Mysize(0),

  00018	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1577 : 		_Myres(0)

  0001f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00026	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00029	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0002c	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00031	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00036	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003d	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00044	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3830 : 	return (_STD move(_Right.insert(0, _Left)));

  00047	8b c6		 mov	 eax, esi
  00049	5e		 pop	 esi

; 3831 : 	}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -28					; size = 4
tv589 = -24						; size = 4
__Count$1$ = -20					; size = 4
$T14 = -20						; size = 1
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T19 = 8						; size = 1
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 3755 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b da		 mov	 ebx, edx
  0002a	8b f9		 mov	 edi, ecx
  0002c	89 7d e4	 mov	 DWORD PTR ___$ReturnUdt$[ebp], edi
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 3698 : 		_My_data._Mysize = 0;

  00036	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003d	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00044	c6 07 00	 mov	 BYTE PTR [edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3760 : 	return (_Ans);

  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 3062 : 		return (this->_Get_data()._Mysize);

  0004e	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  00051	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00054	83 c0 10	 add	 eax, 16			; 00000010H
  00057	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  0005e	89 45 e8	 mov	 DWORD PTR tv589[ebp], eax

; 3756 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3757 : 	_Ans.reserve(_Left.size() + _Right.size());

  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	03 06		 add	 eax, DWORD PTR [esi]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0006b	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  0006f	72 02		 jb	 SHORT $LN57@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00071	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN57@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00073	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00075	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  00078	8b c6		 mov	 eax, esi
  0007a	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  0007d	2b c2		 sub	 eax, edx

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0007f	89 4d ec	 mov	 DWORD PTR __Count$1$[ebp], ecx

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00082	3b c8		 cmp	 ecx, eax
  00084	77 27		 ja	 SHORT $LN64@operator

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  00086	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00089	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  0008c	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0008e	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00091	72 02		 jb	 SHORT $LN73@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00093	8b 07		 mov	 eax, DWORD PTR [edi]
$LN73@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00095	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00096	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00099	53		 push	 ebx
  0009a	56		 push	 esi
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 517  : 		_Left = _Right;

  000a1	8b 45 ec	 mov	 eax, DWORD PTR __Count$1$[ebp]

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  000a7	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  000ab	eb 11		 jmp	 SHORT $LN63@operator
$LN64@operator:

; 2358 : 			}
; 2359 : 
; 2360 : 		return (_Reallocate_grow_by(_Count,

  000ad	51		 push	 ecx
  000ae	53		 push	 ebx
  000af	c6 45 ec 00	 mov	 BYTE PTR $T14[ebp], 0
  000b3	ff 75 ec	 push	 DWORD PTR $T14[ebp]
  000b6	51		 push	 ecx
  000b7	8b cf		 mov	 ecx, edi
  000b9	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN63@operator:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000be	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000c1	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  000c5	72 02		 jb	 SHORT $LN96@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000c7	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN96@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  000c9	8b 5d e8	 mov	 ebx, DWORD PTR tv589[ebp]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  000cc	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  000cf	8b c6		 mov	 eax, esi
  000d1	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  000d4	2b c2		 sub	 eax, edx

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  000d6	8b 1b		 mov	 ebx, DWORD PTR [ebx]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  000d8	3b d8		 cmp	 ebx, eax
  000da	77 36		 ja	 SHORT $LN103@operator

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  000dc	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000df	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  000e2	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000e4	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  000e7	72 02		 jb	 SHORT $LN112@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000e9	8b 07		 mov	 eax, DWORD PTR [edi]
$LN112@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000eb	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  000ec	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000ef	51		 push	 ecx
  000f0	56		 push	 esi
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  000fa	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3760 : 	return (_Ans);

  000fe	8b c7		 mov	 eax, edi

; 3761 : 	}

  00100	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00103	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010a	59		 pop	 ecx
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
$LN103@operator:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  00112	53		 push	 ebx
  00113	51		 push	 ecx
  00114	c6 45 08 00	 mov	 BYTE PTR $T19[ebp], 0
  00118	8b cf		 mov	 ecx, edi
  0011a	ff 75 08	 push	 DWORD PTR $T19[ebp]
  0011d	53		 push	 ebx
  0011e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>

; 3760 : 	return (_Ans);

  00123	8b c7		 mov	 eax, edi

; 3761 : 	}

  00125	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00128	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012f	59		 pop	 ecx
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d e4	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z
_TEXT	SEGMENT
$T6 = -4						; size = 1
___$ReturnUdt$ = -4					; size = 4
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 3884 : 	{	// return string + NTCTS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b da		 mov	 ebx, edx
  00008	8b f1		 mov	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0000a	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3884 : 	{	// return string + NTCTS

  0000d	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0000e	8b fa		 mov	 edi, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3884 : 	{	// return string + NTCTS

  00010	89 75 fc	 mov	 DWORD PTR ___$ReturnUdt$[ebp], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00013	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL95@operator:
  00016	8a 07		 mov	 al, BYTE PTR [edi]
  00018	47		 inc	 edi
  00019	84 c0		 test	 al, al
  0001b	75 f9		 jne	 SHORT $LL95@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  0001d	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00020	2b f9		 sub	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2350 : 		const size_type _Old_size = _My_data._Mysize;

  00022	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00025	2b c1		 sub	 eax, ecx
  00027	3b f8		 cmp	 edi, eax
  00029	77 28		 ja	 SHORT $LN13@operator

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0002b	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  0002f	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00032	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00035	8b c3		 mov	 eax, ebx

; 1596 : 		if (_Large_string_engaged())

  00037	72 02		 jb	 SHORT $LN22@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00039	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN22@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0003b	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0003c	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0003f	52		 push	 edx
  00040	56		 push	 esi
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 517  : 		_Left = _Right;

  00047	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  0004e	8b 75 fc	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00051	eb 13		 jmp	 SHORT $LN12@operator
$LN13@operator:

; 2358 : 			}
; 2359 : 
; 2360 : 		return (_Reallocate_grow_by(_Count,

  00053	57		 push	 edi
  00054	52		 push	 edx
  00055	c6 45 fc 00	 mov	 BYTE PTR $T6[ebp], 0
  00059	8b cb		 mov	 ecx, ebx
  0005b	ff 75 fc	 push	 DWORD PTR $T6[ebp]
  0005e	57		 push	 edi
  0005f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  00064	8b d8		 mov	 ebx, eax
$LN12@operator:

; 1576 : 		_Mysize(0),

  00066	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3885 : 	return (_STD move(_Left.append(_Right)));

  0006d	8b c6		 mov	 eax, esi

; 1577 : 		_Myres(0)

  0006f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00076	0f 10 03	 movups	 xmm0, XMMWORD PTR [ebx]

; 3885 : 	return (_STD move(_Left.append(_Right)));

  00079	5f		 pop	 edi

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0007a	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0007d	f3 0f 7e 43 10	 movq	 xmm0, QWORD PTR [ebx+16]
  00082	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00087	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0008e	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH

; 3885 : 	return (_STD move(_Left.append(_Right)));

  00095	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00096	c6 03 00	 mov	 BYTE PTR [ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3885 : 	return (_STD move(_Left.append(_Right)));

  00099	5b		 pop	 ebx

; 3886 : 	}

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -24					; size = 4
$T17 = -20						; size = 1
$T12 = -20						; size = 1
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$dead$ = edx

; 3799 : 	{	// return string + NTCTS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d e8	 mov	 DWORD PTR ___$ReturnUdt$[ebp], ebx
  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 3698 : 		_My_data._Mysize = 0;

  00034	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003b	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00042	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 480  : 		return (_CSTD strlen(_First));

  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3806 : 	return (_Ans);

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00056	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL112@operator:
  00060	8a 01		 mov	 al, BYTE PTR [ecx]
  00062	41		 inc	 ecx
  00063	84 c0		 test	 al, al
  00065	75 f9		 jne	 SHORT $LL112@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00067	a1 10 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0006c	2b ca		 sub	 ecx, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  0006e	03 c1		 add	 eax, ecx
  00070	8b cb		 mov	 ecx, ebx
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00078	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00084	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]
  00087	8b c6		 mov	 eax, esi

; 1607 : 		if (_Large_string_engaged())

  00089	0f 43 0d 00 00
	00 00		 cmovae	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2350 : 		const size_type _Old_size = _My_data._Mysize;

  00090	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00093	2b c2		 sub	 eax, edx

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00095	8b 3d 10 00 00
	00		 mov	 edi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  0009b	3b f8		 cmp	 edi, eax
  0009d	77 24		 ja	 SHORT $LN60@operator

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  0009f	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  000a2	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  000a5	8b c3		 mov	 eax, ebx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000a7	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  000aa	72 02		 jb	 SHORT $LN69@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000ac	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN69@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000ae	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  000af	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000b2	51		 push	 ecx
  000b3	56		 push	 esi
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  000bd	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  000c1	eb 11		 jmp	 SHORT $LN59@operator
$LN60@operator:

; 2358 : 			}
; 2359 : 
; 2360 : 		return (_Reallocate_grow_by(_Count,

  000c3	57		 push	 edi
  000c4	51		 push	 ecx
  000c5	c6 45 ec 00	 mov	 BYTE PTR $T12[ebp], 0
  000c9	8b cb		 mov	 ecx, ebx
  000cb	ff 75 ec	 push	 DWORD PTR $T12[ebp]
  000ce	57		 push	 edi
  000cf	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN59@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  000d4	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000d7	8b f1		 mov	 esi, ecx
  000d9	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  000dc	0f 1f 40 00	 npad	 4
$LL113@operator:
  000e0	8a 06		 mov	 al, BYTE PTR [esi]
  000e2	46		 inc	 esi
  000e3	84 c0		 test	 al, al
  000e5	75 f9		 jne	 SHORT $LL113@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  000e7	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  000ea	2b f2		 sub	 esi, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2350 : 		const size_type _Old_size = _My_data._Mysize;

  000ec	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  000ef	8b c7		 mov	 eax, edi
  000f1	2b c2		 sub	 eax, edx
  000f3	3b f0		 cmp	 esi, eax
  000f5	77 36		 ja	 SHORT $LN91@operator

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  000f7	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  000fa	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  000fd	8b c3		 mov	 eax, ebx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000ff	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00102	72 02		 jb	 SHORT $LN100@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00104	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN100@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00106	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00107	8d 3c 10	 lea	 edi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0010a	51		 push	 ecx
  0010b	57		 push	 edi
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00115	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3806 : 	return (_Ans);

  00119	8b c3		 mov	 eax, ebx

; 3807 : 	}

  0011b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00125	59		 pop	 ecx
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
$LN91@operator:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  0012d	56		 push	 esi
  0012e	51		 push	 ecx
  0012f	c6 45 ec 00	 mov	 BYTE PTR $T17[ebp], 0
  00133	8b cb		 mov	 ecx, ebx
  00135	ff 75 ec	 push	 DWORD PTR $T17[ebp]
  00138	56		 push	 esi
  00139	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>

; 3806 : 	return (_Ans);

  0013e	8b c3		 mov	 eax, ebx

; 3807 : 	}

  00140	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00143	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014a	59		 pop	 ecx
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi
  0014d	5b		 pop	 ebx
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d e8	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z
_TEXT	SEGMENT
$T4 = -4						; size = 1
___$ReturnUdt$ = -4					; size = 4
__Right$ = 8						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 3894 : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f2		 mov	 esi, edx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	89 7d fc	 mov	 DWORD PTR ___$ReturnUdt$[ebp], edi

; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  0000d	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 2992 : 		if (_Old_size < _My_data._Myres)

  00010	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  00013	73 1d		 jae	 SHORT $LN6@operator

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00015	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2994 : 			_My_data._Mysize = _Old_size + 1;

  00019	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0001c	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  0001f	8b ce		 mov	 ecx, esi

; 1596 : 		if (_Large_string_engaged())

  00021	72 02		 jb	 SHORT $LN15@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00023	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN15@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00025	8a 45 08	 mov	 al, BYTE PTR __Right$[ebp]
  00028	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0002b	c6 44 11 01 00	 mov	 BYTE PTR [ecx+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2998 : 			return;

  00030	eb 12		 jmp	 SHORT $LN5@operator
$LN6@operator:

; 2999 : 			}
; 3000 : 
; 3001 : 		_Reallocate_grow_by(1,

  00032	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00035	c6 45 fc 00	 mov	 BYTE PTR $T4[ebp], 0
  00039	ff 75 fc	 push	 DWORD PTR $T4[ebp]
  0003c	51		 push	 ecx
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN5@operator:

; 1576 : 		_Mysize(0),

  00044	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3896 : 	return (_STD move(_Left));

  0004b	8b c7		 mov	 eax, edi

; 1577 : 		_Myres(0)

  0004d	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00054	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00057	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0005a	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  0005f	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0

; 3698 : 		_My_data._Mysize = 0;

  00064	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0006b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3896 : 	return (_STD move(_Left));

  00072	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00073	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3896 : 	return (_STD move(_Left));

  00076	5e		 pop	 esi

; 3897 : 	}

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 158  : 	{	// get characters into string, discard newline

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8b f2		 mov	 esi, edx

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00006	6a 0a		 push	 10			; 0000000aH
  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	03 cf		 add	 ecx, edi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00015	0f b6 c0	 movzx	 eax, al
  00018	8b d6		 mov	 edx, esi
  0001a	50		 push	 eax
  0001b	8b cf		 mov	 ecx, edi
  0001d	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00022	83 c4 04	 add	 esp, 4
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 160  : 	}

  00027	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -24					; size = 4
$T12 = -20						; size = 1
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T17 = 8						; size = 1
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$dead$ = edx

; 3769 : 	{	// return NTCTS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d e8	 mov	 DWORD PTR ___$ReturnUdt$[ebp], edi
  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 3698 : 		_My_data._Mysize = 0;

  00034	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003b	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00042	c6 07 00	 mov	 BYTE PTR [edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3776 : 	return (_Ans);

  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 3062 : 		return (this->_Get_data()._Mysize);

  0004c	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  0004f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1

; 3770 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3771 : 	using _Size_type = typename _String_type::size_type;
; 3772 : 	_String_type _Ans;
; 3773 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  00056	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00059	83 c0 05	 add	 eax, 5
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00062	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00065	8b c2		 mov	 eax, edx
  00067	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0006a	2b c1		 sub	 eax, ecx
  0006c	83 f8 05	 cmp	 eax, 5
  0006f	72 29		 jb	 SHORT $LN52@operator

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  00071	8d 41 05	 lea	 eax, DWORD PTR [ecx+5]
  00074	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00077	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00079	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  0007c	72 02		 jb	 SHORT $LN61@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0007e	8b 07		 mov	 eax, DWORD PTR [edi]
$LN61@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00080	6a 05		 push	 5
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00082	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00085	68 00 00 00 00	 push	 OFFSET ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  0008a	56		 push	 esi
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00094	c6 46 05 00	 mov	 BYTE PTR [esi+5], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  00098	eb 17		 jmp	 SHORT $LN51@operator
$LN52@operator:

; 2358 : 			}
; 2359 : 
; 2360 : 		return (_Reallocate_grow_by(_Count,

  0009a	6a 05		 push	 5
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  000a1	c6 45 ec 00	 mov	 BYTE PTR $T12[ebp], 0
  000a5	8b cf		 mov	 ecx, edi
  000a7	ff 75 ec	 push	 DWORD PTR $T12[ebp]
  000aa	6a 05		 push	 5
  000ac	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN51@operator:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000b1	8b cb		 mov	 ecx, ebx
  000b3	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  000b7	72 02		 jb	 SHORT $LN84@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000b9	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN84@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  000bb	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  000be	8b c6		 mov	 eax, esi
  000c0	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  000c3	2b c2		 sub	 eax, edx

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  000c5	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  000c8	3b d8		 cmp	 ebx, eax
  000ca	77 36		 ja	 SHORT $LN91@operator

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  000cc	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000cf	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  000d2	8b c7		 mov	 eax, edi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000d4	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  000d7	72 02		 jb	 SHORT $LN100@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000d9	8b 07		 mov	 eax, DWORD PTR [edi]
$LN100@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000db	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  000dc	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000df	51		 push	 ecx
  000e0	56		 push	 esi
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  000ea	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3776 : 	return (_Ans);

  000ee	8b c7		 mov	 eax, edi

; 3777 : 	}

  000f0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fa	59		 pop	 ecx
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
$LN91@operator:

; 2360 : 		return (_Reallocate_grow_by(_Count,

  00102	53		 push	 ebx
  00103	51		 push	 ecx
  00104	c6 45 08 00	 mov	 BYTE PTR $T17[ebp], 0
  00108	8b cf		 mov	 ecx, edi
  0010a	ff 75 08	 push	 DWORD PTR $T17[ebp]
  0010d	53		 push	 ebx
  0010e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>

; 3776 : 	return (_Ans);

  00113	8b c7		 mov	 eax, edi

; 3777 : 	}

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d e8	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Ostr$ = ecx
; __Str$ = edx

; 168  : 	{	// insert a string

  00000	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00001	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 3062 : 		return (this->_Get_data()._Mysize);

  00005	8b 42 10	 mov	 eax, DWORD PTR [edx+16]

; 1607 : 		if (_Large_string_engaged())

  00008	72 02		 jb	 SHORT $LN22@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000a	8b 12		 mov	 edx, DWORD PTR [edx]
$LN22@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  00012	83 c4 04	 add	 esp, 4

; 170  : 	}

  00015	59		 pop	 ecx
  00016	c3		 ret	 0
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0CA@@std@@YAIAAY0CA@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0CA@@std@@YAIAAY0CA@$$CBD@Z PROC		; std::size<char,32>, COMDAT
; ___formal$dead$ = ecx

; 1474 : 	return (_Size);

  00000	b8 20 00 00 00	 mov	 eax, 32			; 00000020H

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0CA@@std@@YAIAAY0CA@$$CBD@Z ENDP		; std::size<char,32>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0CG@@std@@YAIAAY0CG@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0CG@@std@@YAIAAY0CG@$$CBD@Z PROC		; std::size<char,38>, COMDAT
; ___formal$dead$ = ecx

; 1474 : 	return (_Size);

  00000	b8 26 00 00 00	 mov	 eax, 38			; 00000026H

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0CG@@std@@YAIAAY0CG@$$CBD@Z ENDP		; std::size<char,38>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BM@@std@@YAIAAY0BM@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BM@@std@@YAIAAY0BM@$$CBD@Z PROC		; std::size<char,28>, COMDAT
; ___formal$dead$ = ecx

; 1474 : 	return (_Size);

  00000	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BM@@std@@YAIAAY0BM@$$CBD@Z ENDP		; std::size<char,28>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BL@@std@@YAIAAY0BL@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BL@@std@@YAIAAY0BL@$$CBD@Z PROC		; std::size<char,27>, COMDAT
; ___formal$dead$ = ecx

; 1474 : 	return (_Size);

  00000	b8 1b 00 00 00	 mov	 eax, 27			; 0000001bH

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BL@@std@@YAIAAY0BL@$$CBD@Z ENDP		; std::size<char,27>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BH@@std@@YAIAAY0BH@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BH@@std@@YAIAAY0BH@$$CBD@Z PROC		; std::size<char,23>, COMDAT
; ___formal$dead$ = ecx

; 1474 : 	return (_Size);

  00000	b8 17 00 00 00	 mov	 eax, 23			; 00000017H

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BH@@std@@YAIAAY0BH@$$CBD@Z ENDP		; std::size<char,23>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BB@@std@@YAIAAY0BB@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BB@@std@@YAIAAY0BB@$$CBD@Z PROC		; std::size<char,17>, COMDAT
; ___formal$dead$ = ecx

; 1474 : 	return (_Size);

  00000	b8 11 00 00 00	 mov	 eax, 17			; 00000011H

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BB@@std@@YAIAAY0BB@$$CBD@Z ENDP		; std::size<char,17>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0O@@std@@YAIAAY0O@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0O@@std@@YAIAAY0O@$$CBD@Z PROC		; std::size<char,14>, COMDAT
; ___formal$dead$ = ecx

; 1474 : 	return (_Size);

  00000	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0O@@std@@YAIAAY0O@$$CBD@Z ENDP		; std::size<char,14>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BE@@std@@YAIAAY0BE@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BE@@std@@YAIAAY0BE@$$CBD@Z PROC		; std::size<char,20>, COMDAT
; ___formal$dead$ = ecx

; 1474 : 	return (_Size);

  00000	b8 14 00 00 00	 mov	 eax, 20			; 00000014H

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BE@@std@@YAIAAY0BE@$$CBD@Z ENDP		; std::size<char,20>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BN@@std@@YAIAAY0BN@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BN@@std@@YAIAAY0BN@$$CBD@Z PROC		; std::size<char,29>, COMDAT
; ___formal$dead$ = ecx

; 1474 : 	return (_Size);

  00000	b8 1d 00 00 00	 mov	 eax, 29			; 0000001dH

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BN@@std@@YAIAAY0BN@$$CBD@Z ENDP		; std::size<char,29>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z
_TEXT	SEGMENT
__Haystack$1$ = -4					; size = 4
__Start_at$dead$ = 8					; size = 4
__Needle$ = 12						; size = 4
__Possible_matches_end$1$ = 16				; size = 4
__Needle_size$ = 16					; size = 4
??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT
; __Haystack$ = ecx
; __Hay_size$ = edx

; 56   : 	{	// search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00005	8b 5d 10	 mov	 ebx, DWORD PTR __Needle_size$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR __Haystack$1$[ebp], ecx
  0000b	3b da		 cmp	 ebx, edx
  0000d	0f 87 c1 00 00
	00		 ja	 $LN6@Traits_fin

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)

  00013	85 db		 test	 ebx, ebx
  00015	75 07		 jne	 SHORT $LN7@Traits_fin

; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);

  00017	33 c0		 xor	 eax, eax

; 86   : 			}
; 87   : 		}
; 88   : 	}

  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN7@Traits_fin:

; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0001e	8b c1		 mov	 eax, ecx
  00020	42		 inc	 edx
  00021	2b c3		 sub	 eax, ebx
  00023	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00024	8b 75 0c	 mov	 esi, DWORD PTR __Needle$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00027	03 c2		 add	 eax, edx
  00029	89 45 10	 mov	 DWORD PTR __Possible_matches_end$1$[ebp], eax

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0002c	2b c1		 sub	 eax, ecx
  0002e	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0002f	50		 push	 eax
  00030	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00033	50		 push	 eax
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  0003b	8b f8		 mov	 edi, eax
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00040	85 ff		 test	 edi, edi
  00042	74 7a		 je	 SHORT $LN18@Traits_fin
$LL4@Traits_fin:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00044	8b cb		 mov	 ecx, ebx
  00046	8b d7		 mov	 edx, edi
  00048	83 e9 04	 sub	 ecx, 4
  0004b	72 14		 jb	 SHORT $LN25@Traits_fin
  0004d	0f 1f 00	 npad	 3
$LL26@Traits_fin:
  00050	8b 02		 mov	 eax, DWORD PTR [edx]
  00052	3b 06		 cmp	 eax, DWORD PTR [esi]
  00054	75 10		 jne	 SHORT $LN24@Traits_fin
  00056	83 c2 04	 add	 edx, 4
  00059	83 c6 04	 add	 esi, 4
  0005c	83 e9 04	 sub	 ecx, 4
  0005f	73 ef		 jae	 SHORT $LL26@Traits_fin
$LN25@Traits_fin:
  00061	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00064	74 34		 je	 SHORT $LN23@Traits_fin
$LN24@Traits_fin:
  00066	8a 02		 mov	 al, BYTE PTR [edx]
  00068	3a 06		 cmp	 al, BYTE PTR [esi]
  0006a	75 27		 jne	 SHORT $LN27@Traits_fin
  0006c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0006f	74 29		 je	 SHORT $LN23@Traits_fin
  00071	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00074	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00077	75 1a		 jne	 SHORT $LN27@Traits_fin
  00079	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0007c	74 1c		 je	 SHORT $LN23@Traits_fin
  0007e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00081	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00084	75 0d		 jne	 SHORT $LN27@Traits_fin
  00086	83 f9 ff	 cmp	 ecx, -1
  00089	74 0f		 je	 SHORT $LN23@Traits_fin
  0008b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0008e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00091	74 07		 je	 SHORT $LN23@Traits_fin
$LN27@Traits_fin:
  00093	1b c0		 sbb	 eax, eax
  00095	83 c8 01	 or	 eax, 1
  00098	eb 02		 jmp	 SHORT $LN28@Traits_fin
$LN23@Traits_fin:
  0009a	33 c0		 xor	 eax, eax
$LN28@Traits_fin:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  0009c	85 c0		 test	 eax, eax
  0009e	74 28		 je	 SHORT $LN19@Traits_fin

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  000a0	8b 45 10	 mov	 eax, DWORD PTR __Possible_matches_end$1$[ebp]
  000a3	47		 inc	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  000a4	8b 75 0c	 mov	 esi, DWORD PTR __Needle$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  000a7	2b c7		 sub	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  000a9	50		 push	 eax
  000aa	0f be 06	 movsx	 eax, BYTE PTR [esi]
  000ad	50		 push	 eax
  000ae	57		 push	 edi
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  000b5	8b f8		 mov	 edi, eax
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  000ba	85 ff		 test	 edi, edi
  000bc	75 86		 jne	 SHORT $LL4@Traits_fin
$LN18@Traits_fin:
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  000c0	83 c8 ff	 or	 eax, -1

; 86   : 			}
; 87   : 		}
; 88   : 	}

  000c3	5b		 pop	 ebx
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN19@Traits_fin:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  000c8	2b 7d fc	 sub	 edi, DWORD PTR __Haystack$1$[ebp]
  000cb	8b c7		 mov	 eax, edi
  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi

; 86   : 			}
; 87   : 		}
; 88   : 	}

  000cf	5b		 pop	 ebx
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN6@Traits_fin:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

  000d4	83 c8 ff	 or	 eax, -1

; 86   : 			}
; 87   : 		}
; 88   : 	}

  000d7	5b		 pop	 ebx
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00004	0f 42 ca	 cmovb	 ecx, edx
  00007	8b c1		 mov	 eax, ecx

; 24   : 	}

  00009	c3		 ret	 0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT
; __Ptr$ = ecx

; 265  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 266  : 	}

  00002	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT
; __Val$ = ecx

; 249  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 250  : 	}

  00002	c3		 ret	 0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Val$ = ecx

; 249  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 250  : 	}

  00002	c3		 ret	 0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; __Arg$ = ecx

; 1607 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1608 : 	}

  00002	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT
; __Arg$ = ecx

; 1607 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1608 : 	}

  00002	c3		 ret	 0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>, COMDAT
; _this$ = ecx

; 1576 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1711 : 		}

  00007	8b c1		 mov	 eax, ecx

; 1577 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1711 : 		}

  00010	c2 04 00	 ret	 4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 12
__Psave$4 = -24						; size = 4
__Lock$5 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT
; __Loc$ = ecx

; 505  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  0002d	6a 00		 push	 0
  0002f	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave

; 509  : 
; 510  : 		size_t _Id = _Facet::id;

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
  0004a	89 45 e8	 mov	 DWORD PTR __Psave$4[ebp], eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00053	8b f8		 mov	 edi, eax

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00055	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00058	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0005b	73 0c		 jae	 SHORT $LN15@use_facet
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 34 b9	 mov	 esi, DWORD PTR [ecx+edi*4]

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00063	85 f6		 test	 esi, esi
  00065	75 67		 jne	 SHORT $LN7@use_facet
  00067	eb 02		 jmp	 SHORT $LN19@use_facet
$LN15@use_facet:

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00069	33 f6		 xor	 esi, esi
$LN19@use_facet:

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0006b	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  0006f	74 11		 je	 SHORT $LN12@use_facet

; 434  : 			return (_Facptr);	// found facet or not transparent
; 435  : 		else
; 436  : 			{	// look in current locale
; 437  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 438  : 			return (_Id < _Ptr0->_Facetcount

  00077	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0007a	73 0a		 jae	 SHORT $LN20@use_facet
  0007c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007f	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN12@use_facet:

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 512  : 
; 513  : 		if (_Pf != 0)

  00082	85 f6		 test	 esi, esi
  00084	75 48		 jne	 SHORT $LN7@use_facet
$LN20@use_facet:

; 514  : 			;	// got facet from locale
; 515  : 		else if (_Psave != 0)

  00086	8b 75 e8	 mov	 esi, DWORD PTR __Psave$4[ebp]
  00089	85 f6		 test	 esi, esi
  0008b	75 41		 jne	 SHORT $LN7@use_facet

; 516  : 			_Pf = _Psave;	// lazy facet already allocated
; 517  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  0008d	8d 45 e8	 lea	 eax, DWORD PTR __Psave$4[ebp]
  00090	53		 push	 ebx
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00098	83 c4 08	 add	 esp, 8
  0009b	83 f8 ff	 cmp	 eax, -1
  0009e	75 15		 jne	 SHORT $LN6@use_facet

; 518  : 
; 519  :  #if _HAS_EXCEPTIONS
; 520  : 
; 521  : 			_THROW(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000a0	8d 4d dc	 lea	 ecx, DWORD PTR $T1[ebp]
  000a3	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000ad	8b c1		 mov	 eax, ecx
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN24@use_facet:
$LN6@use_facet:

; 522  : 
; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 			abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 
; 527  : 		else
; 528  : 			{	// queue up lazy facet for destruction
; 529  : 			_Pf = _Psave;

  000b5	8b 75 e8	 mov	 esi, DWORD PTR __Psave$4[ebp]

; 530  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 531  : 
; 532  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 533  : 			_Pfmod->_Incref();

  000b8	8b ce		 mov	 ecx, esi
  000ba	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
  000c0	8b 16		 mov	 edx, DWORD PTR [esi]
  000c2	ff 52 04	 call	 DWORD PTR [edx+4]

; 534  : 
; 535  :  #if defined(_M_CEE)
; 536  : 			_Facet_Register_m(_Pfmod);
; 537  : 
; 538  :  #else /* defined(_M_CEE) */
; 539  : 			_Facet_Register(_Pfmod);

  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000cb	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 540  :  #endif /* defined(_M_CEE) */
; 541  : 			}
; 542  : 
; 543  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000ce	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d7	8b c6		 mov	 eax, esi

; 544  : 	_END_LOCK()
; 545  : 	}	// end of use_facet body

  000d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e3	59		 pop	 ecx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
$LN22@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT
; __Val$ = ecx

; 249  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 250  : 	}

  00002	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1053 : 	typename allocator_traits<_Alloc>::propagate_on_container_move_assignment _Tag;
; 1054 : 	_Pocma(_Left, _Right, _Tag);
; 1055 : 	}

  00000	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1034 : 	typename allocator_traits<_Alloc>::propagate_on_container_copy_assignment _Tag;
; 1035 : 	_Pocca(_Left, _Right, _Tag);
; 1036 : 	}

  00000	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1576 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 304  : 		}

  00007	8b c1		 mov	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1577 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 304  : 		}

  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT
; __Val$ = ecx

; 249  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 250  : 	}

  00002	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z
_TEXT	SEGMENT
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$dead$ = edx

; 862  : 		_Ptr->~_Uty();
; 863  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$dead$ = 8				; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 3641 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 3642 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3643 : 		auto& _My_data = this->_Get_data();
; 3644 : 		const size_type _Old_size = _My_data._Mysize;
; 3645 : 		if (max_size() - _Old_size < _Size_increase)

  0000b	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00010	8b c1		 mov	 eax, ecx
  00012	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00015	2b c2		 sub	 eax, edx
  00017	89 55 fc	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  0001a	83 f8 01	 cmp	 eax, 1
  0001d	0f 82 15 01 00
	00		 jb	 $LN143@Reallocate

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  00023	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00026	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00029	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  0002c	89 45 f8	 mov	 DWORD PTR __Old$1$[ebp], eax

; 3592 : 		if (_Masked > _Max)

  0002f	3b d9		 cmp	 ebx, ecx
  00031	76 04		 jbe	 SHORT $LN34@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);

  00033	8b d9		 mov	 ebx, ecx
  00035	eb 18		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  00037	8b f0		 mov	 esi, eax
  00039	d1 ee		 shr	 esi, 1
  0003b	2b ce		 sub	 ecx, esi
  0003d	3b c1		 cmp	 eax, ecx
  0003f	76 07		 jbe	 SHORT $LN35@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);

  00041	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00046	eb 07		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00048	03 c6		 add	 eax, esi
  0004a	3b d8		 cmp	 ebx, eax
  0004c	0f 42 d8	 cmovb	 ebx, eax
$LN33@Reallocate:

; 3652 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3653 : 		auto& _Al = this->_Getal();
; 3654 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0004f	33 c9		 xor	 ecx, ecx
  00051	8b c3		 mov	 eax, ebx
  00053	83 c0 01	 add	 eax, 1
  00056	0f 92 c1	 setb	 cl
  00059	f7 d9		 neg	 ecx
  0005b	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  0005d	75 04		 jne	 SHORT $LN76@Reallocate

; 53   : 		{
; 54   : 		return (_Ptr);

  0005f	33 f6		 xor	 esi, esi
  00061	eb 41		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00063	32 c0		 xor	 al, al
  00065	74 06		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN145@Reallocate:
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0006d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00073	72 21		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00075	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00078	3b c1		 cmp	 eax, ecx
  0007a	77 06		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN146@Reallocate:
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00088	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0008b	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  0008e	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00091	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  00094	eb 0b		 jmp	 SHORT $LN141@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009c	83 c4 04	 add	 esp, 4

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);

  0009f	8b f0		 mov	 esi, eax
$LN141@Reallocate:
  000a1	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000a4	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000a8	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  000ab	89 47 10	 mov	 DWORD PTR [edi+16], eax
  000ae	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000b1	52		 push	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000b2	72 5f		 jb	 SHORT $LN3@Reallocate

; 3660 : 			{
; 3661 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000b4	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000b6	53		 push	 ebx
  000b7	56		 push	 esi
  000b8	e8 00 00 00 00	 call	 _memcpy

; 517  : 		_Left = _Right;

  000bd	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  000c3	8a 45 10	 mov	 al, BYTE PTR _<_Args_0>$[ebp]
  000c6	88 04 16	 mov	 BYTE PTR [esi+edx], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000c9	8b 45 f8	 mov	 eax, DWORD PTR __Old$1$[ebp]
  000cc	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000cd	c6 44 16 01 00	 mov	 BYTE PTR [esi+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000d2	32 c9		 xor	 cl, cl
  000d4	75 37		 jne	 SHORT $_Invalid_parameter$149

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000d6	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000db	72 1a		 jb	 SHORT $LN108@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000dd	f6 c3 1f	 test	 bl, 31			; 0000001fH
  000e0	75 2b		 jne	 SHORT $_Invalid_parameter$149

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000e2	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000e5	3b c3		 cmp	 eax, ebx
  000e7	73 24		 jae	 SHORT $_Invalid_parameter$149

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000e9	2b d8		 sub	 ebx, eax
  000eb	83 fb 04	 cmp	 ebx, 4
  000ee	72 1d		 jb	 SHORT $_Invalid_parameter$149

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  000f0	83 fb 23	 cmp	 ebx, 35			; 00000023H
  000f3	77 18		 ja	 SHORT $_Invalid_parameter$149

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000f5	8b d8		 mov	 ebx, eax
$LN108@Reallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  000f7	53		 push	 ebx
  000f8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000fd	83 c4 04	 add	 esp, 4

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00100	89 37		 mov	 DWORD PTR [edi], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  00102	8b c7		 mov	 eax, edi
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx

; 3673 : 		}

  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c2 0c 00	 ret	 12			; 0000000cH
$_Invalid_parameter$149:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN147@Reallocate:
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00113	57		 push	 edi
  00114	56		 push	 esi
  00115	e8 00 00 00 00	 call	 _memcpy

; 517  : 		_Left = _Right;

  0011a	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  00120	8a 4d 10	 mov	 cl, BYTE PTR _<_Args_0>$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  00123	8b c7		 mov	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00125	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00128	c6 44 16 01 00	 mov	 BYTE PTR [esi+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0012d	89 37		 mov	 DWORD PTR [edi], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx

; 3673 : 		}

  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 0c 00	 ret	 12			; 0000000cH
$LN143@Reallocate:

; 3646 : 			{
; 3647 : 			_Xlen();	// result too long

  00138	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN148@Reallocate:
$LN140@Reallocate:
  0013d	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT
; __Val$ = ecx

; 249  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 250  : 	}

  00002	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Refancy@PAD$0A@@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z PROC		; std::_Refancy<char *,0>, COMDAT
; __Ptr$ = ecx

; 344  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 345  : 	}

  00002	c3		 ret	 0
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z ENDP		; std::_Refancy<char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__New_size$dead$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 1
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>, COMDAT
; _this$ = ecx

; 3609 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 3598 : 		if (_Old > _Max - _Old / 2)

  00009	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0000e	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH

; 3610 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3611 : 		if (_New_size > max_size())
; 3612 : 			{
; 3613 : 			_Xlen();	// result too long
; 3614 : 			}
; 3615 : 
; 3616 : 		auto& _My_data = this->_Get_data();
; 3617 : 		const size_type _Old_capacity = _My_data._Myres;

  00013	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]

; 3598 : 		if (_Old > _Max - _Old / 2)

  00016	8b d1		 mov	 edx, ecx
  00018	d1 ea		 shr	 edx, 1
  0001a	2b c2		 sub	 eax, edx

; 3610 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3611 : 		if (_New_size > max_size())
; 3612 : 			{
; 3613 : 			_Xlen();	// result too long
; 3614 : 			}
; 3615 : 
; 3616 : 		auto& _My_data = this->_Get_data();
; 3617 : 		const size_type _Old_capacity = _My_data._Myres;

  0001c	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx

; 3598 : 		if (_Old > _Max - _Old / 2)

  0001f	3b c8		 cmp	 ecx, eax
  00021	76 07		 jbe	 SHORT $LN35@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);

  00023	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00028	eb 09		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0002a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0002d	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00030	0f 47 d8	 cmova	 ebx, eax
$LN33@Reallocate:

; 3618 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3619 : 		auto& _Al = this->_Getal();
; 3620 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00033	33 c9		 xor	 ecx, ecx
  00035	8b c3		 mov	 eax, ebx
  00037	83 c0 01	 add	 eax, 1
  0003a	0f 92 c1	 setb	 cl
  0003d	f7 d9		 neg	 ecx
  0003f	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  00041	75 04		 jne	 SHORT $LN76@Reallocate

; 53   : 		{
; 54   : 		return (_Ptr);

  00043	33 f6		 xor	 esi, esi
  00045	eb 3e		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00047	32 c0		 xor	 al, al
  00049	74 06		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN126@Reallocate:
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00051	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00057	72 21		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00059	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  0005c	3b c1		 cmp	 eax, ecx
  0005e	77 06		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN127@Reallocate:
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0006c	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0006f	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00072	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00075	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  00078	eb 0b		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00080	83 c4 04	 add	 esp, 4

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);

  00083	8b f0		 mov	 esi, eax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3625 : 		if (this->_BUF_SIZE <= _Old_capacity)

  00085	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]
  00088	0f 57 c0	 xorps	 xmm0, xmm0
  0008b	c7 47 10 08 00
	00 00		 mov	 DWORD PTR [edi+16], 8
  00092	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00095	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0

; 517  : 		_Left = _Right;

  00099	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3625 : 		if (this->_BUF_SIZE <= _Old_capacity)

  0009d	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a0	72 33		 jb	 SHORT $LN3@Reallocate
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000a2	32 d2		 xor	 dl, dl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3627 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000a4	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  000a7	8b 07		 mov	 eax, DWORD PTR [edi]

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000a9	75 37		 jne	 SHORT $_Invalid_parameter$129

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000ab	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000b1	72 19		 jb	 SHORT $LN103@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000b3	a8 1f		 test	 al, 31			; 0000001fH
  000b5	75 2b		 jne	 SHORT $_Invalid_parameter$129

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000b7	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000ba	3b c8		 cmp	 ecx, eax
  000bc	73 24		 jae	 SHORT $_Invalid_parameter$129

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000be	2b c1		 sub	 eax, ecx
  000c0	83 f8 04	 cmp	 eax, 4
  000c3	72 1d		 jb	 SHORT $_Invalid_parameter$129

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  000c5	83 f8 23	 cmp	 eax, 35			; 00000023H
  000c8	77 18		 ja	 SHORT $_Invalid_parameter$129

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000ca	8b c1		 mov	 eax, ecx
$LN103@Reallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d2	83 c4 04	 add	 esp, 4
$LN3@Reallocate:

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000d5	89 37		 mov	 DWORD PTR [edi], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3635 : 		return (*this);

  000d7	8b c7		 mov	 eax, edi
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx

; 3636 : 		}

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 0c 00	 ret	 12			; 0000000cH
$_Invalid_parameter$129:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN128@Reallocate:
$LN125@Reallocate:
  000e8	cc		 int	 3
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
_<_Args_0>$GSCopy$1$ = -4				; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 3609 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00009	53		 push	 ebx
  0000a	89 45 fc	 mov	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp], eax
  0000d	8b d9		 mov	 ebx, ecx

; 3610 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3611 : 		if (_New_size > max_size())

  0000f	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00012	56		 push	 esi
  00013	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00018	0f 87 f6 00 00
	00		 ja	 $LN125@Reallocate

; 3614 : 			}
; 3615 : 
; 3616 : 		auto& _My_data = this->_Get_data();
; 3617 : 		const size_type _Old_capacity = _My_data._Myres;

  0001e	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00021	57		 push	 edi

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00022	8b f8		 mov	 edi, eax

; 3614 : 			}
; 3615 : 
; 3616 : 		auto& _My_data = this->_Get_data();
; 3617 : 		const size_type _Old_capacity = _My_data._Myres;

  00024	89 4d f8	 mov	 DWORD PTR __Old$1$[ebp], ecx

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00027	83 cf 0f	 or	 edi, 15			; 0000000fH

; 3592 : 		if (_Masked > _Max)

  0002a	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00030	76 07		 jbe	 SHORT $LN34@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);

  00032	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  00037	eb 1e		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  00039	8b d1		 mov	 edx, ecx
  0003b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00040	d1 ea		 shr	 edx, 1
  00042	2b c2		 sub	 eax, edx
  00044	3b c8		 cmp	 ecx, eax
  00046	76 07		 jbe	 SHORT $LN35@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);

  00048	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  0004d	eb 08		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0004f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00052	3b f8		 cmp	 edi, eax
  00054	0f 42 f8	 cmovb	 edi, eax
$LN33@Reallocate:

; 3618 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3619 : 		auto& _Al = this->_Getal();
; 3620 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00057	33 c9		 xor	 ecx, ecx
  00059	8b c7		 mov	 eax, edi
  0005b	83 c0 01	 add	 eax, 1
  0005e	0f 92 c1	 setb	 cl
  00061	f7 d9		 neg	 ecx
  00063	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  00065	75 04		 jne	 SHORT $LN76@Reallocate

; 53   : 		{
; 54   : 		return (_Ptr);

  00067	33 f6		 xor	 esi, esi
  00069	eb 3e		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  0006b	32 c0		 xor	 al, al
  0006d	74 06		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN127@Reallocate:
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00075	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0007b	72 21		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0007d	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00080	3b c1		 cmp	 eax, ecx
  00082	77 06		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN128@Reallocate:
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00090	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00093	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00096	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00099	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  0009c	eb 0b		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000a4	83 c4 04	 add	 esp, 4

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);

  000a7	8b f0		 mov	 esi, eax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3622 : 		_My_data._Mysize = _New_size;

  000a9	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000ac	50		 push	 eax
  000ad	ff 75 fc	 push	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3622 : 		_My_data._Mysize = _New_size;

  000b0	89 43 10	 mov	 DWORD PTR [ebx+16], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000b3	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3623 : 		_My_data._Myres = _New_capacity;

  000b4	89 7b 14	 mov	 DWORD PTR [ebx+20], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000b7	e8 00 00 00 00	 call	 _memcpy

; 517  : 		_Left = _Right;

  000bc	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		_Left = _Right;

  000c2	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3625 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000c6	8b 45 f8	 mov	 eax, DWORD PTR __Old$1$[ebp]
  000c9	5f		 pop	 edi
  000ca	83 f8 10	 cmp	 eax, 16			; 00000010H
  000cd	72 33		 jb	 SHORT $LN3@Reallocate
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000cf	32 d2		 xor	 dl, dl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3627 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000d1	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  000d4	8b 03		 mov	 eax, DWORD PTR [ebx]

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000d6	75 36		 jne	 SHORT $_Invalid_parameter$131

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000d8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000de	72 19		 jb	 SHORT $LN103@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000e0	a8 1f		 test	 al, 31			; 0000001fH
  000e2	75 2a		 jne	 SHORT $_Invalid_parameter$131

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000e4	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000e7	3b c8		 cmp	 ecx, eax
  000e9	73 23		 jae	 SHORT $_Invalid_parameter$131

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000eb	2b c1		 sub	 eax, ecx
  000ed	83 f8 04	 cmp	 eax, 4
  000f0	72 1c		 jb	 SHORT $_Invalid_parameter$131

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  000f2	83 f8 23	 cmp	 eax, 35			; 00000023H
  000f5	77 17		 ja	 SHORT $_Invalid_parameter$131

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000f7	8b c1		 mov	 eax, ecx
$LN103@Reallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ff	83 c4 04	 add	 esp, 4
$LN3@Reallocate:

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00102	89 33		 mov	 DWORD PTR [ebx], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3635 : 		return (*this);

  00104	8b c3		 mov	 eax, ebx
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx

; 3636 : 		}

  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c2 0c 00	 ret	 12			; 0000000cH
$_Invalid_parameter$131:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN129@Reallocate:
$LN125@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3613 : 			_Xlen();	// result too long

  00114	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN130@Reallocate:
$LN124@Reallocate:
  00119	cc		 int	 3
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -20					; size = 4
__New_size$1$ = -16					; size = 4
__Old$1$ = -12						; size = 4
$T35 = -8						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 1
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>, COMDAT
; _this$ = ecx

; 3641 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 3642 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3643 : 		auto& _My_data = this->_Get_data();
; 3644 : 		const size_type _Old_size = _My_data._Mysize;
; 3645 : 		if (max_size() - _Old_size < _Size_increase)

  00009	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  0000e	8b c1		 mov	 eax, ecx
  00010	89 5d ec	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR __Size_increase$[ebp]
  00017	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001a	2b c2		 sub	 eax, edx
  0001c	89 55 fc	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  0001f	57		 push	 edi
  00020	3b c6		 cmp	 eax, esi
  00022	0f 82 3a 01 00
	00		 jb	 $LN144@Reallocate

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;

  00028	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]

; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  0002b	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0002e	8b f8		 mov	 edi, eax

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;

  00030	89 45 f0	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00033	83 cf 0f	 or	 edi, 15			; 0000000fH

; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  00036	89 75 f4	 mov	 DWORD PTR __Old$1$[ebp], esi

; 3592 : 		if (_Masked > _Max)

  00039	3b f9		 cmp	 edi, ecx
  0003b	76 04		 jbe	 SHORT $LN34@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);

  0003d	8b f9		 mov	 edi, ecx
  0003f	eb 18		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  00041	8b c6		 mov	 eax, esi
  00043	d1 e8		 shr	 eax, 1
  00045	2b c8		 sub	 ecx, eax
  00047	3b f1		 cmp	 esi, ecx
  00049	76 07		 jbe	 SHORT $LN35@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);

  0004b	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  00050	eb 07		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00052	03 c6		 add	 eax, esi
  00054	3b f8		 cmp	 edi, eax
  00056	0f 42 f8	 cmovb	 edi, eax
$LN33@Reallocate:

; 3652 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3653 : 		auto& _Al = this->_Getal();
; 3654 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00059	33 c9		 xor	 ecx, ecx
  0005b	8b c7		 mov	 eax, edi
  0005d	83 c0 01	 add	 eax, 1
  00060	0f 92 c1	 setb	 cl
  00063	f7 d9		 neg	 ecx
  00065	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  00067	75 04		 jne	 SHORT $LN76@Reallocate

; 53   : 		{
; 54   : 		return (_Ptr);

  00069	33 f6		 xor	 esi, esi
  0006b	eb 41		 jmp	 SHORT $LN141@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  0006d	32 c0		 xor	 al, al
  0006f	74 06		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN146@Reallocate:
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00077	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0007d	72 21		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0007f	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00082	3b c1		 cmp	 eax, ecx
  00084	77 06		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN147@Reallocate:
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00092	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00095	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00098	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0009b	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  0009e	eb 0b		 jmp	 SHORT $LN142@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000a6	83 c4 04	 add	 esp, 4

; 95   : 	return (_Ptr);

  000a9	8b f0		 mov	 esi, eax
$LN142@Reallocate:
  000ab	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
$LN141@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000ae	83 7d f4 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000b2	8b 45 f0	 mov	 eax, DWORD PTR __New_size$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 95   : 	return (_Ptr);

  000b5	89 75 f8	 mov	 DWORD PTR $T35[ebp], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3656 : 		_My_data._Mysize = _New_size;

  000b8	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 3657 : 		_My_data._Myres = _New_capacity;

  000bb	89 7b 14	 mov	 DWORD PTR [ebx+20], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000be	52		 push	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000bf	72 6f		 jb	 SHORT $LN3@Reallocate

; 3660 : 			{
; 3661 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000c1	8b 1b		 mov	 ebx, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000c3	53		 push	 ebx
  000c4	56		 push	 esi
  000c5	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  000ca	8b 7d fc	 mov	 edi, DWORD PTR __Old_size$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000cd	0f be 45 14	 movsx	 eax, BYTE PTR _<_Args_1>$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  000d1	03 fe		 add	 edi, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000d3	8b 75 10	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  000d6	56		 push	 esi
  000d7	50		 push	 eax
  000d8	57		 push	 edi
  000d9	e8 00 00 00 00	 call	 _memset
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000de	8b 45 f4	 mov	 eax, DWORD PTR __Old$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000e1	83 c4 18	 add	 esp, 24			; 00000018H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000e4	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000e5	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000e9	32 c9		 xor	 cl, cl
  000eb	75 3d		 jne	 SHORT $_Invalid_parameter$150

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000ed	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000f2	72 1a		 jb	 SHORT $LN108@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000f4	f6 c3 1f	 test	 bl, 31			; 0000001fH
  000f7	75 31		 jne	 SHORT $_Invalid_parameter$150

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000f9	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000fc	3b c3		 cmp	 eax, ebx
  000fe	73 2a		 jae	 SHORT $_Invalid_parameter$150

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00100	2b d8		 sub	 ebx, eax
  00102	83 fb 04	 cmp	 ebx, 4
  00105	72 23		 jb	 SHORT $_Invalid_parameter$150

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00107	83 fb 23	 cmp	 ebx, 35			; 00000023H
  0010a	77 1e		 ja	 SHORT $_Invalid_parameter$150

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0010c	8b d8		 mov	 ebx, eax
$LN108@Reallocate:

; 151  : 	::operator delete(_Ptr);

  0010e	53		 push	 ebx
  0010f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3664 : 			_My_data._Bx._Ptr = _New_ptr;

  00114	8b 5d ec	 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 151  : 	::operator delete(_Ptr);

  00117	83 c4 04	 add	 esp, 4

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0011a	8b 45 f8	 mov	 eax, DWORD PTR $T35[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  0011d	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0011e	89 03		 mov	 DWORD PTR [ebx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  00120	8b c3		 mov	 eax, ebx
  00122	5e		 pop	 esi
  00123	5b		 pop	 ebx

; 3673 : 		}

  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 10 00	 ret	 16			; 00000010H
$_Invalid_parameter$150:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN148@Reallocate:
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00130	53		 push	 ebx
  00131	56		 push	 esi
  00132	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  00137	8b 7d fc	 mov	 edi, DWORD PTR __Old_size$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  0013a	0f be 4d 14	 movsx	 ecx, BYTE PTR _<_Args_1>$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  0013e	03 fe		 add	 edi, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00140	8b 75 10	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  00143	56		 push	 esi
  00144	51		 push	 ecx
  00145	57		 push	 edi
  00146	e8 00 00 00 00	 call	 _memset
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0014b	8b 45 f8	 mov	 eax, DWORD PTR $T35[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  0014e	83 c4 18	 add	 esp, 24			; 00000018H

; 517  : 		_Left = _Right;

  00151	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00155	89 03		 mov	 DWORD PTR [ebx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  00157	8b c3		 mov	 eax, ebx
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	5b		 pop	 ebx

; 3673 : 		}

  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c2 10 00	 ret	 16			; 00000010H
$LN144@Reallocate:

; 3646 : 			{
; 3647 : 			_Xlen();	// result too long

  00162	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN149@Reallocate:
$LN140@Reallocate:
  00167	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -24					; size = 4
__New_size$1$ = -20					; size = 4
_<_Args_0>$GSCopy$1$ = -16				; size = 4
__Old$1$ = -12						; size = 4
$T35 = -8						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 3641 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	89 45 f0	 mov	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp], eax

; 3642 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3643 : 		auto& _My_data = this->_Get_data();
; 3644 : 		const size_type _Old_size = _My_data._Mysize;
; 3645 : 		if (max_size() - _Old_size < _Size_increase)

  0000f	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00014	89 5d e8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  00017	8b c1		 mov	 eax, ecx
  00019	56		 push	 esi
  0001a	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001d	2b c2		 sub	 eax, edx
  0001f	8b 75 08	 mov	 esi, DWORD PTR __Size_increase$[ebp]
  00022	89 55 fc	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  00025	57		 push	 edi
  00026	3b c6		 cmp	 eax, esi
  00028	0f 82 36 01 00
	00		 jb	 $LN144@Reallocate

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;

  0002e	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]

; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  00031	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00034	8b f8		 mov	 edi, eax

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;

  00036	89 45 ec	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00039	83 cf 0f	 or	 edi, 15			; 0000000fH

; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  0003c	89 75 f4	 mov	 DWORD PTR __Old$1$[ebp], esi

; 3592 : 		if (_Masked > _Max)

  0003f	3b f9		 cmp	 edi, ecx
  00041	76 04		 jbe	 SHORT $LN34@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);

  00043	8b f9		 mov	 edi, ecx
  00045	eb 18		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  00047	8b c6		 mov	 eax, esi
  00049	d1 e8		 shr	 eax, 1
  0004b	2b c8		 sub	 ecx, eax
  0004d	3b f1		 cmp	 esi, ecx
  0004f	76 07		 jbe	 SHORT $LN35@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);

  00051	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  00056	eb 07		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00058	03 c6		 add	 eax, esi
  0005a	3b f8		 cmp	 edi, eax
  0005c	0f 42 f8	 cmovb	 edi, eax
$LN33@Reallocate:

; 3652 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3653 : 		auto& _Al = this->_Getal();
; 3654 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0005f	33 c9		 xor	 ecx, ecx
  00061	8b c7		 mov	 eax, edi
  00063	83 c0 01	 add	 eax, 1
  00066	0f 92 c1	 setb	 cl
  00069	f7 d9		 neg	 ecx
  0006b	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  0006d	75 04		 jne	 SHORT $LN76@Reallocate

; 53   : 		{
; 54   : 		return (_Ptr);

  0006f	33 f6		 xor	 esi, esi
  00071	eb 41		 jmp	 SHORT $LN141@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00073	32 c0		 xor	 al, al
  00075	74 06		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN146@Reallocate:
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0007d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00083	72 21		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00085	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00088	3b c1		 cmp	 eax, ecx
  0008a	77 06		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN147@Reallocate:
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00098	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0009b	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  0009e	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000a1	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  000a4	eb 0b		 jmp	 SHORT $LN142@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ac	83 c4 04	 add	 esp, 4

; 95   : 	return (_Ptr);

  000af	8b f0		 mov	 esi, eax
$LN142@Reallocate:
  000b1	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
$LN141@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000b4	83 7d f4 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000b8	8b 45 ec	 mov	 eax, DWORD PTR __New_size$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 95   : 	return (_Ptr);

  000bb	89 75 f8	 mov	 DWORD PTR $T35[ebp], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3656 : 		_My_data._Mysize = _New_size;

  000be	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 3657 : 		_My_data._Myres = _New_capacity;

  000c1	89 7b 14	 mov	 DWORD PTR [ebx+20], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000c4	52		 push	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000c5	72 6d		 jb	 SHORT $LN3@Reallocate

; 3660 : 			{
; 3661 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000c7	8b 1b		 mov	 ebx, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000c9	53		 push	 ebx
  000ca	56		 push	 esi
  000cb	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2364 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  000d0	8b 7d fc	 mov	 edi, DWORD PTR __Old_size$1$[ebp]
  000d3	03 fe		 add	 edi, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000d5	8b 75 14	 mov	 esi, DWORD PTR _<_Args_1>$[ebp]
  000d8	56		 push	 esi
  000d9	ff 75 f0	 push	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp]
  000dc	57		 push	 edi
  000dd	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000e2	8b 45 f4	 mov	 eax, DWORD PTR __Old$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000e5	83 c4 18	 add	 esp, 24			; 00000018H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000e8	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000e9	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000ed	32 c9		 xor	 cl, cl
  000ef	75 3d		 jne	 SHORT $_Invalid_parameter$150

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000f1	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000f6	72 1a		 jb	 SHORT $LN108@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000f8	f6 c3 1f	 test	 bl, 31			; 0000001fH
  000fb	75 31		 jne	 SHORT $_Invalid_parameter$150

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000fd	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00100	3b c3		 cmp	 eax, ebx
  00102	73 2a		 jae	 SHORT $_Invalid_parameter$150

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00104	2b d8		 sub	 ebx, eax
  00106	83 fb 04	 cmp	 ebx, 4
  00109	72 23		 jb	 SHORT $_Invalid_parameter$150

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  0010b	83 fb 23	 cmp	 ebx, 35			; 00000023H
  0010e	77 1e		 ja	 SHORT $_Invalid_parameter$150

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00110	8b d8		 mov	 ebx, eax
$LN108@Reallocate:

; 151  : 	::operator delete(_Ptr);

  00112	53		 push	 ebx
  00113	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3664 : 			_My_data._Bx._Ptr = _New_ptr;

  00118	8b 5d e8	 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 151  : 	::operator delete(_Ptr);

  0011b	83 c4 04	 add	 esp, 4

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0011e	8b 45 f8	 mov	 eax, DWORD PTR $T35[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  00121	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00122	89 03		 mov	 DWORD PTR [ebx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  00124	8b c3		 mov	 eax, ebx
  00126	5e		 pop	 esi
  00127	5b		 pop	 ebx

; 3673 : 		}

  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c2 10 00	 ret	 16			; 00000010H
$_Invalid_parameter$150:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN148@Reallocate:
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00134	53		 push	 ebx
  00135	56		 push	 esi
  00136	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2364 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  0013b	8b 7d fc	 mov	 edi, DWORD PTR __Old_size$1$[ebp]
  0013e	03 fe		 add	 edi, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00140	8b 75 14	 mov	 esi, DWORD PTR _<_Args_1>$[ebp]
  00143	56		 push	 esi
  00144	ff 75 f0	 push	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp]
  00147	57		 push	 edi
  00148	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0014d	8b 45 f8	 mov	 eax, DWORD PTR $T35[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00150	83 c4 18	 add	 esp, 24			; 00000018H

; 517  : 		_Left = _Right;

  00153	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00157	89 03		 mov	 DWORD PTR [ebx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  00159	8b c3		 mov	 eax, ebx
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx

; 3673 : 		}

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 10 00	 ret	 16			; 00000010H
$LN144@Reallocate:

; 3646 : 			{
; 3647 : 			_Xlen();	// result too long

  00164	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN149@Reallocate:
$LN140@Reallocate:
  00169	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 854  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 02		 mov	 DWORD PTR [edx], eax

; 856  : 			_Objty(_STD forward<_Types>(_Args)...);
; 857  : 		}

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 1576 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1711 : 		}

  00007	8b c1		 mov	 eax, ecx

; 1577 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1711 : 		}

  00010	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 65   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_copy
  00024	83 c4 08	 add	 esp, 8
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
  0002d	8b c6		 mov	 eax, esi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 1576 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1579 : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 3726 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
  0000b	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 3588 : 		{	// determines the next array size to allocate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3589 : 		const size_type _Max = max_size();
; 3590 : 		auto& _My_data = this->_Get_data();
; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]

; 3592 : 		if (_Masked > _Max)
; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);

  00006	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0000b	83 ca 0f	 or	 edx, 15			; 0000000fH
  0000e	3b d0		 cmp	 edx, eax
  00010	77 22		 ja	 SHORT $LN1@Calculate_

; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;

  00012	56		 push	 esi
  00013	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]

; 3598 : 		if (_Old > _Max - _Old / 2)

  00016	8b ce		 mov	 ecx, esi
  00018	d1 e9		 shr	 ecx, 1
  0001a	2b c1		 sub	 eax, ecx
  0001c	3b f0		 cmp	 esi, eax
  0001e	76 0a		 jbe	 SHORT $LN3@Calculate_

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);

  00020	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00025	5e		 pop	 esi

; 3604 : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN3@Calculate_:

; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0002a	03 ce		 add	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 32   : 	return (_Left < _Right ? _Right : _Left);

  0002c	3b d1		 cmp	 edx, ecx
  0002e	5e		 pop	 esi
  0002f	0f 42 d1	 cmovb	 edx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00032	8b c2		 mov	 eax, edx
$LN1@Calculate_:

; 3604 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT
; _this$ = ecx

; 3494 : 		{	// compare [0, size()) with _Ptr for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3494 : 		{	// compare [0, size()) with _Ptr for equality

  00007	8b d1		 mov	 edx, ecx
  00009	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0000a	8b fe		 mov	 edi, esi
  0000c	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000f	90		 npad	 1
$LL27@Equal:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL27@Equal
  00017	2b f9		 sub	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00019	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0001d	8b ca		 mov	 ecx, edx

; 1607 : 		if (_Large_string_engaged())

  0001f	72 02		 jb	 SHORT $LN13@Equal
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN13@Equal:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3496 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00023	8b 52 10	 mov	 edx, DWORD PTR [edx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00026	3b d7		 cmp	 edx, edi
  00028	75 5e		 jne	 SHORT $LN21@Equal
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0002a	83 ea 04	 sub	 edx, 4
  0002d	72 12		 jb	 SHORT $LN30@Equal
  0002f	90		 npad	 1
$LL31@Equal:
  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	3b 06		 cmp	 eax, DWORD PTR [esi]
  00034	75 10		 jne	 SHORT $LN29@Equal
  00036	83 c1 04	 add	 ecx, 4
  00039	83 c6 04	 add	 esi, 4
  0003c	83 ea 04	 sub	 edx, 4
  0003f	73 ef		 jae	 SHORT $LL31@Equal
$LN30@Equal:
  00041	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00044	74 34		 je	 SHORT $LN28@Equal
$LN29@Equal:
  00046	8a 01		 mov	 al, BYTE PTR [ecx]
  00048	3a 06		 cmp	 al, BYTE PTR [esi]
  0004a	75 27		 jne	 SHORT $LN32@Equal
  0004c	83 fa fd	 cmp	 edx, -3			; fffffffdH
  0004f	74 29		 je	 SHORT $LN28@Equal
  00051	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00054	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00057	75 1a		 jne	 SHORT $LN32@Equal
  00059	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0005c	74 1c		 je	 SHORT $LN28@Equal
  0005e	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00061	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00064	75 0d		 jne	 SHORT $LN32@Equal
  00066	83 fa ff	 cmp	 edx, -1
  00069	74 0f		 je	 SHORT $LN28@Equal
  0006b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0006e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00071	74 07		 je	 SHORT $LN28@Equal
$LN32@Equal:
  00073	1b c0		 sbb	 eax, eax
  00075	83 c8 01	 or	 eax, 1
  00078	eb 02		 jmp	 SHORT $LN33@Equal
$LN28@Equal:
  0007a	33 c0		 xor	 eax, eax
$LN33@Equal:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0007c	85 c0		 test	 eax, eax
  0007e	75 08		 jne	 SHORT $LN21@Equal

; 3497 : 		}

  00080	5f		 pop	 edi

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00081	b0 01		 mov	 al, 1

; 3497 : 		}

  00083	5e		 pop	 esi
  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
$LN21@Equal:
  00088	5f		 pop	 edi

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00089	32 c0		 xor	 al, al

; 3497 : 		}

  0008b	5e		 pop	 esi
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T2 = 8							; size = 1
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 3096 : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3097 : 		auto& _My_data = this->_Get_data();
; 3098 : 		if (_My_data._Mysize > _Newcap)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcap$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f8		 cmp	 edi, eax
  0000f	77 74		 ja	 SHORT $LN5@reserve

; 3099 : 			{	// requested capacity is not large enough for current size, ignore
; 3100 : 			return;	// nothing to do
; 3101 : 			}
; 3102 : 
; 3103 : 		if (_My_data._Myres == _Newcap)

  00011	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00014	3b c8		 cmp	 ecx, eax
  00016	74 6d		 je	 SHORT $LN5@reserve

; 3104 : 			{	// we're already at the requested capacity
; 3105 : 			return;	// nothing to do
; 3106 : 			}
; 3107 : 
; 3108 : 		if (_My_data._Myres < _Newcap)

  00018	73 1a		 jae	 SHORT $LN4@reserve

; 3109 : 			{	// reallocate to grow
; 3110 : 			const size_type _Old_size = _My_data._Mysize;
; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  0001a	c6 45 08 00	 mov	 BYTE PTR $T2[ebp], 0
  0001e	2b c7		 sub	 eax, edi
  00020	ff 75 08	 push	 DWORD PTR $T2[ebp]
  00023	8b ce		 mov	 ecx, esi
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  0002b	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 3127 : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@reserve:

; 3117 : 			return;
; 3118 : 			}
; 3119 : 
; 3120 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  00034	83 f8 10	 cmp	 eax, 16			; 00000010H
  00037	73 4c		 jae	 SHORT $LN5@reserve

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00039	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3117 : 			return;
; 3118 : 			}
; 3119 : 
; 3120 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  0003c	72 47		 jb	 SHORT $LN5@reserve

; 3681 : 		const pointer _Ptr = _My_data._Bx._Ptr;

  0003e	53		 push	 ebx
  0003f	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 3682 : 		auto& _Al = this->_Getal();
; 3683 : 		_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3684 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00041	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00044	50		 push	 eax
  00045	53		 push	 ebx
  00046	56		 push	 esi
  00047	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3685 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0004c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3685 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00052	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00053	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00058	72 1a		 jb	 SHORT $LN47@reserve

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0005a	f6 c3 1f	 test	 bl, 31			; 0000001fH
  0005d	75 2c		 jne	 SHORT $_Invalid_parameter$63

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0005f	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00062	3b c3		 cmp	 eax, ebx
  00064	73 25		 jae	 SHORT $_Invalid_parameter$63

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00066	2b d8		 sub	 ebx, eax
  00068	83 fb 04	 cmp	 ebx, 4
  0006b	72 1e		 jb	 SHORT $_Invalid_parameter$63

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  0006d	83 fb 23	 cmp	 ebx, 35			; 00000023H
  00070	77 19		 ja	 SHORT $_Invalid_parameter$63

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00072	8b d8		 mov	 ebx, eax
$LN47@reserve:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00074	53		 push	 ebx
  00075	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007a	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3686 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0007d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00084	5b		 pop	 ebx
$LN5@reserve:

; 3127 : 		}

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
$_Invalid_parameter$63:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN62@reserve:
$LN61@reserve:
  00091	cc		 int	 3
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z PROC ; <lambda_67d87d4aa1269033985980465fd1d824>::operator(), COMDAT
; _this$dead$ = ecx

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00006	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00007	50		 push	 eax
  00008	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __New_ptr$[ebp]
  0000e	e8 00 00 00 00	 call	 _memcpy
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3114 : 				});

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z ENDP ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 3092 : 		return (this->_Get_data()._Myres);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 3093 : 		}

  00003	c3		 ret	 0
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00004	72 03		 jb	 SHORT $LN16@data

; 3045 : 		return (this->_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3046 : 		}

  00008	c3		 ret	 0
$LN16@data:

; 3045 : 		return (this->_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 3046 : 		}

  0000b	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z
_TEXT	SEGMENT
$T5 = -4						; size = 4
__Off$dead$ = 8						; size = 4
__Ptr_shifted_after$1$ = 12				; size = 4
$T4 = 12						; size = 1
__Right$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2481 : 		{	// insert _Right at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Right$[ebp]

; 2481 : 		{	// insert _Right at _Off

  00008	56		 push	 esi
  00009	89 4d fc	 mov	 DWORD PTR $T5[ebp], ecx

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0000c	8b f3		 mov	 esi, ebx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0000e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1607 : 		if (_Large_string_engaged())

  00012	72 02		 jb	 SHORT $LN10@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00014	8b 33		 mov	 esi, DWORD PTR [ebx]
$LN10@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2516 : 		if (_Count <= _My_data._Myres - _Old_size)

  00016	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1622 : 		if (_Mysize < _Off)

  00019	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]

; 2516 : 		if (_Count <= _My_data._Myres - _Old_size)

  0001c	2b c2		 sub	 eax, edx

; 2483 : 		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));

  0001e	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]

; 2516 : 		if (_Count <= _My_data._Myres - _Old_size)

  00021	3b d8		 cmp	 ebx, eax
  00023	77 77		 ja	 SHORT $LN17@insert

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00025	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2518 : 			_My_data._Mysize = _Old_size + _Count;

  00029	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  0002c	57		 push	 edi
  0002d	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00030	8b f9		 mov	 edi, ecx

; 1596 : 		if (_Large_string_engaged())

  00032	72 02		 jb	 SHORT $LN35@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00034	8b 39		 mov	 edi, DWORD PTR [ecx]
$LN35@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2524 : 			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)

  00036	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  00039	3b c7		 cmp	 eax, edi
  0003b	76 1d		 jbe	 SHORT $LN20@insert
  0003d	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00040	3b f0		 cmp	 esi, eax
  00042	77 16		 ja	 SHORT $LN20@insert

; 2527 : 				}
; 2528 : 			else if (_Insert_at <= _Ptr)

  00044	3b fe		 cmp	 edi, esi
  00046	77 09		 ja	 SHORT $LN21@insert

; 2529 : 				{	// all of [_Ptr, _Ptr + _Count) shifts
; 2530 : 				_Ptr_shifted_after = 0;

  00048	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR __Ptr_shifted_after$1$[ebp], 0

; 2531 : 				}
; 2532 : 			else

  0004f	eb 0c		 jmp	 SHORT $LN22@insert
$LN21@insert:

; 2533 : 				{	// [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
; 2534 : 				_Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  00051	8b c7		 mov	 eax, edi
  00053	2b c6		 sub	 eax, esi
  00055	89 45 0c	 mov	 DWORD PTR __Ptr_shifted_after$1$[ebp], eax
  00058	eb 03		 jmp	 SHORT $LN22@insert
$LN20@insert:

; 2525 : 				{	// inserted content is before the shifted region, or does not alias
; 2526 : 				_Ptr_shifted_after = _Count; // none of _Ptr's data shifts

  0005a	89 5d 0c	 mov	 DWORD PTR __Ptr_shifted_after$1$[ebp], ebx
$LN22@insert:

; 2537 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  0005d	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00060	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2537 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00061	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00064	57		 push	 edi
  00065	50		 push	 eax
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0006c	ff 75 0c	 push	 DWORD PTR __Ptr_shifted_after$1$[ebp]
  0006f	56		 push	 esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2539 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00076	8b 45 0c	 mov	 eax, DWORD PTR __Ptr_shifted_after$1$[ebp]
  00079	8b cb		 mov	 ecx, ebx
  0007b	2b c8		 sub	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0007d	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2539 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  0007e	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
  00081	03 ce		 add	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00083	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2539 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00084	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2483 : 		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));

  0008d	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00090	83 c4 24	 add	 esp, 36			; 00000024H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2483 : 		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));

  00093	5f		 pop	 edi

; 2484 : 		}

  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 08 00	 ret	 8
$LN17@insert:

; 2544 : 		return (_Reallocate_grow_by(_Count,

  0009c	53		 push	 ebx
  0009d	56		 push	 esi
  0009e	51		 push	 ecx
  0009f	c6 45 0c 00	 mov	 BYTE PTR $T4[ebp], 0
  000a3	ff 75 0c	 push	 DWORD PTR $T4[ebp]
  000a6	53		 push	 ebx
  000a7	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>

; 2484 : 		}

  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 08 00	 ret	 8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1649 : 			{	// user-provided, for fancy pointers
; 1650 : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Off$dead$ = 8						; size = 4
__Ptr$ = 12						; size = 4
$T2 = 16						; size = 1
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2512 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1622 : 		if (_Mysize < _Off)

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]

; 2512 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  00007	53		 push	 ebx

; 2513 : 		auto& _My_data = this->_Get_data();
; 2514 : 		_My_data._Check_offset(_Off);
; 2515 : 		const size_type _Old_size = _My_data._Mysize;
; 2516 : 		if (_Count <= _My_data._Myres - _Old_size)

  00008	8b 59 14	 mov	 ebx, DWORD PTR [ecx+20]
  0000b	8b c3		 mov	 eax, ebx
  0000d	57		 push	 edi
  0000e	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  00011	2b c2		 sub	 eax, edx
  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	3b f8		 cmp	 edi, eax
  00018	77 6f		 ja	 SHORT $LN2@insert

; 2517 : 			{
; 2518 : 			_My_data._Mysize = _Old_size + _Count;

  0001a	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  0001d	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00020	56		 push	 esi

; 1595 : 		value_type * _Result = _Bx._Buf;

  00021	8b f1		 mov	 esi, ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00023	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00026	72 02		 jb	 SHORT $LN20@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00028	8b 31		 mov	 esi, DWORD PTR [ecx]
$LN20@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2524 : 			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)

  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002d	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00030	3b c6		 cmp	 eax, esi
  00032	76 15		 jbe	 SHORT $LN5@insert
  00034	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00037	3b c8		 cmp	 ecx, eax
  00039	77 0e		 ja	 SHORT $LN5@insert

; 2527 : 				}
; 2528 : 			else if (_Insert_at <= _Ptr)

  0003b	3b f1		 cmp	 esi, ecx
  0003d	77 04		 ja	 SHORT $LN6@insert

; 2529 : 				{	// all of [_Ptr, _Ptr + _Count) shifts
; 2530 : 				_Ptr_shifted_after = 0;

  0003f	33 db		 xor	 ebx, ebx

; 2531 : 				}
; 2532 : 			else

  00041	eb 08		 jmp	 SHORT $LN7@insert
$LN6@insert:

; 2533 : 				{	// [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
; 2534 : 				_Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  00043	8b de		 mov	 ebx, esi
  00045	2b d9		 sub	 ebx, ecx
  00047	eb 02		 jmp	 SHORT $LN7@insert
$LN5@insert:

; 2525 : 				{	// inserted content is before the shifted region, or does not alias
; 2526 : 				_Ptr_shifted_after = _Count; // none of _Ptr's data shifts

  00049	8b df		 mov	 ebx, edi
$LN7@insert:

; 2537 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  0004b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0004e	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2537 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  0004f	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00052	56		 push	 esi
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0005a	53		 push	 ebx
  0005b	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2539 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00064	8b c7		 mov	 eax, edi
  00066	2b c3		 sub	 eax, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00068	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2539 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00069	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006c	03 c3		 add	 eax, ebx
  0006e	03 c7		 add	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00070	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2539 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00071	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2541 : 			return (*this);

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0007d	83 c4 24	 add	 esp, 36			; 00000024H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2541 : 			return (*this);

  00080	5e		 pop	 esi

; 2545 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2546 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {
; 2547 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2548 : 			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2550 : 			}, _Off, _Ptr, _Count));
; 2551 : 		}

  00081	5f		 pop	 edi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 0c 00	 ret	 12			; 0000000cH
$LN2@insert:

; 2542 : 			}
; 2543 : 
; 2544 : 		return (_Reallocate_grow_by(_Count,

  00089	57		 push	 edi
  0008a	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0008d	c6 45 10 00	 mov	 BYTE PTR $T2[ebp], 0
  00091	51		 push	 ecx
  00092	ff 75 10	 push	 DWORD PTR $T2[ebp]
  00095	57		 push	 edi
  00096	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>

; 2545 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2546 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {
; 2547 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2548 : 			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2550 : 			}, _Off, _Ptr, _Count));
; 2551 : 		}

  0009b	5f		 pop	 edi
  0009c	5b		 pop	 ebx
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBE@QADQBDII1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Off$dead$ = 20					; size = 4
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBE@QADQBDII1I@Z PROC ; <lambda_4d79bb85f269e6e8002a4599002d832c>::operator(), COMDAT
; _this$dead$ = ecx

; 2546 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00005	8b 7d 08	 mov	 edi, DWORD PTR __New_ptr$[ebp]
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 _memcpy
  00013	8b 75 1c	 mov	 esi, DWORD PTR __Count$[ebp]
  00016	56		 push	 esi
  00017	ff 75 18	 push	 DWORD PTR __Ptr$[ebp]
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00020	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00024	50		 push	 eax
  00025	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00028	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _memcpy
  00031	83 c4 24	 add	 esp, 36			; 00000024H
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2550 : 			}, _Off, _Ptr, _Count));

  00036	5d		 pop	 ebp
  00037	c2 18 00	 ret	 24			; 00000018H
??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBE@QADQBDII1I@Z ENDP ; <lambda_4d79bb85f269e6e8002a4599002d832c>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
$T4 = -60						; size = 8
__Ok$ = -52						; size = 8
__State$ = -44						; size = 4
$T43 = -40						; size = 1
__Ctype_fac$1$ = -36					; size = 4
__Istr$GSCopy$ = -32					; size = 4
__Result$1$ = -28					; size = 4
__Size$1$ = -24						; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 23   : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f2		 mov	 esi, edx
  0002d	8b f9		 mov	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 29   : 	ios_base::iostate _State = ios_base::goodbit;

  00031	33 db		 xor	 ebx, ebx
  00033	89 7d e0	 mov	 DWORD PTR __Istr$GSCopy$[ebp], edi
  00036	89 5d d4	 mov	 DWORD PTR __State$[ebp], ebx

; 30   : 	bool _Changed = false;

  00039	88 5d ef	 mov	 BYTE PTR __Changed$[ebp], bl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  0003c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 92   : 			: _Myistr(_Istr)

  0003f	89 7d cc	 mov	 DWORD PTR __Ok$[ebp], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00042	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  00046	85 c9		 test	 ecx, ecx
  00048	74 05		 je	 SHORT $LN25@operator

; 95   : 				_Myistr.rdbuf()->_Lock();

  0004a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004c	ff 50 04	 call	 DWORD PTR [eax+4]
$LN25@operator:

; 117  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0004f	6a 00		 push	 0
  00051	8b cf		 mov	 ecx, edi
  00053	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00060	88 45 d0	 mov	 BYTE PTR __Ok$[ebp+4], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 31   : 	const typename _Myis::sentry _Ok(_Istr);

  00063	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 32   : 
; 33   : 	if (_Ok)

  0006a	84 c0		 test	 al, al
  0006c	0f 84 45 01 00
	00		 je	 $LN19@operator

; 34   : 		{	// state okay, extract characters
; 35   : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00072	8d 45 c4	 lea	 eax, DWORD PTR $T4[ebp]
  00075	50		 push	 eax
  00076	8b 07		 mov	 eax, DWORD PTR [edi]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	03 cf		 add	 ecx, edi
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  00083	8b c8		 mov	 ecx, eax
  00085	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00089	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0008e	89 45 dc	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale

; 403  : 		{	// destroy the object

  00091	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 404  : 		if (_Ptr != 0)

  00095	8b 4d c8	 mov	 ecx, DWORD PTR $T4[ebp+4]
  00098	85 c9		 test	 ecx, ecx
  0009a	74 11		 je	 SHORT $LN36@operator

; 405  : 			delete _Ptr->_Decref();

  0009c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009e	ff 50 08	 call	 DWORD PTR [eax+8]
  000a1	8b c8		 mov	 ecx, eax
  000a3	85 c9		 test	 ecx, ecx
  000a5	74 06		 je	 SHORT $LN36@operator
  000a7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a9	6a 01		 push	 1
  000ab	ff 10		 call	 DWORD PTR [eax]
$LN36@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000ad	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1595 : 		value_type * _Result = _Bx._Buf;

  000b1	8b c6		 mov	 eax, esi

; 3692 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  000b3	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1596 : 		if (_Large_string_engaged())

  000ba	72 02		 jb	 SHORT $LN60@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000bc	8b 06		 mov	 eax, DWORD PTR [esi]
$LN60@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000be	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 38   : 		_TRY_IO_BEGIN

  000c1	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 422  : 		return (_Wide);

  000c5	8b 07		 mov	 eax, DWORD PTR [edi]
  000c7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 40   : 			&& (_Mysizt)_Istr.width() < _Str.max_size()

  000ca	83 7c 38 24 00	 cmp	 DWORD PTR [eax+edi+36], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 422  : 		return (_Wide);

  000cf	8b 5c 38 20	 mov	 ebx, DWORD PTR [eax+edi+32]
  000d3	89 5d e8	 mov	 DWORD PTR __Size$1$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 40   : 			&& (_Mysizt)_Istr.width() < _Str.max_size()

  000d6	7c 0e		 jl	 SHORT $LN13@operator
  000d8	7f 04		 jg	 SHORT $LN174@operator
  000da	85 db		 test	 ebx, ebx
  000dc	74 08		 je	 SHORT $LN13@operator
$LN174@operator:
  000de	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  000e4	72 08		 jb	 SHORT $LN98@operator
$LN13@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3070 : 		return (_Min_value(

  000e6	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  000eb	89 5d e8	 mov	 DWORD PTR __Size$1$[ebp], ebx
$LN98@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 42   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  000ee	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
$LN179@operator:
  000f8	8b d0		 mov	 edx, eax

; 44   : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  000fa	85 db		 test	 ebx, ebx
  000fc	0f 84 8a 00 00
	00		 je	 $LN177@operator

; 45   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00102	83 fa ff	 cmp	 edx, -1
  00105	75 08		 jne	 SHORT $LN7@operator

; 46   : 				{	// end of file, quit
; 47   : 				_State |= ios_base::eofbit;

  00107	8d 58 02	 lea	 ebx, DWORD PTR [eax+2]

; 48   : 				break;

  0010a	e9 a1 00 00 00	 jmp	 $LN3@operator
$LN7@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale

; 2344 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

  0010f	8b 45 dc	 mov	 eax, DWORD PTR __Ctype_fac$1$[ebp]
  00112	0f b6 ca	 movzx	 ecx, dl
  00115	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00118	f6 04 48 48	 test	 BYTE PTR [eax+ecx*2], 72 ; 00000048H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 50   : 			else if (_Ctype_fac.is(_Ctype::space,

  0011c	75 6e		 jne	 SHORT $LN177@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  0011e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00121	8b c1		 mov	 eax, ecx
  00123	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00126	2b c3		 sub	 eax, ebx
  00128	83 f8 01	 cmp	 eax, 1
  0012b	72 2d		 jb	 SHORT $LN137@operator

; 1595 : 		value_type * _Result = _Bx._Buf;

  0012d	89 75 e4	 mov	 DWORD PTR __Result$1$[ebp], esi

; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  00130	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00133	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00136	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  00139	72 05		 jb	 SHORT $LN146@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0013b	8b 06		 mov	 eax, DWORD PTR [esi]
  0013d	89 45 e4	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN146@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00140	0f be ca	 movsx	 ecx, dl
  00143	0f b6 c1	 movzx	 eax, cl
  00146	66 c1 e1 08	 shl	 cx, 8
  0014a	66 0b c8	 or	 cx, ax
  0014d	8b 45 e4	 mov	 eax, DWORD PTR __Result$1$[ebp]
  00150	88 0c 18	 mov	 BYTE PTR [eax+ebx], cl

; 517  : 		_Left = _Right;

  00153	c6 44 18 01 00	 mov	 BYTE PTR [eax+ebx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2384 : 			return (*this);

  00158	eb 13		 jmp	 SHORT $LN136@operator
$LN137@operator:

; 2385 : 			}
; 2386 : 
; 2387 : 		return (_Reallocate_grow_by(_Count,

  0015a	52		 push	 edx
  0015b	6a 01		 push	 1
  0015d	c6 45 d8 00	 mov	 BYTE PTR $T43[ebp], 0
  00161	8b ce		 mov	 ecx, esi
  00163	ff 75 d8	 push	 DWORD PTR $T43[ebp]
  00166	6a 01		 push	 1
  00168	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN136@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  0016d	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 44   : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  0016f	8b 5d e8	 mov	 ebx, DWORD PTR __Size$1$[ebp]
  00172	4b		 dec	 ebx

; 51   : 				_Traits::to_char_type(_Meta)))
; 52   : 				break;	// whitespace, quit
; 53   : 			else
; 54   : 				{	// add character to string
; 55   : 				_Str.append(1, _Traits::to_char_type(_Meta));
; 56   : 				_Changed = true;

  00173	c6 45 ef 01	 mov	 BYTE PTR __Changed$[ebp], 1
  00177	89 5d e8	 mov	 DWORD PTR __Size$1$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  0017a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 44   : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  0017d	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00187	e9 6c ff ff ff	 jmp	 $LN179@operator
$LN177@operator:
  0018c	33 db		 xor	 ebx, ebx
  0018e	eb 20		 jmp	 SHORT $LN3@operator
__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:

; 57   : 				}
; 58   : 		_CATCH_IO_(_Istr)

  00190	8b 55 e0	 mov	 edx, DWORD PTR __Istr$GSCopy$[ebp]
  00193	6a 01		 push	 1
  00195	6a 04		 push	 4
  00197	8b 02		 mov	 eax, DWORD PTR [edx]
  00199	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0019c	03 ca		 add	 ecx, edx
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001a4	b8 00 00 00 00	 mov	 eax, $LN20@operator
  001a9	c3		 ret	 0
$LN20@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
  001aa	8b 5d d4	 mov	 ebx, DWORD PTR __State$[ebp]
  001ad	8b 7d e0	 mov	 edi, DWORD PTR __Istr$GSCopy$[ebp]
$LN3@operator:
  001b0	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN19@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 62   : 	if (!_Changed)

  001b7	80 7d ef 00	 cmp	 BYTE PTR __Changed$[ebp], 0
  001bb	8b 07		 mov	 eax, DWORD PTR [edi]
  001bd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  001c0	c7 44 38 20 00
	00 00 00	 mov	 DWORD PTR [eax+edi+32], 0
  001c8	c7 44 38 24 00
	00 00 00	 mov	 DWORD PTR [eax+edi+36], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 62   : 	if (!_Changed)

  001d0	75 03		 jne	 SHORT $LN11@operator

; 63   : 		_State |= ios_base::failbit;

  001d2	83 cb 02	 or	 ebx, 2
$LN11@operator:

; 64   : 	_Istr.setstate(_State);

  001d5	8b 07		 mov	 eax, DWORD PTR [edi]
  001d7	6a 00		 push	 0
  001d9	53		 push	 ebx
  001da	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001dd	03 cf		 add	 ecx, edi
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 99   : 			{	// destroy after unlocking

  001e5	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6

; 100  : 			if (_Myistr.rdbuf() != 0)

  001ec	8b 45 cc	 mov	 eax, DWORD PTR __Ok$[ebp]
  001ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  001f4	8b 4c 01 38	 mov	 ecx, DWORD PTR [ecx+eax+56]
  001f8	85 c9		 test	 ecx, ecx
  001fa	74 05		 je	 SHORT $LN175@operator

; 101  : 				_Myistr.rdbuf()->_Unlock();

  001fc	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fe	ff 52 08	 call	 DWORD PTR [edx+8]
$LN175@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 65   : 	return (_Istr);

  00201	8b c7		 mov	 eax, edi

; 66   : 	}

  00203	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00206	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0020d	59		 pop	 ecx
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	5b		 pop	 ebx
  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$4:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3:
  00010	8d 4d c4	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > &>, COMDAT
; __Arg$ = ecx

; 1607 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1608 : 	}

  00002	c3		 ret	 0
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@ABEHAAVrandom_device@1@HH@Z
_TEXT	SEGMENT
__Umin$1$ = -4						; size = 4
__Eng$dead$ = 8						; size = 4
__Index$1$ = 12						; size = 4
__Min$ = 12						; size = 4
tv379 = 16						; size = 4
__Max$ = 16						; size = 4
??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@ABEHAAVrandom_device@1@HH@Z PROC ; std::uniform_int<int>::_Eval<std::random_device>, COMDAT
; _this$dead$ = ecx

; 2352 : 		{	// compute next value in range [_Min, _Max]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2353 : 		_Rng_from_urng<_Uty, _Engine> _Rng(_Eng);
; 2354 : 
; 2355 : 		const _Uty _Umin = _Adjust(_Uty(_Min));
; 2356 : 		const _Uty _Umax = _Adjust(_Uty(_Max));
; 2357 : 
; 2358 : 		_Uty _Uret = 0;
; 2359 : 
; 2360 : 		if (_Umax - _Umin == _Uty(-1))

  00004	8b 55 10	 mov	 edx, DWORD PTR __Max$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 0c	 mov	 ebx, DWORD PTR __Min$[ebp]
  0000b	81 c3 00 00 00
	80		 add	 ebx, -2147483648	; 80000000H
  00011	2b d3		 sub	 edx, ebx
  00013	89 5d fc	 mov	 DWORD PTR __Umin$1$[ebp], ebx
  00016	81 c2 00 00 00
	80		 add	 edx, -2147483648	; 80000000H
  0001c	89 55 10	 mov	 DWORD PTR tv379[ebp], edx
  0001f	56		 push	 esi
  00020	83 fa ff	 cmp	 edx, -1
  00023	75 20		 jne	 SHORT $LN2@Eval
  00025	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?_Random_device@std@@YAIXZ
  0002b	0f 1f 44 00 00	 npad	 5
$LL32@Eval:

; 6442 : 		return (_Random_device());

  00030	ff d6		 call	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  00032	32 c9		 xor	 cl, cl
  00034	75 fa		 jne	 SHORT $LL32@Eval
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2366 : 		}

  00036	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  0003b	5e		 pop	 esi
  0003c	03 c3		 add	 eax, ebx
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Eval:

; 2361 : 			_Uret = static_cast<_Uty>(_Rng._Get_all_bits());
; 2362 : 		else
; 2363 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  00045	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
  00048	57		 push	 edi
  00049	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?_Random_device@std@@YAIXZ
  0004f	89 5d 0c	 mov	 DWORD PTR __Index$1$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3502 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00052	eb 03		 jmp	 SHORT $LN42@Eval
$LL90@Eval:
  00054	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
$LN42@Eval:

; 3487 : 			_Udiff _Ret = 0;	// random bits

  00057	33 c9		 xor	 ecx, ecx

; 3488 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00059	33 c0		 xor	 eax, eax

; 3489 : 
; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  0005b	85 d2		 test	 edx, edx
  0005d	74 10		 je	 SHORT $LN46@Eval
  0005f	90		 npad	 1
$LL51@Eval:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  00060	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3530 : 			_Udiff _Val = _Ref() - (_Urng::min)();

  00062	8b c8		 mov	 ecx, eax

; 3532 : 			if (_Val <= _Bmask)

  00064	32 c0		 xor	 al, al
  00066	75 f8		 jne	 SHORT $LL51@Eval

; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  00068	83 c8 ff	 or	 eax, -1
  0006b	32 d2		 xor	 dl, dl
  0006d	75 f1		 jne	 SHORT $LL51@Eval
$LN46@Eval:

; 3502 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  0006f	33 d2		 xor	 edx, edx
  00071	f7 f3		 div	 ebx
  00073	8b f0		 mov	 esi, eax
  00075	8b da		 mov	 ebx, edx
  00077	33 d2		 xor	 edx, edx
  00079	8b c1		 mov	 eax, ecx
  0007b	f7 75 0c	 div	 DWORD PTR __Index$1$[ebp]
  0007e	3b c6		 cmp	 eax, esi
  00080	72 07		 jb	 SHORT $LN76@Eval
  00082	8b 55 10	 mov	 edx, DWORD PTR tv379[ebp]
  00085	3b da		 cmp	 ebx, edx
  00087	75 cb		 jne	 SHORT $LL90@Eval
$LN76@Eval:

; 3503 : 				return (_Ret % _Index);

  00089	33 d2		 xor	 edx, edx
  0008b	8b c1		 mov	 eax, ecx
  0008d	f7 75 0c	 div	 DWORD PTR __Index$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2365 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  00090	8b 45 fc	 mov	 eax, DWORD PTR __Umin$1$[ebp]
  00093	5f		 pop	 edi
  00094	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H

; 2366 : 		}

  00099	5e		 pop	 esi
  0009a	03 c2		 add	 eax, edx
  0009c	5b		 pop	 ebx
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 0c 00	 ret	 12			; 0000000cH
??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@ABEHAAVrandom_device@1@HH@Z ENDP ; std::uniform_int<int>::_Eval<std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
__Ok$ = -44						; size = 8
__State$ = -36						; size = 4
$T30 = -32						; size = 1
tv747 = -28						; size = 4
__Istr$GSCopy$ = -24					; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Delim$ = 8						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 75   : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f2		 mov	 esi, edx
  0002d	8b f9		 mov	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 79   : 	bool _Changed = false;

  00031	32 db		 xor	 bl, bl
  00033	89 7d e8	 mov	 DWORD PTR __Istr$GSCopy$[ebp], edi
  00036	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0
  0003d	88 5d ef	 mov	 BYTE PTR __Changed$[ebp], bl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 92   : 			: _Myistr(_Istr)

  00043	89 7d d4	 mov	 DWORD PTR __Ok$[ebp], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00046	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  0004a	85 c9		 test	 ecx, ecx
  0004c	74 05		 je	 SHORT $LN24@getline

; 95   : 				_Myistr.rdbuf()->_Lock();

  0004e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00050	ff 50 04	 call	 DWORD PTR [eax+4]
$LN24@getline:

; 117  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00053	6a 01		 push	 1
  00055	8b cf		 mov	 ecx, edi
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00064	88 45 d8	 mov	 BYTE PTR __Ok$[ebp+4], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 80   : 	const typename _Myis::sentry _Ok(_Istr, true);

  00067	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 81   : 
; 82   : 	if (_Ok)

  0006e	84 c0		 test	 al, al
  00070	0f 84 e6 00 00
	00		 je	 $LN154@getline

; 83   : 		{	// state okay, extract characters
; 84   : 		_TRY_IO_BEGIN

  00076	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  0007a	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0007c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 3692 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00080	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1596 : 		if (_Large_string_engaged())

  00087	72 02		 jb	 SHORT $LN53@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00089	8b 06		 mov	 eax, DWORD PTR [esi]
$LN53@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0008b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 537  : 		return ((unsigned char)_Ch);

  0008e	0f b6 45 08	 movzx	 eax, BYTE PTR __Delim$[ebp]
  00092	89 45 e4	 mov	 DWORD PTR tv747[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00095	8b 07		 mov	 eax, DWORD PTR [edi]
  00097	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 88   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  0009a	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
$LN156@getline:
  000a4	8b d0		 mov	 edx, eax

; 91   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000a6	83 fa ff	 cmp	 edx, -1
  000a9	75 08		 jne	 SHORT $LN7@getline

; 92   : 				{	// end of file, quit
; 93   : 				_State |= ios_base::eofbit;

  000ab	8d 42 02	 lea	 eax, DWORD PTR [edx+2]

; 94   : 				break;

  000ae	e9 9c 00 00 00	 jmp	 $LN3@getline
$LN7@getline:

; 95   : 				}
; 96   : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  000b3	3b 55 e4	 cmp	 edx, DWORD PTR tv747[ebp]
  000b6	75 18		 jne	 SHORT $LN9@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  000b8	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 98   : 				_Changed = true;

  000ba	b3 01		 mov	 bl, 1
  000bc	88 5d ef	 mov	 BYTE PTR __Changed$[ebp], bl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  000bf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 99   : 				_Istr.rdbuf()->sbumpc();

  000c2	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ

; 100  : 				break;

  000cc	33 c0		 xor	 eax, eax
  000ce	eb 7f		 jmp	 SHORT $LN3@getline
$LN9@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3062 : 		return (this->_Get_data()._Mysize);

  000d0	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]

; 3070 : 		return (_Min_value(

  000d3	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 102  : 			else if (_Str.max_size() <= _Str.size())

  000d8	3b c1		 cmp	 eax, ecx
  000da	77 07		 ja	 SHORT $LN11@getline

; 103  : 				{	// string too large, quit
; 104  : 				_State |= ios_base::failbit;

  000dc	b8 02 00 00 00	 mov	 eax, 2
  000e1	eb 6c		 jmp	 SHORT $LN3@getline
$LN11@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2992 : 		if (_Old_size < _My_data._Myres)

  000e3	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  000e6	3b cb		 cmp	 ecx, ebx
  000e8	73 19		 jae	 SHORT $LN117@getline

; 2993 : 			{
; 2994 : 			_My_data._Mysize = _Old_size + 1;

  000ea	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000ed	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1595 : 		value_type * _Result = _Bx._Buf;

  000f0	8b c6		 mov	 eax, esi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000f2	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1596 : 		if (_Large_string_engaged())

  000f5	72 02		 jb	 SHORT $LN126@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000f7	8b 06		 mov	 eax, DWORD PTR [esi]
$LN126@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000f9	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  000fc	c6 44 08 01 00	 mov	 BYTE PTR [eax+ecx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2998 : 			return;

  00101	eb 10		 jmp	 SHORT $LN116@getline
$LN117@getline:

; 2999 : 			}
; 3000 : 
; 3001 : 		_Reallocate_grow_by(1,

  00103	52		 push	 edx
  00104	c6 45 e0 00	 mov	 BYTE PTR $T30[ebp], 0
  00108	ff 75 e0	 push	 DWORD PTR $T30[ebp]
  0010b	51		 push	 ecx
  0010c	8b ce		 mov	 ecx, esi
  0010e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN116@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00113	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 110  : 				_Changed = true;

  00115	b3 01		 mov	 bl, 1
  00117	88 5d ef	 mov	 BYTE PTR __Changed$[ebp], bl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  0011a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 90   : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  0011d	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00127	e9 78 ff ff ff	 jmp	 $LN156@getline
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:

; 111  : 				}
; 112  : 		_CATCH_IO_(_Istr)

  0012c	8b 55 e8	 mov	 edx, DWORD PTR __Istr$GSCopy$[ebp]
  0012f	6a 01		 push	 1
  00131	6a 04		 push	 4
  00133	8b 02		 mov	 eax, DWORD PTR [edx]
  00135	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00138	03 ca		 add	 ecx, edx
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00140	b8 00 00 00 00	 mov	 eax, $LN19@getline
  00145	c3		 ret	 0
$LN19@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
  00146	8b 45 dc	 mov	 eax, DWORD PTR __State$[ebp]
  00149	8a 5d ef	 mov	 bl, BYTE PTR __Changed$[ebp]
  0014c	8b 7d e8	 mov	 edi, DWORD PTR __Istr$GSCopy$[ebp]
$LN3@getline:
  0014f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 113  : 		}
; 114  : 
; 115  : 	if (!_Changed)

  00156	84 db		 test	 bl, bl
  00158	75 07		 jne	 SHORT $LN13@getline

; 81   : 
; 82   : 	if (_Ok)

  0015a	eb 02		 jmp	 SHORT $LN152@getline
$LN154@getline:
  0015c	33 c0		 xor	 eax, eax
$LN152@getline:

; 116  : 		_State |= ios_base::failbit;

  0015e	83 c8 02	 or	 eax, 2
$LN13@getline:

; 117  : 	_Istr.setstate(_State);

  00161	6a 00		 push	 0
  00163	50		 push	 eax
  00164	8b 07		 mov	 eax, DWORD PTR [edi]
  00166	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00169	03 cf		 add	 ecx, edi
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 99   : 			{	// destroy after unlocking

  00171	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 100  : 			if (_Myistr.rdbuf() != 0)

  00178	8b 45 d4	 mov	 eax, DWORD PTR __Ok$[ebp]
  0017b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00180	8b 4c 01 38	 mov	 ecx, DWORD PTR [ecx+eax+56]
  00184	85 c9		 test	 ecx, ecx
  00186	74 05		 je	 SHORT $LN153@getline

; 101  : 				_Myistr.rdbuf()->_Unlock();

  00188	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018a	ff 52 08	 call	 DWORD PTR [edx+8]
$LN153@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 118  : 	return (_Istr);

  0018d	8b c7		 mov	 eax, edi

; 119  : 	}

  0018f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00192	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00199	59		 pop	 ecx
  0019a	5f		 pop	 edi
  0019b	5e		 pop	 esi
  0019c	5b		 pop	 ebx
  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
_TEXT	SEGMENT
__Ok$ = -40						; size = 8
__Data$1$ = -32						; size = 4
$T19 = -32						; size = 1
$T13 = -28						; size = 1
__State$ = -24						; size = 4
__Ostr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Size$ = 8						; size = 4
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned int>, COMDAT
; __Ostr$ = ecx
; __Data$ = edx

; 24   : 	{	// insert a character-type sequence into _Ostr as if through a basic_string copy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	89 55 e0	 mov	 DWORD PTR __Data$1$[ebp], edx
  0002e	8b d9		 mov	 ebx, ecx
  00030	89 5d ec	 mov	 DWORD PTR __Ostr$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 422  : 		return (_Wide);

  00033	8b 03		 mov	 eax, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 25   : 	ios_base::iostate _State = ios_base::goodbit;

  00035	33 ff		 xor	 edi, edi
  00037	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 422  : 		return (_Wide);

  0003a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003d	8b 74 19 20	 mov	 esi, DWORD PTR [ecx+ebx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 26   : 	_SizeT _Pad = _Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size

  00041	39 7c 19 24	 cmp	 DWORD PTR [ecx+ebx+36], edi
  00045	7c 11		 jl	 SHORT $LN17@Insert_str
  00047	7f 04		 jg	 SHORT $LN107@Insert_str
  00049	85 f6		 test	 esi, esi
  0004b	74 0b		 je	 SHORT $LN17@Insert_str
$LN107@Insert_str:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __Size$[ebp]
  00050	3b f0		 cmp	 esi, eax
  00052	76 04		 jbe	 SHORT $LN17@Insert_str
  00054	2b f0		 sub	 esi, eax
  00056	eb 02		 jmp	 SHORT $LN18@Insert_str
$LN17@Insert_str:
  00058	33 f6		 xor	 esi, esi
$LN18@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  0005a	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 98   : 			: _Myostr(_Ostr)

  0005e	89 5d d8	 mov	 DWORD PTR __Ok$[ebp], ebx

; 99   : 			{	// lock the stream buffer, if there
; 100  : 			if (_Myostr.rdbuf() != 0)

  00061	85 c9		 test	 ecx, ecx
  00063	74 05		 je	 SHORT $LN35@Insert_str

; 101  : 				_Myostr.rdbuf()->_Lock();

  00065	8b 01		 mov	 eax, DWORD PTR [ecx]
  00067	ff 50 04	 call	 DWORD PTR [eax+4]
$LN35@Insert_str:

; 121  : 			: _Sentry_base(_Ostr)

  0006a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 314  : 		return (_Mystate);

  00071	8b 03		 mov	 eax, DWORD PTR [ebx]
  00073	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 338  : 		return (rdstate() == goodbit);

  00076	83 7c 18 0c 00	 cmp	 DWORD PTR [eax+ebx+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0007b	75 12		 jne	 SHORT $LN31@Insert_str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 79   : 		return (_Tiestr);

  0007d	8b 4c 18 3c	 mov	 ecx, DWORD PTR [eax+ebx+60]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00081	85 c9		 test	 ecx, ecx
  00083	74 0a		 je	 SHORT $LN31@Insert_str
  00085	3b cb		 cmp	 ecx, ebx
  00087	74 06		 je	 SHORT $LN31@Insert_str

; 124  : 				_Ostr.tie()->flush();

  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN31@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 314  : 		return (_Mystate);

  0008f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00091	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 338  : 		return (rdstate() == goodbit);

  00094	83 7c 19 0c 00	 cmp	 DWORD PTR [ecx+ebx+12], 0
  00099	0f 94 c0	 sete	 al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 125  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  0009c	88 45 dc	 mov	 BYTE PTR __Ok$[ebp+4], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 28   : 	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

  0009f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 29   : 
; 30   : 	if (!_Ok)

  000a6	84 c0		 test	 al, al
  000a8	75 0a		 jne	 SHORT $LN8@Insert_str

; 31   : 		_State |= ios_base::badbit;

  000aa	bf 04 00 00 00	 mov	 edi, 4

; 32   : 	else

  000af	e9 d9 00 00 00	 jmp	 $LN22@Insert_str
$LN8@Insert_str:

; 33   : 		{	// state okay, insert characters
; 34   : 		_TRY_IO_BEGIN

  000b4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 377  : 		return (_Fmtfl);

  000b8	8b 44 19 14	 mov	 eax, DWORD PTR [ecx+ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 35   : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000bc	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000c1	83 f8 40	 cmp	 eax, 64			; 00000040H
  000c4	74 33		 je	 SHORT $LN103@Insert_str
$LL4@Insert_str:

; 36   : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000c6	85 f6		 test	 esi, esi
  000c8	74 2b		 je	 SHORT $LN3@Insert_str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 112  : 		return (_Fillch);

  000ca	8b 03		 mov	 eax, DWORD PTR [ebx]
  000cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cf	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 37   : 				if (_Traits::eq_int_type(_Traits::eof(),

  000d3	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 112  : 		return (_Fillch);

  000d7	88 45 e4	 mov	 BYTE PTR $T13[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 37   : 				if (_Traits::eq_int_type(_Traits::eof(),

  000da	ff 75 e4	 push	 DWORD PTR $T13[ebp]
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  000e3	83 f8 ff	 cmp	 eax, -1
  000e6	75 0a		 jne	 SHORT $LN2@Insert_str

; 38   : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 39   : 					{	// insertion failed, quit
; 40   : 					_State |= ios_base::badbit;

  000e8	bf 04 00 00 00	 mov	 edi, 4
  000ed	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi

; 41   : 					break;

  000f0	eb 2e		 jmp	 SHORT $LL109@Insert_str
$LN2@Insert_str:

; 36   : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000f2	4e		 dec	 esi
  000f3	eb d1		 jmp	 SHORT $LL4@Insert_str
$LN3@Insert_str:

; 45   : 			&& _Ostr.rdbuf()->sputn(_Data, (streamsize)_Size)

  000f5	85 ff		 test	 edi, edi
  000f7	75 27		 jne	 SHORT $LL109@Insert_str
$LN103@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  000f9	8b 03		 mov	 eax, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 45   : 			&& _Ostr.rdbuf()->sputn(_Data, (streamsize)_Size)

  000fb	6a 00		 push	 0
  000fd	ff 75 08	 push	 DWORD PTR __Size$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00100	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 45   : 			&& _Ostr.rdbuf()->sputn(_Data, (streamsize)_Size)

  00103	ff 75 e0	 push	 DWORD PTR __Data$1$[ebp]
  00106	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  00110	3b 45 08	 cmp	 eax, DWORD PTR __Size$[ebp]
  00113	75 35		 jne	 SHORT $LN108@Insert_str
  00115	85 d2		 test	 edx, edx
  00117	75 31		 jne	 SHORT $LN108@Insert_str
  00119	0f 1f 80 00 00
	00 00		 npad	 7
$LL109@Insert_str:

; 48   : 		else
; 49   : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00120	85 f6		 test	 esi, esi
  00122	74 2b		 je	 SHORT $LN6@Insert_str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 112  : 		return (_Fillch);

  00124	8b 03		 mov	 eax, DWORD PTR [ebx]
  00126	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00129	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 50   : 				if (_Traits::eq_int_type(_Traits::eof(),

  0012d	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 112  : 		return (_Fillch);

  00131	88 45 e0	 mov	 BYTE PTR $T19[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 50   : 				if (_Traits::eq_int_type(_Traits::eof(),

  00134	ff 75 e0	 push	 DWORD PTR $T19[ebp]
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0013d	83 f8 ff	 cmp	 eax, -1
  00140	75 05		 jne	 SHORT $LN5@Insert_str

; 51   : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 52   : 					{	// insertion failed, quit
; 53   : 					_State |= ios_base::badbit;

  00142	83 cf 04	 or	 edi, 4

; 54   : 					break;

  00145	eb 08		 jmp	 SHORT $LN6@Insert_str
$LN5@Insert_str:

; 48   : 		else
; 49   : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00147	4e		 dec	 esi
  00148	eb d6		 jmp	 SHORT $LL109@Insert_str
$LN108@Insert_str:

; 46   : 				!= (streamsize)_Size)
; 47   : 				_State |= ios_base::badbit;

  0014a	bf 04 00 00 00	 mov	 edi, 4
$LN6@Insert_str:

; 55   : 					}
; 56   : 		_Ostr.width(0);

  0014f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00151	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  00154	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  0015c	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
  00164	eb 20		 jmp	 SHORT $LN115@Insert_str
__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0:

; 57   : 		_CATCH_IO_(_Ostr)

  00166	8b 55 ec	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00169	6a 01		 push	 1
  0016b	6a 04		 push	 4
  0016d	8b 02		 mov	 eax, DWORD PTR [edx]
  0016f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00172	03 ca		 add	 ecx, edx
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0017a	b8 00 00 00 00	 mov	 eax, $LN23@Insert_str
  0017f	c3		 ret	 0
$LN23@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
  00180	8b 5d ec	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  00183	8b 7d e8	 mov	 edi, DWORD PTR __State$[ebp]
$LN115@Insert_str:
  00186	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN22@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 58   : 		}
; 59   : 
; 60   : 	_Ostr.setstate(_State);

  0018d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0018f	6a 00		 push	 0
  00191	57		 push	 edi
  00192	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00195	03 cb		 add	 ecx, ebx
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 129  : 			{	// destroy the object

  0019d	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 130  :  #if _HAS_EXCEPTIONS
; 131  : 			if (!_STD uncaught_exception())

  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 132  : 				this->_Myostr._Osfx();

  001aa	8b 75 d8	 mov	 esi, DWORD PTR __Ok$[ebp]
  001ad	84 c0		 test	 al, al
  001af	75 08		 jne	 SHORT $LN84@Insert_str
  001b1	8b ce		 mov	 ecx, esi
  001b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN84@Insert_str:

; 105  : 			{	// destroy after unlocking

  001b9	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5

; 106  : 			if (_Myostr.rdbuf() != 0)

  001bd	8b 06		 mov	 eax, DWORD PTR [esi]
  001bf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c2	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  001c6	85 c9		 test	 ecx, ecx
  001c8	74 05		 je	 SHORT $LN110@Insert_str

; 107  : 				_Myostr.rdbuf()->_Unlock();

  001ca	8b 01		 mov	 eax, DWORD PTR [ecx]
  001cc	ff 50 08	 call	 DWORD PTR [eax+8]
$LN110@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 61   : 	return (_Ostr);

  001cf	8b c3		 mov	 eax, ebx

; 62   : 	}

  001d1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001db	59		 pop	 ecx
  001dc	5f		 pop	 edi
  001dd	5e		 pop	 esi
  001de	5b		 pop	 ebx
  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT
; __Arg$ = ecx

; 1592 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1593 : 	}

  00002	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1576 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 313  : 		}

  00007	8b c1		 mov	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1577 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 313  : 		}

  00010	c2 08 00	 ret	 8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1042 : 	_Left = _STD move(_Right);
; 1043 : 	}

  00000	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1029 : 	}

  00000	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT
; __Arg$ = ecx

; 1592 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1593 : 	}

  00002	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT
; __Arg$ = ecx

; 1592 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1593 : 	}

  00002	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1576 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 313  : 		}

  00007	8b c1		 mov	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1577 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 313  : 		}

  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Right_size$ = 12					; size = 4
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z PROC ; std::_Traits_equal<std::char_traits<char> >, COMDAT
; __Left$ = ecx
; __Left_size$ = edx

; 24   : 	{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00003	3b 55 0c	 cmp	 edx, DWORD PTR __Right_size$[ebp]
  00006	75 5e		 jne	 SHORT $LN3@Traits_equ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  0000c	83 ea 04	 sub	 edx, 4
  0000f	72 11		 jb	 SHORT $LN10@Traits_equ
$LL11@Traits_equ:
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	3b 06		 cmp	 eax, DWORD PTR [esi]
  00015	75 10		 jne	 SHORT $LN9@Traits_equ
  00017	83 c1 04	 add	 ecx, 4
  0001a	83 c6 04	 add	 esi, 4
  0001d	83 ea 04	 sub	 edx, 4
  00020	73 ef		 jae	 SHORT $LL11@Traits_equ
$LN10@Traits_equ:
  00022	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00025	74 34		 je	 SHORT $LN8@Traits_equ
$LN9@Traits_equ:
  00027	8a 01		 mov	 al, BYTE PTR [ecx]
  00029	3a 06		 cmp	 al, BYTE PTR [esi]
  0002b	75 27		 jne	 SHORT $LN12@Traits_equ
  0002d	83 fa fd	 cmp	 edx, -3			; fffffffdH
  00030	74 29		 je	 SHORT $LN8@Traits_equ
  00032	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00035	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00038	75 1a		 jne	 SHORT $LN12@Traits_equ
  0003a	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0003d	74 1c		 je	 SHORT $LN8@Traits_equ
  0003f	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00042	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00045	75 0d		 jne	 SHORT $LN12@Traits_equ
  00047	83 fa ff	 cmp	 edx, -1
  0004a	74 0f		 je	 SHORT $LN8@Traits_equ
  0004c	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0004f	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00052	74 07		 je	 SHORT $LN8@Traits_equ
$LN12@Traits_equ:
  00054	1b c0		 sbb	 eax, eax
  00056	83 c8 01	 or	 eax, 1
  00059	eb 02		 jmp	 SHORT $LN13@Traits_equ
$LN8@Traits_equ:
  0005b	33 c0		 xor	 eax, eax
$LN13@Traits_equ:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0005d	5e		 pop	 esi
  0005e	85 c0		 test	 eax, eax
  00060	75 04		 jne	 SHORT $LN3@Traits_equ
  00062	b0 01		 mov	 al, 1

; 26   : 	}

  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN3@Traits_equ:

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00066	32 c0		 xor	 al, al

; 26   : 	}

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z ENDP ; std::_Traits_equal<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z
_TEXT	SEGMENT
__New_size$1$ = -12					; size = 4
__Old$1$ = -8						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >, COMDAT
; _this$ = ecx

; 3641 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 3642 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3643 : 		auto& _My_data = this->_Get_data();
; 3644 : 		const size_type _Old_size = _My_data._Mysize;
; 3645 : 		if (max_size() - _Old_size < _Size_increase)

  0000a	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  0000f	8b c1		 mov	 eax, ecx
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR __Size_increase$[ebp]
  00015	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00018	2b c2		 sub	 eax, edx
  0001a	89 55 fc	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  0001d	3b c7		 cmp	 eax, edi
  0001f	0f 82 03 01 00
	00		 jb	 $LN131@Reallocate

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  00025	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00028	8d 1c 3a	 lea	 ebx, DWORD PTR [edx+edi]
  0002b	89 5d f4	 mov	 DWORD PTR __New_size$1$[ebp], ebx

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0002e	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  00031	89 45 f8	 mov	 DWORD PTR __Old$1$[ebp], eax

; 3592 : 		if (_Masked > _Max)

  00034	3b d9		 cmp	 ebx, ecx
  00036	76 04		 jbe	 SHORT $LN34@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);

  00038	8b d9		 mov	 ebx, ecx
  0003a	eb 18		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  0003c	8b f8		 mov	 edi, eax
  0003e	d1 ef		 shr	 edi, 1
  00040	2b cf		 sub	 ecx, edi
  00042	3b c1		 cmp	 eax, ecx
  00044	76 07		 jbe	 SHORT $LN35@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);

  00046	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0004b	eb 07		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0004d	03 c7		 add	 eax, edi
  0004f	3b d8		 cmp	 ebx, eax
  00051	0f 42 d8	 cmovb	 ebx, eax
$LN33@Reallocate:

; 3652 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3653 : 		auto& _Al = this->_Getal();
; 3654 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00054	33 c9		 xor	 ecx, ecx
  00056	8b c3		 mov	 eax, ebx
  00058	83 c0 01	 add	 eax, 1
  0005b	0f 92 c1	 setb	 cl
  0005e	f7 d9		 neg	 ecx
  00060	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  00062	75 04		 jne	 SHORT $LN76@Reallocate

; 53   : 		{
; 54   : 		return (_Ptr);

  00064	33 ff		 xor	 edi, edi
  00066	eb 41		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00068	32 c0		 xor	 al, al
  0006a	74 06		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN133@Reallocate:
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00072	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00078	72 21		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0007a	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  0007d	3b c1		 cmp	 eax, ecx
  0007f	77 06		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN134@Reallocate:
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0008d	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00090	8d 78 23	 lea	 edi, DWORD PTR [eax+35]
  00093	83 e7 e0	 and	 edi, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00096	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  00099	eb 0b		 jmp	 SHORT $LN129@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000a1	83 c4 04	 add	 esp, 4

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);

  000a4	8b f8		 mov	 edi, eax
$LN129@Reallocate:
  000a6	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000a9	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000ad	8b 45 f4	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  000b0	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000b3	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  000b6	72 55		 jb	 SHORT $LN3@Reallocate

; 3660 : 			{
; 3661 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000b8	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  000ba	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000bd	50		 push	 eax
  000be	53		 push	 ebx
  000bf	57		 push	 edi
  000c0	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000c5	8b 45 f8	 mov	 eax, DWORD PTR __Old$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000cb	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000cc	32 c9		 xor	 cl, cl
  000ce	75 37		 jne	 SHORT $_Invalid_parameter$137

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000d0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000d5	72 1a		 jb	 SHORT $LN102@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000d7	f6 c3 1f	 test	 bl, 31			; 0000001fH
  000da	75 2b		 jne	 SHORT $_Invalid_parameter$137

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000dc	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000df	3b c3		 cmp	 eax, ebx
  000e1	73 24		 jae	 SHORT $_Invalid_parameter$137

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000e3	2b d8		 sub	 ebx, eax
  000e5	83 fb 04	 cmp	 ebx, 4
  000e8	72 1d		 jb	 SHORT $_Invalid_parameter$137

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  000ea	83 fb 23	 cmp	 ebx, 35			; 00000023H
  000ed	77 18		 ja	 SHORT $_Invalid_parameter$137

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000ef	8b d8		 mov	 ebx, eax
$LN102@Reallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  000f1	53		 push	 ebx
  000f2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f7	83 c4 04	 add	 esp, 4

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000fa	89 3e		 mov	 DWORD PTR [esi], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  000fc	8b c6		 mov	 eax, esi
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx

; 3673 : 		}

  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 08 00	 ret	 8
$_Invalid_parameter$137:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN135@Reallocate:
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  0010d	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00110	51		 push	 ecx
  00111	56		 push	 esi
  00112	57		 push	 edi
  00113	e8 00 00 00 00	 call	 _memcpy
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0011b	89 3e		 mov	 DWORD PTR [esi], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  0011d	8b c6		 mov	 eax, esi
  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi
  00121	5b		 pop	 ebx

; 3673 : 		}

  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 08 00	 ret	 8
$LN131@Reallocate:

; 3646 : 			{
; 3647 : 			_Xlen();	// result too long

  00128	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN136@Reallocate:
$LN128@Reallocate:
  0012d	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -20					; size = 4
__New_size$1$ = -16					; size = 4
__Old_size$1$ = -12					; size = 4
_<_Args_1>$GSCopy$1$ = -8				; size = 4
__Old$1$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 3641 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	89 45 f8	 mov	 DWORD PTR _<_Args_1>$GSCopy$1$[ebp], eax

; 3642 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3643 : 		auto& _My_data = this->_Get_data();
; 3644 : 		const size_type _Old_size = _My_data._Mysize;
; 3645 : 		if (max_size() - _Old_size < _Size_increase)

  0000f	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00014	89 5d ec	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  00017	8b c1		 mov	 eax, ecx
  00019	56		 push	 esi
  0001a	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001d	2b c2		 sub	 eax, edx
  0001f	8b 75 08	 mov	 esi, DWORD PTR __Size_increase$[ebp]
  00022	89 55 f4	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  00025	57		 push	 edi
  00026	3b c6		 cmp	 eax, esi
  00028	0f 82 21 01 00
	00		 jb	 $LN142@Reallocate

; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  0002e	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
  00031	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00034	8b f0		 mov	 esi, eax

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;

  00036	89 45 f0	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00039	83 ce 0f	 or	 esi, 15			; 0000000fH

; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  0003c	89 7d fc	 mov	 DWORD PTR __Old$1$[ebp], edi

; 3592 : 		if (_Masked > _Max)

  0003f	3b f1		 cmp	 esi, ecx
  00041	76 04		 jbe	 SHORT $LN34@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);

  00043	8b f1		 mov	 esi, ecx
  00045	eb 18		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  00047	8b c7		 mov	 eax, edi
  00049	d1 e8		 shr	 eax, 1
  0004b	2b c8		 sub	 ecx, eax
  0004d	3b f9		 cmp	 edi, ecx
  0004f	76 07		 jbe	 SHORT $LN35@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);

  00051	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00056	eb 07		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00058	03 c7		 add	 eax, edi
  0005a	3b f0		 cmp	 esi, eax
  0005c	0f 42 f0	 cmovb	 esi, eax
$LN33@Reallocate:

; 3652 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3653 : 		auto& _Al = this->_Getal();
; 3654 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0005f	33 c9		 xor	 ecx, ecx
  00061	8b c6		 mov	 eax, esi
  00063	83 c0 01	 add	 eax, 1
  00066	0f 92 c1	 setb	 cl
  00069	f7 d9		 neg	 ecx
  0006b	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  0006d	75 04		 jne	 SHORT $LN76@Reallocate

; 53   : 		{
; 54   : 		return (_Ptr);

  0006f	33 ff		 xor	 edi, edi
  00071	eb 3e		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00073	32 c0		 xor	 al, al
  00075	74 06		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN144@Reallocate:
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0007d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00083	72 21		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00085	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00088	3b c1		 cmp	 eax, ecx
  0008a	77 06		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN145@Reallocate:
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00098	83 c4 04	 add	 esp, 4

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0009b	8d 78 23	 lea	 edi, DWORD PTR [eax+35]
  0009e	83 e7 e0	 and	 edi, -32		; ffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000a1	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  000a4	eb 0b		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ac	83 c4 04	 add	 esp, 4

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);

  000af	8b f8		 mov	 edi, eax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000b1	83 7d fc 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000b5	8b 45 f0	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  000b8	89 73 14	 mov	 DWORD PTR [ebx+20], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000bb	8b 75 18	 mov	 esi, DWORD PTR _<_Args_2>$[ebp]
  000be	56		 push	 esi
  000bf	ff 75 f8	 push	 DWORD PTR _<_Args_1>$GSCopy$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3656 : 		_My_data._Mysize = _New_size;

  000c2	89 43 10	 mov	 DWORD PTR [ebx+16], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000c5	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000c6	72 63		 jb	 SHORT $LN3@Reallocate

; 3660 : 			{
; 3661 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000c8	8b 1b		 mov	 ebx, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000ca	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000d2	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000d5	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  000d6	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000d9	53		 push	 ebx
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000e0	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000e3	83 c4 18	 add	 esp, 24			; 00000018H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000e6	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000e7	32 c9		 xor	 cl, cl
  000e9	75 3a		 jne	 SHORT $_Invalid_parameter$148

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000eb	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000f0	72 1a		 jb	 SHORT $LN108@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000f2	f6 c3 1f	 test	 bl, 31			; 0000001fH
  000f5	75 2e		 jne	 SHORT $_Invalid_parameter$148

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000f7	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000fa	3b c3		 cmp	 eax, ebx
  000fc	73 27		 jae	 SHORT $_Invalid_parameter$148

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000fe	2b d8		 sub	 ebx, eax
  00100	83 fb 04	 cmp	 ebx, 4
  00103	72 20		 jb	 SHORT $_Invalid_parameter$148

; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)

  00105	83 fb 23	 cmp	 ebx, 35			; 00000023H
  00108	77 1b		 ja	 SHORT $_Invalid_parameter$148

; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0010a	8b d8		 mov	 ebx, eax
$LN108@Reallocate:

; 151  : 	::operator delete(_Ptr);

  0010c	53		 push	 ebx
  0010d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3664 : 			_My_data._Bx._Ptr = _New_ptr;

  00112	8b 5d ec	 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 151  : 	::operator delete(_Ptr);

  00115	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  00118	8b c3		 mov	 eax, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0011a	89 3b		 mov	 DWORD PTR [ebx], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx

; 3673 : 		}

  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c2 14 00	 ret	 20			; 00000014H
$_Invalid_parameter$148:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN146@Reallocate:
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0012b	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00130	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  00133	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00134	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00135	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00138	53		 push	 ebx
  00139	51		 push	 ecx
  0013a	e8 00 00 00 00	 call	 _memcpy
  0013f	83 c4 18	 add	 esp, 24			; 00000018H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00142	89 3b		 mov	 DWORD PTR [ebx], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  00144	8b c3		 mov	 eax, ebx
  00146	5f		 pop	 edi
  00147	5e		 pop	 esi
  00148	5b		 pop	 ebx

; 3673 : 		}

  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 14 00	 ret	 20			; 00000014H
$LN142@Reallocate:

; 3646 : 			{
; 3647 : 			_Xlen();	// result too long

  0014f	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN147@Reallocate:
$LN140@Reallocate:
  00154	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 99   : 			{	// destroy after unlocking

  00022	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 100  : 			if (_Myistr.rdbuf() != 0)

  00029	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00030	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  00034	85 c9		 test	 ecx, ecx
  00036	74 05		 je	 SHORT $LN4@sentry

; 101  : 				_Myistr.rdbuf()->_Unlock();

  00038	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003a	ff 50 08	 call	 DWORD PTR [eax+8]
$LN4@sentry:
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEIXZ
_TEXT	SEGMENT
__Num$1$ = -4						; size = 4
?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEIXZ PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits, COMDAT
; _this$ = ecx

; 3508 : 		{	// return a random value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3509 : 		_Udiff _Ret = 0;
; 3510 : 
; 3511 : 		for (size_t _Num = 0; _Num < CHAR_BIT * sizeof (_Udiff);

  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?_Random_device@std@@YAIXZ
  0000b	56		 push	 esi
  0000c	33 f6		 xor	 esi, esi
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	89 75 fc	 mov	 DWORD PTR __Num$1$[ebp], esi
$LL4@Get_all_bi:

; 3513 : 			{	// don't mask away any bits
; 3514 : 			_Ret <<= _Bits - 1;	// avoid full shift

  00014	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00017	49		 dec	 ecx
  00018	d3 e6		 shl	 esi, cl

; 3515 : 			_Ret <<= 1;

  0001a	03 f6		 add	 esi, esi
  0001c	0f 1f 40 00	 npad	 4
$LL7@Get_all_bi:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  00020	ff d3		 call	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  00022	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00025	77 f9		 ja	 SHORT $LL7@Get_all_bi

; 3512 : 			_Num += _Bits)

  00027	0b f0		 or	 esi, eax
  00029	8b 45 fc	 mov	 eax, DWORD PTR __Num$1$[ebp]
  0002c	03 47 04	 add	 eax, DWORD PTR [edi+4]
  0002f	89 45 fc	 mov	 DWORD PTR __Num$1$[ebp], eax
  00032	83 f8 20	 cmp	 eax, 32			; 00000020H
  00035	72 dd		 jb	 SHORT $LL4@Get_all_bi

; 3516 : 			_Ret |= _Get_bits();
; 3517 : 			}
; 3518 : 
; 3519 : 		return (_Ret);

  00037	5f		 pop	 edi
  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 3520 : 		}

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEII@Z
_TEXT	SEGMENT
__Index$ = 8						; size = 4
??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEII@Z PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::operator(), COMDAT
; _this$ = ecx

; 3484 : 		{	// adapt _Urng closed range to [0, _Index)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Index$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	48		 dec	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Index$[ebp]
  0000f	90		 npad	 1
$LL2@operator:

; 3485 : 		for (; ; )
; 3486 : 			{	// try a sample random value
; 3487 : 			_Udiff _Ret = 0;	// random bits

  00010	33 f6		 xor	 esi, esi

; 3488 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00012	33 db		 xor	 ebx, ebx

; 3489 : 
; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  00014	85 c0		 test	 eax, eax
  00016	74 2d		 je	 SHORT $LN6@operator
$LL5@operator:

; 3491 : 				{	// need more random bits
; 3492 : 				_Ret <<= _Bits - 1;	// avoid full shift

  00018	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001b	49		 dec	 ecx
  0001c	d3 e6		 shl	 esi, cl

; 3493 : 				_Ret <<= 1;

  0001e	03 f6		 add	 esi, esi
$LL11@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3530 : 			_Udiff _Val = _Ref() - (_Urng::min)();

  00026	8b c8		 mov	 ecx, eax

; 3531 : 
; 3532 : 			if (_Val <= _Bmask)

  00028	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0002b	3b c8		 cmp	 ecx, eax
  0002d	77 f1		 ja	 SHORT $LL11@operator

; 3494 : 				_Ret |= _Get_bits();
; 3495 : 				_Mask <<= _Bits - 1;	// avoid full shift

  0002f	0b f1		 or	 esi, ecx
  00031	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00034	49		 dec	 ecx
  00035	d3 e3		 shl	 ebx, cl
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Index$[ebp]

; 3496 : 				_Mask <<= 1;

  0003a	03 db		 add	 ebx, ebx

; 3497 : 				_Mask |= _Bmask;

  0003c	0b d8		 or	 ebx, eax
  0003e	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00041	3b d8		 cmp	 ebx, eax
  00043	72 d3		 jb	 SHORT $LL5@operator
$LN6@operator:

; 3498 : 				}
; 3499 : 
; 3500 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3501 : 			if (_Ret / _Index < _Mask / _Index
; 3502 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00045	33 d2		 xor	 edx, edx
  00047	8b c3		 mov	 eax, ebx
  00049	f7 f1		 div	 ecx
  0004b	8b c8		 mov	 ecx, eax
  0004d	8b da		 mov	 ebx, edx
  0004f	33 d2		 xor	 edx, edx
  00051	8b c6		 mov	 eax, esi
  00053	f7 75 08	 div	 DWORD PTR __Index$[ebp]
  00056	3b c1		 cmp	 eax, ecx
  00058	8b 4d 08	 mov	 ecx, DWORD PTR __Index$[ebp]
  0005b	72 07		 jb	 SHORT $LN25@operator
  0005d	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00060	3b d8		 cmp	 ebx, eax
  00062	75 ac		 jne	 SHORT $LL2@operator
$LN25@operator:

; 3503 : 				return (_Ret % _Index);

  00064	8b c6		 mov	 eax, esi
  00066	33 d2		 xor	 edx, edx
  00068	f7 f1		 div	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	8b c2		 mov	 eax, edx
  0006e	5b		 pop	 ebx

; 3504 : 			}
; 3505 : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEII@Z ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QAE@AAVrandom_device@1@@Z
_TEXT	SEGMENT
__Func$ = 8						; size = 4
??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QAE@AAVrandom_device@1@@Z PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>, COMDAT
; _this$ = ecx

; 3478 : 		{	// construct from URNG

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3477 : 		: _Ref(_Func), _Bits(CHAR_BIT * sizeof (_Udiff)), _Bmask(_Udiff(-1))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Func$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 3479 : 		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
; 3480 : 			--_Bits;
; 3481 : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	c7 41 04 20 00
	00 00		 mov	 DWORD PTR [ecx+4], 32	; 00000020H
  00011	c7 41 08 ff ff
	ff ff		 mov	 DWORD PTR [ecx+8], -1
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QAE@AAVrandom_device@1@@Z ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAII@Z
_TEXT	SEGMENT
?_Adjust@?$uniform_int@H@std@@CAII@Z PROC		; std::uniform_int<int>::_Adjust, COMDAT
; __Uval$ = ecx

; 2370 : 		return (_Adjust(_Uval, is_signed<_Ty>()));

  00000	8d 81 00 00 00
	80		 lea	 eax, DWORD PTR [ecx-2147483648]

; 2371 : 		}

  00006	c3		 ret	 0
?_Adjust@?$uniform_int@H@std@@CAII@Z ENDP		; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 122  : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 123  : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 116  : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 92   : 			: _Myistr(_Istr)

  00029	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0002c	89 16		 mov	 DWORD PTR [esi], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00033	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  00037	85 c9		 test	 ecx, ecx
  00039	74 05		 je	 SHORT $LN5@sentry

; 95   : 				_Myistr.rdbuf()->_Lock();

  0003b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003d	ff 50 04	 call	 DWORD PTR [eax+4]
$LN5@sentry:

; 117  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00040	ff 75 0c	 push	 DWORD PTR __Noskip$[ebp]
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00052	88 46 04	 mov	 BYTE PTR [esi+4], al

; 118  : 			}

  00055	8b c6		 mov	 eax, esi
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 100  : 			if (_Myistr.rdbuf() != 0)

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 101  : 				_Myistr.rdbuf()->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 102  : 			}

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 3692 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00004	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1596 : 		if (_Large_string_engaged())

  0000b	72 0a		 jb	 SHORT $LN31@erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2610 : 		return (*this);

  00012	8b c1		 mov	 eax, ecx

; 2611 : 		}

  00014	c2 04 00	 ret	 4
$LN31@erase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00017	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2610 : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 2611 : 		}

  0001c	c2 04 00	 ret	 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AAEIXZ
_TEXT	SEGMENT
?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AAEIXZ PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits, COMDAT
; _this$ = ecx

; 3527 : 		{	// return a random value within [0, _Bmask]

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?_Random_device@std@@YAIXZ
  00008	8b f1		 mov	 esi, ecx
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL2@Get_bits:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  00010	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  00012	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00015	77 f9		 ja	 SHORT $LL2@Get_bits

; 3533 : 				return (_Val);

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi

; 3534 : 			}
; 3535 : 		}

  00019	c3		 ret	 0
?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AAEIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z PROC ; std::uniform_int<int>::_Adjust, COMDAT
; __Uval$ = ecx

; 2375 : 		const _Uty _Adjuster = (_Uty(-1) >> 1) + 1;	// 2^(N-1)
; 2376 : 
; 2377 : 		if (_Uval < _Adjuster)
; 2378 : 			return (_Uval + _Adjuster);

  00000	8d 81 00 00 00
	80		 lea	 eax, DWORD PTR [ecx-2147483648]

; 2379 : 		else
; 2380 : 			return (_Uval - _Adjuster);
; 2381 : 		}

  00006	c3		 ret	 0
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ENDP ; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 93   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 			: _Myistr(_Istr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]

; 93   : 			{	// lock the stream buffer, if there

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 94   : 			if (_Myistr.rdbuf() != 0)

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN8@Sentry_bas

; 95   : 				_Myistr.rdbuf()->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 96   : 			}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
END
