; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	f:\users\krzysztof\documents\szko?a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_07NMCGPECH@Agata_1?$AA@			; `string'
PUBLIC	??_C@_07PHALKHOE@Agata_2?$AA@			; `string'
PUBLIC	??_C@_07OOBAJGKF@Agata_3?$AA@			; `string'
PUBLIC	??_C@_07KBFBAAGC@Agata_4?$AA@			; `string'
PUBLIC	??_C@_07LIEKDBCD@Agata_5?$AA@			; `string'
PUBLIC	??_C@_05HIHNAHAF@Ewa_1?$AA@			; `string'
PUBLIC	??_C@_05FDFAFEMG@Ewa_2?$AA@			; `string'
PUBLIC	??_C@_05EKELGFIH@Ewa_3?$AA@			; `string'
PUBLIC	??_C@_05FAKPDEA@Ewa_4?$AA@			; `string'
PUBLIC	??_C@_05BMBBMCAB@Ewa_5?$AA@			; `string'
PUBLIC	??_C@_06DNEKEHMO@Ewa2_1?$AA@			; `string'
PUBLIC	??_C@_06BGGHBEAN@Ewa2_2?$AA@			; `string'
PUBLIC	??_C@_06PHMCFEM@Ewa2_3?$AA@			; `string'
PUBLIC	??_C@_06EADNLDIL@Ewa2_4?$AA@			; `string'
PUBLIC	??_C@_06FJCGICMK@Ewa2_5?$AA@			; `string'
PUBLIC	??_C@_07JNGJCCBG@Jacek_1?$AA@			; `string'
PUBLIC	??_C@_07LGEEHBNF@Jacek_2?$AA@			; `string'
PUBLIC	??_C@_07KPFPEAJE@Jacek_3?$AA@			; `string'
PUBLIC	??_C@_07OABONGFD@Jacek_4?$AA@			; `string'
PUBLIC	??_C@_07PJAFOHBC@Jacek_5?$AA@			; `string'
PUBLIC	??_C@_08LJBBBCDF@Jacek2_1?$AA@			; `string'
PUBLIC	??_C@_08JCDMEBPG@Jacek2_2?$AA@			; `string'
PUBLIC	??_C@_08ILCHHALH@Jacek2_3?$AA@			; `string'
PUBLIC	??_C@_08MEGGOGHA@Jacek2_4?$AA@			; `string'
PUBLIC	??_C@_08NNHNNHDB@Jacek2_5?$AA@			; `string'
PUBLIC	??_C@_05DOOIMHKE@Jan_1?$AA@			; `string'
PUBLIC	??_C@_05BFMFJEGH@Jan_2?$AA@			; `string'
PUBLIC	??_C@_05MNOKFCG@Jan_3?$AA@			; `string'
PUBLIC	??_C@_05EDJPDDOB@Jan_4?$AA@			; `string'
PUBLIC	??_C@_05FKIEACKA@Jan_5?$AA@			; `string'
PUBLIC	??_C@_06JMNNEBHA@Jan2_1?$AA@			; `string'
PUBLIC	??_C@_06LHPABCLD@Jan2_2?$AA@			; `string'
PUBLIC	??_C@_06KOOLCDPC@Jan2_3?$AA@			; `string'
PUBLIC	??_C@_06OBKKLFDF@Jan2_4?$AA@			; `string'
PUBLIC	??_C@_06PILBIEHE@Jan2_5?$AA@			; `string'
PUBLIC	??_C@_06HFECHJHC@Maja_1?$AA@			; `string'
PUBLIC	??_C@_06FOGPCKLB@Maja_2?$AA@			; `string'
PUBLIC	??_C@_06EHHEBLPA@Maja_3?$AA@			; `string'
PUBLIC	??_C@_06IDFINDH@Maja_4?$AA@			; `string'
PUBLIC	??_C@_06BBCOLMHG@Maja_5?$AA@			; `string'
PUBLIC	??_C@_07PDCGJMCP@Maja2_1?$AA@			; `string'
PUBLIC	??_C@_07NIALMPOM@Maja2_2?$AA@			; `string'
PUBLIC	??_C@_07MBBAPOKN@Maja2_3?$AA@			; `string'
PUBLIC	??_C@_07IOFBGIGK@Maja2_4?$AA@			; `string'
PUBLIC	??_C@_07JHEKFJCL@Maja2_5?$AA@			; `string'
PUBLIC	??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@		; `string'
PUBLIC	??_C@_05PDJBBECF@pause?$AA@			; `string'
PUBLIC	??_C@_0DL@POFCNLON@Jak?$LJ?5opcje?5chcesz?5obstawi?f?$DP?5?$CIzgo@ ; `string'
PUBLIC	??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@		; `string'
PUBLIC	??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@	; `string'
PUBLIC	??_C@_0BD@LEDAOJLK@r?5?9?5czerwone?5?$CIred?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BD@EPLAAEJB@b?5?9?5czarne?5?$CIblack?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@ ; `string'
PUBLIC	??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@	; `string'
PUBLIC	??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@ ; `string'
PUBLIC	??_C@_0CK@OAIPJBPB@w1?0?5w2?0?5?4?4?4?5?0?5w12?5?9?5wiersz?5trzec@ ; `string'
PUBLIC	??_C@_0CN@CGIAAFPM@0?936?5?9?5pojedy?qcze?5pole?5o?5odpowie@ ; `string'
PUBLIC	??_C@_01JBBJJEPG@p?$AA@				; `string'
PUBLIC	??_C@_01EFFIKLCJ@n?$AA@				; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_01OJONOECF@b?$AA@				; `string'
PUBLIC	??_C@_01JEJKBAGA@g?$AA@				; `string'
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	??_C@_02ICGBAFJO@k1?$AA@			; `string'
PUBLIC	??_C@_02KJEMFGFN@k2?$AA@			; `string'
PUBLIC	??_C@_02LAFHGHBM@k3?$AA@			; `string'
PUBLIC	??_C@_02JHFNFPIK@w1?$AA@			; `string'
PUBLIC	??_C@_02LMHAAMEJ@w2?$AA@			; `string'
PUBLIC	??_C@_02KFGLDNAI@w3?$AA@			; `string'
PUBLIC	??_C@_02OKCKKLMP@w4?$AA@			; `string'
PUBLIC	??_C@_02PDDBJKIO@w5?$AA@			; `string'
PUBLIC	??_C@_02NIBMMJEN@w6?$AA@			; `string'
PUBLIC	??_C@_02MBAHPIAM@w7?$AA@			; `string'
PUBLIC	??_C@_02EGJPOEMD@w8?$AA@			; `string'
PUBLIC	??_C@_02FPIENFIC@w9?$AA@			; `string'
PUBLIC	??_C@_03NCLMABJC@w10?$AA@			; `string'
PUBLIC	??_C@_03MLKHDAND@w11?$AA@			; `string'
PUBLIC	??_C@_03OAIKGDBA@w12?$AA@			; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_01FDFGLJHB@2?$AA@				; `string'
PUBLIC	??_C@_01EKENIIDA@3?$AA@				; `string'
PUBLIC	??_C@_01FAMBOPH@4?$AA@				; `string'
PUBLIC	??_C@_01BMBHCPLG@5?$AA@				; `string'
PUBLIC	??_C@_01DHDKHMHF@6?$AA@				; `string'
PUBLIC	??_C@_01COCBENDE@7?$AA@				; `string'
PUBLIC	??_C@_01KJLJFBPL@8?$AA@				; `string'
PUBLIC	??_C@_01LAKCGALK@9?$AA@				; `string'
PUBLIC	??_C@_02PKFBJPLJ@10?$AA@			; `string'
PUBLIC	??_C@_02ODEKKOPI@11?$AA@			; `string'
PUBLIC	??_C@_02MIGHPNDL@12?$AA@			; `string'
PUBLIC	??_C@_02NBHMMMHK@13?$AA@			; `string'
PUBLIC	??_C@_02JODNFKLN@14?$AA@			; `string'
PUBLIC	??_C@_02IHCGGLPM@15?$AA@			; `string'
PUBLIC	??_C@_02KMALDIDP@16?$AA@			; `string'
PUBLIC	??_C@_02LFBAAJHO@17?$AA@			; `string'
PUBLIC	??_C@_02DCIIBFLB@18?$AA@			; `string'
PUBLIC	??_C@_02CLJDCEPA@19?$AA@			; `string'
PUBLIC	??_C@_02PIBHCBOA@20?$AA@			; `string'
PUBLIC	??_C@_02OBAMBAKB@21?$AA@			; `string'
PUBLIC	??_C@_02MKCBEDGC@22?$AA@			; `string'
PUBLIC	??_C@_02NDDKHCCD@23?$AA@			; `string'
PUBLIC	??_C@_02JMHLOEOE@24?$AA@			; `string'
PUBLIC	??_C@_02IFGANFKF@25?$AA@			; `string'
PUBLIC	??_C@_02KOENIGGG@26?$AA@			; `string'
PUBLIC	??_C@_02LHFGLHCH@27?$AA@			; `string'
PUBLIC	??_C@_02DAMOKLOI@28?$AA@			; `string'
PUBLIC	??_C@_02CJNFJKKJ@29?$AA@			; `string'
PUBLIC	??_C@_02PJNFELNH@30?$AA@			; `string'
PUBLIC	??_C@_02OAMOHKJG@31?$AA@			; `string'
PUBLIC	??_C@_02MLODCJFF@32?$AA@			; `string'
PUBLIC	??_C@_02NCPIBIBE@33?$AA@			; `string'
PUBLIC	??_C@_02JNLJIOND@34?$AA@			; `string'
PUBLIC	??_C@_02IEKCLPJC@35?$AA@			; `string'
PUBLIC	??_C@_02KPIPOMFB@36?$AA@			; `string'
PUBLIC	??_C@_0CF@MANFGHNE@$?0?5jak?$LJ?5kwot?$LJ?5chcesz?5obstawi?f?5wy@ ; `string'
PUBLIC	??_C@_05OMMBNPEF@Masz?5?$AA@			; `string'
PUBLIC	??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@ ; `string'
PUBLIC	??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@ ; `string'
PUBLIC	??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@ ; `string'
PUBLIC	??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@ ; `string'
PUBLIC	??_C@_02MGHEPNFN@?$AI?$AI?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@	; `string'
PUBLIC	??_C@_02KHOJGJKF@?4?5?$AA@			; `string'
PUBLIC	??_C@_02DEPNMBPN@$?4?$AA@			; `string'
PUBLIC	??_C@_0CB@GINPHDN@Obstawi?$LDe?$JM?5poprawnie?0?5wygrywasz?5@ ; `string'
PUBLIC	??_C@_0EF@MDKBMGPE@Obstawi?$LDe?$JM?5niepoprawnie?5lecz?5uda@ ; `string'
PUBLIC	??_C@_0CF@BAJKLKHM@Obstawi?$LDe?$JM?5niepoprawnie?0?5przegra@ ; `string'
PUBLIC	??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@ ; `string'
PUBLIC	??_C@_0CO@DOCNGCMI@$?0?5czy?5chcesz?5grac?5dalej?5?$CI?8t?8?9ta@ ; `string'
PUBLIC	??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@	; `string'
PUBLIC	??_C@_01PFHFFBPC@t?$AA@				; `string'
PUBLIC	??_C@_03PFPKAEFD@tak?$AA@			; `string'
PUBLIC	??_C@_03FFMIKLGN@Tak?$AA@			; `string'
PUBLIC	??_C@_03PIABMJCP@TAK?$AA@			; `string'
PUBLIC	??_C@_03FKMOMPJO@nie?$AA@			; `string'
PUBLIC	??_C@_03PKPMGAKA@Nie?$AA@			; `string'
PUBLIC	??_C@_03FHDFACOC@NIE?$AA@			; `string'
PUBLIC	??_C@_04IBLEHOMF@?4wav?$AA@			; `string'
PUBLIC	??_C@_05PNHGCFLK@p?4wav?$AA@			; `string'
PUBLIC	??_C@_05MEKKEGFB@n?4wav?$AA@			; `string'
PUBLIC	??_C@_05LALOIELB@r?4wav?$AA@			; `string'
PUBLIC	??_C@_05LDGIIGCK@b?4wav?$AA@			; `string'
PUBLIC	??_C@_05ODKFBHJJ@g?4wav?$AA@			; `string'
PUBLIC	??_C@_05GFDBGFDH@d?4wav?$AA@			; `string'
PUBLIC	??_C@_01DICPFPGM@k?$AA@				; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@	; `string'
PUBLIC	??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@ ; `string'
PUBLIC	??_C@_09LFKNBKJA@Posiadasz?$AA@			; `string'
PUBLIC	??_C@_0L@DAFLKCID@Wylosowano?$AA@		; `string'
PUBLIC	??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@		; `string'
PUBLIC	??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@	; `string'
PUBLIC	??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@		; `string'
PUBLIC	??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@	; `string'
PUBLIC	??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@	; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@ ; `string'
PUBLIC	??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@	; `string'
PUBLIC	??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@ ; `string'
PUBLIC	??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ ; `string'
PUBLIC	??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@ ; `string'
PUBLIC	??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@ ; `string'
PUBLIC	??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@ ; `string'
PUBLIC	??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@ ; `string'
PUBLIC	??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@ ; `string'
PUBLIC	??_C@_05CMOJBPHN@G?$LDos?1?$AA@			; `string'
PUBLIC	??_C@_05KFCKMKOB@Jacek?$AA@			; `string'
PUBLIC	??_C@_03FPCJKMNP@Ewa?$AA@			; `string'
PUBLIC	??_C@_04CDICBAGM@Maja?$AA@			; `string'
PUBLIC	??_C@_03JIHJHPIE@Jan?$AA@			; `string'
PUBLIC	??_C@_06DKNIKMFF@Jacek2?$AA@			; `string'
PUBLIC	??_C@_04PLEDLCJI@Ewa2?$AA@			; `string'
PUBLIC	??_C@_05KJFHPLBC@Maja2?$AA@			; `string'
PUBLIC	??_C@_04HDNGKDH@Jan2?$AA@			; `string'
PUBLIC	??_C@_05NKPCGME@Agata?$AA@			; `string'
PUBLIC	??_C@_01IDAFKMJL@_?$AA@				; `string'
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_04JLFAMLOH@G?$LDos?$AA@			; `string'
PUBLIC	??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ ; `string'
PUBLIC	??_C@_04NCAGELPD@?4rar?$AA@			; `string'
PUBLIC	??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@ ; `string'
PUBLIC	??_C@_07KIPBKJCE@win?4wav?$AA@			; `string'
PUBLIC	??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@ ; `string'
PUBLIC	??_C@_0M@COFBHHKL@setting?4txt?$AA@		; `string'
PUBLIC	??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@ ; `string'
PUBLIC	??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ ; `string'
PUBLIC	??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@ ; `string'
PUBLIC	??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@ ; `string'
PUBLIC	??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@ ; `string'
PUBLIC	??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@ ; `string'
PUBLIC	??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@	; `string'
PUBLIC	??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@	; `string'
PUBLIC	??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@ ; `string'
PUBLIC	??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@ ; `string'
PUBLIC	??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@	; `string'
PUBLIC	??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@ ; `string'
PUBLIC	??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@ ; `string'
PUBLIC	??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@ ; `string'
PUBLIC	??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@ ; `string'
PUBLIC	??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@ ; `string'
PUBLIC	??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@ ; `string'
PUBLIC	??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@ ; `string'
PUBLIC	??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@ ; `string'
PUBLIC	??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@ ; `string'
PUBLIC	??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@ ; `string'
PUBLIC	??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@ ; `string'
PUBLIC	??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@ ; `string'
PUBLIC	??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@ ; `string'
PUBLIC	??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ ; `string'
PUBLIC	??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ ; `string'
PUBLIC	??_C@_01EPMOAMKG@$?$AA@				; `string'
PUBLIC	??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@		; `string'
PUBLIC	??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@		; `string'
PUBLIC	??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@ ; `string'
PUBLIC	??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@		; `string'
PUBLIC	??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@ ; `string'
PUBLIC	??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@ ; `string'
PUBLIC	??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@ ; `string'
PUBLIC	??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@ ; `string'
PUBLIC	??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@		; `string'
PUBLIC	??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@	; `string'
PUBLIC	??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@	; `string'
PUBLIC	??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@ ; `string'
PUBLIC	??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@		; `string'
PUBLIC	??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@ ; `string'
PUBLIC	??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ ; `string'
PUBLIC	??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@ ; `string'
PUBLIC	??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@ ; `string'
PUBLIC	??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@	; `string'
PUBLIC	??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@	; `string'
PUBLIC	??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@	; `string'
PUBLIC	??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@	; `string'
PUBLIC	??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@	; `string'
PUBLIC	??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@ ; `string'
PUBLIC	??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@	; `string'
PUBLIC	??_C@_06JGCGFIEG@polish?$AA@			; `string'
PUBLIC	??_C@_07NGJEAPOI@Rar?4exe?$AA@			; `string'
PUBLIC	??_C@_0L@LIFPHICI@Rar?4exe?5x?5?$AA@		; `string'
PUBLIC	??_C@_0BG@BBKNOMOH@invalid?5map?$DMK?0?5T?$DO?5key?$AA@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	?EfektyKompletne@@3_NA				; EfektyKompletne
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Czas@@3U_SYSTEMTIME@@A				; Czas
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?G³osyKompletne@@3_NA				; G³osyKompletne
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?is@?$ctype@D@std@@QBE_NFD@Z:PROC
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?eof@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	__imp_?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC
EXTRN	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync
EXTRN	__imp_?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
EXTRN	__imp_?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC
EXTRN	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow
EXTRN	__imp_?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC
EXTRN	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:PROC
EXTRN	__imp___get_stream_buffer_pointers:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp___fseeki64:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp__GetSystemTime@4:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__fsetpos:PROC
EXTRN	__imp____std_terminate:PROC
EXTRN	__imp__ungetc:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp__RemoveDirectoryA@4:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp__memchr:PROC
EXTRN	__imp__setvbuf:PROC
EXTRN	__imp__fgetpos:PROC
EXTRN	__imp__LoadResource@8:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp___lock_file:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp___unlock_file:PROC
EXTRN	__imp__SetConsoleCursorInfo@8:PROC
EXTRN	__imp___access:PROC
EXTRN	__imp__system:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__PlaySoundA@12:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp__fgetc:PROC
EXTRN	_atexit:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp____std_exception_copy:PROC
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__imp__URLDownloadToFileA@20:PROC
EXTRN	__imp__FindResourceA@12:PROC
EXTRN	__imp__remove:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Random_device@std@@YAIXZ:PROC
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_BADOFF@std@@3_JB:QWORD
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exceptions@std@@YAHXZ:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp__fclose:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp__fflush:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__GetConsoleCursorInfo@8:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__GetStdHandle@4:PROC
EXTRN	__imp__SetConsoleTextAttribute@8:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp__fputc:PROC
EXTRN	__imp__setlocale:PROC
EXTRN	__imp__MoveFileA@8:PROC
EXTRN	__imp__SizeofResource@8:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp____CxxFrameHandler3:PROC
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
?Czas@@3U_SYSTEMTIME@@A DB 010H DUP (?)			; Czas
_BSS	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	078H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	078H
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	070H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	070H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
?EfektyKompletne@@3_NA DB 01H				; EfektyKompletne
?G³osyKompletne@@3_NA DB 01H				; G³osyKompletne
_DATA	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	058H
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	068H
?Ruletka_ko³o@@3QBGB DW 00H				; Ruletka_ko³o
	DW	020H
	DW	0fH
	DW	013H
	DW	04H
	DW	015H
	DW	02H
	DW	019H
	DW	011H
	DW	022H
	DW	06H
	DW	01bH
	DW	0dH
	DW	024H
	DW	0bH
	DW	01eH
	DW	08H
	DW	017H
	DW	0aH
	DW	05H
	DW	018H
	DW	010H
	DW	021H
	DW	01H
	DW	014H
	DW	0eH
	DW	01fH
	DW	09H
	DW	016H
	DW	012H
	DW	01dH
	DW	07H
	DW	01cH
	DW	0cH
	DW	023H
	DW	03H
	DW	01aH
	ORG $+6
?Ruletka_plansza_kolor_col@@3QBGB DW 02H		; Ruletka_plansza_kolor_col
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	ORG $+2
?Ruletka_plansza_kolor@@3QBDB DB 067H			; Ruletka_plansza_kolor
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$alloc'
	DB	'ator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BBKNOMOH@invalid?5map?$DMK?0?5T?$DO?5key?$AA@
CONST	SEGMENT
??_C@_0BG@BBKNOMOH@invalid?5map?$DMK?0?5T?$DO?5key?$AA@ DB 'invalid map<K'
	DB	', T> key', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LIFPHICI@Rar?4exe?5x?5?$AA@
CONST	SEGMENT
??_C@_0L@LIFPHICI@Rar?4exe?5x?5?$AA@ DB 'Rar.exe x ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NGJEAPOI@Rar?4exe?$AA@
CONST	SEGMENT
??_C@_07NGJEAPOI@Rar?4exe?$AA@ DB 'Rar.exe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGCGFIEG@polish?$AA@
CONST	SEGMENT
??_C@_06JGCGFIEG@polish?$AA@ DB 'polish', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@
CONST	SEGMENT
??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@ DB 'efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@
CONST	SEGMENT
??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@ DB 'g', 0b3H, 'o'
	DB	's_szybko', 09cH, 0e6H, '_odczytu_numeru', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@
CONST	SEGMENT
??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@ DB 'g', 0b3H, 'os_odczytu_n'
	DB	'umeru', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@
CONST	SEGMENT
??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@ DB 'czy_kontynuowa', 0e6H, '_'
	DB	'gr', 0eaH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@
CONST	SEGMENT
??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@ DB 'stan_d', 09fH, 'wi', 0eaH, 'k'
	DB	0f3H, 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@
CONST	SEGMENT
??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@ DB 'kwota_pocz', 0b9H, 'tkowa'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@
CONST	SEGMENT
??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@ DB 'styl_liczenia_wygranej'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@
CONST	SEGMENT
??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@ DB 'czas_przeskoku_kul'
	DB	'ki_wolny', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@
CONST	SEGMENT
??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@ DB 'czas_przeskoku_ku'
	DB	'lki_szybki', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
CONST	SEGMENT
??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ DB 'ilo', 09cH, 0e6H
	DB	'_max_dodatkowych_obrot', 0f3H, 'w_ruletki', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@
CONST	SEGMENT
??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@ DB 'ilo', 09cH
	DB	0e6H, '_minimalna_obrot', 0f3H, 'w_ruletki', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
CONST	SEGMENT
??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@ DB ' Wylosowano ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@
CONST	SEGMENT
??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@ DB 'Kulka w gr'
	DB	'ze, zaczekaj na wylosowanie numeru...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
CONST	SEGMENT
??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@ DB ' Obstawiono zaklad ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@
CONST	SEGMENT
??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@ DB 'Obstawiono zak', 0b3H
	DB	'ad ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
CONST	SEGMENT
??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@ DB 'Obstawiono za ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@
CONST	SEGMENT
??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@ DB 'Gratuluje zwi'
	DB	0eaH, 'kszy', 0b3H, 'e', 09cH, ' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@
CONST	SEGMENT
??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@ DB ' krotnie '
	DB	'sw', 0f3H, 'j zas', 0f3H, 'b finansowy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@
CONST	SEGMENT
??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@ DB 'Grat'
	DB	'uluje zwi', 0eaH, 'kszy', 0b3H, 'e', 09cH, ' sw', 0f3H, 'j za'
	DB	's', 0f3H, 'b finansowy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
CONST	SEGMENT
??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@ DB 'Ko', 0f1H, 'cz'
	DB	'ysz gr', 0eaH, ' z wynikiem ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
CONST	SEGMENT
??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@ DB ' Przegrales ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
CONST	SEGMENT
??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@ DB ' Dostajesz '
	DB	'polowe zak', 0b3H, 'adu ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
CONST	SEGMENT
??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@ DB ' Posiadasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
CONST	SEGMENT
??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@ DB ' Wygrywasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EPMOAMKG@$?$AA@
CONST	SEGMENT
??_C@_01EPMOAMKG@$?$AA@ DB '$', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
CONST	SEGMENT
??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ DB 'N'
	DB	'ie mo', 0bfH, 'esz mie', 0e6H, ' wy', 0b3H, 0b9H, 'czonych d', 09fH
	DB	'wi', 0eaH, 'k', 0f3H, 'w i w', 0b3H, 0b9H, 'czon', 0b9H, ' mo'
	DB	'w', 0eaH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
CONST	SEGMENT
??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ DB 'N'
	DB	'ie mo', 0bfH, 'esz mie', 0e6H, ' wy', 0b3H, 0b9H, 'czonych d', 09fH
	DB	'wi', 0eaH, 'k', 0f3H, 'w i w', 0b3H, 0b9H, 'czonych efekt', 0f3H
	DB	'w d', 09fH, 'wi', 0eaH, 'kowych', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@
CONST	SEGMENT
??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@ DB 'Opcja efe'
	DB	'kty d', 09fH, 'wi', 0eaH, 'kowe przyjmuje warto', 09cH, 'ci 0'
	DB	' lub 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@
CONST	SEGMENT
??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@ DB 'Opcja'
	DB	' szybko', 09cH, 0e6H, ' g', 0b3H, 'osu odczytu przyjmuje wart'
	DB	'o', 09cH, 'ci w przedziale [1;5]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@
CONST	SEGMENT
??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@ DB 'Opcja g', 0b3H
	DB	'os odczytu numeru przyjmuje warto', 09cH, 'ci w przedziale [0'
	DB	';10]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@
CONST	SEGMENT
??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@ DB 'Opcja kontynu'
	DB	'owania gry przyjmuje warto', 09cH, 'ci tylko 0 lub 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@
CONST	SEGMENT
??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@ DB 'Stan '
	DB	'd', 09fH, 'wi', 0eaH, 'k', 0f3H, 'w przyjmuje warto', 09cH, 'c'
	DB	'i tylko 0 lub 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@
CONST	SEGMENT
??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@ DB 'Kwot'
	DB	'a pocz', 0b9H, 'tkowa nie mo', 0bfH, 'e by', 0e6H, ' mniejsza'
	DB	' od zera', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@
CONST	SEGMENT
??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@ DB 'Czas'
	DB	' przerwy d', 09fH, 'wi', 0eaH, 'ku nie mo', 0bfH, 'e by', 0e6H
	DB	' mniejszy od zera', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@
CONST	SEGMENT
??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@ DB 'Styl liczeia '
	DB	'wygranej przyjmuje warto', 09cH, 'ci tylko 0 lub 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@
CONST	SEGMENT
??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@ DB 'Jedna z dek'
	DB	'laracji w sprawie obrot', 0f3H, 'w ruletki musi by', 0e6H, ' '
	DB	'wi', 0eaH, 'ksza od zera', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@
CONST	SEGMENT
??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@ DB 'Ilo', 09cH
	DB	0e6H, ' max obrot', 0f3H, 'w ruletki nie mo', 0bfH, 'e by', 0e6H
	DB	' mniejsza od 0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@
CONST	SEGMENT
??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@ DB 'Ilo', 09cH
	DB	0e6H, ' minimalna obrot', 0f3H, 'w ruletki nie mo', 0bfH, 'e b'
	DB	'y', 0e6H, ' mniejsza od 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
CONST	SEGMENT
??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@ DB 'Ustawiam do'
	DB	'my', 09cH, 'lne ustawienie', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@
CONST	SEGMENT
??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@ DB 'Warto', 09cH
	DB	0e6H, ' wolnego czasu przeskoku kulki musi by', 0e6H, ' ni', 0bfH
	DB	'sza ni', 0bfH, ' warto', 09cH, 0e6H, ' szybkiego czasu przesk'
	DB	'oku kulki', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@
CONST	SEGMENT
??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@ DB 'efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@
CONST	SEGMENT
??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@ DB 'g', 0b3H
	DB	'os_szybko', 09cH, 0e6H, '_odczytu_numeru 4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@
CONST	SEGMENT
??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@ DB 'g', 0b3H, 'os_odczyt'
	DB	'u_numeru 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@
CONST	SEGMENT
??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@ DB 'czy_kontynuowa', 0e6H
	DB	'_gr', 0eaH, ' 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@
CONST	SEGMENT
??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@ DB 'stan_d', 09fH, 'wi', 0eaH
	DB	'k', 0f3H, 'w 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@
CONST	SEGMENT
??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@ DB 'kwota_pocz', 0b9H, 't'
	DB	'kowa 1000', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@
CONST	SEGMENT
??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@ DB 'styl_liczenia_wygra'
	DB	'nej 1', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@
CONST	SEGMENT
??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@ DB 'czas_przerwy_dzwi', 0eaH
	DB	'ku 500', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@
CONST	SEGMENT
??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@ DB 'czas_przeskoku'
	DB	'_kulki_wolny 75', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@
CONST	SEGMENT
??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@ DB 'czas_przeskok'
	DB	'u_kulki_szybki 50', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
CONST	SEGMENT
??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ DB 'ilo', 09cH, 0e6H
	DB	'_max_dodatkowych_obrot', 0f3H, 'w_ruletki 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@
CONST	SEGMENT
??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@ DB 'ilo', 09cH
	DB	0e6H, '_minimalna_obrot', 0f3H, 'w_ruletki 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COFBHHKL@setting?4txt?$AA@
CONST	SEGMENT
??_C@_0M@COFBHHKL@setting?4txt?$AA@ DB 'setting.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@
CONST	SEGMENT
??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@ DB 'Pobr'
	DB	'ano brakuj', 0b9H, 'ce pliki g', 0b3H, 'os', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KIPBKJCE@win?4wav?$AA@
CONST	SEGMENT
??_C@_07KIPBKJCE@win?4wav?$AA@ DB 'win.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
CONST	SEGMENT
??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@ DB 'Brak p'
	DB	'lik', 0f3H, 'w dla g', 0b3H, 'osu oraz nie mo', 0bfH, 'na pob'
	DB	'ra', 0e6H, ' danych, wy', 0b3H, 0b9H, 'czono odczytywanie wyn'
	DB	'iku', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04NCAGELPD@?4rar?$AA@
CONST	SEGMENT
??_C@_04NCAGELPD@?4rar?$AA@ DB '.rar', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
CONST	SEGMENT
??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ DB 'Rozpoczynam'
	DB	' pobieranie brakuj', 0b9H, 'cych plik', 0f3H, 'w g', 0b3H, 'o'
	DB	's', 0f3H, 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLFAMLOH@G?$LDos?$AA@
CONST	SEGMENT
??_C@_04JLFAMLOH@G?$LDos?$AA@ DB 'G', 0b3H, 'os', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/G%C5%82os/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IDAFKMJL@_?$AA@
CONST	SEGMENT
??_C@_01IDAFKMJL@_?$AA@ DB '_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NKPCGME@Agata?$AA@
CONST	SEGMENT
??_C@_05NKPCGME@Agata?$AA@ DB 'Agata', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDNGKDH@Jan2?$AA@
CONST	SEGMENT
??_C@_04HDNGKDH@Jan2?$AA@ DB 'Jan2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KJFHPLBC@Maja2?$AA@
CONST	SEGMENT
??_C@_05KJFHPLBC@Maja2?$AA@ DB 'Maja2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PLEDLCJI@Ewa2?$AA@
CONST	SEGMENT
??_C@_04PLEDLCJI@Ewa2?$AA@ DB 'Ewa2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKNIKMFF@Jacek2?$AA@
CONST	SEGMENT
??_C@_06DKNIKMFF@Jacek2?$AA@ DB 'Jacek2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JIHJHPIE@Jan?$AA@
CONST	SEGMENT
??_C@_03JIHJHPIE@Jan?$AA@ DB 'Jan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CDICBAGM@Maja?$AA@
CONST	SEGMENT
??_C@_04CDICBAGM@Maja?$AA@ DB 'Maja', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FPCJKMNP@Ewa?$AA@
CONST	SEGMENT
??_C@_03FPCJKMNP@Ewa?$AA@ DB 'Ewa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFCKMKOB@Jacek?$AA@
CONST	SEGMENT
??_C@_05KFCKMKOB@Jacek?$AA@ DB 'Jacek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
CONST	SEGMENT
??_C@_05CMOJBPHN@G?$LDos?1?$AA@ DB 'G', 0b3H, 'os/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@
CONST	SEGMENT
??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@ DB 'Pobran'
	DB	'o brakuj', 0b9H, 'ce pliki efekt', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/zwielokrotnenie.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
CONST	SEGMENT
??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/zwielokrotnenie.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/wygrana2.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
CONST	SEGMENT
??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/wygrana2.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/wygrana1.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
CONST	SEGMENT
??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/wygrana1.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
CONST	SEGMENT
??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@ DB 'Brak p'
	DB	'lik', 0f3H, 'w dla efekt', 0f3H, 'w d', 09fH, 'wi', 0eaH, 'ko'
	DB	'wych oraz nie mo', 0bfH, 'na pobra', 0e6H, ' danych, wy', 0b3H
	DB	0b9H, 'czono efekty d', 09fH, 'wi', 0eaH, 'kowe muzyczne, w', 0b3H
	DB	0b9H, 'czono efekty systemowe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/bankrut.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
CONST	SEGMENT
??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ DB 'Rozpoczynam'
	DB	' pobieranie brakuj', 0b9H, 'cych plik', 0f3H, 'w efekt', 0f3H
	DB	'w', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
CONST	SEGMENT
??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/bankrut.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
CONST	SEGMENT
??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@ DB 'Efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@
CONST	SEGMENT
??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@ DB 'Nowa gra rozpoc'
	DB	'zeta dnia ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@
CONST	SEGMENT
??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@ DB 'Gra rozpoczeta dnia ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
CONST	SEGMENT
??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@ DB ' o godzinie ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@
CONST	SEGMENT
??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@ DB 'Gra rozpoczeta dnia', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@
CONST	SEGMENT
??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@ DB 'Obstawiono za', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
CONST	SEGMENT
??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@ DB 'Obstawiono zaklad', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
CONST	SEGMENT
??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@ DB ' Wylosowano', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DAFLKCID@Wylosowano?$AA@
CONST	SEGMENT
??_C@_0L@DAFLKCID@Wylosowano?$AA@ DB 'Wylosowano', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LFKNBKJA@Posiadasz?$AA@
CONST	SEGMENT
??_C@_09LFKNBKJA@Posiadasz?$AA@ DB 'Posiadasz', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@
CONST	SEGMENT
??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@ DB 'Uruch'
	DB	'omiono ponownie gr', 0eaH, ' z wy', 0b3H, 0b9H, 'czon', 0b9H, ' '
	DB	'opcj', 0b9H, ' kontynuowania', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
CONST	SEGMENT
??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@ DB 'log_aktualny.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DICPFPGM@k?$AA@
CONST	SEGMENT
??_C@_01DICPFPGM@k?$AA@ DB 'k', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFDBGFDH@d?4wav?$AA@
CONST	SEGMENT
??_C@_05GFDBGFDH@d?4wav?$AA@ DB 'd.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ODKFBHJJ@g?4wav?$AA@
CONST	SEGMENT
??_C@_05ODKFBHJJ@g?4wav?$AA@ DB 'g.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LDGIIGCK@b?4wav?$AA@
CONST	SEGMENT
??_C@_05LDGIIGCK@b?4wav?$AA@ DB 'b.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LALOIELB@r?4wav?$AA@
CONST	SEGMENT
??_C@_05LALOIELB@r?4wav?$AA@ DB 'r.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEKKEGFB@n?4wav?$AA@
CONST	SEGMENT
??_C@_05MEKKEGFB@n?4wav?$AA@ DB 'n.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PNHGCFLK@p?4wav?$AA@
CONST	SEGMENT
??_C@_05PNHGCFLK@p?4wav?$AA@ DB 'p.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBLEHOMF@?4wav?$AA@
CONST	SEGMENT
??_C@_04IBLEHOMF@?4wav?$AA@ DB '.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FHDFACOC@NIE?$AA@
CONST	SEGMENT
??_C@_03FHDFACOC@NIE?$AA@ DB 'NIE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PKPMGAKA@Nie?$AA@
CONST	SEGMENT
??_C@_03PKPMGAKA@Nie?$AA@ DB 'Nie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKMOMPJO@nie?$AA@
CONST	SEGMENT
??_C@_03FKMOMPJO@nie?$AA@ DB 'nie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PIABMJCP@TAK?$AA@
CONST	SEGMENT
??_C@_03PIABMJCP@TAK?$AA@ DB 'TAK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFMIKLGN@Tak?$AA@
CONST	SEGMENT
??_C@_03FFMIKLGN@Tak?$AA@ DB 'Tak', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFPKAEFD@tak?$AA@
CONST	SEGMENT
??_C@_03PFPKAEFD@tak?$AA@ DB 'tak', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PFHFFBPC@t?$AA@
CONST	SEGMENT
??_C@_01PFHFFBPC@t?$AA@ DB 't', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@
CONST	SEGMENT
??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@ DB 'Na koncie masz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DOCNGCMI@$?0?5czy?5chcesz?5grac?5dalej?5?$CI?8t?8?9ta@
CONST	SEGMENT
??_C@_0CO@DOCNGCMI@$?0?5czy?5chcesz?5grac?5dalej?5?$CI?8t?8?9ta@ DB '$, c'
	DB	'zy chcesz grac dalej (''t''-tak, ''n''-nie) ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@
CONST	SEGMENT
??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@ DB 'Nie m'
	DB	'o', 0bfH, 'esz kontynuowa', 0e6H, ', przegra', 0b3H, 'e', 09cH
	DB	' wszystko', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BAJKLKHM@Obstawi?$LDe?$JM?5niepoprawnie?0?5przegra@
CONST	SEGMENT
??_C@_0CF@BAJKLKHM@Obstawi?$LDe?$JM?5niepoprawnie?0?5przegra@ DB 'Obstawi'
	DB	0b3H, 'e', 09cH, ' niepoprawnie, przegra', 0b3H, 'e', 09cH, ' '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@MDKBMGPE@Obstawi?$LDe?$JM?5niepoprawnie?5lecz?5uda@
CONST	SEGMENT
??_C@_0EF@MDKBMGPE@Obstawi?$LDe?$JM?5niepoprawnie?5lecz?5uda@ DB 'Obstawi'
	DB	0b3H, 'e', 09cH, ' niepoprawnie lecz uda', 0b3H, 'o Ci si', 0eaH
	DB	', dostajesz po', 0b3H, 'ow', 0eaH, ' zak', 0b3H, 'adu ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GINPHDN@Obstawi?$LDe?$JM?5poprawnie?0?5wygrywasz?5@
CONST	SEGMENT
??_C@_0CB@GINPHDN@Obstawi?$LDe?$JM?5poprawnie?0?5wygrywasz?5@ DB 'Obstawi'
	DB	0b3H, 'e', 09cH, ' poprawnie, wygrywasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DEPNMBPN@$?4?$AA@
CONST	SEGMENT
??_C@_02DEPNMBPN@$?4?$AA@ DB '$.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KHOJGJKF@?4?5?$AA@
CONST	SEGMENT
??_C@_02KHOJGJKF@?4?5?$AA@ DB '. ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
CONST	SEGMENT
??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@ DB 'Wylosowano numer ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
CONST	SEGMENT
??_C@_02MGHEPNFN@?$AI?$AI?$AA@ DB 08H, 08H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@
CONST	SEGMENT
??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@ DB 'Ni'
	DB	'e mo', 0bfH, 'esz obstawi', 0e6H, ' ujemn', 0b9H, ' kwot', 0b9H
	DB	' zak', 0b3H, 'adu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@
CONST	SEGMENT
??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@ DB 'Nie masz tyle pie'
	DB	'ni', 0eaH, 'dzy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@
CONST	SEGMENT
??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@ DB 'Nie mo', 0bfH
	DB	'esz obstawi', 0e6H, ' zerowego zak', 0b3H, 'adu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@
CONST	SEGMENT
??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@ DB 'Wpro'
	DB	'wadzi', 0b3H, 'e', 0e6H, ' nieprawid', 0b3H, 'ow', 0b9H, ' wa'
	DB	'rto', 09cH, 0e6H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OMMBNPEF@Masz?5?$AA@
CONST	SEGMENT
??_C@_05OMMBNPEF@Masz?5?$AA@ DB 'Masz ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MANFGHNE@$?0?5jak?$LJ?5kwot?$LJ?5chcesz?5obstawi?f?5wy@
CONST	SEGMENT
??_C@_0CF@MANFGHNE@$?0?5jak?$LJ?5kwot?$LJ?5chcesz?5obstawi?f?5wy@ DB '$, '
	DB	'jak', 0b9H, ' kwot', 0b9H, ' chcesz obstawi', 0e6H, ' wynik?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPIPOMFB@36?$AA@
CONST	SEGMENT
??_C@_02KPIPOMFB@36?$AA@ DB '36', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IEKCLPJC@35?$AA@
CONST	SEGMENT
??_C@_02IEKCLPJC@35?$AA@ DB '35', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JNLJIOND@34?$AA@
CONST	SEGMENT
??_C@_02JNLJIOND@34?$AA@ DB '34', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NCPIBIBE@33?$AA@
CONST	SEGMENT
??_C@_02NCPIBIBE@33?$AA@ DB '33', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MLODCJFF@32?$AA@
CONST	SEGMENT
??_C@_02MLODCJFF@32?$AA@ DB '32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OAMOHKJG@31?$AA@
CONST	SEGMENT
??_C@_02OAMOHKJG@31?$AA@ DB '31', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PJNFELNH@30?$AA@
CONST	SEGMENT
??_C@_02PJNFELNH@30?$AA@ DB '30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CJNFJKKJ@29?$AA@
CONST	SEGMENT
??_C@_02CJNFJKKJ@29?$AA@ DB '29', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DAMOKLOI@28?$AA@
CONST	SEGMENT
??_C@_02DAMOKLOI@28?$AA@ DB '28', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LHFGLHCH@27?$AA@
CONST	SEGMENT
??_C@_02LHFGLHCH@27?$AA@ DB '27', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KOENIGGG@26?$AA@
CONST	SEGMENT
??_C@_02KOENIGGG@26?$AA@ DB '26', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IFGANFKF@25?$AA@
CONST	SEGMENT
??_C@_02IFGANFKF@25?$AA@ DB '25', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMHLOEOE@24?$AA@
CONST	SEGMENT
??_C@_02JMHLOEOE@24?$AA@ DB '24', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NDDKHCCD@23?$AA@
CONST	SEGMENT
??_C@_02NDDKHCCD@23?$AA@ DB '23', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MKCBEDGC@22?$AA@
CONST	SEGMENT
??_C@_02MKCBEDGC@22?$AA@ DB '22', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OBAMBAKB@21?$AA@
CONST	SEGMENT
??_C@_02OBAMBAKB@21?$AA@ DB '21', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PIBHCBOA@20?$AA@
CONST	SEGMENT
??_C@_02PIBHCBOA@20?$AA@ DB '20', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLJDCEPA@19?$AA@
CONST	SEGMENT
??_C@_02CLJDCEPA@19?$AA@ DB '19', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCIIBFLB@18?$AA@
CONST	SEGMENT
??_C@_02DCIIBFLB@18?$AA@ DB '18', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFBAAJHO@17?$AA@
CONST	SEGMENT
??_C@_02LFBAAJHO@17?$AA@ DB '17', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KMALDIDP@16?$AA@
CONST	SEGMENT
??_C@_02KMALDIDP@16?$AA@ DB '16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IHCGGLPM@15?$AA@
CONST	SEGMENT
??_C@_02IHCGGLPM@15?$AA@ DB '15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JODNFKLN@14?$AA@
CONST	SEGMENT
??_C@_02JODNFKLN@14?$AA@ DB '14', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NBHMMMHK@13?$AA@
CONST	SEGMENT
??_C@_02NBHMMMHK@13?$AA@ DB '13', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MIGHPNDL@12?$AA@
CONST	SEGMENT
??_C@_02MIGHPNDL@12?$AA@ DB '12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ODEKKOPI@11?$AA@
CONST	SEGMENT
??_C@_02ODEKKOPI@11?$AA@ DB '11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PKFBJPLJ@10?$AA@
CONST	SEGMENT
??_C@_02PKFBJPLJ@10?$AA@ DB '10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LAKCGALK@9?$AA@
CONST	SEGMENT
??_C@_01LAKCGALK@9?$AA@ DB '9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8?$AA@
CONST	SEGMENT
??_C@_01KJLJFBPL@8?$AA@ DB '8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01COCBENDE@7?$AA@
CONST	SEGMENT
??_C@_01COCBENDE@7?$AA@ DB '7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DHDKHMHF@6?$AA@
CONST	SEGMENT
??_C@_01DHDKHMHF@6?$AA@ DB '6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BMBHCPLG@5?$AA@
CONST	SEGMENT
??_C@_01BMBHCPLG@5?$AA@ DB '5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FAMBOPH@4?$AA@
CONST	SEGMENT
??_C@_01FAMBOPH@4?$AA@ DB '4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EKENIIDA@3?$AA@
CONST	SEGMENT
??_C@_01EKENIIDA@3?$AA@ DB '3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FDFGLJHB@2?$AA@
CONST	SEGMENT
??_C@_01FDFGLJHB@2?$AA@ DB '2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OAIKGDBA@w12?$AA@
CONST	SEGMENT
??_C@_03OAIKGDBA@w12?$AA@ DB 'w12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MLKHDAND@w11?$AA@
CONST	SEGMENT
??_C@_03MLKHDAND@w11?$AA@ DB 'w11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NCLMABJC@w10?$AA@
CONST	SEGMENT
??_C@_03NCLMABJC@w10?$AA@ DB 'w10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FPIENFIC@w9?$AA@
CONST	SEGMENT
??_C@_02FPIENFIC@w9?$AA@ DB 'w9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGJPOEMD@w8?$AA@
CONST	SEGMENT
??_C@_02EGJPOEMD@w8?$AA@ DB 'w8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MBAHPIAM@w7?$AA@
CONST	SEGMENT
??_C@_02MBAHPIAM@w7?$AA@ DB 'w7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NIBMMJEN@w6?$AA@
CONST	SEGMENT
??_C@_02NIBMMJEN@w6?$AA@ DB 'w6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDDBJKIO@w5?$AA@
CONST	SEGMENT
??_C@_02PDDBJKIO@w5?$AA@ DB 'w5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OKCKKLMP@w4?$AA@
CONST	SEGMENT
??_C@_02OKCKKLMP@w4?$AA@ DB 'w4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KFGLDNAI@w3?$AA@
CONST	SEGMENT
??_C@_02KFGLDNAI@w3?$AA@ DB 'w3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMHAAMEJ@w2?$AA@
CONST	SEGMENT
??_C@_02LMHAAMEJ@w2?$AA@ DB 'w2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JHFNFPIK@w1?$AA@
CONST	SEGMENT
??_C@_02JHFNFPIK@w1?$AA@ DB 'w1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LAFHGHBM@k3?$AA@
CONST	SEGMENT
??_C@_02LAFHGHBM@k3?$AA@ DB 'k3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KJEMFGFN@k2?$AA@
CONST	SEGMENT
??_C@_02KJEMFGFN@k2?$AA@ DB 'k2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ICGBAFJO@k1?$AA@
CONST	SEGMENT
??_C@_02ICGBAFJO@k1?$AA@ DB 'k1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JEJKBAGA@g?$AA@
CONST	SEGMENT
??_C@_01JEJKBAGA@g?$AA@ DB 'g', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OJONOECF@b?$AA@
CONST	SEGMENT
??_C@_01OJONOECF@b?$AA@ DB 'b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n?$AA@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n?$AA@ DB 'n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p?$AA@
CONST	SEGMENT
??_C@_01JBBJJEPG@p?$AA@ DB 'p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CGIAAFPM@0?936?5?9?5pojedy?qcze?5pole?5o?5odpowie@
CONST	SEGMENT
??_C@_0CN@CGIAAFPM@0?936?5?9?5pojedy?qcze?5pole?5o?5odpowie@ DB '0-36 - p'
	DB	'ojedy', 0f1H, 'cze pole o odpowiednim numerze', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OAIPJBPB@w1?0?5w2?0?5?4?4?4?5?0?5w12?5?9?5wiersz?5trzec@
CONST	SEGMENT
??_C@_0CK@OAIPJBPB@w1?0?5w2?0?5?4?4?4?5?0?5w12?5?9?5wiersz?5trzec@ DB 'w1'
	DB	', w2, ... , w12 - wiersz trzech numer', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@
CONST	SEGMENT
??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@ DB 'k1, k'
	DB	'2, k3 - kolumna 1, kolumna 2, kolumna 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@
CONST	SEGMENT
??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@ DB 'd - dolna po', 0b3H, 'o'
	DB	'wa', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@
CONST	SEGMENT
??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@ DB 'g - g', 0f3H, 'rna p'
	DB	'o', 0b3H, 'owa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EPLAAEJB@b?5?9?5czarne?5?$CIblack?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@EPLAAEJB@b?5?9?5czarne?5?$CIblack?$CJ?$AA@ DB 'b - czarne (blac'
	DB	'k)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LEDAOJLK@r?5?9?5czerwone?5?$CIred?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@LEDAOJLK@r?5?9?5czerwone?5?$CIred?$CJ?$AA@ DB 'r - czerwone (re'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@
CONST	SEGMENT
??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@ DB 'n - nieparzyste', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@
CONST	SEGMENT
??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@ DB 'p - parzyste', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@POFCNLON@Jak?$LJ?5opcje?5chcesz?5obstawi?f?$DP?5?$CIzgo@
CONST	SEGMENT
??_C@_0DL@POFCNLON@Jak?$LJ?5opcje?5chcesz?5obstawi?f?$DP?5?$CIzgo@ DB 'Ja'
	DB	'k', 0b9H, ' opcje chcesz obstawi', 0e6H, '? (zgodnie z poni', 0bfH
	DB	'szym opisem) :', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause?$AA@
CONST	SEGMENT
??_C@_05PDJBBECF@pause?$AA@ DB 'pause', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@
CONST	SEGMENT
??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@ DB 'log_og', 0f3H, 'lny.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JHEKFJCL@Maja2_5?$AA@
CONST	SEGMENT
??_C@_07JHEKFJCL@Maja2_5?$AA@ DB 'Maja2_5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IOFBGIGK@Maja2_4?$AA@
CONST	SEGMENT
??_C@_07IOFBGIGK@Maja2_4?$AA@ DB 'Maja2_4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBBAPOKN@Maja2_3?$AA@
CONST	SEGMENT
??_C@_07MBBAPOKN@Maja2_3?$AA@ DB 'Maja2_3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NIALMPOM@Maja2_2?$AA@
CONST	SEGMENT
??_C@_07NIALMPOM@Maja2_2?$AA@ DB 'Maja2_2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PDCGJMCP@Maja2_1?$AA@
CONST	SEGMENT
??_C@_07PDCGJMCP@Maja2_1?$AA@ DB 'Maja2_1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BBCOLMHG@Maja_5?$AA@
CONST	SEGMENT
??_C@_06BBCOLMHG@Maja_5?$AA@ DB 'Maja_5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDFINDH@Maja_4?$AA@
CONST	SEGMENT
??_C@_06IDFINDH@Maja_4?$AA@ DB 'Maja_4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EHHEBLPA@Maja_3?$AA@
CONST	SEGMENT
??_C@_06EHHEBLPA@Maja_3?$AA@ DB 'Maja_3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOGPCKLB@Maja_2?$AA@
CONST	SEGMENT
??_C@_06FOGPCKLB@Maja_2?$AA@ DB 'Maja_2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HFECHJHC@Maja_1?$AA@
CONST	SEGMENT
??_C@_06HFECHJHC@Maja_1?$AA@ DB 'Maja_1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PILBIEHE@Jan2_5?$AA@
CONST	SEGMENT
??_C@_06PILBIEHE@Jan2_5?$AA@ DB 'Jan2_5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OBKKLFDF@Jan2_4?$AA@
CONST	SEGMENT
??_C@_06OBKKLFDF@Jan2_4?$AA@ DB 'Jan2_4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KOOLCDPC@Jan2_3?$AA@
CONST	SEGMENT
??_C@_06KOOLCDPC@Jan2_3?$AA@ DB 'Jan2_3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LHPABCLD@Jan2_2?$AA@
CONST	SEGMENT
??_C@_06LHPABCLD@Jan2_2?$AA@ DB 'Jan2_2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JMNNEBHA@Jan2_1?$AA@
CONST	SEGMENT
??_C@_06JMNNEBHA@Jan2_1?$AA@ DB 'Jan2_1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKIEACKA@Jan_5?$AA@
CONST	SEGMENT
??_C@_05FKIEACKA@Jan_5?$AA@ DB 'Jan_5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EDJPDDOB@Jan_4?$AA@
CONST	SEGMENT
??_C@_05EDJPDDOB@Jan_4?$AA@ DB 'Jan_4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNOKFCG@Jan_3?$AA@
CONST	SEGMENT
??_C@_05MNOKFCG@Jan_3?$AA@ DB 'Jan_3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BFMFJEGH@Jan_2?$AA@
CONST	SEGMENT
??_C@_05BFMFJEGH@Jan_2?$AA@ DB 'Jan_2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DOOIMHKE@Jan_1?$AA@
CONST	SEGMENT
??_C@_05DOOIMHKE@Jan_1?$AA@ DB 'Jan_1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NNHNNHDB@Jacek2_5?$AA@
CONST	SEGMENT
??_C@_08NNHNNHDB@Jacek2_5?$AA@ DB 'Jacek2_5', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MEGGOGHA@Jacek2_4?$AA@
CONST	SEGMENT
??_C@_08MEGGOGHA@Jacek2_4?$AA@ DB 'Jacek2_4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILCHHALH@Jacek2_3?$AA@
CONST	SEGMENT
??_C@_08ILCHHALH@Jacek2_3?$AA@ DB 'Jacek2_3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JCDMEBPG@Jacek2_2?$AA@
CONST	SEGMENT
??_C@_08JCDMEBPG@Jacek2_2?$AA@ DB 'Jacek2_2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LJBBBCDF@Jacek2_1?$AA@
CONST	SEGMENT
??_C@_08LJBBBCDF@Jacek2_1?$AA@ DB 'Jacek2_1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PJAFOHBC@Jacek_5?$AA@
CONST	SEGMENT
??_C@_07PJAFOHBC@Jacek_5?$AA@ DB 'Jacek_5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OABONGFD@Jacek_4?$AA@
CONST	SEGMENT
??_C@_07OABONGFD@Jacek_4?$AA@ DB 'Jacek_4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KPFPEAJE@Jacek_3?$AA@
CONST	SEGMENT
??_C@_07KPFPEAJE@Jacek_3?$AA@ DB 'Jacek_3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LGEEHBNF@Jacek_2?$AA@
CONST	SEGMENT
??_C@_07LGEEHBNF@Jacek_2?$AA@ DB 'Jacek_2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNGJCCBG@Jacek_1?$AA@
CONST	SEGMENT
??_C@_07JNGJCCBG@Jacek_1?$AA@ DB 'Jacek_1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FJCGICMK@Ewa2_5?$AA@
CONST	SEGMENT
??_C@_06FJCGICMK@Ewa2_5?$AA@ DB 'Ewa2_5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EADNLDIL@Ewa2_4?$AA@
CONST	SEGMENT
??_C@_06EADNLDIL@Ewa2_4?$AA@ DB 'Ewa2_4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PHMCFEM@Ewa2_3?$AA@
CONST	SEGMENT
??_C@_06PHMCFEM@Ewa2_3?$AA@ DB 'Ewa2_3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BGGHBEAN@Ewa2_2?$AA@
CONST	SEGMENT
??_C@_06BGGHBEAN@Ewa2_2?$AA@ DB 'Ewa2_2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNEKEHMO@Ewa2_1?$AA@
CONST	SEGMENT
??_C@_06DNEKEHMO@Ewa2_1?$AA@ DB 'Ewa2_1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMBBMCAB@Ewa_5?$AA@
CONST	SEGMENT
??_C@_05BMBBMCAB@Ewa_5?$AA@ DB 'Ewa_5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FAKPDEA@Ewa_4?$AA@
CONST	SEGMENT
??_C@_05FAKPDEA@Ewa_4?$AA@ DB 'Ewa_4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EKELGFIH@Ewa_3?$AA@
CONST	SEGMENT
??_C@_05EKELGFIH@Ewa_3?$AA@ DB 'Ewa_3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FDFAFEMG@Ewa_2?$AA@
CONST	SEGMENT
??_C@_05FDFAFEMG@Ewa_2?$AA@ DB 'Ewa_2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HIHNAHAF@Ewa_1?$AA@
CONST	SEGMENT
??_C@_05HIHNAHAF@Ewa_1?$AA@ DB 'Ewa_1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LIEKDBCD@Agata_5?$AA@
CONST	SEGMENT
??_C@_07LIEKDBCD@Agata_5?$AA@ DB 'Agata_5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KBFBAAGC@Agata_4?$AA@
CONST	SEGMENT
??_C@_07KBFBAAGC@Agata_4?$AA@ DB 'Agata_4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OOBAJGKF@Agata_3?$AA@
CONST	SEGMENT
??_C@_07OOBAJGKF@Agata_3?$AA@ DB 'Agata_3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PHALKHOE@Agata_2?$AA@
CONST	SEGMENT
??_C@_07PHALKHOE@Agata_2?$AA@ DB 'Agata_2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NMCGPECH@Agata_1?$AA@
CONST	SEGMENT
??_C@_07NMCGPECH@Agata_1?$AA@ DB 'Agata_1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > > &>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > > >
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > > &,bool,0>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >,bool,0>
PUBLIC	??$_Buy_if_not_node@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Buy_if_not_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1>::_Get_first
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> > >::max_size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::max_size
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::operator--
PUBLIC	?__autoclassinit2@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QAEXI@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::__autoclassinit2
PUBLIC	??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@QAE@ABU01@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> *>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> *>
PUBLIC	??$forward@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@YAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@0@AAU10@@Z ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> &>
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@ABU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> const &>
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QBEABIXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Mysize
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,std::_Iterator_base0>
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,std::_Iterator_base0>::operator--
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1>,1>::_Get_first
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::size
PUBLIC	?_Destroy_if_node@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Destroy_if_node
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Buynode0
PUBLIC	?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Freenode0
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Getcomp
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::operator--
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Insert_hint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> *>
PUBLIC	??$_Buynode@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> const &>
PUBLIC	??$forward@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@YAABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@0@ABU10@@Z ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> const &>
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ; std::uniform_int<int>::_Adjust
PUBLIC	?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAII@Z		; std::uniform_int<int>::_Adjust
PUBLIC	??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QAE@AAVrandom_device@1@@Z ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>
PUBLIC	??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEII@Z ; std::_Rng_from_urng<unsigned int,std::random_device>::operator()
PUBLIC	?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEIXZ ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z ; std::_Traits_equal<std::char_traits<char> >
PUBLIC	??$move@AAD@std@@YA$$QADAAD@Z			; std::move<char &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> * &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1><>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$forward@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABU10@@Z ; std::forward<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> *>
PUBLIC	??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$emplace_hint@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::emplace_hint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> const &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@ABEHAAVrandom_device@1@HH@Z ; std::uniform_int<int>::_Eval<std::random_device>
PUBLIC	??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
PUBLIC	??$forward@AAY08$$CBD@std@@YAAAY08$$CBDAAY08$$CBD@Z ; std::forward<char const (&)[9]>
PUBLIC	??$forward@AAY06$$CBD@std@@YAAAY06$$CBDAAY06$$CBD@Z ; std::forward<char const (&)[7]>
PUBLIC	??$forward@AAY05$$CBD@std@@YAAAY05$$CBDAAY05$$CBD@Z ; std::forward<char const (&)[6]>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$forward@AAY07$$CBD@std@@YAAAY07$$CBDAAY07$$CBD@Z ; std::forward<char const (&)[8]>
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Compare@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Compare
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> > >::deallocate
PUBLIC	?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
PUBLIC	?_Get_bytes@?$_Default_allocate_traits@$00@std@@SAPAXII@Z ; std::_Default_allocate_traits<1>::_Get_bytes
PUBLIC	??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@QAEPAXI@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??$swap@DX@std@@YAXAAD0@Z			; std::swap<char,void>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@AAPAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> * &>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> *>
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >
PUBLIC	??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@0@AAU10@@Z ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >
PUBLIC	??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>
PUBLIC	??$?0ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> > >
PUBLIC	??$addressof@$$CBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@YAPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@0@ABU10@@Z ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> const >
PUBLIC	??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPAXIII@Z ; std::_Allocate<std::_Default_allocate_traits<1> >
PUBLIC	??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
PUBLIC	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
PUBLIC	??$_Refancy@PAD$0A@@std@@YAPADPAD@Z		; std::_Refancy<char *,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$insert@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEXPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::insert<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> const *>
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > const >
PUBLIC	??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$size@D$0BN@@std@@YAIAAY0BN@$$CBD@Z		; std::size<char,29>
PUBLIC	??$size@D$0BE@@std@@YAIAAY0BE@$$CBD@Z		; std::size<char,20>
PUBLIC	??$size@D$0O@@std@@YAIAAY0O@$$CBD@Z		; std::size<char,14>
PUBLIC	??$size@D$0BB@@std@@YAIAAY0BB@$$CBD@Z		; std::size<char,17>
PUBLIC	??$size@D$0BH@@std@@YAIAAY0BH@$$CBD@Z		; std::size<char,23>
PUBLIC	??$size@D$0BL@@std@@YAIAAY0BL@$$CBD@Z		; std::size<char,27>
PUBLIC	??$size@D$0BM@@std@@YAIAAY0BM@$$CBD@Z		; std::size<char,28>
PUBLIC	??$size@D$0CG@@std@@YAIAAY0CG@$$CBD@Z		; std::size<char,38>
PUBLIC	??$size@D$0CA@@std@@YAIAAY0CA@$$CBD@Z		; std::size<char,32>
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?RVrandom_device@std@@@?$uniform_int@H@std@@QBEHAAVrandom_device@1@@Z ; std::uniform_int<int>::operator()<std::random_device>
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?0AAY08$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@QAE@AAY08$$CBD$$QAH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short><char const (&)[9],int,0>
PUBLIC	??$?0AAY06$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@QAE@AAY06$$CBD$$QAH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short><char const (&)[7],int,0>
PUBLIC	??$?0AAY05$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@QAE@AAY05$$CBD$$QAH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short><char const (&)[6],int,0>
PUBLIC	??$?0AAY07$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@QAE@AAY07$$CBD$$QAH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short><char const (&)[8],int,0>
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::_Min
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Rrotate
PUBLIC	?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Max
PUBLIC	?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Min
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >::allocate
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,std::_Iterator_base0>::operator++
PUBLIC	?_Extract@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Extract
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Erase
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Root
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Buyheadnode
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEAAIXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Mysize
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::operator++
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1>,1>::_Get_second
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::clear
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Lmost
PUBLIC	?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Construct
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Getal
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Get_data
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::operator++
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::operator!=
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,std::_Iterator_base0>
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1>,1>::_Get_second
PUBLIC	?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z	; std::uniform_int<int>::param_type::_Init
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::end
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::erase
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Kfn
PUBLIC	??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >
PUBLIC	?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Freeheadnode
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Get_data
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Myhead
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Myhead
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::operator*
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >,1>,1>::_Get_first
PUBLIC	?begin@?$initializer_list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@2@XZ ; std::initializer_list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >::begin
PUBLIC	?end@?$initializer_list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@2@XZ ; std::initializer_list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >::end
PUBLIC	?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
PUBLIC	??0param_type@?$uniform_int@H@std@@QAE@HH@Z	; std::uniform_int<int>::param_type::param_type
PUBLIC	?pointer_to@?$pointer_traits@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@SAPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@2@ABU32@@Z ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> const *>::pointer_to
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ	; std::fpos<_Mbstatet>::seekpos
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
PUBLIC	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
PUBLIC	?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::end
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEXV?$initializer_list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::insert
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::lower_bound
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Tidy
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Key
PUBLIC	??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::_Getcomp
PUBLIC	??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::operator->
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::operator==
PUBLIC	??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
PUBLIC	?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
PUBLIC	?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
PUBLIC	??0?$uniform_int@H@std@@QAE@HH@Z		; std::uniform_int<int>::uniform_int<int>
PUBLIC	?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ; std::pointer_traits<char *>::pointer_to
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?__autoclassinit2@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@QAEXI@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > > >::__autoclassinit2
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_fstream<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::close
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
PUBLIC	??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >
PUBLIC	?at@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QBEABGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::at
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >,0> >
PUBLIC	??0?$initializer_list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@QAE@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@0@Z ; std::initializer_list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >::initializer_list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> >
PUBLIC	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
PUBLIC	??0?$uniform_int_distribution@H@std@@QAE@HH@Z	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
PUBLIC	?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Usuñ_Folder_Wypakowany_i_Winrar
PUBLIC	?Przenie_Plik@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Przenie_Plik
PUBLIC	?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Wypakuj_Rar
PUBLIC	?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
PUBLIC	?Inicjacje_Pocz¹tkowe@@YAXXZ			; Inicjacje_Pocz¹tkowe
PUBLIC	?Ustaw_Ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ustaw_Ustawienia
PUBLIC	?Pêtla_G³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; Pêtla_G³ówna
PUBLIC	?Koniec_Gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z ; Koniec_Gry
PUBLIC	?Og³o_Wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ; Og³o_Wynik
PUBLIC	?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?Sprawd_Ustawienia@@YAXXZ			; Sprawd_Ustawienia
PUBLIC	?Sprawd_Pliki@@YAXXZ				; Sprawd_Pliki
PUBLIC	?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Wczytaj_z_Pliku
PUBLIC	?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
PUBLIC	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Odczytaj_Liczbê
PUBLIC	?Wylosuj@@YAHABH0@Z				; Wylosuj
PUBLIC	?Show_Cursor@@YAXXZ				; Show_Cursor
PUBLIC	?Hide_Cursor@@YAXXZ				; Hide_Cursor
PUBLIC	?Change_Col@@YAXABH@Z				; Change_Col
PUBLIC	?Czy_Kontynuowaæ@@YA_NABH@Z			; Czy_Kontynuowaæ
PUBLIC	?Sprawd_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Sprawd_Zak³ad
PUBLIC	?Zakrêæ_Ruletk¹@@YAHXZ				; Zakrêæ_Ruletk¹
PUBLIC	?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z		; Wczytaj_Kwotê_Zak³adu
PUBLIC	?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Obstaw
PUBLIC	?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	_main
PUBLIC	??0S_Ustawienia@@QAE@XZ				; S_Ustawienia::S_Ustawienia
PUBLIC	?__autoclassinit2@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QAEXI@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::__autoclassinit2
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >
PUBLIC	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short>
PUBLIC	??Rrandom_device@std@@QAEIXZ			; std::random_device::operator()
PUBLIC	?entropy@random_device@std@@QBENXZ		; std::random_device::entropy
PUBLIC	?max@random_device@std@@SAIXZ			; std::random_device::max
PUBLIC	?min@random_device@std@@SAIXZ			; std::random_device::min
PUBLIC	??0random_device@std@@QAE@XZ			; std::random_device::random_device
PUBLIC	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z		; std::_Ungetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	?_Deallocate@std@@YAXPAXIII@Z			; std::_Deallocate
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?eq@?$char_traits@D@std@@SA_NABD0@Z		; std::char_traits<char>::eq
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAPADQADID@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?find@?$char_traits@D@std@@SAPBDQBDIABD@Z	; std::char_traits<char>::find
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	?compare@?$char_traits@D@std@@SAHQBD0I@Z	; std::char_traits<char>::compare
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
PUBLIC	?Ustawienia@@3US_Ustawienia@@A			; Ustawienia
PUBLIC	__real@4040000000000000
PUBLIC	__real@4042800000000000
EXTRN	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___std_terminate:PROC
EXTRN	__dtoui3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
?Numer_zasobu_rar@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@B DQ 01H DUP (?) ; Numer_zasobu_rar
_BSS	ENDS
CRT$XCU	SEGMENT
?Numer_zasobu_rar$initializer$@@3P6AXXZA DD FLAT:??__ENumer_zasobu_rar@@YAXXZ ; Numer_zasobu_rar$initializer$
CRT$XCU	ENDS
;	COMDAT __real@4042800000000000
CONST	SEGMENT
__real@4042800000000000 DQ 04042800000000000r	; 37
CONST	ENDS
;	COMDAT __real@4040000000000000
CONST	SEGMENT
__real@4040000000000000 DQ 04040000000000000r	; 32
	ORG $+2
?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DQ 00000000000000000r ; 0 ; G³os
	DQ	00000000000000000r		; 0
	DQ	00000000f00000000r		; 3.18299e-313
?Ustawienia@@3US_Ustawienia@@A DQ 0004b003200030002r ; 3.00393e-307 ; Ustawienia
	DQ	0000003e8000101f4r		; 2.122e-311
	DQ	00004000100010001r		; 5.56271e-309
	DD	01H
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1locale@std@@QAE@XZ DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??__ENumer_zasobu_rar@@YAXXZ DQ 00000002e19930522r ; 9.78238e-313
	DD	FLAT:__unwindtable$??__ENumer_zasobu_rar@@YAXXZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
	ORG $+4
__unwindtable$??__ENumer_zasobu_rar@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$18
	DD	012H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$19
	DD	013H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$20
	DD	014H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$21
	DD	015H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$22
	DD	016H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$23
	DD	017H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$24
	DD	018H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$25
	DD	019H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$26
	DD	01aH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$27
	DD	01bH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$28
	DD	01cH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$29
	DD	01dH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$30
	DD	01eH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$31
	DD	01fH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$32
	DD	020H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$33
	DD	021H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$34
	DD	022H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$35
	DD	023H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$36
	DD	024H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$37
	DD	025H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$38
	DD	026H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$39
	DD	027H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$40
	DD	028H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$41
	DD	029H
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$42
	DD	02aH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$43
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$45
	DD	02cH
	DD	FLAT:__unwindfunclet$??__ENumer_zasobu_rar@@YAXXZ$408
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$5
	DD	01H
	DD	FLAT:__unwindfunclet$_main$6
	DD	02H
	DD	FLAT:__unwindfunclet$_main$8
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
	DD	04H
	DD	FLAT:__unwindfunclet$_main$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Czy_Kontynuowaæ@@YA_NABH@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$?Czy_Kontynuowaæ@@YA_NABH@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$?Czy_Kontynuowaæ@@YA_NABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Czy_Kontynuowaæ@@YA_NABH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$19
	DD	00H
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$20
	DD	01H
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	04H
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$10
	DD	06H
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$11
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$406
	DD	08H
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$407
	DD	09H
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$409
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$13
	DD	0bH
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$14
	DD	0cH
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$15
	DD	0dH
	DD	FLAT:__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Sprawd_Pliki@@YAXXZ DD 019930522H
	DD	05bH
	DD	FLAT:__unwindtable$?Sprawd_Pliki@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Sprawd_Pliki@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$6
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$8
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$9
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$10
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$12
	DD	06H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$13
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$16
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$17
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$18
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$20
	DD	0bH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$21
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$24
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$25
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$26
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$28
	DD	010H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$29
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$32
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$33
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$34
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$36
	DD	015H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$37
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$40
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$41
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$42
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$44
	DD	01aH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$45
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$48
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$49
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$50
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$52
	DD	01fH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$53
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$55
	DD	021H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$56
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$58
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$59
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$60
	DD	025H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$61
	DD	026H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$62
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$64
	DD	028H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$65
	DD	029H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$66
	DD	02aH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$67
	DD	02bH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$68
	DD	02cH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$69
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$826
	DD	02eH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$827
	DD	02fH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$829
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$71
	DD	031H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$72
	DD	032H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$73
	DD	033H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$74
	DD	031H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$76
	DD	031H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$77
	DD	031H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$78
	DD	037H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$79
	DD	038H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$80
	DD	039H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$81
	DD	03aH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$82
	DD	03bH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$83
	DD	03cH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$84
	DD	031H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$86
	DD	03eH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$87
	DD	03fH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$88
	DD	040H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$89
	DD	041H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$90
	DD	042H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$91
	DD	043H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$92
	DD	044H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$93
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$95
	DD	046H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$96
	DD	047H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$97
	DD	046H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$99
	DD	046H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$100
	DD	046H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$101
	DD	04bH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$102
	DD	04cH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$103
	DD	04dH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$104
	DD	04eH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$105
	DD	046H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$107
	DD	050H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$108
	DD	051H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$109
	DD	052H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$110
	DD	053H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$111
	DD	054H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$112
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$115
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$116
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$117
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$119
	DD	059H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$120
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Sprawd_Ustawienia@@YAXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Sprawd_Ustawienia@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Sprawd_Ustawienia@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$0
	DD	03H
	DD	FLAT:__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$21
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DQ 00000001019930522r ; 3.41639e-313
	DD	FLAT:__unwindtable$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
	ORG $+4
__unwindtable$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$231
	DD	02H
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$232
	DD	03H
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$234
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$11
	DD	06H
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$12
	DD	07H
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$430
	DD	09H
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$431
	DD	0aH
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$433
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$15
	DD	0cH
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$16
	DD	0dH
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$19
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@1@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@1@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000319930522r ; 6.57797e-314
	DD	FLAT:__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000319930522r ; 6.57797e-314
	DD	FLAT:__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000319930522r ; 6.57797e-314
	DD	FLAT:__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DQ 00000000319930522r ; 6.57797e-314
	DD	FLAT:__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000500000000r		; 1.061e-313
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DQ 00000000219930522r ; 4.45598e-314
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@0@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@0@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@2@0@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEXXZ DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DQ 00000000619930522r ; 1.2944e-313
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2
	DQ	00000000000000001r		; 4.94066e-324
	DQ	00000000000000001r		; 4.94066e-324
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DQ 00000000200000002r ; 4.24399e-314
	DQ	00000000100000003r		; 2.122e-314
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$12
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$12 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DQ 00000000619930522r ; 1.2944e-313
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DQ	00000000000000001r		; 4.94066e-324
	DQ	00000000000000001r		; 4.94066e-324
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DQ 00000000200000002r ; 4.24399e-314
	DQ	00000000100000003r		; 2.122e-314
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$11
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$11 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DQ 00000000719930522r ; 1.5066e-313
	DD	FLAT:__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3
	DD	01H
	DD	FLAT:___std_terminate
	DQ	00000000000000001r		; 4.94066e-324
	DQ	00000000000000001r		; 4.94066e-324
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DQ 00000000400000004r ; 8.48798e-314
	DQ	00000000100000005r		; 2.122e-314
	DD	FLAT:__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$35
__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$35 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DQ 00000000519930522r ; 1.0822e-313
	DD	FLAT:__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2
	DQ	00000000000000001r		; 4.94066e-324
	DQ	00000000000000001r		; 4.94066e-324
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DQ 00000000200000002r ; 4.24399e-314
	DQ	00000000100000003r		; 2.122e-314
	DD	FLAT:__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$30
__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$30 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DQ 00000000619930522r ; 1.2944e-313
	DD	FLAT:__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2
	DQ	00000000000000001r		; 4.94066e-324
	DQ	00000000000000001r		; 4.94066e-324
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DQ 00000000200000002r ; 4.24399e-314
	DQ	00000000100000003r		; 2.122e-314
	DD	FLAT:__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$10
__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$10 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000500000000r		; 1.061e-313
__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Buynode@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z DQ 00000000319930522r ; 6.57797e-314
	DD	FLAT:__unwindtable$??$_Buynode@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$_Buynode@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z DQ 000000000ffffffffr ; 2.122e-314
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Buynode@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z$7
	DQ	000000000ffffffffr		; 2.122e-314
__tryblocktable$??$_Buynode@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z DQ 00000000100000000r ; 2.122e-314
	DQ	00000000100000002r		; 2.122e-314
	DD	FLAT:__catchsym$??$_Buynode@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z$10
__catchsym$??$_Buynode@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z$10 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$_Buynode@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z DQ 00000000219930522r ; 4.45598e-314
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z DQ 000000000ffffffffr ; 2.122e-314
	DQ	000000000ffffffffr		; 2.122e-314
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z DQ 00000000000000000r ; 0
	DQ	00000000100000001r		; 2.122e-314
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z$234
__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z$234 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@ABU31@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@ABU31@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@ABU31@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@ABU31@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z DQ 00000000219930522r ; 4.45598e-314
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z DQ 000000000ffffffffr ; 2.122e-314
	DQ	000000000ffffffffr		; 2.122e-314
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z DQ 00000000000000000r ; 0
	DQ	00000000100000001r		; 2.122e-314
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z$98
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z$98 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@PAX@1@@Z$0
xdata$x	ENDS
CRT$XCU	SEGMENT
?G³os$initializer$@@3P6AXXZA DD FLAT:??__EG³os@@YAXXZ	; G³os$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_wylosowana_liczba$ = -432				; size = 4
_this$ = -428						; size = 4
_kwota_zak³adu$ = -428					; size = 4
$T1 = -424						; size = 4
_iloæ_pieniêdzy$ = -424				; size = 4
_co_kontynuowaæ$ = -417					; size = 1
_log_ogólny$ = -416					; size = 176
_log$ = -240						; size = 192
_typ_zak³adu$ = -48					; size = 24
_hCCI$12 = -24						; size = 8
_wygrana$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_main
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a4 01 00
	00		 sub	 esp, 420		; 000001a4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1409 : 	wincl.hIcon = LoadIcon(GetModuleHandle(nullptr), MAKEINTRESOURCE(IDI_ICON1)); //Przypisanie ikony programu

  0002c	6a 6d		 push	 109			; 0000006dH
  0002e	6a 00		 push	 0

; 85   : {

  00030	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 1409 : 	wincl.hIcon = LoadIcon(GetModuleHandle(nullptr), MAKEINTRESOURCE(IDI_ICON1)); //Przypisanie ikony programu

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00040	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__LoadIconA@8
  00046	50		 push	 eax
  00047	ff d6		 call	 esi

; 1410 : 	wincl.hIconSm = LoadIcon(GetModuleHandle(nullptr), MAKEINTRESOURCE(IDI_ICON1));//Przypisanie ma³ej ikony programu

  00049	6a 6d		 push	 109			; 0000006dH
  0004b	6a 00		 push	 0
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00053	50		 push	 eax
  00054	ff d6		 call	 esi

; 1411 : 
; 1412 : 	//Inicjowanie funkcji
; 1413 : 	setlocale(LC_ALL, "polish"); // W celu polskich liter w konsoli

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_06JGCGFIEG@polish?$AA@
  0005b	6a 00		 push	 0
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setlocale
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00063	6a 00		 push	 0
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1414 : 	srand((unsigned int)time(nullptr)); //Zainicjowanie generatorza LCG (Liniowy Generator Kongruentny) dla ma³o wa¿nych liczb

  0006b	50		 push	 eax
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand
  00072	83 c4 10	 add	 esp, 16			; 00000010H

; 401  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00075	6a f5		 push	 -11			; fffffff5H
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  0007d	8b f0		 mov	 esi, eax

; 402  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 403  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0007f	8d 45 e8	 lea	 eax, DWORD PTR _hCCI$12[ebp]
  00082	50		 push	 eax
  00083	56		 push	 esi
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 404  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoæ widocznoci kursorsora tekstego w konsoli jest ró¿na od prawdy

  0008a	83 7d ec 01	 cmp	 DWORD PTR _hCCI$12[ebp+4], 1
  0008e	74 12		 je	 SHORT $LN14@main

; 405  : 	{
; 406  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoci kursora na widoczny
; 407  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  00090	8d 45 e8	 lea	 eax, DWORD PTR _hCCI$12[ebp]
  00093	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _hCCI$12[ebp+4], 1
  0009a	50		 push	 eax
  0009b	56		 push	 esi
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8
$LN14@main:

; 86   : 	Inicjacje_Pocz¹tkowe(); //Zainicjowanie funkcji pocz¹tkowych
; 87   : 
; 88   : 	Sprawd_Ustawienia(); //Wczytanie ustawieñ z pliku

  000a2	e8 00 00 00 00	 call	 ?Sprawd_Ustawienia@@YAXXZ ; Sprawd_Ustawienia

; 89   : 	Sprawd_Pliki(); //Wczytanie plików audio

  000a7	e8 00 00 00 00	 call	 ?Sprawd_Pliki@@YAXXZ	; Sprawd_Pliki
  000ac	68 b0 00 00 00	 push	 176			; 000000b0H
  000b1	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _log_ogólny$[ebp]
  000b7	6a 00		 push	 0
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _memset

; 92   : 	ofstream log_ogólny; //Utworzenie typu do celu zapisu do pliku

  000bf	83 c4 08	 add	 esp, 8
  000c2	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  000c8	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000cd	51		 push	 ecx
  000ce	6a 0a		 push	 10			; 0000000aH
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@
  000d5	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+4]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 92   : 	ofstream log_ogólny; //Utworzenie typu do celu zapisu do pliku

  000db	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000e2	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  000e7	85 c0		 test	 eax, eax

; 1150 : 			_Myios::setstate(ios_base::failbit);

  000e9	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  000ef	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _log_ogólny$[ebp]
  000f5	6a 00		 push	 0
  000f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fa	75 0c		 jne	 SHORT $LN20@main
  000fc	6a 02		 push	 2
  000fe	03 c8		 add	 ecx, eax
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1151 : 		else

  00106	eb 0a		 jmp	 SHORT $LN21@main
$LN20@main:

; 1152 : 			_Myios::clear();	// added with C++11

  00108	6a 00		 push	 0
  0010a	03 c8		 add	 ecx, eax
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN21@main:
  00112	68 c0 00 00 00	 push	 192			; 000000c0H
  00117	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp]
  0011d	6a 00		 push	 0
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 _memset
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1206 : 		{	// construct unopened

  00128	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00132	8d 4d 88	 lea	 ecx, DWORD PTR _log$[ebp+120]
  00135	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+16], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00145	6a 00		 push	 0
  00147	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp+24]
  0014d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00151	50		 push	 eax
  00152	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp]
  00158	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T1[ebp], 1
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00168	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0016f	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
  00175	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00178	c7 84 05 10 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _log$[ebp+eax], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00183	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
  00189	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0018c	8d 41 88	 lea	 eax, DWORD PTR [ecx-120]
  0018f	89 84 0d 0c ff
	ff ff		 mov	 DWORD PTR _log$[ebp+ecx-4], eax
  00196	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp+24]

; 155  : 		: _Mysb()

  0019c	8b c8		 mov	 ecx, eax

; 1206 : 		{	// construct unopened

  0019e	89 85 54 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 155  : 		: _Mysb()

  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  001aa	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  001ae	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+24]

; 156  : 		{	// construct from pointer to C stream

  001b4	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+24], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 636  : 		_Closef = _Which == _Openfl;

  001be	c6 85 70 ff ff
	ff 00		 mov	 BYTE PTR _log$[ebp+96], 0

; 637  : 		_Wrotesome = false;

  001c5	c6 85 65 ff ff
	ff 00		 mov	 BYTE PTR _log$[ebp+85], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  001cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;
; 663  : 		_State = _Stinit;

  001d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  001d7	89 85 68 ff ff
	ff		 mov	 DWORD PTR _log$[ebp+88], eax
  001dd	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  001e2	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+100], 0
  001ec	89 85 6c ff ff
	ff		 mov	 DWORD PTR _log$[ebp+92], eax

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  001f2	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+80], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 95   : 	int iloæ_pieniêdzy = Ustawienia.kwota_pocz¹tkowa, kwota_zak³adu, wylosowana_liczba, wygrana; //Zmienne do których wczytuje siê wartoci liczbowe pobrane od u¿ytkownika takie jak kwota zak³adu a przechowuje iloæ posiadanych pieniêdzy a tak¿e przechowuje wyniki funkcji losowania liczby z ruletki i kwote wygran¹ z zak³adu

  001fc	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12
  00201	89 85 58 fe ff
	ff		 mov	 DWORD PTR _iloæ_pieniêdzy$[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00207	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0020e	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00215	c6 45 d0 00	 mov	 BYTE PTR _typ_zak³adu$[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 99   : 	Wczytaj_z_Pliku(log_ogólny, log, co_kontynuowaæ, iloæ_pieniêdzy, kwota_zak³adu, wylosowana_liczba, typ_zak³adu); //Wczytanie stanu gry z pliku

  00219	8d 45 d0	 lea	 eax, DWORD PTR _typ_zak³adu$[ebp]
  0021c	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00220	50		 push	 eax
  00221	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00227	50		 push	 eax
  00228	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _kwota_zak³adu$[ebp]
  0022e	50		 push	 eax
  0022f	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00235	50		 push	 eax
  00236	8d 85 5f fe ff
	ff		 lea	 eax, DWORD PTR _co_kontynuowaæ$[ebp]
  0023c	50		 push	 eax
  0023d	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR _log$[ebp]
  00243	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  00249	e8 00 00 00 00	 call	 ?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Wczytaj_z_Pliku
  0024e	83 c4 14	 add	 esp, 20			; 00000014H
$LL4@main:

; 100  : 
; 101  : 	do
; 102  : 	{
; 103  : 		Pêtla_G³ówna(wygrana, kwota_zak³adu, iloæ_pieniêdzy, log_ogólny, log, co_kontynuowaæ, typ_zak³adu, wylosowana_liczba); //Funkcja obs³uguj¹ca wszystkie elementy gry

  00251	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00257	50		 push	 eax
  00258	8d 45 d0	 lea	 eax, DWORD PTR _typ_zak³adu$[ebp]
  0025b	50		 push	 eax
  0025c	8d 85 5f fe ff
	ff		 lea	 eax, DWORD PTR _co_kontynuowaæ$[ebp]
  00262	50		 push	 eax
  00263	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp]
  00269	50		 push	 eax
  0026a	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _log_ogólny$[ebp]
  00270	50		 push	 eax
  00271	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00277	50		 push	 eax
  00278	8d 95 54 fe ff
	ff		 lea	 edx, DWORD PTR _kwota_zak³adu$[ebp]
  0027e	8d 4d ec	 lea	 ecx, DWORD PTR _wygrana$[ebp]
  00281	e8 00 00 00 00	 call	 ?Pêtla_G³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; Pêtla_G³ówna
  00286	83 c4 18	 add	 esp, 24			; 00000018H

; 104  : 		co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  00289	c6 85 5f fe ff
	ff 6e		 mov	 BYTE PTR _co_kontynuowaæ$[ebp], 110 ; 0000006eH

; 105  : 	} while (Czy_Kontynuowaæ(iloæ_pieniêdzy)); //Pêtla dza³aj¹ca do czasu wartoci fa³sz zwróconej przez funkcjê Czy_kontynuowaæ

  00290	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00296	e8 00 00 00 00	 call	 ?Czy_Kontynuowaæ@@YA_NABH@Z ; Czy_Kontynuowaæ
  0029b	84 c0		 test	 al, al
  0029d	75 b2		 jne	 SHORT $LL4@main

; 106  : 
; 107  : 	Koniec_Gry(log_ogólny, log, iloæ_pieniêdzy); //Zakoñczenie gry i wskazanie wyniku

  0029f	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  002a5	50		 push	 eax
  002a6	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR _log$[ebp]
  002ac	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  002b2	e8 00 00 00 00	 call	 ?Koniec_Gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z ; Koniec_Gry

; 109  : 	system("pause"); //Wywo³anie funkcji wymagaj¹cej do zamkniêcia naciniêcie dowolnego klawisza

  002b7	68 00 00 00 00	 push	 OFFSET ??_C@_05PDJBBECF@pause?$AA@
  002bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__system
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002c2	8b 55 e4	 mov	 edx, DWORD PTR _typ_zak³adu$[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 109  : 	system("pause"); //Wywo³anie funkcji wymagaj¹cej do zamkniêcia naciniêcie dowolnego klawisza

  002c5	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002c8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  002cb	72 3e		 jb	 SHORT $LN100@main
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002cd	8b 4d d0	 mov	 ecx, DWORD PTR _typ_zak³adu$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002d0	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002d1	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  002d3	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002d9	72 26		 jb	 SHORT $LN103@main

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  002db	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  002de	3b f2		 cmp	 esi, edx
  002e0	76 19		 jbe	 SHORT $_Invalid_parameter$153

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  002e2	8b d6		 mov	 edx, esi
  002e4	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  002e6	75 13		 jne	 SHORT $_Invalid_parameter$153

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002e8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002eb	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  002ed	73 0c		 jae	 SHORT $_Invalid_parameter$153

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  002ef	2b c1		 sub	 eax, ecx
  002f1	83 f8 04	 cmp	 eax, 4
  002f4	72 05		 jb	 SHORT $_Invalid_parameter$153

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  002f6	83 f8 23	 cmp	 eax, 35			; 00000023H
  002f9	76 06		 jbe	 SHORT $LN103@main
$_Invalid_parameter$153:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN152@main:
$LN103@main:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00301	52		 push	 edx
  00302	51		 push	 ecx
  00303	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00308	83 c4 08	 add	 esp, 8
$LN100@main:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1352 : 		{	// destroy the object

  0030b	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00311	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00318	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0031f	c6 45 d0 00	 mov	 BYTE PTR _typ_zak³adu$[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1352 : 		{	// destroy the object

  00323	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00326	c7 84 05 10 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _log$[ebp+eax], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00331	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
  00337	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0033a	8d 41 88	 lea	 eax, DWORD PTR [ecx-120]
  0033d	89 84 0d 0c ff
	ff ff		 mov	 DWORD PTR _log$[ebp+ecx-4], eax

; 1353 : 		}

  00344	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+24]
  0034a	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0034f	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+32]
  00355	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0035b	8d 4d 88	 lea	 ecx, DWORD PTR _log$[ebp+120]
  0035e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ

; 1132 : 		{	// destroy the object

  00364	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _log_ogólny$[ebp]
  0036a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0036d	c7 84 05 60 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _log_ogólny$[ebp+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00378	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _log_ogólny$[ebp]
  0037e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00381	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00384	89 84 0d 5c fe
	ff ff		 mov	 DWORD PTR _log_ogólny$[ebp+ecx-4], eax

; 1133 : 		}

  0038b	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+4]
  00391	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00396	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+8]
  0039c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  003a2	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+104]
  003a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 111  : 	return 0; //Zwrócenie wartoæ 0, czyli porogram zakoñczy³ siê bez b³êdu

  003ae	33 c0		 xor	 eax, eax

; 112  : }

  003b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003ba	59		 pop	 ecx
  003bb	5e		 pop	 esi
  003bc	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003bf	33 cd		 xor	 ecx, ebp
  003c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c6	8b e5		 mov	 esp, ebp
  003c8	5d		 pop	 ebp
  003c9	c3		 ret	 0
$LN151@main:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
  00000	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$_main$5:
  0000b	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00011	83 e0 01	 and	 eax, 1
  00014	0f 84 10 00 00
	00		 je	 $LN30@main
  0001a	83 a5 58 fe ff
	ff fe		 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00021	8d 4d 88	 lea	 ecx, DWORD PTR _log$[ebp+120]
  00024	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN30@main:
  0002a	c3		 ret	 0
__unwindfunclet$_main$6:
  0002b	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+32]
  00031	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$_main$8:
  00037	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$_main$1:
  00043	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp]
  00049	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$_main$2:
  0004e	8d 4d d0	 lea	 ecx, DWORD PTR _typ_zak³adu$[ebp]
  00051	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$_main:
  00056	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0005d	8b 8a 54 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-428]
  00063	33 c8		 xor	 ecx, eax
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0006d	33 c8		 xor	 ecx, eax
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_main
  00079	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T190 = -480						; size = 24
_this$ = -456						; size = 4
_this$ = -456						; size = 4
$T192 = -452						; size = 24
$T160 = -452						; size = 24
$T22 = -452						; size = 24
$T191 = -428						; size = 24
$T152 = -428						; size = 24
$T14 = -428						; size = 24
$T189 = -404						; size = 24
$T142 = -404						; size = 24
$T130 = -404						; size = 24
$T119 = -404						; size = 24
$T98 = -404						; size = 24
$T87 = -404						; size = 24
$T66 = -404						; size = 24
$T55 = -404						; size = 24
$T7 = -404						; size = 24
_wylosowana_liczba$GSCopy$1$ = -380			; size = 4
$T146 = -380						; size = 1
_numers$198 = -376					; size = 176
_numers$ = -200						; size = 176
tv5337 = -24						; size = 4
tv5336 = -24						; size = 4
tv5335 = -24						; size = 4
__Ch$ = -24						; size = 1
$T1 = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Odczytaj_Liczbê, COMDAT
; _wylosowana_liczba$ = ecx
; _typ_zak³adu$ = edx

; 433  : void Odczytaj_Liczbê(const int & wylosowana_liczba, const string & typ_zak³adu) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 ec d0 01 00
	00		 sub	 esp, 464		; 000001d0H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	56		 push	 esi
  00036	57		 push	 edi
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	8b f2		 mov	 esi, edx
  00043	8b f9		 mov	 edi, ecx
  00045	89 bd 84 fe ff
	ff		 mov	 DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp], edi
  0004b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 434  : 	if ((Ustawienia.g³os_odczytu_numeru == 0) || (!G³osyKompletne)) return; //Je¿eli ustawienia wy³¹czaj¹ g³os lub brak plików g³osu to wyjd z funkcji

  00052	66 83 3d 14 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, 0
  0005a	0f 84 4b 0a 00
	00		 je	 $LN3@Odczytaj_L
  00060	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  00067	0f 84 3e 0a 00
	00		 je	 $LN3@Odczytaj_L
  0006d	68 b0 00 00 00	 push	 176			; 000000b0H
  00072	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _numers$[ebp]
  00078	6a 00		 push	 0
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _memset
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 590  : 		{	// construct empty character buffer

  00083	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0008d	8d 4d a0	 lea	 ecx, DWORD PTR _numers$[ebp+104]
  00090	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  000a0	6a 00		 push	 0
  000a2	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _numers$[ebp+24]
  000a8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000af	50		 push	 eax
  000b0	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp]
  000b6	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  000c3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000ca	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  000d0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d3	c7 84 05 38 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  000de	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  000e4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e7	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  000ea	89 84 0d 34 ff
	ff ff		 mov	 DWORD PTR _numers$[ebp+ecx-4], eax
  000f1	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _numers$[ebp+24]

; 30   : 		{	// construct empty character buffer from mode

  000f7	8b c8		 mov	 ecx, eax

; 589  : 			_Stringbuffer(_Mode)

  000f9	89 85 38 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00105	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

  0010f	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _numers$[ebp+80], 0

; 312  : 		_Mystate = _State;

  00116	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _numers$[ebp+84], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 436  : 	stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  0011d	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 437  : 	numers << wylosowana_liczba; //Wpisanie to typu wylosowanej liczby

  00124	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+16]
  0012a	ff 37		 push	 DWORD PTR [edi]
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 644  : 		return (_Stringbuffer.str());

  00132	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00138	50		 push	 eax
  00139	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+24]
  0013f	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3805 : 	return (_STD move(_Right.insert(0, _Left)));

  00144	68 00 00 00 00	 push	 OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00149	51		 push	 ecx
  0014a	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 438  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  00150	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3805 : 	return (_STD move(_Right.insert(0, _Left)));

  00154	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1563 : 		_Mysize(0),

  00159	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+16], 0

; 1564 : 		_Myres(0)

  00163	c7 85 68 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0016d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00170	0f 11 85 54 fe
	ff ff		 movups	 XMMWORD PTR $T14[ebp], xmm0
  00177	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0017c	66 0f d6 85 64
	fe ff ff	 movq	 QWORD PTR $T14[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  00184	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0018b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00192	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 438  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  00195	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  0019a	8d 95 54 fe ff
	ff		 lea	 edx, DWORD PTR $T14[ebp]
  001a0	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  001a4	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  001aa	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  001af	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001b2	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  001b6	72 02		 jb	 SHORT $LN668@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001b8	8b 00		 mov	 eax, DWORD PTR [eax]
$LN668@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 438  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  001ba	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PlaySoundA@12
  001c0	6a 00		 push	 0
  001c2	6a 00		 push	 0
  001c4	50		 push	 eax
  001c5	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001c7	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+20]
  001cd	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  001d0	72 4c		 jb	 SHORT $LN712@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001d2	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001d8	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001d9	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001db	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001e1	72 31		 jb	 SHORT $LN715@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001e3	8d 7a 23	 lea	 edi, DWORD PTR [edx+35]
  001e6	89 7d e8	 mov	 DWORD PTR tv5337[ebp], edi
  001e9	3b fa		 cmp	 edi, edx
  001eb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PlaySoundA@12
  001f1	76 1b		 jbe	 SHORT $_Invalid_parameter$2395

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001f3	8b 55 e8	 mov	 edx, DWORD PTR tv5337[ebp]
  001f6	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001f9	75 13		 jne	 SHORT $_Invalid_parameter$2395

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001fb	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  001fe	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00200	73 0c		 jae	 SHORT $_Invalid_parameter$2395

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00202	2b c8		 sub	 ecx, eax
  00204	83 f9 04	 cmp	 ecx, 4
  00207	72 05		 jb	 SHORT $_Invalid_parameter$2395

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00209	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0020c	76 06		 jbe	 SHORT $LN715@Odczytaj_L
$_Invalid_parameter$2395:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2383@Odczytaj_L:
$LN715@Odczytaj_L:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00214	52		 push	 edx
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0021b	83 c4 08	 add	 esp, 8
$LN712@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 438  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  0021e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00222	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR $T14[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00228	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00232	c7 85 50 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T22[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0023c	c6 85 3c fe ff
	ff 00		 mov	 BYTE PTR $T22[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00243	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00246	72 4c		 jb	 SHORT $LN783@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00248	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR $T14[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0024e	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0024f	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00251	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00257	72 31		 jb	 SHORT $LN786@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00259	8d 7a 23	 lea	 edi, DWORD PTR [edx+35]
  0025c	89 7d e8	 mov	 DWORD PTR tv5336[ebp], edi
  0025f	3b fa		 cmp	 edi, edx
  00261	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PlaySoundA@12
  00267	76 1b		 jbe	 SHORT $_Invalid_parameter$2396

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00269	8b 55 e8	 mov	 edx, DWORD PTR tv5336[ebp]
  0026c	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0026f	75 13		 jne	 SHORT $_Invalid_parameter$2396

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00271	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00274	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00276	73 0c		 jae	 SHORT $_Invalid_parameter$2396

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00278	2b c8		 sub	 ecx, eax
  0027a	83 f9 04	 cmp	 ecx, 4
  0027d	72 05		 jb	 SHORT $_Invalid_parameter$2396

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0027f	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00282	76 06		 jbe	 SHORT $LN786@Odczytaj_L
$_Invalid_parameter$2396:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2384@Odczytaj_L:
$LN786@Odczytaj_L:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0028a	52		 push	 edx
  0028b	50		 push	 eax
  0028c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00291	83 c4 08	 add	 esp, 8
$LN783@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 438  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  00294	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00298	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T7[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  0029e	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  002a8	c7 85 68 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T14[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  002b2	c6 85 54 fe ff
	ff 00		 mov	 BYTE PTR $T14[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002b9	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  002bc	72 4c		 jb	 SHORT $LN854@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002be	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002c4	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002c5	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  002c7	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002cd	72 31		 jb	 SHORT $LN857@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  002cf	8d 7a 23	 lea	 edi, DWORD PTR [edx+35]
  002d2	89 7d e8	 mov	 DWORD PTR tv5335[ebp], edi
  002d5	3b fa		 cmp	 edi, edx
  002d7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PlaySoundA@12
  002dd	76 1b		 jbe	 SHORT $_Invalid_parameter$2397

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  002df	8b 55 e8	 mov	 edx, DWORD PTR tv5335[ebp]
  002e2	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  002e5	75 13		 jne	 SHORT $_Invalid_parameter$2397

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002e7	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  002ea	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  002ec	73 0c		 jae	 SHORT $_Invalid_parameter$2397

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  002ee	2b c8		 sub	 ecx, eax
  002f0	83 f9 04	 cmp	 ecx, 4
  002f3	72 05		 jb	 SHORT $_Invalid_parameter$2397

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  002f5	83 f9 23	 cmp	 ecx, 35			; 00000023H
  002f8	76 06		 jbe	 SHORT $LN857@Odczytaj_L
$_Invalid_parameter$2397:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2385@Odczytaj_L:
$LN857@Odczytaj_L:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00300	52		 push	 edx
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00307	83 c4 08	 add	 esp, 8
$LN854@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 439  : 	if (wylosowana_liczba != 0)

  0030a	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  00310	8b 00		 mov	 eax, DWORD PTR [eax]
  00312	85 c0		 test	 eax, eax
  00314	0f 84 4a 07 00
	00		 je	 $LN1086@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0031a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0031d	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0031f	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00322	72 02		 jb	 SHORT $LN2361@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00324	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2361@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00326	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00329	83 fa 01	 cmp	 edx, 1
  0032c	75 14		 jne	 SHORT $LN910@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0032e	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00331	3c 70		 cmp	 al, 112			; 00000070H
  00333	75 04		 jne	 SHORT $LN2368@Odczytaj_L
  00335	33 c0		 xor	 eax, eax
  00337	eb 05		 jmp	 SHORT $LN2369@Odczytaj_L
$LN2368@Odczytaj_L:
  00339	1b c0		 sbb	 eax, eax
  0033b	83 c8 01	 or	 eax, 1
$LN2369@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0033e	85 c0		 test	 eax, eax
  00340	74 2a		 je	 SHORT $LN7@Odczytaj_L
$LN910@Odczytaj_L:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00342	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00344	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00347	72 02		 jb	 SHORT $LN2362@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00349	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2362@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0034b	83 fa 01	 cmp	 edx, 1
  0034e	0f 85 02 01 00
	00		 jne	 $LN939@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00354	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00357	3c 6e		 cmp	 al, 110			; 0000006eH
  00359	75 04		 jne	 SHORT $LN2370@Odczytaj_L
  0035b	33 c0		 xor	 eax, eax
  0035d	eb 05		 jmp	 SHORT $LN2371@Odczytaj_L
$LN2370@Odczytaj_L:
  0035f	1b c0		 sbb	 eax, eax
  00361	83 c8 01	 or	 eax, 1
$LN2371@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00364	85 c0		 test	 eax, eax
  00366	0f 85 ea 00 00
	00		 jne	 $LN939@Odczytaj_L
$LN7@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 441  : 			if (wylosowana_liczba % 2 == 0) //Je¿eli wylosowana liczba modulo 2 jest 0 to

  0036c	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]

; 442  : 				PlaySound((G³os + "p.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana licza jest parzysta

  00372	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00377	8b 01		 mov	 eax, DWORD PTR [ecx]
  00379	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]
  0037f	a8 01		 test	 al, 1
  00381	75 71		 jne	 SHORT $LN8@Odczytaj_L
  00383	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  00388	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0038d	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00390	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00394	72 02		 jb	 SHORT $LN955@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00396	8b 00		 mov	 eax, DWORD PTR [eax]
$LN955@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 442  : 				PlaySound((G³os + "p.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana licza jest parzysta

  00398	6a 00		 push	 0
  0039a	6a 00		 push	 0
  0039c	50		 push	 eax
  0039d	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0039f	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T55[ebp+20]
  003a5	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  003a8	0f 82 b6 06 00
	00		 jb	 $LN1086@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  003ae	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T55[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  003b4	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  003b5	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  003b7	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  003bd	72 26		 jb	 SHORT $LN1002@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  003bf	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  003c2	3b f2		 cmp	 esi, edx
  003c4	76 19		 jbe	 SHORT $_Invalid_parameter$2398

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  003c6	8b d6		 mov	 edx, esi
  003c8	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  003ca	75 13		 jne	 SHORT $_Invalid_parameter$2398

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  003cc	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  003cf	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  003d1	73 0c		 jae	 SHORT $_Invalid_parameter$2398

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  003d3	2b c1		 sub	 eax, ecx
  003d5	83 f8 04	 cmp	 eax, 4
  003d8	72 05		 jb	 SHORT $_Invalid_parameter$2398

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  003da	83 f8 23	 cmp	 eax, 35			; 00000023H
  003dd	76 06		 jbe	 SHORT $LN1002@Odczytaj_L
$_Invalid_parameter$2398:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  003df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2386@Odczytaj_L:
$LN1002@Odczytaj_L:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  003e5	52		 push	 edx
  003e6	51		 push	 ecx
  003e7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003ec	83 c4 08	 add	 esp, 8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 443  : 			else

  003ef	e9 70 06 00 00	 jmp	 $LN1086@Odczytaj_L
$LN8@Odczytaj_L:

; 444  : 				PlaySound((G³os + "n.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana licza jest nieparzysta

  003f4	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  003f9	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  003fe	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00401	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00405	72 02		 jb	 SHORT $LN1042@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00407	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1042@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 444  : 				PlaySound((G³os + "n.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana licza jest nieparzysta

  00409	6a 00		 push	 0
  0040b	6a 00		 push	 0
  0040d	50		 push	 eax
  0040e	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00410	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T66[ebp+20]
  00416	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00419	0f 82 45 06 00
	00		 jb	 $LN1086@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0041f	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T66[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00425	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00426	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00428	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0042e	72 b5		 jb	 SHORT $LN1002@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00430	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00433	3b f2		 cmp	 esi, edx
  00435	76 19		 jbe	 SHORT $_Invalid_parameter$2399

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00437	8b d6		 mov	 edx, esi
  00439	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0043b	75 13		 jne	 SHORT $_Invalid_parameter$2399

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0043d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00440	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00442	73 0c		 jae	 SHORT $_Invalid_parameter$2399

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00444	2b c1		 sub	 eax, ecx
  00446	83 f8 04	 cmp	 eax, 4
  00449	72 05		 jb	 SHORT $_Invalid_parameter$2399

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0044b	83 f8 23	 cmp	 eax, 35			; 00000023H
  0044e	76 95		 jbe	 SHORT $LN1002@Odczytaj_L
$_Invalid_parameter$2399:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00450	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2387@Odczytaj_L:
$LN939@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00456	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00458	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0045b	72 02		 jb	 SHORT $LN2363@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0045d	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2363@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0045f	83 fa 01	 cmp	 edx, 1
  00462	75 14		 jne	 SHORT $LN1142@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00464	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00467	3c 72		 cmp	 al, 114			; 00000072H
  00469	75 04		 jne	 SHORT $LN2372@Odczytaj_L
  0046b	33 c0		 xor	 eax, eax
  0046d	eb 05		 jmp	 SHORT $LN2373@Odczytaj_L
$LN2372@Odczytaj_L:
  0046f	1b c0		 sbb	 eax, eax
  00471	83 c8 01	 or	 eax, 1
$LN2373@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00474	85 c0		 test	 eax, eax
  00476	74 2a		 je	 SHORT $LN12@Odczytaj_L
$LN1142@Odczytaj_L:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00478	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0047a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0047d	72 02		 jb	 SHORT $LN2364@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0047f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2364@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00481	83 fa 01	 cmp	 edx, 1
  00484	0f 85 08 01 00
	00		 jne	 $LN1171@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0048a	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0048d	3c 62		 cmp	 al, 98			; 00000062H
  0048f	75 04		 jne	 SHORT $LN2374@Odczytaj_L
  00491	33 c0		 xor	 eax, eax
  00493	eb 05		 jmp	 SHORT $LN2375@Odczytaj_L
$LN2374@Odczytaj_L:
  00495	1b c0		 sbb	 eax, eax
  00497	83 c8 01	 or	 eax, 1
$LN2375@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0049a	85 c0		 test	 eax, eax
  0049c	0f 85 f0 00 00
	00		 jne	 $LN1171@Odczytaj_L
$LN12@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 446  : 			if (Ruletka_plansza_kolor[wylosowana_liczba] == 'r') //Je¿eli kolor wylosowanej liczby to czerwony

  004a2	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]

; 447  : 				PlaySound((G³os + "r.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest koloru czerwonego

  004a8	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  004ad	8b 01		 mov	 eax, DWORD PTR [ecx]
  004af	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T87[ebp]
  004b5	80 b8 00 00 00
	00 72		 cmp	 BYTE PTR ?Ruletka_plansza_kolor@@3QBDB[eax], 114 ; 00000072H
  004bc	75 6a		 jne	 SHORT $LN13@Odczytaj_L
  004be	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  004c3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  004c8	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004cb	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  004cf	72 02		 jb	 SHORT $LN1187@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004d1	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1187@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 447  : 				PlaySound((G³os + "r.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest koloru czerwonego

  004d3	6a 00		 push	 0
  004d5	6a 00		 push	 0
  004d7	50		 push	 eax
  004d8	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004da	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T87[ebp+20]
  004e0	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  004e3	0f 82 7b 05 00
	00		 jb	 $LN1086@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  004e9	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T87[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  004ef	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  004f0	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  004f2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  004f8	0f 82 e7 fe ff
	ff		 jb	 $LN1002@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  004fe	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00501	3b f2		 cmp	 esi, edx
  00503	76 1d		 jbe	 SHORT $_Invalid_parameter$2400

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00505	8b d6		 mov	 edx, esi
  00507	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00509	75 17		 jne	 SHORT $_Invalid_parameter$2400

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0050b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0050e	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00510	73 10		 jae	 SHORT $_Invalid_parameter$2400

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00512	2b c1		 sub	 eax, ecx
  00514	83 f8 04	 cmp	 eax, 4
  00517	72 09		 jb	 SHORT $_Invalid_parameter$2400

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00519	83 f8 23	 cmp	 eax, 35			; 00000023H
  0051c	0f 86 c3 fe ff
	ff		 jbe	 $LN1002@Odczytaj_L
$_Invalid_parameter$2400:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00522	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2388@Odczytaj_L:
$LN13@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 449  : 				PlaySound((G³os + "b.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e liczba jest koloru czarnego

  00528	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  0052d	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00532	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00535	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00539	72 02		 jb	 SHORT $LN1274@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0053b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1274@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 449  : 				PlaySound((G³os + "b.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e liczba jest koloru czarnego

  0053d	6a 00		 push	 0
  0053f	6a 00		 push	 0
  00541	50		 push	 eax
  00542	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00544	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T98[ebp+20]
  0054a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  0054d	0f 82 11 05 00
	00		 jb	 $LN1086@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00553	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T98[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00559	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0055a	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0055c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00562	0f 82 7d fe ff
	ff		 jb	 $LN1002@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00568	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  0056b	3b f2		 cmp	 esi, edx
  0056d	76 1d		 jbe	 SHORT $_Invalid_parameter$2401

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0056f	8b d6		 mov	 edx, esi
  00571	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00573	75 17		 jne	 SHORT $_Invalid_parameter$2401

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00575	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00578	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0057a	73 10		 jae	 SHORT $_Invalid_parameter$2401

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0057c	2b c1		 sub	 eax, ecx
  0057e	83 f8 04	 cmp	 eax, 4
  00581	72 09		 jb	 SHORT $_Invalid_parameter$2401

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00583	83 f8 23	 cmp	 eax, 35			; 00000023H
  00586	0f 86 59 fe ff
	ff		 jbe	 $LN1002@Odczytaj_L
$_Invalid_parameter$2401:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0058c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2389@Odczytaj_L:
$LN1171@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00592	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00594	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00597	72 02		 jb	 SHORT $LN2365@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00599	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2365@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0059b	83 fa 01	 cmp	 edx, 1
  0059e	75 14		 jne	 SHORT $LN1374@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005a0	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  005a3	3c 67		 cmp	 al, 103			; 00000067H
  005a5	75 04		 jne	 SHORT $LN2376@Odczytaj_L
  005a7	33 c0		 xor	 eax, eax
  005a9	eb 05		 jmp	 SHORT $LN2377@Odczytaj_L
$LN2376@Odczytaj_L:
  005ab	1b c0		 sbb	 eax, eax
  005ad	83 c8 01	 or	 eax, 1
$LN2377@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005b0	85 c0		 test	 eax, eax
  005b2	74 2a		 je	 SHORT $LN17@Odczytaj_L
$LN1374@Odczytaj_L:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  005b4	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005b6	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  005b9	72 02		 jb	 SHORT $LN2366@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005bb	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2366@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005bd	83 fa 01	 cmp	 edx, 1
  005c0	0f 85 02 01 00
	00		 jne	 $LN1403@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005c6	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  005c9	3c 64		 cmp	 al, 100			; 00000064H
  005cb	75 04		 jne	 SHORT $LN2378@Odczytaj_L
  005cd	33 c0		 xor	 eax, eax
  005cf	eb 05		 jmp	 SHORT $LN2379@Odczytaj_L
$LN2378@Odczytaj_L:
  005d1	1b c0		 sbb	 eax, eax
  005d3	83 c8 01	 or	 eax, 1
$LN2379@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005d6	85 c0		 test	 eax, eax
  005d8	0f 85 ea 00 00
	00		 jne	 $LN1403@Odczytaj_L
$LN17@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 451  : 			if (wylosowana_liczba < 19) //Je¿eli wylosowa liczba jest mniejsza ni¿ 19

  005de	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]

; 452  : 				PlaySound((G³os + "g.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest z górnej po³ówki

  005e4	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  005e9	83 39 13	 cmp	 DWORD PTR [ecx], 19	; 00000013H
  005ec	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T119[ebp]
  005f2	7d 6a		 jge	 SHORT $LN18@Odczytaj_L
  005f4	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  005f9	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  005fe	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00601	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00605	72 02		 jb	 SHORT $LN1419@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00607	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1419@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 452  : 				PlaySound((G³os + "g.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest z górnej po³ówki

  00609	6a 00		 push	 0
  0060b	6a 00		 push	 0
  0060d	50		 push	 eax
  0060e	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00610	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T119[ebp+20]
  00616	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00619	0f 82 45 04 00
	00		 jb	 $LN1086@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0061f	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T119[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00625	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00626	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00628	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0062e	0f 82 b1 fd ff
	ff		 jb	 $LN1002@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00634	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00637	3b f2		 cmp	 esi, edx
  00639	76 1d		 jbe	 SHORT $_Invalid_parameter$2402

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0063b	8b d6		 mov	 edx, esi
  0063d	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0063f	75 17		 jne	 SHORT $_Invalid_parameter$2402

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00641	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00644	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00646	73 10		 jae	 SHORT $_Invalid_parameter$2402

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00648	2b c1		 sub	 eax, ecx
  0064a	83 f8 04	 cmp	 eax, 4
  0064d	72 09		 jb	 SHORT $_Invalid_parameter$2402

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0064f	83 f8 23	 cmp	 eax, 35			; 00000023H
  00652	0f 86 8d fd ff
	ff		 jbe	 $LN1002@Odczytaj_L
$_Invalid_parameter$2402:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00658	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2390@Odczytaj_L:
$LN18@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 454  : 				PlaySound((G³os + "d.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana liczba jest z dolnej po³ówki

  0065e	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  00663	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00668	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0066b	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0066f	72 02		 jb	 SHORT $LN1506@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00671	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1506@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 454  : 				PlaySound((G³os + "d.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana liczba jest z dolnej po³ówki

  00673	6a 00		 push	 0
  00675	6a 00		 push	 0
  00677	50		 push	 eax
  00678	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0067a	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T130[ebp+20]
  00680	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00683	0f 82 db 03 00
	00		 jb	 $LN1086@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00689	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T130[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0068f	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00690	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00692	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00698	0f 82 47 fd ff
	ff		 jb	 $LN1002@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0069e	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  006a1	3b f2		 cmp	 esi, edx
  006a3	76 1d		 jbe	 SHORT $_Invalid_parameter$2403

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  006a5	8b d6		 mov	 edx, esi
  006a7	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  006a9	75 17		 jne	 SHORT $_Invalid_parameter$2403

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  006ab	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  006ae	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  006b0	73 10		 jae	 SHORT $_Invalid_parameter$2403

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  006b2	2b c1		 sub	 eax, ecx
  006b4	83 f8 04	 cmp	 eax, 4
  006b7	72 09		 jb	 SHORT $_Invalid_parameter$2403

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  006b9	83 f8 23	 cmp	 eax, 35			; 00000023H
  006bc	0f 86 23 fd ff
	ff		 jbe	 $LN1002@Odczytaj_L
$_Invalid_parameter$2403:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  006c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2391@Odczytaj_L:
$LN1403@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  006c8	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006ca	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  006cd	72 02		 jb	 SHORT $LN2367@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  006cf	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2367@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 455  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  006d1	80 38 6b	 cmp	 BYTE PTR [eax], 107	; 0000006bH
  006d4	0f 85 f3 01 00
	00		 jne	 $LN20@Odczytaj_L

; 456  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  006da	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  006df	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  006e4	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T142[ebp]
  006ea	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  006ef	83 c4 04	 add	 esp, 4
  006f2	8b f0		 mov	 esi, eax
  006f4	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  006f8	b9 03 00 00 00	 mov	 ecx, 3
  006fd	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  00703	8b 00		 mov	 eax, DWORD PTR [eax]
  00705	48		 dec	 eax
  00706	99		 cdq
  00707	f7 f9		 idiv	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  00709	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 456  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  0070c	80 c2 31	 add	 dl, 49			; 00000031H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3870 : 	_Left.push_back(_Right);

  0070f	88 55 e8	 mov	 BYTE PTR __Ch$[ebp], dl

; 2977 : 		if (_Old_size < _My_data._Myres)

  00712	3b 4e 14	 cmp	 ecx, DWORD PTR [esi+20]
  00715	73 1a		 jae	 SHORT $LN1603@Odczytaj_L

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00717	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2979 : 			_My_data._Mysize = _Old_size + 1;

  0071b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0071e	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00721	8b c6		 mov	 eax, esi

; 1583 : 		if (_Large_string_engaged())

  00723	72 02		 jb	 SHORT $LN1612@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00725	8b 06		 mov	 eax, DWORD PTR [esi]
$LN1612@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00727	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  0072a	c6 44 08 01 00	 mov	 BYTE PTR [eax+ecx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  0072f	eb 18		 jmp	 SHORT $LN1602@Odczytaj_L
$LN1603@Odczytaj_L:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  00731	ff 75 e8	 push	 DWORD PTR __Ch$[ebp]
  00734	c6 85 84 fe ff
	ff 00		 mov	 BYTE PTR $T146[ebp], 0
  0073b	ff b5 84 fe ff
	ff		 push	 DWORD PTR $T146[ebp]
  00741	51		 push	 ecx
  00742	8b ce		 mov	 ecx, esi
  00744	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN1602@Odczytaj_L:

; 1563 : 		_Mysize(0),

  00749	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T152[ebp+16], 0

; 1564 : 		_Myres(0)

  00753	c7 85 68 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T152[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0075d	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00760	0f 11 85 54 fe
	ff ff		 movups	 XMMWORD PTR $T152[ebp], xmm0
  00767	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  0076c	66 0f d6 85 64
	fe ff ff	 movq	 QWORD PTR $T152[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  00774	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0077b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00782	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 456  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  00785	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  0078a	8d 95 54 fe ff
	ff		 lea	 edx, DWORD PTR $T152[ebp]
  00790	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00794	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T160[ebp]
  0079a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0079f	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007a2	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  007a6	72 02		 jb	 SHORT $LN1695@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  007a8	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1695@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 456  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  007aa	6a 00		 push	 0
  007ac	6a 00		 push	 0
  007ae	50		 push	 eax
  007af	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007b1	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR $T160[ebp+20]
  007b7	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  007ba	72 41		 jb	 SHORT $LN1739@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  007bc	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR $T160[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  007c2	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  007c3	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  007c5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  007cb	72 26		 jb	 SHORT $LN1742@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  007cd	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  007d0	3b f2		 cmp	 esi, edx
  007d2	76 19		 jbe	 SHORT $_Invalid_parameter$2404

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  007d4	8b d6		 mov	 edx, esi
  007d6	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  007d8	75 13		 jne	 SHORT $_Invalid_parameter$2404

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  007da	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  007dd	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  007df	73 0c		 jae	 SHORT $_Invalid_parameter$2404

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  007e1	2b c1		 sub	 eax, ecx
  007e3	83 f8 04	 cmp	 eax, 4
  007e6	72 05		 jb	 SHORT $_Invalid_parameter$2404

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  007e8	83 f8 23	 cmp	 eax, 35			; 00000023H
  007eb	76 06		 jbe	 SHORT $LN1742@Odczytaj_L
$_Invalid_parameter$2404:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  007ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2392@Odczytaj_L:
$LN1742@Odczytaj_L:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  007f3	52		 push	 edx
  007f4	51		 push	 ecx
  007f5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  007fa	83 c4 08	 add	 esp, 8
$LN1739@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007fd	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR $T152[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00803	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T160[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0080d	c7 85 50 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T160[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00817	c6 85 3c fe ff
	ff 00		 mov	 BYTE PTR $T160[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0081e	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00821	72 41		 jb	 SHORT $LN1810@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00823	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR $T152[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00829	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0082a	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0082c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00832	72 26		 jb	 SHORT $LN1813@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00834	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00837	3b f2		 cmp	 esi, edx
  00839	76 19		 jbe	 SHORT $_Invalid_parameter$2405

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0083b	8b d6		 mov	 edx, esi
  0083d	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0083f	75 13		 jne	 SHORT $_Invalid_parameter$2405

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00841	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00844	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00846	73 0c		 jae	 SHORT $_Invalid_parameter$2405

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00848	2b c1		 sub	 eax, ecx
  0084a	83 f8 04	 cmp	 eax, 4
  0084d	72 05		 jb	 SHORT $_Invalid_parameter$2405

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0084f	83 f8 23	 cmp	 eax, 35			; 00000023H
  00852	76 06		 jbe	 SHORT $LN1813@Odczytaj_L
$_Invalid_parameter$2405:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00854	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2393@Odczytaj_L:
$LN1813@Odczytaj_L:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0085a	52		 push	 edx
  0085b	51		 push	 ecx
  0085c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00861	83 c4 08	 add	 esp, 8
$LN1810@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00864	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T142[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  0086a	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T152[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00874	c7 85 68 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T152[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0087e	c6 85 54 fe ff
	ff 00		 mov	 BYTE PTR $T152[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00885	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00888	0f 82 d6 01 00
	00		 jb	 $LN1086@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0088e	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T142[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00894	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00895	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00897	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0089d	0f 82 42 fb ff
	ff		 jb	 $LN1002@Odczytaj_L

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  008a3	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  008a6	3b f2		 cmp	 esi, edx
  008a8	76 1d		 jbe	 SHORT $_Invalid_parameter$2406

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  008aa	8b d6		 mov	 edx, esi
  008ac	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  008ae	75 17		 jne	 SHORT $_Invalid_parameter$2406

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  008b0	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  008b3	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  008b5	73 10		 jae	 SHORT $_Invalid_parameter$2406

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  008b7	2b c1		 sub	 eax, ecx
  008b9	83 f8 04	 cmp	 eax, 4
  008bc	72 09		 jb	 SHORT $_Invalid_parameter$2406

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  008be	83 f8 23	 cmp	 eax, 35			; 00000023H
  008c1	0f 86 1e fb ff
	ff		 jbe	 $LN1002@Odczytaj_L
$_Invalid_parameter$2406:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  008c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2394@Odczytaj_L:
$LN20@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008cd	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  008d0	72 02		 jb	 SHORT $LN1923@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  008d2	8b 36		 mov	 esi, DWORD PTR [esi]
$LN1923@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 457  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  008d4	80 3e 77	 cmp	 BYTE PTR [esi], 119	; 00000077H
  008d7	0f 85 87 01 00
	00		 jne	 $LN1086@Odczytaj_L
  008dd	68 b0 00 00 00	 push	 176			; 000000b0H
  008e2	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _numers$198[ebp]
  008e8	6a 00		 push	 0
  008ea	50		 push	 eax
  008eb	e8 00 00 00 00	 call	 _memset
  008f0	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 590  : 		{	// construct empty character buffer

  008f3	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$198[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  008fd	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp+104]
  00903	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$198[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0090d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00913	6a 00		 push	 0
  00915	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _numers$198[ebp+24]
  0091b	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0091f	50		 push	 eax
  00920	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp]
  00926	c7 45 e8 2b 00
	00 00		 mov	 DWORD PTR $T1[ebp], 43	; 0000002bH
  0092d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00933	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9
  0093a	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _numers$198[ebp]
  00940	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00943	c7 84 05 88 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$198[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0094e	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _numers$198[ebp]
  00954	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00957	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  0095a	89 84 0d 84 fe
	ff ff		 mov	 DWORD PTR _numers$198[ebp+ecx-4], eax
  00961	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _numers$198[ebp+24]

; 30   : 		{	// construct empty character buffer from mode

  00967	8b c8		 mov	 ecx, eax

; 589  : 			_Stringbuffer(_Mode)

  00969	89 85 38 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

  0096f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00975	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$198[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

  0097f	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$198[ebp+80], 0

; 312  : 		_Mystate = _State;

  00989	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$198[ebp+84], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 459  : 			stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  00993	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH

; 460  : 			numers << ((wylosowana_liczba - 1) / 3 + 1); //Wpisanie do typu obliczonego wiersza wylosowanej liczby

  00997	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  0099d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0099f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  009a4	49		 dec	 ecx
  009a5	f7 e9		 imul	 ecx
  009a7	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp+16]
  009ad	8b c2		 mov	 eax, edx
  009af	42		 inc	 edx
  009b0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  009b3	03 c2		 add	 eax, edx
  009b5	50		 push	 eax
  009b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 644  : 		return (_Stringbuffer.str());

  009bc	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR $T189[ebp]
  009c2	50		 push	 eax
  009c3	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp+24]
  009c9	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 461  : 			PlaySound((G³os + "w" + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiego wiersza jest wylosowana liczba

  009ce	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  009d3	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  009d8	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  009dc	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T190[ebp]
  009e2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  009e7	83 c4 04	 add	 esp, 4
  009ea	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T189[ebp]
  009f0	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  009f4	51		 push	 ecx
  009f5	8b d0		 mov	 edx, eax
  009f7	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T191[ebp]
  009fd	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00a02	83 c4 04	 add	 esp, 4
  00a05	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  00a0a	8b d0		 mov	 edx, eax
  00a0c	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00a10	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T192[ebp]
  00a16	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00a1b	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a1e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00a22	72 02		 jb	 SHORT $LN2336@Odczytaj_L
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a24	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2336@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 461  : 			PlaySound((G³os + "w" + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiego wiersza jest wylosowana liczba

  00a26	6a 00		 push	 0
  00a28	6a 00		 push	 0
  00a2a	50		 push	 eax
  00a2b	ff d7		 call	 edi
  00a2d	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T192[ebp]
  00a33	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a38	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T191[ebp]
  00a3e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a43	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T190[ebp]
  00a49	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a4e	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T189[ebp]
  00a54	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 462  : 		}

  00a59	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp]
  00a5f	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1086@Odczytaj_L:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 634  : 		{	// destroy the object

  00a64	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  00a6a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00a6d	c7 84 05 38 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00a78	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  00a7e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a81	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00a84	89 84 0d 34 ff
	ff ff		 mov	 DWORD PTR _numers$[ebp+ecx-4], eax

; 635  : 		}

  00a8b	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+24]
  00a91	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00a96	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+32]
  00a9c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00aa2	8d 4d a0	 lea	 ecx, DWORD PTR _numers$[ebp+104]
  00aa5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN3@Odczytaj_L:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 463  : }

  00aab	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00aae	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00ab5	59		 pop	 ecx
  00ab6	5f		 pop	 edi
  00ab7	5e		 pop	 esi
  00ab8	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00abb	33 cd		 xor	 ecx, ebp
  00abd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ac2	8b e5		 mov	 esp, ebp
  00ac4	5d		 pop	 ebp
  00ac5	8b e3		 mov	 esp, ebx
  00ac7	5b		 pop	 ebx
  00ac8	c3		 ret	 0
$LN2382@Odczytaj_L:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$19:
  00000	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0d 00 00
	00		 je	 $LN49@Odczytaj_L
  0000c	83 65 e8 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8d 4d a0	 lea	 ecx, DWORD PTR _numers$[ebp+104]
  00013	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN49@Odczytaj_L:
  00019	c3		 ret	 0
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$20:
  0001a	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+32]
  00020	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$22:
  00026	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00032	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp]
  00038	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  0003d	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
  00048	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  0004e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$10:
  00053	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T142[ebp]
  00059	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$11:
  0005e	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T152[ebp]
  00064	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$406:
  00069	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  0006c	83 e0 20	 and	 eax, 32			; 00000020H
  0006f	0f 84 10 00 00
	00		 je	 $LN1936@Odczytaj_L
  00075	83 65 e8 df	 and	 DWORD PTR $T1[ebp], -33	; ffffffdfH
  00079	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp+104]
  0007f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN1936@Odczytaj_L:
  00085	c3		 ret	 0
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$407:
  00086	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp+32]
  0008c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$409:
  00092	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00098	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$13:
  0009e	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp]
  000a4	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$14:
  000a9	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T189[ebp]
  000af	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$15:
  000b4	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T190[ebp]
  000ba	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$16:
  000bf	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T191[ebp]
  000c5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  000ca	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000ce	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000d1	8b 8a 20 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-480]
  000d7	33 c8		 xor	 ecx, eax
  000d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000de	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  000e1	33 c8		 xor	 ecx, eax
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  000ed	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Odczytaj_Liczbê
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_typ_zak³adu$GSCopy$1$ = -180				; size = 4
_log$GSCopy$1$ = -176					; size = 4
tv3844 = -176						; size = 4
_wylosowana_liczba$GSCopy$1$ = -172			; size = 4
tv3853 = -172						; size = 4
_kwota_zak³adu$GSCopy$1$ = -168				; size = 4
_iloæ_pieniêdzy$GSCopy$1$ = -164			; size = 4
_buf2$214 = -160					; size = 24
_buf2$215 = -136					; size = 24
_buf2$216 = -112					; size = 24
_buf2$217 = -88						; size = 24
_bufor2$218 = -64					; size = 24
_buf$219 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_co_kontynuowaæ$ = 8					; size = 4
_iloæ_pieniêdzy$ = 12					; size = 4
_kwota_zak³adu$ = 16					; size = 4
_wylosowana_liczba$ = 20				; size = 4
_typ_zak³adu$ = 24					; size = 4
?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; Wczytaj_z_Pliku, COMDAT
; _log_ogólny$ = ecx
; _log$ = edx

; 466  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b da		 mov	 ebx, edx
  00030	89 9d 50 ff ff
	ff		 mov	 DWORD PTR _log$GSCopy$1$[ebp], ebx
  00036	8b f1		 mov	 esi, ecx

; 467  : 	if (!Ustawienia.czy_kontynuowaæ_grê) //Je¿eli czy_kontynuowaæ_grê == 0

  00038	66 83 3d 12 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, 0
  00040	8b 45 0c	 mov	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00043	8b 7d 08	 mov	 edi, DWORD PTR _co_kontynuowaæ$[ebp]
  00046	89 85 5c ff ff
	ff		 mov	 DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp], eax
  0004c	8b 45 10	 mov	 eax, DWORD PTR _kwota_zak³adu$[ebp]
  0004f	89 85 58 ff ff
	ff		 mov	 DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp], eax
  00055	8b 45 14	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00058	89 85 54 ff ff
	ff		 mov	 DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp], eax
  0005e	8b 45 18	 mov	 eax, DWORD PTR _typ_zak³adu$[ebp]
  00061	89 85 4c ff ff
	ff		 mov	 DWORD PTR _typ_zak³adu$GSCopy$1$[ebp], eax
  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___access
  0006c	75 4c		 jne	 SHORT $LN31@Wczytaj_z_

; 468  : 		if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  0006e	6a 00		 push	 0
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00075	ff d0		 call	 eax
  00077	83 c4 08	 add	 esp, 8
  0007a	85 c0		 test	 eax, eax
  0007c	75 37		 jne	 SHORT $LN1724@Wczytaj_z_

; 469  : 		{
; 470  : 			co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 471  : 			remove("log_aktualny.txt"); //Usuniêcie pliku log aktualny poniewa¿ rozpoczyna siê now¹ grê

  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00083	c6 07 6e	 mov	 BYTE PTR [edi], 110	; 0000006eH
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__remove
  0008c	83 c4 04	 add	 esp, 4

; 472  : 			log_ogólny << '\n' << "Uruchomiono ponownie grê z wy³¹czon¹ opcj¹ kontynuowania" << '\n'; //Wpisanie do buforu logu ogólnego informacje o rozpoczêciu nowej gry spowodowane ustawieniem gry

  0008f	b2 0a		 mov	 dl, 10			; 0000000aH
  00091	8b ce		 mov	 ecx, esi
  00093	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
  00098	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@
  0009d	8b c8		 mov	 ecx, eax
  0009f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000a4	b2 0a		 mov	 dl, 10			; 0000000aH
  000a6	8b c8		 mov	 ecx, eax
  000a8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 473  : 			log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000ad	8b ce		 mov	 ecx, esi
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN1724@Wczytaj_z_:

; 468  : 		if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000b5	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___access
$LN31@Wczytaj_z_:

; 476  : 	if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000ba	6a 00		 push	 0
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000c1	ff d0		 call	 eax
  000c3	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000c6	51		 push	 ecx
  000c7	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 476  : 	if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000ca	85 c0		 test	 eax, eax
  000cc	0f 85 84 09 00
	00		 jne	 $LN32@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000d2	6a 01		 push	 1
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000d9	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  000de	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1370 : 			_Myios::setstate(ios_base::failbit);

  000e0	6a 00		 push	 0
  000e2	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000e5	03 cb		 add	 ecx, ebx
  000e7	85 c0		 test	 eax, eax
  000e9	75 0a		 jne	 SHORT $LN74@Wczytaj_z_
  000eb	6a 02		 push	 2
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1371 : 		else

  000f3	eb 08		 jmp	 SHORT $LN75@Wczytaj_z_
$LN74@Wczytaj_z_:

; 1372 : 			_Myios::clear();	// added with C++11

  000f5	6a 00		 push	 0
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN75@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  000fd	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _buf$219[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00104	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _buf$219[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0010b	c6 45 d8 00	 mov	 BYTE PTR _buf$219[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 479  : 		string buf, bufor2; //Uworzenie 2 buforów na tekst, pierwszy na ostatni¹ linie tekst, drugi na przedostani¹ nie pust¹ linie tekstu lub ostani¹ w przypadku gdy ostania jest pusta

  0010f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00116	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _bufor2$218[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0011d	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _bufor2$218[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00124	c6 45 c0 00	 mov	 BYTE PTR _bufor2$218[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 479  : 		string buf, bufor2; //Uworzenie 2 buforów na tekst, pierwszy na ostatni¹ linie tekst, drugi na przedostani¹ nie pust¹ linie tekstu lub ostani¹ w przypadku gdy ostania jest pusta

  00128	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  0012c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0012e	6a 0a		 push	 10			; 0000000aH
  00130	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00133	03 cb		 add	 ecx, ebx
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0013b	0f b6 c0	 movzx	 eax, al
  0013e	8d 55 d8	 lea	 edx, DWORD PTR _buf$219[ebp]
  00141	50		 push	 eax
  00142	8b cb		 mov	 ecx, ebx
  00144	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  00149	8b 03		 mov	 eax, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  0014b	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  0014e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  00151	f6 44 18 0c 01	 test	 BYTE PTR [eax+ebx+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 481  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  00156	75 54		 jne	 SHORT $LN3@Wczytaj_z_
  00158	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00160	8b 75 e8	 mov	 esi, DWORD PTR _buf$219[ebp+16]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00163	8b 4d ec	 mov	 ecx, DWORD PTR _buf$219[ebp+20]

; 1594 : 		if (_Large_string_engaged())

  00166	8b 55 d8	 mov	 edx, DWORD PTR _buf$219[ebp]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00169	85 f6		 test	 esi, esi
  0016b	74 13		 je	 SHORT $LN164@Wczytaj_z_

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0016d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00170	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00173	56		 push	 esi

; 1594 : 		if (_Large_string_engaged())

  00174	0f 43 c2	 cmovae	 eax, edx

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00177	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$218[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN164@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	6a 0a		 push	 10			; 0000000aH
  00184	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00187	03 cb		 add	 ecx, ebx
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0018f	0f b6 c0	 movzx	 eax, al
  00192	8d 55 d8	 lea	 edx, DWORD PTR _buf$219[ebp]
  00195	50		 push	 eax
  00196	8b cb		 mov	 ecx, ebx
  00198	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  0019d	8b 03		 mov	 eax, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  0019f	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  001a2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  001a5	f6 44 18 0c 01	 test	 BYTE PTR [eax+ebx+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 481  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  001aa	74 b4		 je	 SHORT $LL2@Wczytaj_z_
$LN3@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001ac	83 7d e8 00	 cmp	 DWORD PTR _buf$219[ebp+16], 0
  001b0	75 17		 jne	 SHORT $LN238@Wczytaj_z_

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001b2	83 7d d4 10	 cmp	 DWORD PTR _bufor2$218[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001b6	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$218[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  001b9	ff 75 d0	 push	 DWORD PTR _bufor2$218[ebp+16]

; 1594 : 		if (_Large_string_engaged())

  001bc	0f 43 45 c0	 cmovae	 eax, DWORD PTR _bufor2$218[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  001c0	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN238@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 487  : 		if (buf.find("Posiadasz") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o skoñczeniu rundy

  001c9	51		 push	 ecx
  001ca	68 00 00 00 00	 push	 OFFSET ??_C@_09LFKNBKJA@Posiadasz?$AA@
  001cf	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  001d2	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  001d7	83 f8 ff	 cmp	 eax, -1
  001da	0f 84 15 01 00
	00		 je	 $LN36@Wczytaj_z_

; 488  : 		{
; 489  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 490  : 			auto pocz¹tek = (unsigned short)buf.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst pozycji ostatniego znaku tekstu o kwocie pieniêdzy któr¹ posiada jeszcze gracz, typ zmiennej auto wsazuje, ¿e kompilator sam wybierze typ zmiennej

  001e0	0f b7 75 e8	 movzx	 esi, WORD PTR _buf$219[ebp+16]
  001e4	8b 55 ec	 mov	 edx, DWORD PTR _buf$219[ebp+20]
  001e7	c6 07 6e	 mov	 BYTE PTR [edi], 110	; 0000006eH
  001ea	8b 7d d8	 mov	 edi, DWORD PTR _buf$219[ebp]
  001ed	0f 1f 00	 npad	 3
$LL4@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001f0	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 491  : 			while (buf[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  001f3	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  001f6	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  001f9	0f 43 cf	 cmovae	 ecx, edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 491  : 			while (buf[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  001fc	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  00200	74 0d		 je	 SHORT $LN5@Wczytaj_z_
  00202	66 85 f6	 test	 si, si
  00205	74 08		 je	 SHORT $LN5@Wczytaj_z_
  00207	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  0020d	eb e1		 jmp	 SHORT $LL4@Wczytaj_z_
$LN5@Wczytaj_z_:

; 492  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu
; 493  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeniej odczytanego tekstu

  0020f	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]
  00212	46		 inc	 esi
  00213	50		 push	 eax
  00214	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$215[ebp]
  0021a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0021f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00223	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$215[ebp]

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00229	8b 45 88	 mov	 eax, DWORD PTR _buf2$215[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 494  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  0022c	0f b7 d6	 movzx	 edx, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0022f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00235	3b c2		 cmp	 eax, edx
  00237	0f 42 d0	 cmovb	 edx, eax

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0023a	83 7d 8c 10	 cmp	 DWORD PTR _buf2$215[ebp+20], 16 ; 00000010H

; 1583 : 		if (_Large_string_engaged())

  0023e	0f 43 8d 78 ff
	ff ff		 cmovae	 ecx, DWORD PTR _buf2$215[ebp]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00245	2b c2		 sub	 eax, edx

; 2607 : 		_My_data._Mysize = _New_size;

  00247	89 45 88	 mov	 DWORD PTR _buf2$215[ebp+16], eax

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0024a	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0024b	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0024c	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0024f	50		 push	 eax
  00250	51		 push	 ecx
  00251	ff d6		 call	 esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 495  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00253	8b 45 88	 mov	 eax, DWORD PTR _buf2$215[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00256	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 495  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00259	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  0025c	3b c2		 cmp	 eax, edx
  0025e	0f 82 6b 0a 00
	00		 jb	 $LN1727@Wczytaj_z_

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00264	83 7d 8c 10	 cmp	 DWORD PTR _buf2$215[ebp+20], 16 ; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00268	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$215[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0026e	6a 01		 push	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1583 : 		if (_Large_string_engaged())

  00270	0f 43 8d 78 ff
	ff ff		 cmovae	 ecx, DWORD PTR _buf2$215[ebp]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00277	03 ca		 add	 ecx, edx

; 2607 : 		_My_data._Mysize = _New_size;

  00279	89 55 88	 mov	 DWORD PTR _buf2$215[ebp+16], edx

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0027c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0027f	50		 push	 eax
  00280	51		 push	 ecx
  00281	ff d6		 call	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00283	83 7d 8c 10	 cmp	 DWORD PTR _buf2$215[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00287	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buf2$215[ebp]

; 1594 : 		if (_Large_string_engaged())

  0028d	0f 43 85 78 ff
	ff ff		 cmovae	 eax, DWORD PTR _buf2$215[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 496  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00294	50		 push	 eax
  00295	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0029b	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp]
  002a1	83 c4 10	 add	 esp, 16			; 00000010H

; 497  : 		}

  002a4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002a8	8b 55 8c	 mov	 edx, DWORD PTR _buf2$215[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 496  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  002ab	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002ad	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  002b0	0f 82 c3 06 00
	00		 jb	 $LN50@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002b6	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _buf2$215[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002bc	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002bd	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  002bf	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002c5	0f 82 91 06 00
	00		 jb	 $LN1429@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  002cb	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  002ce	3b f2		 cmp	 esi, edx
  002d0	76 1d		 jbe	 SHORT $_Invalid_parameter$1736

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  002d2	8b d6		 mov	 edx, esi
  002d4	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  002d6	75 17		 jne	 SHORT $_Invalid_parameter$1736

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002d8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002db	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  002dd	73 10		 jae	 SHORT $_Invalid_parameter$1736

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  002df	2b c1		 sub	 eax, ecx
  002e1	83 f8 04	 cmp	 eax, 4
  002e4	72 09		 jb	 SHORT $_Invalid_parameter$1736

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  002e6	83 f8 23	 cmp	 eax, 35			; 00000023H
  002e9	0f 86 6d 06 00
	00		 jbe	 $LN1429@Wczytaj_z_
$_Invalid_parameter$1736:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1729@Wczytaj_z_:
$LN36@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 498  : 		else if (buf.find("Wylosowano") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o wylosowaniu liczby

  002f5	51		 push	 ecx
  002f6	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DAFLKCID@Wylosowano?$AA@
  002fb	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  002fe	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00303	83 f8 ff	 cmp	 eax, -1
  00306	0f 84 85 02 00
	00		 je	 $LN38@Wczytaj_z_

; 499  : 		{
; 500  : 			co_kontynuowaæ = 'w'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od sprawdzenia wygranej
; 501  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o wylosowanej liczbie

  0030c	8b 55 e8	 mov	 edx, DWORD PTR _buf$219[ebp+16]
  0030f	33 f6		 xor	 esi, esi
  00311	c6 07 77	 mov	 BYTE PTR [edi], 119	; 00000077H
  00314	8b 7d ec	 mov	 edi, DWORD PTR _buf$219[ebp+20]
$LL6@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00317	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 502  : 			while (buf[pocz¹tek] != 'y' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukiwanie od pocz¹tku litery y która wystêpuje w wyrazie po którym jest wylosowana liczba

  0031a	0f b7 ce	 movzx	 ecx, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0031d	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00320	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 502  : 			while (buf[pocz¹tek] != 'y' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukiwanie od pocz¹tku litery y która wystêpuje w wyrazie po którym jest wylosowana liczba

  00324	80 3c 08 79	 cmp	 BYTE PTR [eax+ecx], 121	; 00000079H
  00328	74 07		 je	 SHORT $LN7@Wczytaj_z_
  0032a	3b ca		 cmp	 ecx, edx
  0032c	7d 03		 jge	 SHORT $LN7@Wczytaj_z_
  0032e	46		 inc	 esi
  0032f	eb e6		 jmp	 SHORT $LL6@Wczytaj_z_
$LN7@Wczytaj_z_:

; 503  : 			pocz¹tek += 10; //Przesuniêcie o +10 pozycji pocz¹tku tekstu o po której jest wylosowana liczba
; 504  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeniej odczytanego tekstu

  00331	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]
  00334	83 c6 0a	 add	 esi, 10			; 0000000aH
  00337	50		 push	 eax
  00338	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  0033b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 505  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00340	0f b7 c6	 movzx	 eax, si
  00343	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  00346	50		 push	 eax
  00347	6a 00		 push	 0
  00349	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0034d	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00352	83 7d bc 10	 cmp	 DWORD PTR _buf2$217[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00356	8d 45 a8	 lea	 eax, DWORD PTR _buf2$217[ebp]

; 1594 : 		if (_Large_string_engaged())

  00359	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$217[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 506  : 			wylosowana_liczba = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  0035d	50		 push	 eax
  0035e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00364	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  0036a	83 c4 04	 add	 esp, 4

; 507  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o typie zak³adu

  0036d	8b 7d ec	 mov	 edi, DWORD PTR _buf$219[ebp+20]
  00370	33 f6		 xor	 esi, esi
  00372	8b 55 e8	 mov	 edx, DWORD PTR _buf$219[ebp+16]
  00375	89 01		 mov	 DWORD PTR [ecx], eax
$LL8@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00377	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 508  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (int)buf.size()) ++pocz¹tek;

  0037a	0f b7 ce	 movzx	 ecx, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0037d	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00380	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 508  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (int)buf.size()) ++pocz¹tek;

  00384	80 3c 08 64	 cmp	 BYTE PTR [eax+ecx], 100	; 00000064H
  00388	74 07		 je	 SHORT $LN9@Wczytaj_z_
  0038a	3b ca		 cmp	 ecx, edx
  0038c	7d 03		 jge	 SHORT $LN9@Wczytaj_z_
  0038e	46		 inc	 esi
  0038f	eb e6		 jmp	 SHORT $LL8@Wczytaj_z_
$LN9@Wczytaj_z_:

; 509  : 			pocz¹tek += 2;  //Przesuniêcie o +2 pozycji pocz¹tku tekstu o po której jest typ zak³adu

  00391	83 c6 02	 add	 esi, 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00394	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00397	83 ff 10	 cmp	 edi, 16			; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0039a	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  0039d	52		 push	 edx

; 1594 : 		if (_Large_string_engaged())

  0039e	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$219[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 511  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  003a8	0f b7 c6	 movzx	 eax, si
  003ab	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  003ae	50		 push	 eax
  003af	6a 00		 push	 0
  003b1	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 512  : 			buf2.erase(buf2.find(" Wylosowano"), string::npos); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê nazw¹ typu zak³adu

  003b6	6a ff		 push	 -1
  003b8	51		 push	 ecx
  003b9	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
  003be	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  003c1	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  003c6	50		 push	 eax
  003c7	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  003ca	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2238 : 		if (this != _STD addressof(_Right))

  003cf	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _typ_zak³adu$GSCopy$1$[ebp]
  003d5	8d 45 a8	 lea	 eax, DWORD PTR _buf2$217[ebp]
  003d8	3b c8		 cmp	 ecx, eax
  003da	74 11		 je	 SHORT $LN559@Wczytaj_z_

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003dc	83 7d bc 10	 cmp	 DWORD PTR _buf2$217[ebp+20], 16 ; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  003e0	ff 75 b8	 push	 DWORD PTR _buf2$217[ebp+16]

; 1594 : 		if (_Large_string_engaged())

  003e3	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$217[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  003e7	50		 push	 eax
  003e8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN559@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 514  : 			buf.erase(buf.find("Obstawiono zaklad"), string::npos); //Usuniêcie wszystkiego w prawo razem z wyszukanym tekstem

  003ed	6a ff		 push	 -1
  003ef	51		 push	 ecx
  003f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  003f5	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  003f8	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  003fd	50		 push	 eax
  003fe	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  00401	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00406	8b 7d ec	 mov	 edi, DWORD PTR _buf$219[ebp+20]

; 1582 : 		value_type * _Result = _Bx._Buf;

  00409	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  0040c	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 515  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie zak³adu

  0040f	33 d2		 xor	 edx, edx

; 517  : 			else //Je¿eli nie to

  00411	66 8b 5d e8	 mov	 bx, WORD PTR _buf$219[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00415	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00418	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 516  : 			if (buf[12] == 'a') { pocz¹tek = 14; } //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a wiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  0041b	80 78 0c 61	 cmp	 BYTE PTR [eax+12], 97	; 00000061H
  0041f	75 07		 jne	 SHORT $LN1714@Wczytaj_z_
  00421	ba 0e 00 00 00	 mov	 edx, 14			; 0000000eH

; 517  : 			else //Je¿eli nie to

  00426	eb 28		 jmp	 SHORT $LN41@Wczytaj_z_
$LN1714@Wczytaj_z_:
  00428	8b 75 d8	 mov	 esi, DWORD PTR _buf$219[ebp]
  0042b	0f 1f 44 00 00	 npad	 5
$LL10@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00430	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 519  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  00433	0f b7 c2	 movzx	 eax, dx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00436	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00439	0f 43 ce	 cmovae	 ecx, esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 519  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  0043c	80 3c 08 7a	 cmp	 BYTE PTR [eax+ecx], 122	; 0000007aH
  00440	74 08		 je	 SHORT $LN11@Wczytaj_z_
  00442	66 3b d3	 cmp	 dx, bx
  00445	73 03		 jae	 SHORT $LN11@Wczytaj_z_
  00447	42		 inc	 edx
  00448	eb e6		 jmp	 SHORT $LL10@Wczytaj_z_
$LN11@Wczytaj_z_:

; 520  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  0044a	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
  0044d	83 c2 03	 add	 edx, 3
$LN41@Wczytaj_z_:

; 521  : 			}
; 522  : 			int koniec = pocz¹tek + 1; //Przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  00450	0f b7 c2	 movzx	 eax, dx
  00453	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv3853[ebp], eax
  00459	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0045c	0f 1f 40 00	 npad	 4
$LL12@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00460	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00463	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00466	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 523  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Poszukujemy znaku dolara przed którym jest kwota zak³adu

  00469	80 3c 30 24	 cmp	 BYTE PTR [eax+esi], 36	; 00000024H
  0046d	74 0a		 je	 SHORT $LN13@Wczytaj_z_
  0046f	0f b7 c3	 movzx	 eax, bx
  00472	3b f0		 cmp	 esi, eax
  00474	7d 03		 jge	 SHORT $LN13@Wczytaj_z_
  00476	46		 inc	 esi
  00477	eb e7		 jmp	 SHORT $LL12@Wczytaj_z_
$LN13@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00479	ff 75 e8	 push	 DWORD PTR _buf$219[ebp+16]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0047c	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0047f	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1594 : 		if (_Large_string_engaged())

  00482	0f 43 c1	 cmovae	 eax, ecx

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00485	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  00488	50		 push	 eax
  00489	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 525  : 			buf2.erase(koniec, string::npos); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  0048e	6a ff		 push	 -1
  00490	56		 push	 esi
  00491	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  00494	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 526  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00499	ff b5 54 ff ff
	ff		 push	 DWORD PTR tv3853[ebp]
  0049f	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  004a2	6a 00		 push	 0
  004a4	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004a9	83 7d bc 10	 cmp	 DWORD PTR _buf2$217[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  004ad	8d 45 a8	 lea	 eax, DWORD PTR _buf2$217[ebp]

; 1594 : 		if (_Large_string_engaged())

  004b0	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$217[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 527  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  004b4	50		 push	 eax
  004b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  004bb	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]
  004c1	83 c4 04	 add	 esp, 4

; 528  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  004c4	0f b7 75 d0	 movzx	 esi, WORD PTR _bufor2$218[ebp+16]
  004c8	8b 55 d4	 mov	 edx, DWORD PTR _bufor2$218[ebp+20]
  004cb	8b 7d c0	 mov	 edi, DWORD PTR _bufor2$218[ebp]
  004ce	8b 9d 50 ff ff
	ff		 mov	 ebx, DWORD PTR _log$GSCopy$1$[ebp]
  004d4	89 01		 mov	 DWORD PTR [ecx], eax
$LL14@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004d6	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 529  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  004d9	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  004dc	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$218[ebp]

; 1583 : 		if (_Large_string_engaged())

  004df	0f 43 cf	 cmovae	 ecx, edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 529  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  004e2	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  004e6	74 0d		 je	 SHORT $LN15@Wczytaj_z_
  004e8	66 85 f6	 test	 si, si
  004eb	74 08		 je	 SHORT $LN15@Wczytaj_z_
  004ed	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  004f3	eb e1		 jmp	 SHORT $LL14@Wczytaj_z_
$LN15@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  004f5	ff 75 d0	 push	 DWORD PTR _bufor2$218[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 530  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  004f8	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  004f9	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$218[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004fc	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  004ff	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]

; 1594 : 		if (_Large_string_engaged())

  00502	0f 43 c7	 cmovae	 eax, edi

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00505	50		 push	 eax
  00506	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 532  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  0050b	0f b7 c6	 movzx	 eax, si
  0050e	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  00511	50		 push	 eax
  00512	6a 00		 push	 0
  00514	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 533  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00519	8b 45 b8	 mov	 eax, DWORD PTR _buf2$217[ebp+16]
  0051c	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  0051f	6a 01		 push	 1
  00521	48		 dec	 eax
  00522	50		 push	 eax
  00523	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00528	83 7d bc 10	 cmp	 DWORD PTR _buf2$217[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0052c	8d 45 a8	 lea	 eax, DWORD PTR _buf2$217[ebp]

; 1594 : 		if (_Large_string_engaged())

  0052f	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$217[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 534  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00533	50		 push	 eax
  00534	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0053a	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp]
  00540	83 c4 04	 add	 esp, 4

; 535  : 		}

  00543	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00547	8b 55 bc	 mov	 edx, DWORD PTR _buf2$217[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 534  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  0054a	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0054c	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  0054f	0f 82 24 04 00
	00		 jb	 $LN50@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00555	8b 4d a8	 mov	 ecx, DWORD PTR _buf2$217[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00558	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00559	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0055b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00561	0f 82 f5 03 00
	00		 jb	 $LN1429@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00567	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  0056a	3b f2		 cmp	 esi, edx
  0056c	76 1d		 jbe	 SHORT $_Invalid_parameter$1737

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0056e	8b d6		 mov	 edx, esi
  00570	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00572	75 17		 jne	 SHORT $_Invalid_parameter$1737

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00574	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00577	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00579	73 10		 jae	 SHORT $_Invalid_parameter$1737

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0057b	2b c1		 sub	 eax, ecx
  0057d	83 f8 04	 cmp	 eax, 4
  00580	72 09		 jb	 SHORT $_Invalid_parameter$1737

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00582	83 f8 23	 cmp	 eax, 35			; 00000023H
  00585	0f 86 d1 03 00
	00		 jbe	 $LN1429@Wczytaj_z_
$_Invalid_parameter$1737:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0058b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1730@Wczytaj_z_:
$LN38@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 536  : 		else if (buf.find("Obstawiono zaklad") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o typie obstawionego zak³adu

  00591	51		 push	 ecx
  00592	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  00597	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  0059a	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0059f	83 f8 ff	 cmp	 eax, -1
  005a2	0f 84 03 02 00
	00		 je	 $LN42@Wczytaj_z_

; 537  : 		{
; 538  : 			co_kontynuowaæ = 't'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od wylosowania liczby
; 539  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o typie zak³adu

  005a8	66 8b 55 e8	 mov	 dx, WORD PTR _buf$219[ebp+16]
  005ac	33 f6		 xor	 esi, esi
  005ae	c6 07 74	 mov	 BYTE PTR [edi], 116	; 00000074H
  005b1	8b 7d ec	 mov	 edi, DWORD PTR _buf$219[ebp+20]
$LL16@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005b4	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 540  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek;

  005b7	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  005ba	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  005bd	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 540  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek;

  005c1	80 3c 08 64	 cmp	 BYTE PTR [eax+ecx], 100	; 00000064H
  005c5	74 08		 je	 SHORT $LN17@Wczytaj_z_
  005c7	66 3b f2	 cmp	 si, dx
  005ca	73 03		 jae	 SHORT $LN17@Wczytaj_z_
  005cc	46		 inc	 esi
  005cd	eb e5		 jmp	 SHORT $LL16@Wczytaj_z_
$LN17@Wczytaj_z_:

; 541  : 			pocz¹tek += 2; //Przesuniêcie pozycji pocz¹tku tekstu o 2 po której jest typ zak³adu
; 542  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeniej odczytanego tekstu

  005cf	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]
  005d2	83 c6 02	 add	 esi, 2
  005d5	50		 push	 eax
  005d6	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  005d9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 543  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  005de	0f b7 c6	 movzx	 eax, si
  005e1	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  005e4	50		 push	 eax
  005e5	6a 00		 push	 0
  005e7	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  005eb	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2238 : 		if (this != _STD addressof(_Right))

  005f0	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _typ_zak³adu$GSCopy$1$[ebp]
  005f6	8d 45 90	 lea	 eax, DWORD PTR _buf2$216[ebp]
  005f9	3b c8		 cmp	 ecx, eax
  005fb	74 11		 je	 SHORT $LN902@Wczytaj_z_

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005fd	83 7d a4 10	 cmp	 DWORD PTR _buf2$216[ebp+20], 16 ; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00601	ff 75 a0	 push	 DWORD PTR _buf2$216[ebp+16]

; 1594 : 		if (_Large_string_engaged())

  00604	0f 43 45 90	 cmovae	 eax, DWORD PTR _buf2$216[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00608	50		 push	 eax
  00609	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN902@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 545  : 			buf.erase(buf.find("Obstawiono zaklad"), string::npos); //Usuniêcie wszystkiego w prawo razem z wyszukanym tekstem

  0060e	6a ff		 push	 -1
  00610	51		 push	 ecx
  00611	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  00616	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  00619	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0061e	50		 push	 eax
  0061f	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  00622	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00627	8b 55 ec	 mov	 edx, DWORD PTR _buf$219[ebp+20]

; 1582 : 		value_type * _Result = _Bx._Buf;

  0062a	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  0062d	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 546  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie zak³adu

  00630	33 ff		 xor	 edi, edi

; 547  : 			if (buf[12] == 'a') pocz¹tek = 14; //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a wiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  00632	8b 75 e8	 mov	 esi, DWORD PTR _buf$219[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00635	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00638	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 547  : 			if (buf[12] == 'a') pocz¹tek = 14; //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a wiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  0063b	80 78 0c 61	 cmp	 BYTE PTR [eax+12], 97	; 00000061H
  0063f	75 0f		 jne	 SHORT $LL18@Wczytaj_z_
  00641	bf 0e 00 00 00	 mov	 edi, 14			; 0000000eH

; 548  : 			else //Je¿eli nie to

  00646	eb 27		 jmp	 SHORT $LN45@Wczytaj_z_
  00648	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL18@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00650	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00653	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00656	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 550  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  00659	0f b7 cf	 movzx	 ecx, di
  0065c	80 3c 08 7a	 cmp	 BYTE PTR [eax+ecx], 122	; 0000007aH
  00660	74 0a		 je	 SHORT $LN19@Wczytaj_z_
  00662	3b ce		 cmp	 ecx, esi
  00664	7d 06		 jge	 SHORT $LN19@Wczytaj_z_
  00666	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
  00669	47		 inc	 edi
  0066a	eb e4		 jmp	 SHORT $LL18@Wczytaj_z_
$LN19@Wczytaj_z_:

; 551  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  0066c	83 c7 03	 add	 edi, 3
$LN45@Wczytaj_z_:

; 552  : 			}
; 553  : 			unsigned short koniec = pocz¹tek + 1; //Przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  0066f	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00672	0f b7 f0	 movzx	 esi, ax
$LL20@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00675	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 554  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Pêtla poszukuj¹ca znaku dolara, pêtla koñczy siê znalezieniem znaku dolara

  00678	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0067b	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  0067e	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 554  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Pêtla poszukuj¹ca znaku dolara, pêtla koñczy siê znalezieniem znaku dolara

  00682	80 3c 08 24	 cmp	 BYTE PTR [eax+ecx], 36	; 00000024H
  00686	74 09		 je	 SHORT $LN21@Wczytaj_z_
  00688	66 3b 75 e8	 cmp	 si, WORD PTR _buf$219[ebp+16]
  0068c	73 03		 jae	 SHORT $LN21@Wczytaj_z_
  0068e	46		 inc	 esi
  0068f	eb e4		 jmp	 SHORT $LL20@Wczytaj_z_
$LN21@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00691	ff 75 e8	 push	 DWORD PTR _buf$219[ebp+16]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00694	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00697	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0069a	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]

; 1594 : 		if (_Large_string_engaged())

  0069d	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$219[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  006a1	50		 push	 eax
  006a2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 556  : 			buf2.erase(koniec, string::npos); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  006a7	6a ff		 push	 -1
  006a9	0f b7 c6	 movzx	 eax, si
  006ac	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  006af	50		 push	 eax
  006b0	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 557  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  006b5	0f b7 c7	 movzx	 eax, di
  006b8	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  006bb	50		 push	 eax
  006bc	6a 00		 push	 0
  006be	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006c3	83 7d a4 10	 cmp	 DWORD PTR _buf2$216[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  006c7	8d 45 90	 lea	 eax, DWORD PTR _buf2$216[ebp]

; 1594 : 		if (_Large_string_engaged())

  006ca	0f 43 45 90	 cmovae	 eax, DWORD PTR _buf2$216[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 558  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  006ce	50		 push	 eax
  006cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  006d5	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]
  006db	83 c4 04	 add	 esp, 4

; 559  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  006de	0f b7 75 d0	 movzx	 esi, WORD PTR _bufor2$218[ebp+16]
  006e2	8b 55 d4	 mov	 edx, DWORD PTR _bufor2$218[ebp+20]
  006e5	8b 7d c0	 mov	 edi, DWORD PTR _bufor2$218[ebp]
  006e8	89 01		 mov	 DWORD PTR [ecx], eax
  006ea	66 0f 1f 44 00
	00		 npad	 6
$LL22@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006f0	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 560  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  006f3	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  006f6	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$218[ebp]

; 1583 : 		if (_Large_string_engaged())

  006f9	0f 43 cf	 cmovae	 ecx, edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 560  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  006fc	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  00700	74 0d		 je	 SHORT $LN23@Wczytaj_z_
  00702	66 85 f6	 test	 si, si
  00705	74 08		 je	 SHORT $LN23@Wczytaj_z_
  00707	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  0070d	eb e1		 jmp	 SHORT $LL22@Wczytaj_z_
$LN23@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0070f	ff 75 d0	 push	 DWORD PTR _bufor2$218[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 561  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  00712	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00713	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$218[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00716	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00719	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]

; 1594 : 		if (_Large_string_engaged())

  0071c	0f 43 c7	 cmovae	 eax, edi

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0071f	50		 push	 eax
  00720	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 563  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00725	0f b7 c6	 movzx	 eax, si
  00728	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  0072b	50		 push	 eax
  0072c	6a 00		 push	 0
  0072e	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 564  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00733	8b 45 a0	 mov	 eax, DWORD PTR _buf2$216[ebp+16]
  00736	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  00739	6a 01		 push	 1
  0073b	48		 dec	 eax
  0073c	50		 push	 eax
  0073d	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00742	83 7d a4 10	 cmp	 DWORD PTR _buf2$216[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00746	8d 45 90	 lea	 eax, DWORD PTR _buf2$216[ebp]

; 1594 : 		if (_Large_string_engaged())

  00749	0f 43 45 90	 cmovae	 eax, DWORD PTR _buf2$216[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 565  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  0074d	50		 push	 eax
  0074e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00754	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp]
  0075a	83 c4 04	 add	 esp, 4

; 566  : 		}

  0075d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00761	8b 55 a4	 mov	 edx, DWORD PTR _buf2$216[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 565  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00764	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00766	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00769	0f 82 0a 02 00
	00		 jb	 $LN50@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0076f	8b 4d 90	 mov	 ecx, DWORD PTR _buf2$216[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00772	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00773	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00775	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0077b	0f 82 db 01 00
	00		 jb	 $LN1429@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00781	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00784	3b f2		 cmp	 esi, edx
  00786	76 1d		 jbe	 SHORT $_Invalid_parameter$1738

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00788	8b d6		 mov	 edx, esi
  0078a	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0078c	75 17		 jne	 SHORT $_Invalid_parameter$1738

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0078e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00791	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00793	73 10		 jae	 SHORT $_Invalid_parameter$1738

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00795	2b c1		 sub	 eax, ecx
  00797	83 f8 04	 cmp	 eax, 4
  0079a	72 09		 jb	 SHORT $_Invalid_parameter$1738

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0079c	83 f8 23	 cmp	 eax, 35			; 00000023H
  0079f	0f 86 b7 01 00
	00		 jbe	 $LN1429@Wczytaj_z_
$_Invalid_parameter$1738:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  007a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1731@Wczytaj_z_:
$LN42@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 567  : 		else if (buf.find("Obstawiono za") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o kwocie obstawionego zak³adu

  007ab	51		 push	 ecx
  007ac	68 00 00 00 00	 push	 OFFSET ??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@
  007b1	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  007b4	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  007b9	83 f8 ff	 cmp	 eax, -1
  007bc	0f 84 a6 01 00
	00		 je	 $LN46@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007c2	8b 55 ec	 mov	 edx, DWORD PTR _buf$219[ebp+20]

; 1582 : 		value_type * _Result = _Bx._Buf;

  007c5	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  007c8	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 570  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  007cb	33 f6		 xor	 esi, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007cd	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 569  : 			co_kontynuowaæ = 'k';  //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od zapytania o typ zak³adu

  007d0	c6 07 6b	 mov	 BYTE PTR [edi], 107	; 0000006bH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1583 : 		if (_Large_string_engaged())

  007d3	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 571  : 			if (buf[12] == 'a') { pocz¹tek = 14; } //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a wiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  007d6	80 78 0c 61	 cmp	 BYTE PTR [eax+12], 97	; 00000061H
  007da	75 07		 jne	 SHORT $LN1711@Wczytaj_z_
  007dc	be 0e 00 00 00	 mov	 esi, 14			; 0000000eH

; 572  : 			else //Je¿eli nie to

  007e1	eb 24		 jmp	 SHORT $LN49@Wczytaj_z_
$LN1711@Wczytaj_z_:
  007e3	8b 7d d8	 mov	 edi, DWORD PTR _buf$219[ebp]
$LL24@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007e6	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 574  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  007e9	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  007ec	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  007ef	0f 43 cf	 cmovae	 ecx, edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 574  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  007f2	80 3c 08 7a	 cmp	 BYTE PTR [eax+ecx], 122	; 0000007aH
  007f6	74 09		 je	 SHORT $LN25@Wczytaj_z_
  007f8	66 3b 75 e8	 cmp	 si, WORD PTR _buf$219[ebp+16]
  007fc	73 03		 jae	 SHORT $LN25@Wczytaj_z_
  007fe	46		 inc	 esi
  007ff	eb e5		 jmp	 SHORT $LL24@Wczytaj_z_
$LN25@Wczytaj_z_:

; 575  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  00801	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
  00804	83 c6 03	 add	 esi, 3
$LN49@Wczytaj_z_:

; 576  : 			}
; 577  : 			unsigned short koniec = pocz¹tek + 1; //Utworzenie i przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  00807	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0080a	0f b7 f8	 movzx	 edi, ax
  0080d	0f 1f 00	 npad	 3
$LL26@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00810	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00813	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00816	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 578  : 			while (buf[koniec] != '$' && koniec < (int)buf.size()) ++koniec; //Pêtla szukaj¹ca znaku dolara

  00819	0f b7 cf	 movzx	 ecx, di
  0081c	80 3c 08 24	 cmp	 BYTE PTR [eax+ecx], 36	; 00000024H
  00820	74 0b		 je	 SHORT $LN27@Wczytaj_z_
  00822	3b 4d e8	 cmp	 ecx, DWORD PTR _buf$219[ebp+16]
  00825	7d 06		 jge	 SHORT $LN27@Wczytaj_z_
  00827	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
  0082a	47		 inc	 edi
  0082b	eb e3		 jmp	 SHORT $LL26@Wczytaj_z_
$LN27@Wczytaj_z_:

; 579  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeniej odczytanego tekstu

  0082d	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]
  00830	50		 push	 eax
  00831	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  00837	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 580  : 			buf2.erase(koniec, string::npos); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  0083c	6a ff		 push	 -1
  0083e	0f b7 c7	 movzx	 eax, di
  00841	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  00847	50		 push	 eax
  00848	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0084c	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 581  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00851	0f b7 c6	 movzx	 eax, si
  00854	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  0085a	50		 push	 eax
  0085b	6a 00		 push	 0
  0085d	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00862	83 bd 74 ff ff
	ff 10		 cmp	 DWORD PTR _buf2$214[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00869	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _buf2$214[ebp]

; 1594 : 		if (_Large_string_engaged())

  0086f	0f 43 85 60 ff
	ff ff		 cmovae	 eax, DWORD PTR _buf2$214[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 582  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00876	50		 push	 eax
  00877	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0087d	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]
  00883	83 c4 04	 add	 esp, 4

; 583  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  00886	0f b7 75 d0	 movzx	 esi, WORD PTR _bufor2$218[ebp+16]
  0088a	8b 55 d4	 mov	 edx, DWORD PTR _bufor2$218[ebp+20]
  0088d	8b 7d c0	 mov	 edi, DWORD PTR _bufor2$218[ebp]
  00890	89 01		 mov	 DWORD PTR [ecx], eax
$LL28@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00892	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 584  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  00895	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00898	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$218[ebp]

; 1583 : 		if (_Large_string_engaged())

  0089b	0f 43 cf	 cmovae	 ecx, edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 584  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  0089e	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  008a2	74 0d		 je	 SHORT $LN29@Wczytaj_z_
  008a4	66 85 f6	 test	 si, si
  008a7	74 08		 je	 SHORT $LN29@Wczytaj_z_
  008a9	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  008af	eb e1		 jmp	 SHORT $LL28@Wczytaj_z_
$LN29@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  008b1	ff 75 d0	 push	 DWORD PTR _bufor2$218[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 585  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  008b4	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008b5	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$218[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008b8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  008bb	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]

; 1594 : 		if (_Large_string_engaged())

  008c1	0f 43 c7	 cmovae	 eax, edi

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  008c4	50		 push	 eax
  008c5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 587  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  008ca	0f b7 c6	 movzx	 eax, si
  008cd	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  008d3	50		 push	 eax
  008d4	6a 00		 push	 0
  008d6	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 588  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  008db	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _buf2$214[ebp+16]
  008e1	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  008e7	6a 01		 push	 1
  008e9	48		 dec	 eax
  008ea	50		 push	 eax
  008eb	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008f0	83 bd 74 ff ff
	ff 10		 cmp	 DWORD PTR _buf2$214[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008f7	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _buf2$214[ebp]

; 1594 : 		if (_Large_string_engaged())

  008fd	0f 43 85 60 ff
	ff ff		 cmovae	 eax, DWORD PTR _buf2$214[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 589  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00904	50		 push	 eax
  00905	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0090b	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp]
  00911	83 c4 04	 add	 esp, 4

; 590  : 		}

  00914	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00918	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _buf2$214[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 589  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  0091e	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00920	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00923	72 54		 jb	 SHORT $LN50@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00925	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _buf2$214[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0092b	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0092c	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0092e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00934	72 26		 jb	 SHORT $LN1429@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00936	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00939	3b f2		 cmp	 esi, edx
  0093b	76 19		 jbe	 SHORT $_Invalid_parameter$1739

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0093d	8b d6		 mov	 edx, esi
  0093f	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00941	75 13		 jne	 SHORT $_Invalid_parameter$1739

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00943	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00946	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00948	73 0c		 jae	 SHORT $_Invalid_parameter$1739

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0094a	2b c1		 sub	 eax, ecx
  0094c	83 f8 04	 cmp	 eax, 4
  0094f	72 05		 jb	 SHORT $_Invalid_parameter$1739

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00951	83 f8 23	 cmp	 eax, 35			; 00000023H
  00954	76 06		 jbe	 SHORT $LN1429@Wczytaj_z_
$_Invalid_parameter$1739:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00956	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1732@Wczytaj_z_:
$LN1429@Wczytaj_z_:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0095c	52		 push	 edx
  0095d	51		 push	 ecx
  0095e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00963	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1641 : 			}

  00966	eb 11		 jmp	 SHORT $LN50@Wczytaj_z_
$LN46@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 591  : 		else if (buf.find("Gra rozpoczeta dnia") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o rozpoczêciu nowej gry

  00968	51		 push	 ecx
  00969	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@
  0096e	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  00971	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00976	c6 07 6e	 mov	 BYTE PTR [edi], 110	; 0000006eH
$LN50@Wczytaj_z_:

; 592  : 		{
; 593  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 594  : 		}
; 595  : 		else //Je¿eli co pójdzie nie tak, to warunek aby gra siê niewysypa³a
; 596  : 		{
; 597  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 598  : 		}
; 599  : 		log.close(); //Zamkniêcie pliku logu ogólnego

  00979	8b cb		 mov	 ecx, ebx
  0097b	e8 00 00 00 00	 call	 ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::close
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00980	51		 push	 ecx
  00981	6a 0a		 push	 10			; 0000000aH
  00983	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00988	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  0098b	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00990	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1370 : 			_Myios::setstate(ios_base::failbit);

  00992	6a 00		 push	 0
  00994	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00997	03 cb		 add	 ecx, ebx
  00999	85 c0		 test	 eax, eax
  0099b	75 0a		 jne	 SHORT $LN1460@Wczytaj_z_
  0099d	6a 02		 push	 2
  0099f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1371 : 		else

  009a5	eb 08		 jmp	 SHORT $LN1461@Wczytaj_z_
$LN1460@Wczytaj_z_:

; 1372 : 			_Myios::clear();	// added with C++11

  009a7	6a 00		 push	 0
  009a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN1461@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009af	8b 55 d4	 mov	 edx, DWORD PTR _bufor2$218[ebp+20]
  009b2	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  009b5	72 3e		 jb	 SHORT $LN1501@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  009b7	8b 4d c0	 mov	 ecx, DWORD PTR _bufor2$218[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  009ba	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  009bb	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  009bd	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  009c3	72 26		 jb	 SHORT $LN1504@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  009c5	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  009c8	3b f2		 cmp	 esi, edx
  009ca	76 19		 jbe	 SHORT $_Invalid_parameter$1740

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  009cc	8b d6		 mov	 edx, esi
  009ce	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  009d0	75 13		 jne	 SHORT $_Invalid_parameter$1740

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  009d2	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  009d5	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  009d7	73 0c		 jae	 SHORT $_Invalid_parameter$1740

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  009d9	2b c1		 sub	 eax, ecx
  009db	83 f8 04	 cmp	 eax, 4
  009de	72 05		 jb	 SHORT $_Invalid_parameter$1740

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  009e0	83 f8 23	 cmp	 eax, 35			; 00000023H
  009e3	76 06		 jbe	 SHORT $LN1504@Wczytaj_z_
$_Invalid_parameter$1740:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  009e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1733@Wczytaj_z_:
$LN1504@Wczytaj_z_:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  009eb	52		 push	 edx
  009ec	51		 push	 ecx
  009ed	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009f2	83 c4 08	 add	 esp, 8
$LN1501@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009f5	8b 55 ec	 mov	 edx, DWORD PTR _buf$219[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  009f8	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _bufor2$218[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  009ff	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _bufor2$218[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00a06	c6 45 c0 00	 mov	 BYTE PTR _bufor2$218[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a0a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00a0d	0f 82 a0 02 00
	00		 jb	 $LN33@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00a13	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00a16	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00a17	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00a19	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00a1f	72 26		 jb	 SHORT $LN1575@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00a21	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00a24	3b f2		 cmp	 esi, edx
  00a26	76 19		 jbe	 SHORT $_Invalid_parameter$1741

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00a28	8b d6		 mov	 edx, esi
  00a2a	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00a2c	75 13		 jne	 SHORT $_Invalid_parameter$1741

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00a2e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00a31	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00a33	73 0c		 jae	 SHORT $_Invalid_parameter$1741

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00a35	2b c1		 sub	 eax, ecx
  00a37	83 f8 04	 cmp	 eax, 4
  00a3a	72 05		 jb	 SHORT $_Invalid_parameter$1741

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00a3c	83 f8 23	 cmp	 eax, 35			; 00000023H
  00a3f	76 06		 jbe	 SHORT $LN1575@Wczytaj_z_
$_Invalid_parameter$1741:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00a41	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1734@Wczytaj_z_:
$LN1575@Wczytaj_z_:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00a47	52		 push	 edx
  00a48	51		 push	 ecx
  00a49	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00a4e	83 c4 08	 add	 esp, 8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 602  : 	else

  00a51	e9 5d 02 00 00	 jmp	 $LN33@Wczytaj_z_
$LN32@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00a56	6a 02		 push	 2
  00a58	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 604  : 		co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  00a5d	c6 07 6e	 mov	 BYTE PTR [edi], 110	; 0000006eH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00a60	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00a65	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1370 : 			_Myios::setstate(ios_base::failbit);

  00a67	6a 00		 push	 0
  00a69	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00a6c	03 cb		 add	 ecx, ebx
  00a6e	85 c0		 test	 eax, eax
  00a70	75 0a		 jne	 SHORT $LN1606@Wczytaj_z_
  00a72	6a 02		 push	 2
  00a74	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1371 : 		else

  00a7a	eb 08		 jmp	 SHORT $LN1607@Wczytaj_z_
$LN1606@Wczytaj_z_:

; 1372 : 			_Myios::clear();	// added with C++11

  00a7c	6a 00		 push	 0
  00a7e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN1607@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 606  : 		GetSystemTime(&Czas); //Pobieranie aktualnej daty i czasu z zegara systemowego

  00a84	68 00 00 00 00	 push	 OFFSET ?Czas@@3U_SYSTEMTIME@@A ; Czas
  00a89	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemTime@4

; 607  : 		log << "Gra rozpoczeta dnia " << Czas.wDay << "." << Czas.wMonth << "." << Czas.wYear << " o godzinie "; //Wpisanie do bufora zapisu danych o dniu,miesi¹cu i roku do pliku log_aktualny.txt

  00a8f	33 c0		 xor	 eax, eax
  00a91	8d 7b 10	 lea	 edi, DWORD PTR [ebx+16]
  00a94	85 db		 test	 ebx, ebx
  00a96	89 bd 50 ff ff
	ff		 mov	 DWORD PTR tv3844[ebp], edi
  00a9c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@
  00aa1	0f 44 f8	 cmove	 edi, eax
  00aa4	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A
  00aab	50		 push	 eax
  00aac	0f b7 05 02 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+2
  00ab3	8b cf		 mov	 ecx, edi
  00ab5	50		 push	 eax
  00ab6	0f b7 05 06 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+6
  00abd	50		 push	 eax
  00abe	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00ac3	8b c8		 mov	 ecx, eax
  00ac5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00acb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00ad0	8b c8		 mov	 ecx, eax
  00ad2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00ad7	8b c8		 mov	 ecx, eax
  00ad9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00adf	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00ae4	8b c8		 mov	 ecx, eax
  00ae6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00aeb	8b c8		 mov	 ecx, eax
  00aed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00af3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
  00af8	8b c8		 mov	 ecx, eax
  00afa	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 608  : 		if (Czas.wHour < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania godzinny je¿eli godzina jest minejsza ni¿ 10 do pliku log_aktualny.txt

  00aff	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
  00b05	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00b09	73 12		 jae	 SHORT $LN52@Wczytaj_z_
  00b0b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00b10	8b cf		 mov	 ecx, edi
  00b12	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00b17	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
$LN52@Wczytaj_z_:

; 609  : 		log << Czas.wHour << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia godzin od minut do pliku log_aktualny.txt

  00b1d	8b 9d 50 ff ff
	ff		 mov	 ebx, DWORD PTR tv3844[ebp]
  00b23	8b cb		 mov	 ecx, ebx
  00b25	0f b7 c0	 movzx	 eax, ax
  00b28	50		 push	 eax
  00b29	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00b2f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00b34	8b c8		 mov	 ecx, eax
  00b36	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 610  : 		if (Czas.wMinute < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania minut je¿eli minuty jest minejsze ni¿ 10 do pliku log_aktualny.txt

  00b3b	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
  00b41	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00b45	73 12		 jae	 SHORT $LN53@Wczytaj_z_
  00b47	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00b4c	8b cf		 mov	 ecx, edi
  00b4e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00b53	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
$LN53@Wczytaj_z_:

; 611  : 		log << Czas.wMinute << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia minut od sekund do pliku log_aktualny.txt

  00b59	0f b7 c0	 movzx	 eax, ax
  00b5c	8b cb		 mov	 ecx, ebx
  00b5e	50		 push	 eax
  00b5f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00b65	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00b6a	8b c8		 mov	 ecx, eax
  00b6c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 612  : 		if (Czas.wSecond < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania sekund je¿eli sekundy jest minejsza ni¿ 10 do pliku log_aktualny.txt

  00b71	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
  00b77	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00b7b	73 12		 jae	 SHORT $LN54@Wczytaj_z_
  00b7d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00b82	8b cf		 mov	 ecx, edi
  00b84	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00b89	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
$LN54@Wczytaj_z_:

; 613  : 		log << Czas.wSecond << '\n'; // Wpisanie do bufora zapisu danych o sekundzie do pliku log_aktualny.txt

  00b8f	0f b7 c0	 movzx	 eax, ax
  00b92	8b cb		 mov	 ecx, ebx
  00b94	50		 push	 eax
  00b95	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00b9b	b2 0a		 mov	 dl, 10			; 0000000aH
  00b9d	8b c8		 mov	 ecx, eax
  00b9f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 614  : 		log_ogólny << "Nowa gra rozpoczeta dnia " << Czas.wDay << "." << Czas.wMonth << "." << Czas.wYear << " o godzinie "; //Wpisanie do bufora zapisu danych o dniu,miesi¹cu i roku do pliku log_ogólny.txt

  00ba4	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A
  00bab	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@
  00bb0	50		 push	 eax
  00bb1	0f b7 05 02 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+2
  00bb8	8b ce		 mov	 ecx, esi
  00bba	50		 push	 eax
  00bbb	0f b7 05 06 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+6
  00bc2	50		 push	 eax
  00bc3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00bc8	8b c8		 mov	 ecx, eax
  00bca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00bd0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00bd5	8b c8		 mov	 ecx, eax
  00bd7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00bdc	8b c8		 mov	 ecx, eax
  00bde	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00be4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00be9	8b c8		 mov	 ecx, eax
  00beb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00bf0	8b c8		 mov	 ecx, eax
  00bf2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00bf8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
  00bfd	8b c8		 mov	 ecx, eax
  00bff	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 615  : 		if (Czas.wHour < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania godzinny je¿eli godzina jest minejsza ni¿ 10 do pliku log_ogólny.txt

  00c04	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
  00c0a	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00c0e	73 12		 jae	 SHORT $LN55@Wczytaj_z_
  00c10	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00c15	8b ce		 mov	 ecx, esi
  00c17	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00c1c	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
$LN55@Wczytaj_z_:

; 616  : 		log_ogólny << Czas.wHour << ":";//Wpisanie do bufora zapisu znaku : dla rozdzielenia godzin od minut do pliku log_aktualny.txt

  00c22	0f b7 c0	 movzx	 eax, ax
  00c25	8b ce		 mov	 ecx, esi
  00c27	50		 push	 eax
  00c28	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00c2e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00c33	8b c8		 mov	 ecx, eax
  00c35	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 617  : 		if (Czas.wMinute < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania minut je¿eli minuty jest minejsza ni¿ 10 do pliku log_ogólny.txt

  00c3a	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
  00c40	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00c44	73 12		 jae	 SHORT $LN56@Wczytaj_z_
  00c46	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00c4b	8b ce		 mov	 ecx, esi
  00c4d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00c52	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
$LN56@Wczytaj_z_:

; 618  : 		log_ogólny << Czas.wMinute << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia minut od sekund do pliku log_ogólny.txt

  00c58	0f b7 c0	 movzx	 eax, ax
  00c5b	8b ce		 mov	 ecx, esi
  00c5d	50		 push	 eax
  00c5e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00c64	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00c69	8b c8		 mov	 ecx, eax
  00c6b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 619  : 		if (Czas.wSecond < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania sekund je¿eli sekundy jest minejsza ni¿ 10 do pliku log_ogólny.txt

  00c70	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
  00c76	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00c7a	73 12		 jae	 SHORT $LN57@Wczytaj_z_
  00c7c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00c81	8b ce		 mov	 ecx, esi
  00c83	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00c88	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
$LN57@Wczytaj_z_:

; 620  : 		log_ogólny << Czas.wSecond << '\n'; // Wpisanie do bufora zapisu danych o sekundzie do pliku log_ogólny.txt

  00c8e	0f b7 c0	 movzx	 eax, ax
  00c91	8b ce		 mov	 ecx, esi
  00c93	50		 push	 eax
  00c94	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00c9a	b2 0a		 mov	 dl, 10			; 0000000aH
  00c9c	8b c8		 mov	 ecx, eax
  00c9e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 621  : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  00ca3	8b cb		 mov	 ecx, ebx
  00ca5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 622  : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00cab	8b ce		 mov	 ecx, esi
  00cad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN33@Wczytaj_z_:

; 624  : }

  00cb3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00cb6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00cbd	59		 pop	 ecx
  00cbe	5f		 pop	 edi
  00cbf	5e		 pop	 esi
  00cc0	5b		 pop	 ebx
  00cc1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cc4	33 cd		 xor	 ecx, ebp
  00cc6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ccb	8b e5		 mov	 esp, ebp
  00ccd	5d		 pop	 ebp
  00cce	c3		 ret	 0
$LN1727@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1611 : 			_Xran();

  00ccf	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN1735@Wczytaj_z_:
$LN1726@Wczytaj_z_:
  00cd4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$218[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2:
  00010	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$215[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3:
  0001b	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4:
  00023	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5:
  0002b	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  00031	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
  00036	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003d	8b 8a 44 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-188]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0004d	33 c8		 xor	 ecx, eax
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  00059	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Wczytaj_z_Pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; Wczytaj_z_Pliku
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Sprawd_Pliki@@YAXXZ
_TEXT	SEGMENT
$T653 = -536						; size = 24
$T645 = -536						; size = 24
$T634 = -536						; size = 24
$T625 = -536						; size = 24
$T548 = -536						; size = 24
$T652 = -512						; size = 24
$T644 = -512						; size = 24
$T633 = -512						; size = 24
$T624 = -512						; size = 24
$T550 = -512						; size = 24
$T492 = -488						; size = 1
$T471 = -484						; size = 1
$T668 = -480						; size = 4
$T432 = -476						; size = 1
$T413 = -472						; size = 1
$T665 = -468						; size = 24
$T661 = -468						; size = 24
$T660 = -468						; size = 24
$T655 = -468						; size = 24
$T647 = -468						; size = 24
$T638 = -468						; size = 24
$T636 = -468						; size = 24
$T619 = -468						; size = 24
$T664 = -444						; size = 24
$T654 = -444						; size = 24
$T646 = -444						; size = 24
$T637 = -444						; size = 24
$T635 = -444						; size = 24
$T626 = -444						; size = 24
$T618 = -444						; size = 24
$T617 = -444						; size = 24
$T530 = -444						; size = 24
$T666 = -420						; size = 24
$T662 = -420						; size = 24
$T659 = -420						; size = 24
$T657 = -420						; size = 24
$T656 = -420						; size = 24
$T648 = -420						; size = 24
$T642 = -420						; size = 24
$T641 = -420						; size = 24
$T639 = -420						; size = 24
$T628 = -420						; size = 24
$T534 = -396						; size = 1
tv12476 = -396						; size = 4
$T669 = -392						; size = 4
$T555 = -392						; size = 1
$T1 = -392						; size = 4
$T629 = -388						; size = 24
$T620 = -388						; size = 24
$T579 = -388						; size = 24
$T551 = -388						; size = 24
$T477 = -388						; size = 24
$T419 = -388						; size = 24
$T190 = -388						; size = 24
$T670 = -364						; size = 4
_i$1$ = -360						; size = 4
$T99 = -360						; size = 1
tv12363 = -360						; size = 4
$T651 = -356						; size = 24
$T643 = -356						; size = 24
$T632 = -356						; size = 24
$T623 = -356						; size = 24
$T578 = -356						; size = 24
$T569 = -356						; size = 24
$T465 = -356						; size = 24
$T464 = -356						; size = 24
$T463 = -356						; size = 24
$T401 = -356						; size = 24
$T389 = -356						; size = 24
$T386 = -356						; size = 24
$T385 = -356						; size = 24
$T379 = -356						; size = 24
$T371 = -356						; size = 24
$T359 = -356						; size = 24
$T356 = -356						; size = 24
$T355 = -356						; size = 24
$T349 = -356						; size = 24
$T341 = -356						; size = 24
$T329 = -356						; size = 24
$T326 = -356						; size = 24
$T325 = -356						; size = 24
$T319 = -356						; size = 24
$T311 = -356						; size = 24
$T299 = -356						; size = 24
$T296 = -356						; size = 24
$T295 = -356						; size = 24
$T289 = -356						; size = 24
$T281 = -356						; size = 24
$T261 = -356						; size = 24
$T650 = -332						; size = 24
$T631 = -332						; size = 24
$T622 = -332						; size = 24
$T580 = -332						; size = 24
$T561 = -332						; size = 24
$T486 = -332						; size = 24
$T409 = -332						; size = 24
$T400 = -332						; size = 24
$T387 = -332						; size = 24
$T370 = -332						; size = 24
$T357 = -332						; size = 24
$T340 = -332						; size = 24
$T327 = -332						; size = 24
$T310 = -332						; size = 24
$T297 = -332						; size = 24
$T280 = -332						; size = 24
$T254 = -332						; size = 24
$T247 = -332						; size = 24
$T235 = -332						; size = 24
$T188 = -332						; size = 24
$T165 = -332						; size = 24
$T158 = -332						; size = 24
$T151 = -332						; size = 24
$T139 = -332						; size = 24
$T630 = -308						; size = 24
$T621 = -308						; size = 24
$T592 = -308						; size = 24
$T540 = -308						; size = 24
$T498 = -308						; size = 24
$T438 = -308						; size = 24
$T398 = -308						; size = 24
$T368 = -308						; size = 24
$T338 = -308						; size = 24
$T308 = -308						; size = 24
$T278 = -308						; size = 24
$T263 = -308						; size = 24
$T191 = -308						; size = 24
$T167 = -308						; size = 24
$T35 = -308						; size = 24
$T24 = -308						; size = 24
$T13 = -308						; size = 24
$T2 = -308						; size = 24
_czy_pobrano$1$ = -283					; size = 1
$T671 = -282						; size = 1
$T672 = -282						; size = 1
$T673 = -282						; size = 1
$T674 = -282						; size = 1
$T675 = -282						; size = 1
$T676 = -282						; size = 1
$T677 = -282						; size = 1
$T678 = -282						; size = 1
$T679 = -282						; size = 1
tv12576 = -282						; size = 1
_czy_pobierano$1$ = -281				; size = 1
_czy_pobierano$1$ = -281				; size = 1
_numers$680 = -280					; size = 176
_numers$681 = -280					; size = 176
__Ch$ = -104						; size = 1
_link$682 = -100					; size = 24
__Ch$ = -76						; size = 1
_this$ = -76						; size = 4
$T586 = -72						; size = 1
__Ch$ = -72						; size = 1
_g³os2$683 = -68					; size = 24
_g³os3$684 = -44					; size = 24
_i$1$ = -20						; size = 4
_i$1$ = -20						; size = 4
__Result$1$ = -20					; size = 4
$T685 = -20						; size = 4
_res$1$ = -20						; size = 4
$T686 = -20						; size = 4
$T104 = -20						; size = 1
__Ch$ = -20						; size = 1
$T96 = -20						; size = 1
$T91 = -20						; size = 1
$T71 = -20						; size = 1
$T61 = -20						; size = 1
$T56 = -20						; size = 1
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Sprawd_Pliki@@YAXXZ PROC				; Sprawd_Pliki, COMDAT

; 627  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Sprawd_Pliki@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 628  : 	if (Ustawienia.efekty_dwiêkowe == 1) //Je¿eli w³¹czono efekty dwiêkowe

  00037	66 83 3d 18 00
	00 00 01	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, 1
  0003f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___access
  00045	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__URLDownloadToFileA@20
  0004b	0f 85 c1 04 00
	00		 jne	 $LN38@Sprawd_P

; 629  : 	{
; 630  : 		if ((_access("Efekty_dwiêkowe", 0))) //Sprawd czy nie ma folderu Efekty dwiêkowe

  00051	6a 00		 push	 0
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
  00058	ff d6		 call	 esi
  0005a	83 c4 08	 add	 esp, 8
  0005d	85 c0		 test	 eax, eax
  0005f	74 0d		 je	 SHORT $LN14@Sprawd_P

; 631  : 		{
; 632  : 			CreateDirectoryA("Efekty_dwiêkowe", nullptr); //Je¿eli nie ma to utwórz go

  00061	6a 00		 push	 0
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8
$LN14@Sprawd_P:

; 633  : 		}
; 634  : 
; 635  : 		bool czy_pobierano = false; //Utworzenie zmiennej informuj¹c¹ czy rozpoczêto pobieranie plików
; 636  : 		bool czy_pobrano = true; //Utworzenie zmiennej informuj¹c¹ czy ostatnie pobieranie zakoñczy³o siê sukesem
; 637  : 
; 638  : 		if ((_access("Efekty_dwiêkowe/bankrut.wav", 0))) //Sprawdzenie czy plik nie istnieje

  0006e	6a 00		 push	 0
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  00075	c6 85 e7 fe ff
	ff 00		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0007c	c6 85 e5 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobrano$1$[ebp], 1
  00083	ff d6		 call	 esi
  00085	83 c4 08	 add	 esp, 8
  00088	85 c0		 test	 eax, eax
  0008a	0f 84 16 01 00
	00		 je	 $LN4517@Sprawd_P

; 639  : 		{
; 640  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o
; 641  : 			{
; 642  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00096	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0009b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000a0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000a5	8b c8		 mov	 ecx, eax
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000ad	6a 1c		 push	 28			; 0000001cH
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  000b4	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 643  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  000ba	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  000c1	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000cb	c7 85 e0 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000d5	c6 85 cc fe ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000dc	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 645  : 			if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/bankrut.wav", IDR_bankrut)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku bankrut.wav

  000e1	ba 7c 00 00 00	 mov	 edx, 124		; 0000007cH
  000e6	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000ec	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000f1	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 645  : 			if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/bankrut.wav", IDR_bankrut)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku bankrut.wav

  000f7	84 c0		 test	 al, al
  000f9	0f 94 c0	 sete	 al
  000fc	88 85 e6 fe ff
	ff		 mov	 BYTE PTR $T677[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00102	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00105	72 5c		 jb	 SHORT $LN292@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00107	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0010d	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0010e	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00110	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00116	72 3b		 jb	 SHORT $LN295@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00118	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  0011b	3b f2		 cmp	 esi, edx
  0011d	0f 86 65 03 00
	00		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00123	8b d6		 mov	 edx, esi
  00125	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00128	0f 85 5a 03 00
	00		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0012e	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00131	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00133	0f 83 4f 03 00
	00		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00139	2b c8		 sub	 ecx, eax
  0013b	83 f9 04	 cmp	 ecx, 4
  0013e	0f 82 44 03 00
	00		 jb	 $_Invalid_parameter$4562

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00144	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00147	0f 87 3b 03 00
	00		 ja	 $_Invalid_parameter$4562

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0014d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___access
$LN295@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00153	52		 push	 edx
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0015a	8a 85 e6 fe ff
	ff		 mov	 al, BYTE PTR $T677[ebp]
  00160	83 c4 08	 add	 esp, 8
$LN292@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 645  : 			if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/bankrut.wav", IDR_bankrut)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku bankrut.wav

  00163	84 c0		 test	 al, al
  00165	74 3f		 je	 SHORT $LN4517@Sprawd_P

; 646  : 			{
; 647  : 				auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/bankrut.wav", "Efekty_dwiêkowe/bankrut.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  00167	6a 00		 push	 0
  00169	6a 00		 push	 0
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@
  00175	6a 00		 push	 0
  00177	ff d7		 call	 edi

; 648  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00179	85 c0		 test	 eax, eax
  0017b	74 29		 je	 SHORT $LN4517@Sprawd_P

; 649  : 					if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 650  : 					{
; 651  : 						czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false
; 652  : 						cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudanym pobieraniu i konsekwencji tego

  0017d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00183	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  00188	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0018d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00192	8b c8		 mov	 ecx, eax
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 653  : 						EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio

  0019a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne

; 654  : 					}
; 655  : 			}
; 656  : 		}
; 657  : 
; 658  : 		if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo

  001a1	e9 6c 03 00 00	 jmp	 $LN38@Sprawd_P
$LN4517@Sprawd_P:

; 659  : 			if ((_access("Efekty_dwiêkowe/wygrana1.wav", 0))) //Sprawdzenie czy plik nie istnieje

  001a6	6a 00		 push	 0
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
  001ad	ff d6		 call	 esi
  001af	83 c4 08	 add	 esp, 8
  001b2	85 c0		 test	 eax, eax
  001b4	0f 84 fa 00 00
	00		 je	 $LN4521@Sprawd_P

; 660  : 			{
; 661  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  001ba	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  001c1	75 24		 jne	 SHORT $LN22@Sprawd_P

; 662  : 				{
; 663  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001c9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  001ce	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001d3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001d8	8b c8		 mov	 ecx, eax
  001da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 664  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  001e0	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN22@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  001e7	6a 1d		 push	 29			; 0000001dH
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
  001ee	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]

; 3683 : 		_My_data._Mysize = 0;

  001f4	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001fe	c7 85 e0 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T13[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00208	c6 85 cc fe ff
	ff 00		 mov	 BYTE PTR $T13[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0020f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 666  : 				if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/wygrana1.wav", IDR_wygrana1)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku wygrana1.wav

  00214	ba 7d 00 00 00	 mov	 edx, 125		; 0000007dH
  00219	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  0021f	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00224	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T13[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 666  : 				if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/wygrana1.wav", IDR_wygrana1)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku wygrana1.wav

  0022a	84 c0		 test	 al, al
  0022c	0f 94 c0	 sete	 al
  0022f	88 85 e6 fe ff
	ff		 mov	 BYTE PTR $T679[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00235	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00238	72 5c		 jb	 SHORT $LN393@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0023a	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T13[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00240	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00241	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00243	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00249	72 3b		 jb	 SHORT $LN396@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0024b	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  0024e	3b f2		 cmp	 esi, edx
  00250	0f 86 32 02 00
	00		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00256	8b d6		 mov	 edx, esi
  00258	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0025b	0f 85 27 02 00
	00		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00261	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00264	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00266	0f 83 1c 02 00
	00		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0026c	2b c8		 sub	 ecx, eax
  0026e	83 f9 04	 cmp	 ecx, 4
  00271	0f 82 11 02 00
	00		 jb	 $_Invalid_parameter$4562

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00277	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0027a	0f 87 08 02 00
	00		 ja	 $_Invalid_parameter$4562

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00280	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___access
$LN396@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00286	52		 push	 edx
  00287	50		 push	 eax
  00288	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0028d	8a 85 e6 fe ff
	ff		 mov	 al, BYTE PTR $T679[ebp]
  00293	83 c4 08	 add	 esp, 8
$LN393@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 666  : 				if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/wygrana1.wav", IDR_wygrana1)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku wygrana1.wav

  00296	84 c0		 test	 al, al
  00298	74 1a		 je	 SHORT $LN4521@Sprawd_P

; 667  : 				{
; 668  : 					auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/wygrana1.wav", "Efekty_dwiêkowe/wygrana1.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  0029a	6a 00		 push	 0
  0029c	6a 00		 push	 0
  0029e	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
  002a3	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@
  002a8	6a 00		 push	 0
  002aa	ff d7		 call	 edi

; 669  : 					if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  002ac	85 c0		 test	 eax, eax
  002ae	0f 85 04 02 00
	00		 jne	 $LN4535@Sprawd_P
$LN4521@Sprawd_P:

; 670  : 						if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 671  : 						{
; 672  : 							czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false
; 673  : 							cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudanym pobieraniu i konsekwencji tego
; 674  : 							EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 675  : 						}
; 676  : 				}
; 677  : 			}
; 678  : 
; 679  : 		if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 680  : 			if ((_access("Efekty_dwiêkowe/wygrana2.wav", 0))) //Sprawdzenie czy plik nie istnieje

  002b4	6a 00		 push	 0
  002b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
  002bb	ff d6		 call	 esi
  002bd	83 c4 08	 add	 esp, 8
  002c0	85 c0		 test	 eax, eax
  002c2	0f 84 fa 00 00
	00		 je	 $LN4523@Sprawd_P

; 681  : 			{
; 682  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  002c8	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  002cf	75 24		 jne	 SHORT $LN28@Sprawd_P

; 683  : 				{
; 684  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  002d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002d7	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  002dc	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002e1	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002e6	8b c8		 mov	 ecx, eax
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 685  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  002ee	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN28@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002f5	6a 1d		 push	 29			; 0000001dH
  002f7	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
  002fc	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]

; 3683 : 		_My_data._Mysize = 0;

  00302	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T24[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0030c	c7 85 e0 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T24[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00316	c6 85 cc fe ff
	ff 00		 mov	 BYTE PTR $T24[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0031d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 687  : 				if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/wygrana2.wav", IDR_wygrana2)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku wygrana2.wav

  00322	ba 7e 00 00 00	 mov	 edx, 126		; 0000007eH
  00327	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  0032d	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00332	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T24[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 687  : 				if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/wygrana2.wav", IDR_wygrana2)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku wygrana2.wav

  00338	84 c0		 test	 al, al
  0033a	0f 94 c0	 sete	 al
  0033d	88 85 e6 fe ff
	ff		 mov	 BYTE PTR $T678[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00343	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00346	72 5c		 jb	 SHORT $LN493@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00348	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T24[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0034e	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0034f	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00351	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00357	72 3b		 jb	 SHORT $LN496@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00359	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  0035c	3b f2		 cmp	 esi, edx
  0035e	0f 86 24 01 00
	00		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00364	8b d6		 mov	 edx, esi
  00366	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00369	0f 85 19 01 00
	00		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0036f	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00372	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00374	0f 83 0e 01 00
	00		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0037a	2b c8		 sub	 ecx, eax
  0037c	83 f9 04	 cmp	 ecx, 4
  0037f	0f 82 03 01 00
	00		 jb	 $_Invalid_parameter$4562

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00385	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00388	0f 87 fa 00 00
	00		 ja	 $_Invalid_parameter$4562

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0038e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___access
$LN496@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00394	52		 push	 edx
  00395	50		 push	 eax
  00396	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0039b	8a 85 e6 fe ff
	ff		 mov	 al, BYTE PTR $T678[ebp]
  003a1	83 c4 08	 add	 esp, 8
$LN493@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 687  : 				if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/wygrana2.wav", IDR_wygrana2)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku wygrana2.wav

  003a4	84 c0		 test	 al, al
  003a6	74 1a		 je	 SHORT $LN4523@Sprawd_P

; 688  : 				{
; 689  : 					auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/wygrana2.wav", "Efekty_dwiêkowe/wygrana2.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  003a8	6a 00		 push	 0
  003aa	6a 00		 push	 0
  003ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
  003b1	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@
  003b6	6a 00		 push	 0
  003b8	ff d7		 call	 edi

; 690  : 					if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  003ba	85 c0		 test	 eax, eax
  003bc	0f 85 f6 00 00
	00		 jne	 $LN4535@Sprawd_P
$LN4523@Sprawd_P:

; 691  : 						if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 692  : 						{
; 693  : 							czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false
; 694  : 							cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudanym pobieraniu i konsekwencji tego
; 695  : 							EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 696  : 						}
; 697  : 				}
; 698  : 			}
; 699  : 
; 700  : 		if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 701  : 			if ((_access("Efekty_dwiêkowe/zwielokrotnenie.wav", 0))) //Sprawdzenie czy plik nie istnieje

  003c2	6a 00		 push	 0
  003c4	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  003c9	ff d6		 call	 esi
  003cb	83 c4 08	 add	 esp, 8
  003ce	85 c0		 test	 eax, eax
  003d0	0f 84 0d 01 00
	00		 je	 $LN37@Sprawd_P

; 702  : 			{
; 703  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  003d6	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  003dd	75 24		 jne	 SHORT $LN34@Sprawd_P

; 704  : 				{
; 705  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  003df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  003e5	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  003ea	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  003ef	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003f4	8b c8		 mov	 ecx, eax
  003f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 706  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  003fc	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN34@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00403	6a 24		 push	 36			; 00000024H
  00405	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  0040a	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]

; 3683 : 		_My_data._Mysize = 0;

  00410	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T35[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0041a	c7 85 e0 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T35[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00424	c6 85 cc fe ff
	ff 00		 mov	 BYTE PTR $T35[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0042b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 708  : 				if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/zwielokrotnenie.wav", IDR_zwielokrotnenie)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku zwielokrotnienie.wav

  00430	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00435	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]
  0043b	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00440	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T35[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 708  : 				if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/zwielokrotnenie.wav", IDR_zwielokrotnenie)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku zwielokrotnienie.wav

  00446	84 c0		 test	 al, al
  00448	0f 94 c0	 sete	 al
  0044b	88 85 e6 fe ff
	ff		 mov	 BYTE PTR $T676[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00451	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00454	72 48		 jb	 SHORT $LN593@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00456	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T35[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0045c	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0045d	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0045f	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00465	72 27		 jb	 SHORT $LN596@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00467	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  0046a	3b f2		 cmp	 esi, edx
  0046c	76 1a		 jbe	 SHORT $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0046e	8b d6		 mov	 edx, esi
  00470	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00473	75 13		 jne	 SHORT $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00475	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00478	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0047a	73 0c		 jae	 SHORT $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0047c	2b c8		 sub	 ecx, eax
  0047e	83 f9 04	 cmp	 ecx, 4
  00481	72 05		 jb	 SHORT $_Invalid_parameter$4562

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00483	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00486	76 06		 jbe	 SHORT $LN596@Sprawd_P
$_Invalid_parameter$4562:
$_Invalid_parameter$4563:
$_Invalid_parameter$4564:
$_Invalid_parameter$4565:
$_Invalid_parameter$4566:
$_Invalid_parameter$4567:
$_Invalid_parameter$4568:
$_Invalid_parameter$4569:
$_Invalid_parameter$4570:
$_Invalid_parameter$4571:
$_Invalid_parameter$4572:
$_Invalid_parameter$4573:
$_Invalid_parameter$4574:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00488	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4548@Sprawd_P:
$LN596@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0048e	52		 push	 edx
  0048f	50		 push	 eax
  00490	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00495	8a 85 e6 fe ff
	ff		 mov	 al, BYTE PTR $T676[ebp]
  0049b	83 c4 08	 add	 esp, 8
$LN593@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 708  : 				if (!Wyci¹gnij_z_Programu("Efekty_dwiêkowe/zwielokrotnenie.wav", IDR_zwielokrotnenie)) //Je¿eli nie uda³o wydobyæ siê z zasobów pliku zwielokrotnienie.wav

  0049e	84 c0		 test	 al, al
  004a0	74 41		 je	 SHORT $LN37@Sprawd_P

; 709  : 				{
; 710  : 					auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/zwielokrotnenie.wav", "Efekty_dwiêkowe/zwielokrotnenie.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  004a2	6a 00		 push	 0
  004a4	6a 00		 push	 0
  004a6	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  004ab	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@
  004b0	6a 00		 push	 0
  004b2	ff d7		 call	 edi

; 711  : 					if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  004b4	85 c0		 test	 eax, eax
  004b6	74 2b		 je	 SHORT $LN37@Sprawd_P
$LN4535@Sprawd_P:

; 712  : 						if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 713  : 						{
; 714  : 							czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false
; 715  : 							cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  004b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004be	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  004c3	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  004c8	c6 85 e5 fe ff
	ff 00		 mov	 BYTE PTR _czy_pobrano$1$[ebp], 0
  004cf	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004d4	8b c8		 mov	 ecx, eax
  004d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 716  : 							EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio

  004dc	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
$LN37@Sprawd_P:

; 717  : 						}
; 718  : 				}
; 719  : 			}
; 720  : 
; 721  : 		if (czy_pobierano && czy_pobrano) cout << "Pobrano brakuj¹ce pliki efektów" << endl; //Poinformowanie o ukoñczonu pobierania plików

  004e3	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  004ea	74 26		 je	 SHORT $LN38@Sprawd_P
  004ec	80 bd e5 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobrano$1$[ebp], 0
  004f3	74 1d		 je	 SHORT $LN38@Sprawd_P
  004f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004fb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@
  00500	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00505	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0050a	8b c8		 mov	 ecx, eax
  0050c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN38@Sprawd_P:

; 722  : 	}
; 723  : 
; 724  : 	if (Ustawienia.g³os_odczytu_numeru > 0) //Je¿eli w³¹czono odczyt g³osowy

  00512	66 83 3d 14 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, 0
  0051a	0f 8e 16 28 00
	00		 jle	 $LN39@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00520	6a 05		 push	 5
  00522	68 00 00 00 00	 push	 OFFSET ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  00527	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0052c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 728  : 		switch (Ustawienia.g³os_odczytu_numeru) //U¿ycie warunku wielokrotnego wyboru do wpisania odpowiedniej nazwy g³osu do zmiennej g³os_nazwa

  00531	0f bf 05 14 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20
  00538	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__memmove
  0053e	48		 dec	 eax
  0053f	83 f8 08	 cmp	 eax, 8
  00542	0f 87 87 01 00
	00		 ja	 $LN892@Sprawd_P
  00548	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN4547@Sprawd_P[eax*4]
$LN40@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0054f	6a 05		 push	 5
  00551	68 00 00 00 00	 push	 OFFSET ??_C@_05KFCKMKOB@Jacek?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  00556	e9 27 01 00 00	 jmp	 $LN4542@Sprawd_P
$LN41@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0055b	6a 03		 push	 3
  0055d	68 00 00 00 00	 push	 OFFSET ??_C@_03FPCJKMNP@Ewa?$AA@
$LN4543@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00562	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00568	8b c2		 mov	 eax, edx
  0056a	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00570	2b c1		 sub	 eax, ecx
  00572	83 f8 03	 cmp	 eax, 3
  00575	72 28		 jb	 SHORT $LN676@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00577	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  0057a	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]

; 1582 : 		value_type * _Result = _Bx._Buf;

  0057d	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00582	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  00587	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0058e	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00590	56		 push	 esi
  00591	ff d7		 call	 edi
  00593	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  00596	c6 46 03 00	 mov	 BYTE PTR [esi+3], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0059a	e9 30 01 00 00	 jmp	 $LN892@Sprawd_P
$LN676@Sprawd_P:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  0059f	c6 45 ec 00	 mov	 BYTE PTR $T56[ebp], 0
  005a3	ff 75 ec	 push	 DWORD PTR $T56[ebp]
  005a6	6a 03		 push	 3
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 738  : 			break; //Wyjcie z instrukcji case

  005a8	e9 18 01 00 00	 jmp	 $LN4536@Sprawd_P
$LN42@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  005ad	6a 04		 push	 4
  005af	68 00 00 00 00	 push	 OFFSET ??_C@_04CDICBAGM@Maja?$AA@
$LN4544@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  005b4	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  005ba	8b c2		 mov	 eax, edx
  005bc	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  005c2	2b c1		 sub	 eax, ecx
  005c4	83 f8 04	 cmp	 eax, 4
  005c7	72 28		 jb	 SHORT $LN707@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005c9	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  005cc	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1582 : 		value_type * _Result = _Bx._Buf;

  005cf	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  005d4	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  005d9	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  005e0	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  005e2	56		 push	 esi
  005e3	ff d7		 call	 edi
  005e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  005e8	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  005ec	e9 de 00 00 00	 jmp	 $LN892@Sprawd_P
$LN707@Sprawd_P:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  005f1	c6 45 ec 00	 mov	 BYTE PTR $T61[ebp], 0
  005f5	ff 75 ec	 push	 DWORD PTR $T61[ebp]
  005f8	6a 04		 push	 4
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 743  : 			break; //Wyjcie z instrukcji case

  005fa	e9 c6 00 00 00	 jmp	 $LN4536@Sprawd_P
$LN43@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  005ff	6a 03		 push	 3
  00601	68 00 00 00 00	 push	 OFFSET ??_C@_03JIHJHPIE@Jan?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  00606	e9 57 ff ff ff	 jmp	 $LN4543@Sprawd_P
$LN44@Sprawd_P:

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  0060b	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00611	8b c2		 mov	 eax, edx
  00613	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00619	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0061b	6a 06		 push	 6
  0061d	68 00 00 00 00	 push	 OFFSET ??_C@_06DKNIKMFF@Jacek2?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00622	83 f8 06	 cmp	 eax, 6
  00625	72 28		 jb	 SHORT $LN769@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00627	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  0062a	8d 41 06	 lea	 eax, DWORD PTR [ecx+6]

; 1582 : 		value_type * _Result = _Bx._Buf;

  0062d	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00632	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  00637	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0063e	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00640	56		 push	 esi
  00641	ff d7		 call	 edi
  00643	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  00646	c6 46 06 00	 mov	 BYTE PTR [esi+6], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0064a	e9 80 00 00 00	 jmp	 $LN892@Sprawd_P
$LN769@Sprawd_P:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  0064f	c6 45 ec 00	 mov	 BYTE PTR $T71[ebp], 0
  00653	ff 75 ec	 push	 DWORD PTR $T71[ebp]
  00656	6a 06		 push	 6
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 753  : 			break; //Wyjcie z instrukcji case

  00658	eb 6b		 jmp	 SHORT $LN4536@Sprawd_P
$LN45@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0065a	6a 04		 push	 4
  0065c	68 00 00 00 00	 push	 OFFSET ??_C@_04PLEDLCJI@Ewa2?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  00661	e9 4e ff ff ff	 jmp	 $LN4544@Sprawd_P
$LN46@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00666	6a 05		 push	 5
  00668	68 00 00 00 00	 push	 OFFSET ??_C@_05KJFHPLBC@Maja2?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0066d	eb 13		 jmp	 SHORT $LN4542@Sprawd_P
$LN47@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0066f	6a 04		 push	 4
  00671	68 00 00 00 00	 push	 OFFSET ??_C@_04HDNGKDH@Jan2?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  00676	e9 39 ff ff ff	 jmp	 $LN4544@Sprawd_P
$LN48@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0067b	6a 05		 push	 5
  0067d	68 00 00 00 00	 push	 OFFSET ??_C@_05NKPCGME@Agata?$AA@
$LN4542@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00682	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00688	8b c2		 mov	 eax, edx
  0068a	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00690	2b c1		 sub	 eax, ecx
  00692	83 f8 05	 cmp	 eax, 5
  00695	72 25		 jb	 SHORT $LN645@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00697	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  0069a	8d 41 05	 lea	 eax, DWORD PTR [ecx+5]

; 1582 : 		value_type * _Result = _Bx._Buf;

  0069d	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  006a2	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  006a7	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  006ae	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  006b0	56		 push	 esi
  006b1	ff d7		 call	 edi
  006b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  006b6	c6 46 05 00	 mov	 BYTE PTR [esi+5], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  006ba	eb 13		 jmp	 SHORT $LN892@Sprawd_P
$LN645@Sprawd_P:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  006bc	c6 45 ec 00	 mov	 BYTE PTR $T91[ebp], 0
  006c0	ff 75 ec	 push	 DWORD PTR $T91[ebp]
  006c3	6a 05		 push	 5
$LN4536@Sprawd_P:
  006c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  006ca	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN892@Sprawd_P:

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  006cf	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  006d5	8b c2		 mov	 eax, edx
  006d7	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  006dd	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  006df	6a 01		 push	 1
  006e1	68 00 00 00 00	 push	 OFFSET ??_C@_01IDAFKMJL@_?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  006e6	83 f8 01	 cmp	 eax, 1
  006e9	72 25		 jb	 SHORT $LN924@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006eb	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  006ee	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 1582 : 		value_type * _Result = _Bx._Buf;

  006f1	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  006f6	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  006fb	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00702	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00704	56		 push	 esi
  00705	ff d7		 call	 edi
  00707	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  0070a	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0070e	eb 13		 jmp	 SHORT $LN923@Sprawd_P
$LN924@Sprawd_P:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  00710	c6 45 ec 00	 mov	 BYTE PTR $T96[ebp], 0
  00714	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00719	ff 75 ec	 push	 DWORD PTR $T96[ebp]
  0071c	6a 01		 push	 1
  0071e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN923@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 781  : 		G³os += '0' + Ustawienia.g³os_szybkoæ_odczytu_numeru; //Dodanie do zmiennej szybkoci mowy

  00723	8a 0d 16 00 00
	00		 mov	 cl, BYTE PTR ?Ustawienia@@3US_Ustawienia@@A+22
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  00729	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 781  : 		G³os += '0' + Ustawienia.g³os_szybkoæ_odczytu_numeru; //Dodanie do zmiennej szybkoci mowy

  0072f	80 c1 30	 add	 cl, 48			; 00000030H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2977 : 		if (_Old_size < _My_data._Myres)

  00732	8b 35 14 00 00
	00		 mov	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20

; 2299 : 		push_back(_Ch);

  00738	88 4d ec	 mov	 BYTE PTR __Ch$[ebp], cl

; 2977 : 		if (_Old_size < _My_data._Myres)

  0073b	3b d6		 cmp	 edx, esi
  0073d	73 21		 jae	 SHORT $LN948@Sprawd_P

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  0073f	8d 42 01	 lea	 eax, DWORD PTR [edx+1]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00742	83 fe 10	 cmp	 esi, 16			; 00000010H

; 2979 : 			_My_data._Mysize = _Old_size + 1;

  00745	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0074a	b8 00 00 00 00	 mov	 eax, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1583 : 		if (_Large_string_engaged())

  0074f	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00756	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00759	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  0075e	eb 1b		 jmp	 SHORT $LN947@Sprawd_P
$LN948@Sprawd_P:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  00760	ff 75 ec	 push	 DWORD PTR __Ch$[ebp]
  00763	c6 85 98 fe ff
	ff 00		 mov	 BYTE PTR $T99[ebp], 0
  0076a	ff b5 98 fe ff
	ff		 push	 DWORD PTR $T99[ebp]
  00770	51		 push	 ecx
  00771	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00776	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN947@Sprawd_P:

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  0077b	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00781	8b c2		 mov	 eax, edx
  00783	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00789	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0078b	6a 01		 push	 1
  0078d	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00792	83 f8 01	 cmp	 eax, 1
  00795	72 25		 jb	 SHORT $LN979@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00797	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  0079a	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 1582 : 		value_type * _Result = _Bx._Buf;

  0079d	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  007a2	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  007a7	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  007ae	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  007b0	56		 push	 esi
  007b1	ff d7		 call	 edi
  007b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  007b6	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  007ba	eb 13		 jmp	 SHORT $LN978@Sprawd_P
$LN979@Sprawd_P:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  007bc	c6 45 ec 00	 mov	 BYTE PTR $T104[ebp], 0
  007c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  007c5	ff 75 ec	 push	 DWORD PTR $T104[ebp]
  007c8	6a 01		 push	 1
  007ca	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN978@Sprawd_P:

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  007cf	6a 42		 push	 66			; 00000042H
  007d1	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
  007d6	8d 4d 9c	 lea	 ecx, DWORD PTR _link$682[ebp]

; 3683 : 		_My_data._Mysize = 0;

  007d9	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _link$682[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  007e0	c7 45 b0 0f 00
	00 00		 mov	 DWORD PTR _link$682[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  007e7	c6 45 9c 00	 mov	 BYTE PTR _link$682[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  007eb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 784  : 		const string link = "https://github.com/talez2709/Ruletka/raw/master/Ruletka/G%C5%82os/"; //Zmienna przechowywuj¹ca pocz¹tek strony do pobierania g³osu

  007f0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  007f7	a1 10 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 3683 : 		_My_data._Mysize = 0;

  007fc	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _g³os2$683[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00803	c7 45 d0 0f 00
	00 00		 mov	 DWORD PTR _g³os2$683[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0080a	c6 45 bc 00	 mov	 BYTE PTR _g³os2$683[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  0080e	83 f8 05	 cmp	 eax, 5
  00811	0f 82 3a 25 00
	00		 jb	 $LN4545@Sprawd_P

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00817	83 c0 fb	 add	 eax, -5			; fffffffbH
  0081a	83 c9 ff	 or	 ecx, -1
  0081d	83 f8 ff	 cmp	 eax, -1
  00820	0f 42 c8	 cmovb	 ecx, eax

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00823	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0082a	b8 00 00 00 00	 mov	 eax, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1594 : 		if (_Large_string_engaged())

  0082f	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00836	51		 push	 ecx
  00837	83 c0 05	 add	 eax, 5
  0083a	8d 4d bc	 lea	 ecx, DWORD PTR _g³os2$683[ebp]
  0083d	50		 push	 eax
  0083e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 786  : 		string g³os2 = G³os.substr(5, string::npos); //Utworzenie zmiennej typu string do celów operowania adresem przy pobieraniu danych i w³o¿enie do zmiennej napisu z zmiennej G³os z pominiêciem 5 pierwszych znaków

  00843	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 788  : 		string g³os3 = g³os2.substr(0, g³os2.size() - 1);

  00847	8b 45 cc	 mov	 eax, DWORD PTR _g³os2$683[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0084a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _g³os3$684[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00851	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _g³os3$684[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00858	c6 45 d4 00	 mov	 BYTE PTR _g³os3$684[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 788  : 		string g³os3 = g³os2.substr(0, g³os2.size() - 1);

  0085c	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  0085f	3b c1		 cmp	 eax, ecx
  00861	0f 42 c8	 cmovb	 ecx, eax

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00864	83 7d d0 10	 cmp	 DWORD PTR _g³os2$683[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00868	8d 45 bc	 lea	 eax, DWORD PTR _g³os2$683[ebp]

; 1594 : 		if (_Large_string_engaged())

  0086b	0f 43 45 bc	 cmovae	 eax, DWORD PTR _g³os2$683[ebp]

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0086f	51		 push	 ecx
  00870	50		 push	 eax
  00871	8d 4d d4	 lea	 ecx, DWORD PTR _g³os3$684[ebp]
  00874	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3468 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  00879	bf 03 00 00 00	 mov	 edi, 3
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 790  : 		if ((_access("G³os", 0))) //Sprawd czy nie ma folderu G³os

  0087e	6a 00		 push	 0
  00880	68 00 00 00 00	 push	 OFFSET ??_C@_04JLFAMLOH@G?$LDos?$AA@
  00885	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00889	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access

; 791  : 		{
; 792  : 			CreateDirectoryA("G³os", nullptr); //Je¿eli nie ma to utwórz go

  0088f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateDirectoryA@8
  00895	83 c4 08	 add	 esp, 8
  00898	85 c0		 test	 eax, eax
  0089a	74 09		 je	 SHORT $LN50@Sprawd_P
  0089c	6a 00		 push	 0
  0089e	68 00 00 00 00	 push	 OFFSET ??_C@_04JLFAMLOH@G?$LDos?$AA@
  008a3	ff d6		 call	 esi
$LN50@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008a5	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008ac	b8 00 00 00 00	 mov	 eax, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 794  : 		if ((_access((G³os).c_str(), 0))) //Sprawd czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoci¹ g³osu

  008b1	6a 00		 push	 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1594 : 		if (_Large_string_engaged())

  008b3	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 794  : 		if ((_access((G³os).c_str(), 0))) //Sprawd czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoci¹ g³osu

  008ba	50		 push	 eax
  008bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  008c1	83 c4 08	 add	 esp, 8
  008c4	85 c0		 test	 eax, eax
  008c6	74 18		 je	 SHORT $LN51@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008c8	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008cf	b8 00 00 00 00	 mov	 eax, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 796  : 			CreateDirectoryA((G³os).c_str(), nullptr); //Je¿eli nie ma to utwórz go

  008d4	6a 00		 push	 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1594 : 		if (_Large_string_engaged())

  008d6	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 796  : 			CreateDirectoryA((G³os).c_str(), nullptr); //Je¿eli nie ma to utwórz go

  008dd	50		 push	 eax
  008de	ff d6		 call	 esi
$LN51@Sprawd_P:

; 801  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  008e0	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  008e5	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  008ea	c6 85 e7 fe ff
	ff 00		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 0
  008f1	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T139[ebp]
  008f7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  008fc	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008ff	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00903	72 02		 jb	 SHORT $LN1210@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00905	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1210@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 801  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00907	6a 00		 push	 0
  00909	50		 push	 eax
  0090a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00910	8b b5 c8 fe ff
	ff		 mov	 esi, DWORD PTR $T139[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 801  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00916	83 c4 08	 add	 esp, 8
  00919	89 45 ec	 mov	 DWORD PTR $T686[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0091c	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  0091f	72 45		 jb	 SHORT $LN1254@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00921	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR $T139[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00927	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00928	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0092a	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00930	72 27		 jb	 SHORT $LN1257@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00932	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  00935	3b c6		 cmp	 eax, esi
  00937	76 1a		 jbe	 SHORT $_Invalid_parameter$4575

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00939	8b f0		 mov	 esi, eax
  0093b	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0093e	75 13		 jne	 SHORT $_Invalid_parameter$4575

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00940	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00943	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00945	73 0c		 jae	 SHORT $_Invalid_parameter$4575

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00947	2b ca		 sub	 ecx, edx
  00949	83 f9 04	 cmp	 ecx, 4
  0094c	72 05		 jb	 SHORT $_Invalid_parameter$4575

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0094e	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00951	76 06		 jbe	 SHORT $LN1257@Sprawd_P
$_Invalid_parameter$4575:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00953	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4549@Sprawd_P:
$LN1257@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00959	56		 push	 esi
  0095a	52		 push	 edx
  0095b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00960	8b 45 ec	 mov	 eax, DWORD PTR $T686[ebp]
  00963	83 c4 08	 add	 esp, 8
$LN1254@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 801  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00966	85 c0		 test	 eax, eax
  00968	0f 84 c4 03 00
	00		 je	 $LN55@Sprawd_P

; 802  : 		{
; 803  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o
; 804  : 			{
; 805  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0096e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00974	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00979	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0097e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00983	8b c8		 mov	 ecx, eax
  00985	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 806  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 807  : 				Wyci¹gnij_z_Programu((g³os3 + ".rar"), Numer_zasobu_rar.at(g³os3));

  0098b	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  00990	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  00993	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  0099a	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T151[ebp]
  009a0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  009a5	83 c4 04	 add	 esp, 4
  009a8	8b f0		 mov	 esi, eax
  009aa	8d 45 d4	 lea	 eax, DWORD PTR _g³os3$684[ebp]
  009ad	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  009b1	50		 push	 eax
  009b2	e8 00 00 00 00	 call	 ?at@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QBEABGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::at
  009b7	8b ce		 mov	 ecx, esi
  009b9	66 8b 10	 mov	 dx, WORD PTR [eax]
  009bc	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
  009c1	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009c5	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T151[ebp+20]
  009cb	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  009ce	72 42		 jb	 SHORT $LN1325@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  009d0	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T151[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  009d6	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  009d7	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  009d9	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  009df	72 27		 jb	 SHORT $LN1328@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  009e1	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  009e4	3b f2		 cmp	 esi, edx
  009e6	76 1a		 jbe	 SHORT $_Invalid_parameter$4576

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  009e8	8b d6		 mov	 edx, esi
  009ea	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  009ed	75 13		 jne	 SHORT $_Invalid_parameter$4576

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  009ef	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  009f2	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  009f4	73 0c		 jae	 SHORT $_Invalid_parameter$4576

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  009f6	2b c8		 sub	 ecx, eax
  009f8	83 f9 04	 cmp	 ecx, 4
  009fb	72 05		 jb	 SHORT $_Invalid_parameter$4576

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  009fd	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00a00	76 06		 jbe	 SHORT $LN1328@Sprawd_P
$_Invalid_parameter$4576:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00a02	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4550@Sprawd_P:
$LN1328@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00a08	52		 push	 edx
  00a09	50		 push	 eax
  00a0a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00a0f	83 c4 08	 add	 esp, 8
$LN1325@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 808  : 				Wypakuj_Rar(g³os3 + ".rar");

  00a12	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  00a17	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  00a1a	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T158[ebp]
  00a20	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00a25	83 c4 04	 add	 esp, 4
  00a28	8b c8		 mov	 ecx, eax
  00a2a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00a2e	e8 00 00 00 00	 call	 ?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Wypakuj_Rar
  00a33	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a37	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T158[ebp+20]
  00a3d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00a40	72 42		 jb	 SHORT $LN1396@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00a42	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T158[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00a48	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00a49	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00a4b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00a51	72 27		 jb	 SHORT $LN1399@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00a53	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00a56	3b f2		 cmp	 esi, edx
  00a58	76 1a		 jbe	 SHORT $_Invalid_parameter$4577

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00a5a	8b d6		 mov	 edx, esi
  00a5c	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00a5f	75 13		 jne	 SHORT $_Invalid_parameter$4577

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00a61	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00a64	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00a66	73 0c		 jae	 SHORT $_Invalid_parameter$4577

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00a68	2b c8		 sub	 ecx, eax
  00a6a	83 f9 04	 cmp	 ecx, 4
  00a6d	72 05		 jb	 SHORT $_Invalid_parameter$4577

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00a6f	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00a72	76 06		 jbe	 SHORT $LN1399@Sprawd_P
$_Invalid_parameter$4577:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00a74	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4551@Sprawd_P:
$LN1399@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00a7a	52		 push	 edx
  00a7b	50		 push	 eax
  00a7c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00a81	83 c4 08	 add	 esp, 8
$LN1396@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 810  : 			if (!Przenie_Plik(g³os2 + "p.wav", G³os + "p.wav"))

  00a84	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  00a89	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00a8e	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T165[ebp]
  00a94	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00a99	8b f0		 mov	 esi, eax
  00a9b	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  00aa0	8d 55 bc	 lea	 edx, DWORD PTR _g³os2$683[ebp]
  00aa3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00aa7	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T167[ebp]
  00aad	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00ab2	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ab5	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00ab9	72 02		 jb	 SHORT $LN1441@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00abb	8b 36		 mov	 esi, DWORD PTR [esi]
$LN1441@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00abd	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00ac1	72 02		 jb	 SHORT $LN1457@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00ac3	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1457@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  00ac5	56		 push	 esi
  00ac6	50		 push	 eax
  00ac7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00acd	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T167[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  00ad3	85 c0		 test	 eax, eax

; 810  : 			if (!Przenie_Plik(g³os2 + "p.wav", G³os + "p.wav"))

  00ad5	0f 94 85 e6 fe
	ff ff		 sete	 BYTE PTR $T675[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00adc	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00adf	72 42		 jb	 SHORT $LN1501@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00ae1	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T167[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00ae7	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00ae8	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00aea	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00af0	72 27		 jb	 SHORT $LN1504@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00af2	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00af5	3b f2		 cmp	 esi, edx
  00af7	76 1a		 jbe	 SHORT $_Invalid_parameter$4578

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00af9	8b d6		 mov	 edx, esi
  00afb	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00afe	75 13		 jne	 SHORT $_Invalid_parameter$4578

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00b00	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00b03	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00b05	73 0c		 jae	 SHORT $_Invalid_parameter$4578

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00b07	2b c8		 sub	 ecx, eax
  00b09	83 f9 04	 cmp	 ecx, 4
  00b0c	72 05		 jb	 SHORT $_Invalid_parameter$4578

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00b0e	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00b11	76 06		 jbe	 SHORT $LN1504@Sprawd_P
$_Invalid_parameter$4578:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00b13	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4552@Sprawd_P:
$LN1504@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00b19	52		 push	 edx
  00b1a	50		 push	 eax
  00b1b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b20	83 c4 08	 add	 esp, 8
$LN1501@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 810  : 			if (!Przenie_Plik(g³os2 + "p.wav", G³os + "p.wav"))

  00b23	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b27	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T165[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00b2d	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T167[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00b37	c7 85 e0 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T167[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00b41	c6 85 cc fe ff
	ff 00		 mov	 BYTE PTR $T167[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b48	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00b4b	72 42		 jb	 SHORT $LN1572@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00b4d	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T165[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00b53	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00b54	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00b56	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00b5c	72 27		 jb	 SHORT $LN1575@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00b5e	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00b61	3b f2		 cmp	 esi, edx
  00b63	76 1a		 jbe	 SHORT $_Invalid_parameter$4579

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00b65	8b d6		 mov	 edx, esi
  00b67	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00b6a	75 13		 jne	 SHORT $_Invalid_parameter$4579

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00b6c	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00b6f	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00b71	73 0c		 jae	 SHORT $_Invalid_parameter$4579

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00b73	2b c8		 sub	 ecx, eax
  00b75	83 f9 04	 cmp	 ecx, 4
  00b78	72 05		 jb	 SHORT $_Invalid_parameter$4579

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00b7a	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00b7d	76 06		 jbe	 SHORT $LN1575@Sprawd_P
$_Invalid_parameter$4579:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00b7f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4553@Sprawd_P:
$LN1575@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00b85	52		 push	 edx
  00b86	50		 push	 eax
  00b87	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b8c	83 c4 08	 add	 esp, 8
$LN1572@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 810  : 			if (!Przenie_Plik(g³os2 + "p.wav", G³os + "p.wav"))

  00b8f	80 bd e6 fe ff
	ff 00		 cmp	 BYTE PTR $T675[ebp], 0
  00b96	0f 84 96 01 00
	00		 je	 $LN55@Sprawd_P

; 812  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), (G³os + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00b9c	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  00ba1	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00ba6	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T188[ebp]
  00bac	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00bb1	8b f0		 mov	 esi, eax
  00bb3	8d 45 bc	 lea	 eax, DWORD PTR _g³os2$683[ebp]
  00bb6	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00bba	50		 push	 eax
  00bbb	8d 55 9c	 lea	 edx, DWORD PTR _link$682[ebp]
  00bbe	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T190[ebp]
  00bc4	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00bc9	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  00bce	8b d0		 mov	 edx, eax
  00bd0	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00bd4	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T191[ebp]
  00bda	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00bdf	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00be2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00be6	72 02		 jb	 SHORT $LN1615@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00be8	8b 36		 mov	 esi, DWORD PTR [esi]
$LN1615@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00bea	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00bee	72 02		 jb	 SHORT $LN1631@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00bf0	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1631@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 812  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), (G³os + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00bf2	6a 00		 push	 0
  00bf4	6a 00		 push	 0
  00bf6	56		 push	 esi
  00bf7	50		 push	 eax
  00bf8	6a 00		 push	 0
  00bfa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c00	8b b5 e0 fe ff
	ff		 mov	 esi, DWORD PTR $T191[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 812  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), (G³os + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00c06	89 45 ec	 mov	 DWORD PTR _res$1$[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c09	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00c0c	72 42		 jb	 SHORT $LN1675@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00c0e	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR $T191[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00c14	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00c15	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00c17	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00c1d	72 27		 jb	 SHORT $LN1678@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00c1f	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  00c22	3b c6		 cmp	 eax, esi
  00c24	76 1a		 jbe	 SHORT $_Invalid_parameter$4580

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00c26	8b f0		 mov	 esi, eax
  00c28	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00c2b	75 13		 jne	 SHORT $_Invalid_parameter$4580

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00c2d	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00c30	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00c32	73 0c		 jae	 SHORT $_Invalid_parameter$4580

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00c34	2b ca		 sub	 ecx, edx
  00c36	83 f9 04	 cmp	 ecx, 4
  00c39	72 05		 jb	 SHORT $_Invalid_parameter$4580

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00c3b	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00c3e	76 06		 jbe	 SHORT $LN1678@Sprawd_P
$_Invalid_parameter$4580:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00c40	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4554@Sprawd_P:
$LN1678@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00c46	56		 push	 esi
  00c47	52		 push	 edx
  00c48	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00c4d	83 c4 08	 add	 esp, 8
$LN1675@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 812  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), (G³os + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00c50	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c54	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR $T190[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00c5a	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T191[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00c64	c7 85 e0 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T191[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00c6e	c6 85 cc fe ff
	ff 00		 mov	 BYTE PTR $T191[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c75	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00c78	72 42		 jb	 SHORT $LN1746@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00c7a	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR $T190[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00c80	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00c81	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00c83	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00c89	72 27		 jb	 SHORT $LN1749@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00c8b	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00c8e	3b f2		 cmp	 esi, edx
  00c90	76 1a		 jbe	 SHORT $_Invalid_parameter$4581

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00c92	8b d6		 mov	 edx, esi
  00c94	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00c97	75 13		 jne	 SHORT $_Invalid_parameter$4581

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00c99	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00c9c	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00c9e	73 0c		 jae	 SHORT $_Invalid_parameter$4581

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00ca0	2b c8		 sub	 ecx, eax
  00ca2	83 f9 04	 cmp	 ecx, 4
  00ca5	72 05		 jb	 SHORT $_Invalid_parameter$4581

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00ca7	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00caa	76 06		 jbe	 SHORT $LN1749@Sprawd_P
$_Invalid_parameter$4581:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00cac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4555@Sprawd_P:
$LN1749@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00cb2	52		 push	 edx
  00cb3	50		 push	 eax
  00cb4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00cb9	83 c4 08	 add	 esp, 8
$LN1746@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 812  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), (G³os + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00cbc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00cc0	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T188[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00cc6	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T190[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00cd0	c7 85 90 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T190[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00cda	c6 85 7c fe ff
	ff 00		 mov	 BYTE PTR $T190[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ce1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00ce4	72 42		 jb	 SHORT $LN1817@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00ce6	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T188[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00cec	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00ced	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00cef	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00cf5	72 27		 jb	 SHORT $LN1820@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00cf7	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00cfa	3b f2		 cmp	 esi, edx
  00cfc	76 1a		 jbe	 SHORT $_Invalid_parameter$4582

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00cfe	8b d6		 mov	 edx, esi
  00d00	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00d03	75 13		 jne	 SHORT $_Invalid_parameter$4582

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00d05	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00d08	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00d0a	73 0c		 jae	 SHORT $_Invalid_parameter$4582

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00d0c	2b c8		 sub	 ecx, eax
  00d0e	83 f9 04	 cmp	 ecx, 4
  00d11	72 05		 jb	 SHORT $_Invalid_parameter$4582

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00d13	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00d16	76 06		 jbe	 SHORT $LN1820@Sprawd_P
$_Invalid_parameter$4582:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00d18	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4556@Sprawd_P:
$LN1820@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00d1e	52		 push	 edx
  00d1f	50		 push	 eax
  00d20	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00d25	83 c4 08	 add	 esp, 8
$LN1817@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 813  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00d28	83 7d ec 00	 cmp	 DWORD PTR _res$1$[ebp], 0
  00d2c	0f 85 5a 1f 00
	00		 jne	 $LN4540@Sprawd_P
$LN55@Sprawd_P:
$_Invalid_parameter$4583:
$_Invalid_parameter$4584:
$_Invalid_parameter$4585:

; 822  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00d32	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  00d37	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00d3c	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T235[ebp]
  00d42	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00d47	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d4a	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00d4e	72 02		 jb	 SHORT $LN2073@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00d50	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2073@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 822  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00d52	6a 00		 push	 0
  00d54	50		 push	 eax
  00d55	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d5b	8b b5 c8 fe ff
	ff		 mov	 esi, DWORD PTR $T235[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 822  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00d61	83 c4 08	 add	 esp, 8
  00d64	89 45 ec	 mov	 DWORD PTR $T685[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d67	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00d6a	72 45		 jb	 SHORT $LN2117@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00d6c	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR $T235[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00d72	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00d73	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00d75	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00d7b	72 27		 jb	 SHORT $LN2120@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00d7d	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  00d80	3b c6		 cmp	 eax, esi
  00d82	76 1a		 jbe	 SHORT $_Invalid_parameter$4586

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00d84	8b f0		 mov	 esi, eax
  00d86	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00d89	75 13		 jne	 SHORT $_Invalid_parameter$4586

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00d8b	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00d8e	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00d90	73 0c		 jae	 SHORT $_Invalid_parameter$4586

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00d92	2b ca		 sub	 ecx, edx
  00d94	83 f9 04	 cmp	 ecx, 4
  00d97	72 05		 jb	 SHORT $_Invalid_parameter$4586

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00d99	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00d9c	76 06		 jbe	 SHORT $LN2120@Sprawd_P
$_Invalid_parameter$4586:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00d9e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4557@Sprawd_P:
$LN2120@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00da4	56		 push	 esi
  00da5	52		 push	 edx
  00da6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00dab	8b 45 ec	 mov	 eax, DWORD PTR $T685[ebp]
  00dae	83 c4 08	 add	 esp, 8
$LN2117@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 822  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00db1	85 c0		 test	 eax, eax
  00db3	0f 84 8c 02 00
	00		 je	 $LN59@Sprawd_P

; 823  : 		{
; 824  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  00db9	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00dc0	0f 85 16 01 00
	00		 jne	 $LN2259@Sprawd_P

; 825  : 			{
; 826  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00dc6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00dcc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00dd1	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00dd6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00ddb	8b c8		 mov	 ecx, eax
  00ddd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 827  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 828  : 				Wyci¹gnij_z_Programu((g³os3 + ".rar"), Numer_zasobu_rar.at(g³os3));

  00de3	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  00de8	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  00deb	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  00df2	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T247[ebp]
  00df8	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00dfd	83 c4 04	 add	 esp, 4
  00e00	8b f0		 mov	 esi, eax
  00e02	8d 45 d4	 lea	 eax, DWORD PTR _g³os3$684[ebp]
  00e05	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00e09	50		 push	 eax
  00e0a	e8 00 00 00 00	 call	 ?at@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QBEABGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::at
  00e0f	8b ce		 mov	 ecx, esi
  00e11	66 8b 10	 mov	 dx, WORD PTR [eax]
  00e14	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
  00e19	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00e1d	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T247[ebp+20]
  00e23	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00e26	72 42		 jb	 SHORT $LN2188@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00e28	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T247[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00e2e	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00e2f	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00e31	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00e37	72 27		 jb	 SHORT $LN2191@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00e39	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00e3c	3b f2		 cmp	 esi, edx
  00e3e	76 1a		 jbe	 SHORT $_Invalid_parameter$4587

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00e40	8b d6		 mov	 edx, esi
  00e42	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00e45	75 13		 jne	 SHORT $_Invalid_parameter$4587

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00e47	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00e4a	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00e4c	73 0c		 jae	 SHORT $_Invalid_parameter$4587

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00e4e	2b c8		 sub	 ecx, eax
  00e50	83 f9 04	 cmp	 ecx, 4
  00e53	72 05		 jb	 SHORT $_Invalid_parameter$4587

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00e55	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00e58	76 06		 jbe	 SHORT $LN2191@Sprawd_P
$_Invalid_parameter$4587:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00e5a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4558@Sprawd_P:
$LN2191@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00e60	52		 push	 edx
  00e61	50		 push	 eax
  00e62	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00e67	83 c4 08	 add	 esp, 8
$LN2188@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 829  : 				Wypakuj_Rar(g³os3 + ".rar");

  00e6a	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  00e6f	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  00e72	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T254[ebp]
  00e78	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00e7d	83 c4 04	 add	 esp, 4
  00e80	8b c8		 mov	 ecx, eax
  00e82	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00e86	e8 00 00 00 00	 call	 ?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Wypakuj_Rar
  00e8b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00e8f	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T254[ebp+20]
  00e95	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00e98	72 42		 jb	 SHORT $LN2259@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00e9a	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T254[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00ea0	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00ea1	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00ea3	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00ea9	72 27		 jb	 SHORT $LN2262@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00eab	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00eae	3b f2		 cmp	 esi, edx
  00eb0	76 1a		 jbe	 SHORT $_Invalid_parameter$4588

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00eb2	8b d6		 mov	 edx, esi
  00eb4	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00eb7	75 13		 jne	 SHORT $_Invalid_parameter$4588

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00eb9	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00ebc	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00ebe	73 0c		 jae	 SHORT $_Invalid_parameter$4588

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00ec0	2b c8		 sub	 ecx, eax
  00ec2	83 f9 04	 cmp	 ecx, 4
  00ec5	72 05		 jb	 SHORT $_Invalid_parameter$4588

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00ec7	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00eca	76 06		 jbe	 SHORT $LN2262@Sprawd_P
$_Invalid_parameter$4588:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00ecc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4559@Sprawd_P:
$LN2262@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00ed2	52		 push	 edx
  00ed3	50		 push	 eax
  00ed4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00ed9	83 c4 08	 add	 esp, 8
$LN2259@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 831  : 			if (!Przenie_Plik(g³os2 + "n.wav", G³os + "n.wav"))

  00edc	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  00ee1	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00ee6	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T261[ebp]
  00eec	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00ef1	8b f0		 mov	 esi, eax
  00ef3	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  00ef8	8d 55 bc	 lea	 edx, DWORD PTR _g³os2$683[ebp]
  00efb	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00eff	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T263[ebp]
  00f05	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00f0a	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00f0d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00f11	72 02		 jb	 SHORT $LN2304@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00f13	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2304@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00f15	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00f19	72 02		 jb	 SHORT $LN2320@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00f1b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2320@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  00f1d	56		 push	 esi
  00f1e	50		 push	 eax
  00f1f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00f25	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T263[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  00f2b	85 c0		 test	 eax, eax

; 831  : 			if (!Przenie_Plik(g³os2 + "n.wav", G³os + "n.wav"))

  00f2d	0f 94 85 e6 fe
	ff ff		 sete	 BYTE PTR $T674[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00f34	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00f37	72 42		 jb	 SHORT $LN2364@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00f39	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T263[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00f3f	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00f40	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00f42	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00f48	72 27		 jb	 SHORT $LN2367@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00f4a	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00f4d	3b f2		 cmp	 esi, edx
  00f4f	76 1a		 jbe	 SHORT $_Invalid_parameter$4589

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00f51	8b d6		 mov	 edx, esi
  00f53	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00f56	75 13		 jne	 SHORT $_Invalid_parameter$4589

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00f58	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00f5b	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00f5d	73 0c		 jae	 SHORT $_Invalid_parameter$4589

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00f5f	2b c8		 sub	 ecx, eax
  00f61	83 f9 04	 cmp	 ecx, 4
  00f64	72 05		 jb	 SHORT $_Invalid_parameter$4589

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00f66	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00f69	76 06		 jbe	 SHORT $LN2367@Sprawd_P
$_Invalid_parameter$4589:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00f6b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4560@Sprawd_P:
$LN2367@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00f71	52		 push	 edx
  00f72	50		 push	 eax
  00f73	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00f78	83 c4 08	 add	 esp, 8
$LN2364@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 831  : 			if (!Przenie_Plik(g³os2 + "n.wav", G³os + "n.wav"))

  00f7b	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T261[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00f81	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T263[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00f8b	c7 85 e0 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T263[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00f95	c6 85 cc fe ff
	ff 00		 mov	 BYTE PTR $T263[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 831  : 			if (!Przenie_Plik(g³os2 + "n.wav", G³os + "n.wav"))

  00f9c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00fa0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00fa5	80 bd e6 fe ff
	ff 00		 cmp	 BYTE PTR $T674[ebp], 0
  00fac	0f 84 93 00 00
	00		 je	 $LN59@Sprawd_P

; 833  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), (G³os + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00fb2	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  00fb7	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00fbc	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T278[ebp]
  00fc2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00fc7	8b f0		 mov	 esi, eax
  00fc9	8d 45 bc	 lea	 eax, DWORD PTR _g³os2$683[ebp]
  00fcc	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00fd0	50		 push	 eax
  00fd1	8d 55 9c	 lea	 edx, DWORD PTR _link$682[ebp]
  00fd4	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T280[ebp]
  00fda	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00fdf	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  00fe4	8b d0		 mov	 edx, eax
  00fe6	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00fea	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T281[ebp]
  00ff0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00ff5	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ff8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00ffc	72 02		 jb	 SHORT $LN2407@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00ffe	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2407@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01000	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01004	72 02		 jb	 SHORT $LN2423@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01006	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2423@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 833  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), (G³os + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01008	6a 00		 push	 0
  0100a	6a 00		 push	 0
  0100c	56		 push	 esi
  0100d	50		 push	 eax
  0100e	6a 00		 push	 0
  01010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  01016	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T281[ebp]
  0101c	8b f0		 mov	 esi, eax
  0101e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01023	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T280[ebp]
  01029	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0102e	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T278[ebp]
  01034	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01038	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 834  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0103d	85 f6		 test	 esi, esi
  0103f	0f 85 47 1c 00
	00		 jne	 $LN4540@Sprawd_P
$LN59@Sprawd_P:

; 843  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01045	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  0104a	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0104f	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T289[ebp]
  01055	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0105a	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0105d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01061	72 02		 jb	 SHORT $LN2439@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01063	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2439@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 843  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01065	6a 00		 push	 0
  01067	50		 push	 eax
  01068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  0106e	83 c4 08	 add	 esp, 8
  01071	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T289[ebp]
  01077	8b f0		 mov	 esi, eax
  01079	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0107e	85 f6		 test	 esi, esi
  01080	0f 84 9f 01 00
	00		 je	 $LN63@Sprawd_P

; 844  : 		{
; 845  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  01086	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0108d	0f 85 92 00 00
	00		 jne	 $LN61@Sprawd_P

; 846  : 			{
; 847  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01099	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0109e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  010a3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  010a8	8b c8		 mov	 ecx, eax
  010aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 848  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 849  : 				Wyci¹gnij_z_Programu((g³os3 + ".rar"), Numer_zasobu_rar.at(g³os3));

  010b0	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  010b5	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  010b8	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  010bf	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T295[ebp]
  010c5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  010ca	83 c4 04	 add	 esp, 4
  010cd	8b f0		 mov	 esi, eax
  010cf	8d 45 d4	 lea	 eax, DWORD PTR _g³os3$684[ebp]
  010d2	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  010d6	50		 push	 eax
  010d7	e8 00 00 00 00	 call	 ?at@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QBEABGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::at
  010dc	8b ce		 mov	 ecx, esi
  010de	66 8b 10	 mov	 dx, WORD PTR [eax]
  010e1	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
  010e6	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T295[ebp]
  010ec	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  010f0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 850  : 				Wypakuj_Rar(g³os3 + ".rar");

  010f5	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  010fa	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  010fd	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T296[ebp]
  01103	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01108	83 c4 04	 add	 esp, 4
  0110b	8b c8		 mov	 ecx, eax
  0110d	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  01111	e8 00 00 00 00	 call	 ?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Wypakuj_Rar
  01116	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T296[ebp]
  0111c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01120	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN61@Sprawd_P:

; 851  : 			}
; 852  : 			if (!Przenie_Plik(g³os2 + "r.wav", G³os + "r.wav"))

  01125	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  0112a	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0112f	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T297[ebp]
  01135	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0113a	8b f0		 mov	 esi, eax
  0113c	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  01141	8d 55 bc	 lea	 edx, DWORD PTR _g³os2$683[ebp]
  01144	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  01148	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T299[ebp]
  0114e	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01153	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01156	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0115a	72 02		 jb	 SHORT $LN2457@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0115c	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2457@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0115e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01162	72 02		 jb	 SHORT $LN2473@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01164	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2473@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  01166	56		 push	 esi
  01167	50		 push	 eax
  01168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8

; 851  : 			}
; 852  : 			if (!Przenie_Plik(g³os2 + "r.wav", G³os + "r.wav"))

  0116e	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T299[ebp]

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  01174	8b f0		 mov	 esi, eax

; 851  : 			}
; 852  : 			if (!Przenie_Plik(g³os2 + "r.wav", G³os + "r.wav"))

  01176	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0117b	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T297[ebp]
  01181	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01185	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0118a	85 f6		 test	 esi, esi
  0118c	0f 85 93 00 00
	00		 jne	 $LN63@Sprawd_P

; 854  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), (G³os + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01192	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  01197	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0119c	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T308[ebp]
  011a2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  011a7	8b f0		 mov	 esi, eax
  011a9	8d 45 bc	 lea	 eax, DWORD PTR _g³os2$683[ebp]
  011ac	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  011b0	50		 push	 eax
  011b1	8d 55 9c	 lea	 edx, DWORD PTR _link$682[ebp]
  011b4	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T310[ebp]
  011ba	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  011bf	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  011c4	8b d0		 mov	 edx, eax
  011c6	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  011ca	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T311[ebp]
  011d0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  011d5	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  011d8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  011dc	72 02		 jb	 SHORT $LN2489@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  011de	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2489@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  011e0	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  011e4	72 02		 jb	 SHORT $LN2505@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  011e6	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2505@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 854  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), (G³os + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  011e8	6a 00		 push	 0
  011ea	6a 00		 push	 0
  011ec	56		 push	 esi
  011ed	50		 push	 eax
  011ee	6a 00		 push	 0
  011f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  011f6	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T311[ebp]
  011fc	8b f0		 mov	 esi, eax
  011fe	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01203	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T310[ebp]
  01209	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0120e	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T308[ebp]
  01214	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01218	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 855  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0121d	85 f6		 test	 esi, esi
  0121f	0f 85 67 1a 00
	00		 jne	 $LN4540@Sprawd_P
$LN63@Sprawd_P:

; 864  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01225	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  0122a	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0122f	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T319[ebp]
  01235	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0123a	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0123d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01241	72 02		 jb	 SHORT $LN2521@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01243	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2521@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 864  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01245	6a 00		 push	 0
  01247	50		 push	 eax
  01248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  0124e	83 c4 08	 add	 esp, 8
  01251	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T319[ebp]
  01257	8b f0		 mov	 esi, eax
  01259	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0125e	85 f6		 test	 esi, esi
  01260	0f 84 9f 01 00
	00		 je	 $LN67@Sprawd_P

; 865  : 		{
; 866  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  01266	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0126d	0f 85 92 00 00
	00		 jne	 $LN65@Sprawd_P

; 867  : 			{
; 868  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01279	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0127e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  01283	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01288	8b c8		 mov	 ecx, eax
  0128a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 869  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 870  : 				Wyci¹gnij_z_Programu((g³os3 + ".rar"), Numer_zasobu_rar.at(g³os3));

  01290	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  01295	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  01298	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  0129f	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T325[ebp]
  012a5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  012aa	83 c4 04	 add	 esp, 4
  012ad	8b f0		 mov	 esi, eax
  012af	8d 45 d4	 lea	 eax, DWORD PTR _g³os3$684[ebp]
  012b2	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  012b6	50		 push	 eax
  012b7	e8 00 00 00 00	 call	 ?at@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QBEABGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::at
  012bc	8b ce		 mov	 ecx, esi
  012be	66 8b 10	 mov	 dx, WORD PTR [eax]
  012c1	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
  012c6	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T325[ebp]
  012cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  012d0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 871  : 				Wypakuj_Rar(g³os3 + ".rar");

  012d5	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  012da	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  012dd	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T326[ebp]
  012e3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  012e8	83 c4 04	 add	 esp, 4
  012eb	8b c8		 mov	 ecx, eax
  012ed	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  012f1	e8 00 00 00 00	 call	 ?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Wypakuj_Rar
  012f6	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T326[ebp]
  012fc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01300	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN65@Sprawd_P:

; 872  : 			}
; 873  : 			if (!Przenie_Plik(g³os2 + "b.wav", G³os + "b.wav"))

  01305	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  0130a	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0130f	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T327[ebp]
  01315	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0131a	8b f0		 mov	 esi, eax
  0131c	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  01321	8d 55 bc	 lea	 edx, DWORD PTR _g³os2$683[ebp]
  01324	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  01328	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T329[ebp]
  0132e	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01333	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01336	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0133a	72 02		 jb	 SHORT $LN2539@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0133c	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2539@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0133e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01342	72 02		 jb	 SHORT $LN2555@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01344	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2555@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  01346	56		 push	 esi
  01347	50		 push	 eax
  01348	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8

; 872  : 			}
; 873  : 			if (!Przenie_Plik(g³os2 + "b.wav", G³os + "b.wav"))

  0134e	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T329[ebp]

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  01354	8b f0		 mov	 esi, eax

; 872  : 			}
; 873  : 			if (!Przenie_Plik(g³os2 + "b.wav", G³os + "b.wav"))

  01356	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0135b	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T327[ebp]
  01361	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01365	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0136a	85 f6		 test	 esi, esi
  0136c	0f 85 93 00 00
	00		 jne	 $LN67@Sprawd_P

; 875  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "b.wav").c_str(), (G³os + "b.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01372	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  01377	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0137c	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T338[ebp]
  01382	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01387	8b f0		 mov	 esi, eax
  01389	8d 45 bc	 lea	 eax, DWORD PTR _g³os2$683[ebp]
  0138c	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  01390	50		 push	 eax
  01391	8d 55 9c	 lea	 edx, DWORD PTR _link$682[ebp]
  01394	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T340[ebp]
  0139a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0139f	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  013a4	8b d0		 mov	 edx, eax
  013a6	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  013aa	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T341[ebp]
  013b0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  013b5	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  013b8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  013bc	72 02		 jb	 SHORT $LN2571@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  013be	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2571@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  013c0	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  013c4	72 02		 jb	 SHORT $LN2587@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  013c6	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2587@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 875  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "b.wav").c_str(), (G³os + "b.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  013c8	6a 00		 push	 0
  013ca	6a 00		 push	 0
  013cc	56		 push	 esi
  013cd	50		 push	 eax
  013ce	6a 00		 push	 0
  013d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  013d6	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T341[ebp]
  013dc	8b f0		 mov	 esi, eax
  013de	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  013e3	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T340[ebp]
  013e9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  013ee	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T338[ebp]
  013f4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  013f8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 876  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  013fd	85 f6		 test	 esi, esi
  013ff	0f 85 87 18 00
	00		 jne	 $LN4540@Sprawd_P
$LN67@Sprawd_P:

; 885  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01405	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  0140a	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0140f	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T349[ebp]
  01415	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0141a	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0141d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01421	72 02		 jb	 SHORT $LN2603@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01423	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2603@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 885  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01425	6a 00		 push	 0
  01427	50		 push	 eax
  01428	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  0142e	83 c4 08	 add	 esp, 8
  01431	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T349[ebp]
  01437	8b f0		 mov	 esi, eax
  01439	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0143e	85 f6		 test	 esi, esi
  01440	0f 84 9f 01 00
	00		 je	 $LN71@Sprawd_P

; 886  : 		{
; 887  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  01446	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0144d	0f 85 92 00 00
	00		 jne	 $LN69@Sprawd_P

; 888  : 			{
; 889  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01453	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01459	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0145e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  01463	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01468	8b c8		 mov	 ecx, eax
  0146a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 890  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 891  : 				Wyci¹gnij_z_Programu((g³os3 + ".rar"), Numer_zasobu_rar.at(g³os3));

  01470	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  01475	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  01478	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  0147f	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T355[ebp]
  01485	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0148a	83 c4 04	 add	 esp, 4
  0148d	8b f0		 mov	 esi, eax
  0148f	8d 45 d4	 lea	 eax, DWORD PTR _g³os3$684[ebp]
  01492	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
  01496	50		 push	 eax
  01497	e8 00 00 00 00	 call	 ?at@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QBEABGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::at
  0149c	8b ce		 mov	 ecx, esi
  0149e	66 8b 10	 mov	 dx, WORD PTR [eax]
  014a1	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
  014a6	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T355[ebp]
  014ac	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  014b0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 892  : 				Wypakuj_Rar(g³os3 + ".rar");

  014b5	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  014ba	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  014bd	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T356[ebp]
  014c3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  014c8	83 c4 04	 add	 esp, 4
  014cb	8b c8		 mov	 ecx, eax
  014cd	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  014d1	e8 00 00 00 00	 call	 ?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Wypakuj_Rar
  014d6	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T356[ebp]
  014dc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  014e0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN69@Sprawd_P:

; 893  : 			}
; 894  : 			if (!Przenie_Plik(g³os2 + "g.wav", G³os + "g.wav"))

  014e5	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  014ea	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  014ef	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T357[ebp]
  014f5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  014fa	8b f0		 mov	 esi, eax
  014fc	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  01501	8d 55 bc	 lea	 edx, DWORD PTR _g³os2$683[ebp]
  01504	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H
  01508	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T359[ebp]
  0150e	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01513	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01516	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0151a	72 02		 jb	 SHORT $LN2621@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0151c	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2621@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0151e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01522	72 02		 jb	 SHORT $LN2637@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01524	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2637@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  01526	56		 push	 esi
  01527	50		 push	 eax
  01528	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8

; 893  : 			}
; 894  : 			if (!Przenie_Plik(g³os2 + "g.wav", G³os + "g.wav"))

  0152e	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T359[ebp]

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  01534	8b f0		 mov	 esi, eax

; 893  : 			}
; 894  : 			if (!Przenie_Plik(g³os2 + "g.wav", G³os + "g.wav"))

  01536	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0153b	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T357[ebp]
  01541	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01545	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0154a	85 f6		 test	 esi, esi
  0154c	0f 85 93 00 00
	00		 jne	 $LN71@Sprawd_P

; 896  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "g.wav").c_str(), (G³os + "g.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01552	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  01557	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0155c	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T368[ebp]
  01562	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01567	8b f0		 mov	 esi, eax
  01569	8d 45 bc	 lea	 eax, DWORD PTR _g³os2$683[ebp]
  0156c	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  01570	50		 push	 eax
  01571	8d 55 9c	 lea	 edx, DWORD PTR _link$682[ebp]
  01574	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T370[ebp]
  0157a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0157f	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  01584	8b d0		 mov	 edx, eax
  01586	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
  0158a	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T371[ebp]
  01590	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01595	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01598	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0159c	72 02		 jb	 SHORT $LN2653@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0159e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2653@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  015a0	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  015a4	72 02		 jb	 SHORT $LN2669@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  015a6	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2669@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 896  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "g.wav").c_str(), (G³os + "g.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  015a8	6a 00		 push	 0
  015aa	6a 00		 push	 0
  015ac	56		 push	 esi
  015ad	50		 push	 eax
  015ae	6a 00		 push	 0
  015b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  015b6	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T371[ebp]
  015bc	8b f0		 mov	 esi, eax
  015be	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  015c3	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T370[ebp]
  015c9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  015ce	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T368[ebp]
  015d4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  015d8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 897  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  015dd	85 f6		 test	 esi, esi
  015df	0f 85 a7 16 00
	00		 jne	 $LN4540@Sprawd_P
$LN71@Sprawd_P:

; 906  : 		if ((_access((G³os + "d.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  015e5	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  015ea	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  015ef	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T379[ebp]
  015f5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  015fa	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  015fd	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01601	72 02		 jb	 SHORT $LN2685@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01603	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2685@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 906  : 		if ((_access((G³os + "d.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01605	6a 00		 push	 0
  01607	50		 push	 eax
  01608	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  0160e	83 c4 08	 add	 esp, 8
  01611	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T379[ebp]
  01617	8b f0		 mov	 esi, eax
  01619	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0161e	85 f6		 test	 esi, esi
  01620	0f 84 9f 01 00
	00		 je	 $LN75@Sprawd_P

; 907  : 		{
; 908  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  01626	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0162d	0f 85 92 00 00
	00		 jne	 $LN73@Sprawd_P

; 909  : 			{
; 910  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01633	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01639	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0163e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  01643	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01648	8b c8		 mov	 ecx, eax
  0164a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 911  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 912  : 				Wyci¹gnij_z_Programu((g³os3 + ".rar"), Numer_zasobu_rar.at(g³os3));

  01650	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  01655	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  01658	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  0165f	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T385[ebp]
  01665	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0166a	83 c4 04	 add	 esp, 4
  0166d	8b f0		 mov	 esi, eax
  0166f	8d 45 d4	 lea	 eax, DWORD PTR _g³os3$684[ebp]
  01672	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  01676	50		 push	 eax
  01677	e8 00 00 00 00	 call	 ?at@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QBEABGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::at
  0167c	8b ce		 mov	 ecx, esi
  0167e	66 8b 10	 mov	 dx, WORD PTR [eax]
  01681	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
  01686	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T385[ebp]
  0168c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01690	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 913  : 				Wypakuj_Rar(g³os3 + ".rar");

  01695	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  0169a	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  0169d	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T386[ebp]
  016a3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  016a8	83 c4 04	 add	 esp, 4
  016ab	8b c8		 mov	 ecx, eax
  016ad	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+8], 29 ; 0000001dH
  016b1	e8 00 00 00 00	 call	 ?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Wypakuj_Rar
  016b6	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T386[ebp]
  016bc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  016c0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN73@Sprawd_P:

; 914  : 			}
; 915  : 			if (!Przenie_Plik(g³os2 + "d.wav", G³os + "d.wav"))

  016c5	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  016ca	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  016cf	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T387[ebp]
  016d5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  016da	8b f0		 mov	 esi, eax
  016dc	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  016e1	8d 55 bc	 lea	 edx, DWORD PTR _g³os2$683[ebp]
  016e4	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+8], 30 ; 0000001eH
  016e8	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T389[ebp]
  016ee	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  016f3	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  016f6	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  016fa	72 02		 jb	 SHORT $LN2703@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  016fc	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2703@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  016fe	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01702	72 02		 jb	 SHORT $LN2719@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01704	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2719@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  01706	56		 push	 esi
  01707	50		 push	 eax
  01708	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8

; 914  : 			}
; 915  : 			if (!Przenie_Plik(g³os2 + "d.wav", G³os + "d.wav"))

  0170e	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T389[ebp]

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  01714	8b f0		 mov	 esi, eax

; 914  : 			}
; 915  : 			if (!Przenie_Plik(g³os2 + "d.wav", G³os + "d.wav"))

  01716	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0171b	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T387[ebp]
  01721	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01725	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0172a	85 f6		 test	 esi, esi
  0172c	0f 85 93 00 00
	00		 jne	 $LN75@Sprawd_P

; 917  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "d.wav").c_str(), (G³os + "d.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01732	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  01737	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0173c	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T398[ebp]
  01742	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01747	8b f0		 mov	 esi, eax
  01749	8d 45 bc	 lea	 eax, DWORD PTR _g³os2$683[ebp]
  0174c	c6 45 fc 1f	 mov	 BYTE PTR __$EHRec$[ebp+8], 31 ; 0000001fH
  01750	50		 push	 eax
  01751	8d 55 9c	 lea	 edx, DWORD PTR _link$682[ebp]
  01754	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T400[ebp]
  0175a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0175f	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  01764	8b d0		 mov	 edx, eax
  01766	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
  0176a	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T401[ebp]
  01770	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01775	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01778	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0177c	72 02		 jb	 SHORT $LN2735@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0177e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2735@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01780	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01784	72 02		 jb	 SHORT $LN2751@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01786	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2751@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 917  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "d.wav").c_str(), (G³os + "d.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01788	6a 00		 push	 0
  0178a	6a 00		 push	 0
  0178c	56		 push	 esi
  0178d	50		 push	 eax
  0178e	6a 00		 push	 0
  01790	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  01796	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T401[ebp]
  0179c	8b f0		 mov	 esi, eax
  0179e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  017a3	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T400[ebp]
  017a9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  017ae	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T398[ebp]
  017b4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  017b8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 918  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  017bd	85 f6		 test	 esi, esi
  017bf	0f 85 c7 14 00
	00		 jne	 $LN4540@Sprawd_P
$LN75@Sprawd_P:

; 919  : 				{
; 920  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 921  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 922  : 					return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 923  : 				}
; 924  : 			}
; 925  : 		}
; 926  : 
; 927  : 		for (unsigned short i = 1; i <= 3; ++i) //Pêtla licz¹ca od 1 do 3

  017c5	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 1
  017cc	0f 1f 40 00	 npad	 4
$LL6@Sprawd_P:

; 929  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  017d0	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  017d5	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  017da	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T409[ebp]
  017e0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  017e5	83 c4 04	 add	 esp, 4
  017e8	8b f0		 mov	 esi, eax
  017ea	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
  017ee	8a 4d ec	 mov	 cl, BYTE PTR _i$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  017f1	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 929  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  017f4	80 c1 30	 add	 cl, 48			; 00000030H
  017f7	89 8d 98 fe ff
	ff		 mov	 DWORD PTR tv12363[ebp], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3870 : 	_Left.push_back(_Right);

  017fd	88 4d 98	 mov	 BYTE PTR __Ch$[ebp], cl

; 2977 : 		if (_Old_size < _My_data._Myres)

  01800	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  01803	73 1a		 jae	 SHORT $LN2762@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01805	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2979 : 			_My_data._Mysize = _Old_size + 1;

  01809	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0180c	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0180f	8b c6		 mov	 eax, esi

; 1583 : 		if (_Large_string_engaged())

  01811	72 02		 jb	 SHORT $LN2771@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01813	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2771@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01815	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  01818	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  0181d	eb 18		 jmp	 SHORT $LN2761@Sprawd_P
$LN2762@Sprawd_P:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  0181f	ff 75 98	 push	 DWORD PTR __Ch$[ebp]
  01822	c6 85 28 fe ff
	ff 00		 mov	 BYTE PTR $T413[ebp], 0
  01829	ff b5 28 fe ff
	ff		 push	 DWORD PTR $T413[ebp]
  0182f	51		 push	 ecx
  01830	8b ce		 mov	 ecx, esi
  01832	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN2761@Sprawd_P:

; 1563 : 		_Mysize(0),

  01837	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T419[ebp+16], 0

; 1564 : 		_Myres(0)

  01841	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T419[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0184b	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  0184e	0f 11 85 7c fe
	ff ff		 movups	 XMMWORD PTR $T419[ebp], xmm0
  01855	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  0185a	66 0f d6 85 8c
	fe ff ff	 movq	 QWORD PTR $T419[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  01862	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01869	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01870	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 929  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01873	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2335 : 		const size_type _Old_size = _My_data._Mysize;

  01877	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR $T419[ebp+20]
  0187d	8b c2		 mov	 eax, edx
  0187f	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR $T419[ebp+16]
  01885	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01887	6a 04		 push	 4
  01889	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  0188e	83 f8 04	 cmp	 eax, 4
  01891	72 31		 jb	 SHORT $LN2856@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01893	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  01896	8d b5 7c fe ff
	ff		 lea	 esi, DWORD PTR $T419[ebp]

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  0189c	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1583 : 		if (_Large_string_engaged())

  0189f	0f 43 b5 7c fe
	ff ff		 cmovae	 esi, DWORD PTR $T419[ebp]

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  018a6	03 f1		 add	 esi, ecx
  018a8	89 85 8c fe ff
	ff		 mov	 DWORD PTR $T419[ebp+16], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  018ae	56		 push	 esi
  018af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  018b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  018b8	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  018bc	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR $T419[ebp]
  018c2	eb 1a		 jmp	 SHORT $LN2855@Sprawd_P
$LN2856@Sprawd_P:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  018c4	c6 85 24 fe ff
	ff 00		 mov	 BYTE PTR $T432[ebp], 0
  018cb	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T419[ebp]
  018d1	ff b5 24 fe ff
	ff		 push	 DWORD PTR $T432[ebp]
  018d7	6a 04		 push	 4
  018d9	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN2855@Sprawd_P:

; 1563 : 		_Mysize(0),

  018de	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T438[ebp+16], 0

; 3860 : 	return (_STD move(_Left.append(_Right)));

  018e8	83 cf 0c	 or	 edi, 12			; 0000000cH

; 1564 : 		_Myres(0)

  018eb	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T438[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  018f5	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 929  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  018f8	6a 00		 push	 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3860 : 	return (_STD move(_Left.append(_Right)));

  018fa	89 bd 94 fe ff
	ff		 mov	 DWORD PTR $T670[ebp], edi

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01900	0f 11 85 cc fe
	ff ff		 movups	 XMMWORD PTR $T438[ebp], xmm0
  01907	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0190c	66 0f d6 85 dc
	fe ff ff	 movq	 QWORD PTR $T438[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  01914	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0191b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01922	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01925	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR $T438[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0192b	83 bd e0 fe ff
	ff 10		 cmp	 DWORD PTR $T438[ebp+20], 16 ; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01932	0f 43 85 cc fe
	ff ff		 cmovae	 eax, DWORD PTR $T438[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 929  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01939	50		 push	 eax
  0193a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01940	8b b5 e0 fe ff
	ff		 mov	 esi, DWORD PTR $T438[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 929  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01946	83 c4 08	 add	 esp, 8
  01949	89 85 20 fe ff
	ff		 mov	 DWORD PTR $T668[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0194f	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  01952	72 4a		 jb	 SHORT $LN2981@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01954	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR $T438[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0195a	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0195b	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0195d	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  01963	72 2f		 jb	 SHORT $LN2984@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01965	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  01968	3b c6		 cmp	 eax, esi
  0196a	0f 86 18 eb ff
	ff		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01970	8b f0		 mov	 esi, eax
  01972	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01975	0f 85 0d eb ff
	ff		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0197b	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  0197e	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01980	0f 83 02 eb ff
	ff		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01986	2b ca		 sub	 ecx, edx
  01988	83 e9 04	 sub	 ecx, 4
  0198b	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  0198e	0f 87 f4 ea ff
	ff		 ja	 $_Invalid_parameter$4562
$LN2984@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01994	56		 push	 esi
  01995	52		 push	 edx
  01996	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0199b	83 c4 08	 add	 esp, 8
$LN2981@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 929  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0199e	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  019a2	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR $T419[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  019a8	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T438[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  019b2	c7 85 e0 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T438[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  019bc	c6 85 cc fe ff
	ff 00		 mov	 BYTE PTR $T438[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  019c3	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  019c6	72 4a		 jb	 SHORT $LN3041@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  019c8	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR $T419[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  019ce	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  019cf	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  019d1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  019d7	72 2f		 jb	 SHORT $LN3044@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  019d9	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  019dc	3b f2		 cmp	 esi, edx
  019de	0f 86 a4 ea ff
	ff		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  019e4	8b d6		 mov	 edx, esi
  019e6	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  019e9	0f 85 99 ea ff
	ff		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  019ef	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  019f2	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  019f4	0f 83 8e ea ff
	ff		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  019fa	2b c8		 sub	 ecx, eax
  019fc	83 e9 04	 sub	 ecx, 4
  019ff	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01a02	0f 87 80 ea ff
	ff		 ja	 $_Invalid_parameter$4562
$LN3044@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01a08	52		 push	 edx
  01a09	50		 push	 eax
  01a0a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01a0f	83 c4 08	 add	 esp, 8
$LN3041@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 929  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01a12	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01a16	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T409[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  01a1c	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T419[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01a26	c7 85 90 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T419[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01a30	c6 85 7c fe ff
	ff 00		 mov	 BYTE PTR $T419[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01a37	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  01a3a	72 4a		 jb	 SHORT $LN3101@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01a3c	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T409[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01a42	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01a43	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01a45	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01a4b	72 2f		 jb	 SHORT $LN3104@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01a4d	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  01a50	3b f2		 cmp	 esi, edx
  01a52	0f 86 30 ea ff
	ff		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01a58	8b d6		 mov	 edx, esi
  01a5a	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01a5d	0f 85 25 ea ff
	ff		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01a63	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  01a66	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01a68	0f 83 1a ea ff
	ff		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01a6e	2b c8		 sub	 ecx, eax
  01a70	83 e9 04	 sub	 ecx, 4
  01a73	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01a76	0f 87 0c ea ff
	ff		 ja	 $_Invalid_parameter$4562
$LN3104@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01a7c	52		 push	 edx
  01a7d	50		 push	 eax
  01a7e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01a83	83 c4 08	 add	 esp, 8
$LN3101@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 929  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01a86	83 bd 20 fe ff
	ff 00		 cmp	 DWORD PTR $T668[ebp], 0
  01a8d	0f 84 1f 06 00
	00		 je	 $LN4@Sprawd_P

; 930  : 			{
; 931  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  01a93	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  01a9a	0f 85 92 00 00
	00		 jne	 $LN77@Sprawd_P

; 932  : 				{
; 933  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01aa0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01aa6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01aab	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  01ab0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01ab5	8b c8		 mov	 ecx, eax
  01ab7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 934  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 935  : 					Wyci¹gnij_z_Programu((g³os3 + ".rar"), Numer_zasobu_rar.at(g³os3));

  01abd	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  01ac2	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  01ac5	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  01acc	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T463[ebp]
  01ad2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ad7	83 c4 04	 add	 esp, 4
  01ada	8b f0		 mov	 esi, eax
  01adc	8d 45 d4	 lea	 eax, DWORD PTR _g³os3$684[ebp]
  01adf	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+8], 35 ; 00000023H
  01ae3	50		 push	 eax
  01ae4	e8 00 00 00 00	 call	 ?at@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QBEABGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::at
  01ae9	8b ce		 mov	 ecx, esi
  01aeb	66 8b 10	 mov	 dx, WORD PTR [eax]
  01aee	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
  01af3	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T463[ebp]
  01af9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01afd	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 936  : 					Wypakuj_Rar(g³os3 + ".rar");

  01b02	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  01b07	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  01b0a	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T464[ebp]
  01b10	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01b15	83 c4 04	 add	 esp, 4
  01b18	8b c8		 mov	 ecx, eax
  01b1a	c6 45 fc 24	 mov	 BYTE PTR __$EHRec$[ebp+8], 36 ; 00000024H
  01b1e	e8 00 00 00 00	 call	 ?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Wypakuj_Rar
  01b23	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T464[ebp]
  01b29	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01b2d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN77@Sprawd_P:

; 938  : 				if (!Przenie_Plik(g³os2 + (char)(48 + i) + ".wav", G³os + (char)(48 + i) + ".wav"))

  01b32	ff b5 98 fe ff
	ff		 push	 DWORD PTR tv12363[ebp]
  01b38	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  01b3d	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T465[ebp]
  01b43	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01b48	83 c4 04	 add	 esp, 4
  01b4b	8b f8		 mov	 edi, eax
  01b4d	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+8], 37 ; 00000025H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  01b51	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  01b54	8b c2		 mov	 eax, edx
  01b56	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  01b59	2b c1		 sub	 eax, ecx
  01b5b	83 f8 04	 cmp	 eax, 4
  01b5e	72 29		 jb	 SHORT $LN3146@Sprawd_P

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  01b60	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  01b63	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  01b66	8b c7		 mov	 eax, edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01b68	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  01b6b	72 02		 jb	 SHORT $LN3155@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01b6d	8b 07		 mov	 eax, DWORD PTR [edi]
$LN3155@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01b6f	6a 04		 push	 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  01b71	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01b74	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01b79	56		 push	 esi
  01b7a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  01b80	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  01b83	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  01b87	eb 1f		 jmp	 SHORT $LN3145@Sprawd_P
$LN3146@Sprawd_P:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  01b89	6a 04		 push	 4
  01b8b	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01b90	c6 85 1c fe ff
	ff 00		 mov	 BYTE PTR $T471[ebp], 0
  01b97	8b cf		 mov	 ecx, edi
  01b99	ff b5 1c fe ff
	ff		 push	 DWORD PTR $T471[ebp]
  01b9f	6a 04		 push	 4
  01ba1	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  01ba6	8b f8		 mov	 edi, eax
$LN3145@Sprawd_P:

; 1563 : 		_Mysize(0),

  01ba8	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T477[ebp+16], 0

; 1564 : 		_Myres(0)

  01bb2	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T477[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01bbc	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  01bbf	0f 11 85 7c fe
	ff ff		 movups	 XMMWORD PTR $T477[ebp], xmm0
  01bc6	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  01bcb	66 0f d6 85 8c
	fe ff ff	 movq	 QWORD PTR $T477[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  01bd3	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01bda	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01be1	c6 07 00	 mov	 BYTE PTR [edi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 938  : 				if (!Przenie_Plik(g³os2 + (char)(48 + i) + ".wav", G³os + (char)(48 + i) + ".wav"))

  01be4	c6 45 fc 26	 mov	 BYTE PTR __$EHRec$[ebp+8], 38 ; 00000026H
  01be8	8d 55 bc	 lea	 edx, DWORD PTR _g³os2$683[ebp]
  01beb	ff b5 98 fe ff
	ff		 push	 DWORD PTR tv12363[ebp]
  01bf1	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T486[ebp]
  01bf7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01bfc	83 c4 04	 add	 esp, 4
  01bff	8b f8		 mov	 edi, eax
  01c01	c6 45 fc 27	 mov	 BYTE PTR __$EHRec$[ebp+8], 39 ; 00000027H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  01c05	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  01c08	8b c2		 mov	 eax, edx
  01c0a	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  01c0d	2b c1		 sub	 eax, ecx
  01c0f	83 f8 04	 cmp	 eax, 4
  01c12	72 29		 jb	 SHORT $LN3240@Sprawd_P

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  01c14	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  01c17	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  01c1a	8b c7		 mov	 eax, edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01c1c	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  01c1f	72 02		 jb	 SHORT $LN3249@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01c21	8b 07		 mov	 eax, DWORD PTR [edi]
$LN3249@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01c23	6a 04		 push	 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  01c25	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01c28	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01c2d	56		 push	 esi
  01c2e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  01c34	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  01c37	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  01c3b	eb 1f		 jmp	 SHORT $LN3239@Sprawd_P
$LN3240@Sprawd_P:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  01c3d	6a 04		 push	 4
  01c3f	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01c44	c6 85 18 fe ff
	ff 00		 mov	 BYTE PTR $T492[ebp], 0
  01c4b	8b cf		 mov	 ecx, edi
  01c4d	ff b5 18 fe ff
	ff		 push	 DWORD PTR $T492[ebp]
  01c53	6a 04		 push	 4
  01c55	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  01c5a	8b f8		 mov	 edi, eax
$LN3239@Sprawd_P:

; 1563 : 		_Mysize(0),

  01c5c	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T498[ebp+16], 0

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01c66	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T477[ebp]

; 1564 : 		_Myres(0)

  01c6c	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T498[ebp+20], 0

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01c76	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR $T498[ebp]

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01c7c	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  01c7f	0f 11 85 cc fe
	ff ff		 movups	 XMMWORD PTR $T498[ebp], xmm0
  01c86	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  01c8b	66 0f d6 85 dc
	fe ff ff	 movq	 QWORD PTR $T498[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  01c93	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01c9a	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01ca1	c6 07 00	 mov	 BYTE PTR [edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3860 : 	return (_STD move(_Left.append(_Right)));

  01ca4	8b bd 94 fe ff
	ff		 mov	 edi, DWORD PTR $T670[ebp]
  01caa	83 cf 30	 or	 edi, 48			; 00000030H

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01cad	83 bd 90 fe ff
	ff 10		 cmp	 DWORD PTR $T477[ebp+20], 16 ; 00000010H

; 3860 : 	return (_STD move(_Left.append(_Right)));

  01cb4	89 bd 94 fe ff
	ff		 mov	 DWORD PTR $T670[ebp], edi

; 1594 : 		if (_Large_string_engaged())

  01cba	0f 43 8d 7c fe
	ff ff		 cmovae	 ecx, DWORD PTR $T477[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01cc1	83 bd e0 fe ff
	ff 10		 cmp	 DWORD PTR $T498[ebp+20], 16 ; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  01cc8	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1594 : 		if (_Large_string_engaged())

  01cc9	0f 43 85 cc fe
	ff ff		 cmovae	 eax, DWORD PTR $T498[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  01cd0	50		 push	 eax
  01cd1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01cd7	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T498[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  01cdd	85 c0		 test	 eax, eax

; 938  : 				if (!Przenie_Plik(g³os2 + (char)(48 + i) + ".wav", G³os + (char)(48 + i) + ".wav"))

  01cdf	0f 94 85 e6 fe
	ff ff		 sete	 BYTE PTR $T673[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01ce6	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  01ce9	72 4a		 jb	 SHORT $LN3383@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01ceb	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T498[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01cf1	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01cf2	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01cf4	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01cfa	72 2f		 jb	 SHORT $LN3386@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01cfc	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  01cff	3b f2		 cmp	 esi, edx
  01d01	0f 86 81 e7 ff
	ff		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01d07	8b d6		 mov	 edx, esi
  01d09	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01d0c	0f 85 76 e7 ff
	ff		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01d12	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  01d15	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01d17	0f 83 6b e7 ff
	ff		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01d1d	2b c8		 sub	 ecx, eax
  01d1f	83 e9 04	 sub	 ecx, 4
  01d22	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01d25	0f 87 5d e7 ff
	ff		 ja	 $_Invalid_parameter$4562
$LN3386@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01d2b	52		 push	 edx
  01d2c	50		 push	 eax
  01d2d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01d32	83 c4 08	 add	 esp, 8
$LN3383@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 938  : 				if (!Przenie_Plik(g³os2 + (char)(48 + i) + ".wav", G³os + (char)(48 + i) + ".wav"))

  01d35	c6 45 fc 26	 mov	 BYTE PTR __$EHRec$[ebp+8], 38 ; 00000026H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01d39	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T486[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  01d3f	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T498[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01d49	c7 85 e0 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T498[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01d53	c6 85 cc fe ff
	ff 00		 mov	 BYTE PTR $T498[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01d5a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  01d5d	72 4a		 jb	 SHORT $LN3443@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01d5f	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T486[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01d65	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01d66	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01d68	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01d6e	72 2f		 jb	 SHORT $LN3446@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01d70	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  01d73	3b f2		 cmp	 esi, edx
  01d75	0f 86 0d e7 ff
	ff		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01d7b	8b d6		 mov	 edx, esi
  01d7d	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01d80	0f 85 02 e7 ff
	ff		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01d86	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  01d89	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01d8b	0f 83 f7 e6 ff
	ff		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01d91	2b c8		 sub	 ecx, eax
  01d93	83 e9 04	 sub	 ecx, 4
  01d96	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01d99	0f 87 e9 e6 ff
	ff		 ja	 $_Invalid_parameter$4562
$LN3446@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01d9f	52		 push	 edx
  01da0	50		 push	 eax
  01da1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01da6	83 c4 08	 add	 esp, 8
$LN3443@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 938  : 				if (!Przenie_Plik(g³os2 + (char)(48 + i) + ".wav", G³os + (char)(48 + i) + ".wav"))

  01da9	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+8], 37 ; 00000025H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01dad	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR $T477[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  01db3	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T486[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01dbd	c7 85 c8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T486[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01dc7	c6 85 b4 fe ff
	ff 00		 mov	 BYTE PTR $T486[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01dce	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  01dd1	72 4a		 jb	 SHORT $LN3503@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01dd3	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR $T477[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01dd9	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01dda	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01ddc	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01de2	72 2f		 jb	 SHORT $LN3506@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01de4	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  01de7	3b f2		 cmp	 esi, edx
  01de9	0f 86 99 e6 ff
	ff		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01def	8b d6		 mov	 edx, esi
  01df1	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01df4	0f 85 8e e6 ff
	ff		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01dfa	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  01dfd	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01dff	0f 83 83 e6 ff
	ff		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01e05	2b c8		 sub	 ecx, eax
  01e07	83 e9 04	 sub	 ecx, 4
  01e0a	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01e0d	0f 87 75 e6 ff
	ff		 ja	 $_Invalid_parameter$4562
$LN3506@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01e13	52		 push	 edx
  01e14	50		 push	 eax
  01e15	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01e1a	83 c4 08	 add	 esp, 8
$LN3503@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 938  : 				if (!Przenie_Plik(g³os2 + (char)(48 + i) + ".wav", G³os + (char)(48 + i) + ".wav"))

  01e1d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01e21	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR $T465[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  01e27	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T477[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01e31	c7 85 90 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T477[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01e3b	c6 85 7c fe ff
	ff 00		 mov	 BYTE PTR $T477[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01e42	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  01e45	72 4a		 jb	 SHORT $LN3563@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01e47	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR $T465[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01e4d	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01e4e	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01e50	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01e56	72 2f		 jb	 SHORT $LN3566@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01e58	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  01e5b	3b f2		 cmp	 esi, edx
  01e5d	0f 86 25 e6 ff
	ff		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01e63	8b d6		 mov	 edx, esi
  01e65	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01e68	0f 85 1a e6 ff
	ff		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01e6e	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  01e71	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01e73	0f 83 0f e6 ff
	ff		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01e79	2b c8		 sub	 ecx, eax
  01e7b	83 e9 04	 sub	 ecx, 4
  01e7e	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01e81	0f 87 01 e6 ff
	ff		 ja	 $_Invalid_parameter$4562
$LN3566@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01e87	52		 push	 edx
  01e88	50		 push	 eax
  01e89	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01e8e	83 c4 08	 add	 esp, 8
$LN3563@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 938  : 				if (!Przenie_Plik(g³os2 + (char)(48 + i) + ".wav", G³os + (char)(48 + i) + ".wav"))

  01e91	80 bd e6 fe ff
	ff 00		 cmp	 BYTE PTR $T673[ebp], 0
  01e98	0f 84 14 02 00
	00		 je	 $LN4@Sprawd_P

; 940  : 					auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), (G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01e9e	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  01ea3	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  01ea8	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T530[ebp]
  01eae	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01eb3	83 c4 04	 add	 esp, 4
  01eb6	8b f0		 mov	 esi, eax
  01eb8	c6 45 fc 28	 mov	 BYTE PTR __$EHRec$[ebp+8], 40 ; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  01ebc	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 2977 : 		if (_Old_size < _My_data._Myres)

  01ebf	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]

; 3870 : 	_Left.push_back(_Right);

  01ec2	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR tv12363[ebp]
  01ec8	88 4d b4	 mov	 BYTE PTR __Ch$[ebp], cl

; 2977 : 		if (_Old_size < _My_data._Myres)

  01ecb	3b d7		 cmp	 edx, edi
  01ecd	73 19		 jae	 SHORT $LN3601@Sprawd_P

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  01ecf	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  01ed2	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  01ed5	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01ed7	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  01eda	72 02		 jb	 SHORT $LN3610@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01edc	8b 06		 mov	 eax, DWORD PTR [esi]
$LN3610@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01ede	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  01ee1	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  01ee6	eb 18		 jmp	 SHORT $LN3600@Sprawd_P
$LN3601@Sprawd_P:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  01ee8	ff 75 b4	 push	 DWORD PTR __Ch$[ebp]
  01eeb	c6 85 74 fe ff
	ff 00		 mov	 BYTE PTR $T534[ebp], 0
  01ef2	ff b5 74 fe ff
	ff		 push	 DWORD PTR $T534[ebp]
  01ef8	51		 push	 ecx
  01ef9	8b ce		 mov	 ecx, esi
  01efb	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN3600@Sprawd_P:

; 1563 : 		_Mysize(0),

  01f00	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T540[ebp+16], 0

; 1564 : 		_Myres(0)

  01f0a	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T540[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01f14	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  01f17	0f 11 85 cc fe
	ff ff		 movups	 XMMWORD PTR $T540[ebp], xmm0
  01f1e	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  01f23	66 0f d6 85 dc
	fe ff ff	 movq	 QWORD PTR $T540[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  01f2b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01f32	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01f39	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 940  : 					auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), (G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01f3c	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01f41	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR $T540[ebp]
  01f47	c6 45 fc 29	 mov	 BYTE PTR __$EHRec$[ebp+8], 41 ; 00000029H
  01f4b	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T548[ebp]
  01f51	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01f56	8b f8		 mov	 edi, eax
  01f58	8d 45 bc	 lea	 eax, DWORD PTR _g³os2$683[ebp]
  01f5b	c6 45 fc 2a	 mov	 BYTE PTR __$EHRec$[ebp+8], 42 ; 0000002aH
  01f5f	50		 push	 eax
  01f60	8d 55 9c	 lea	 edx, DWORD PTR _link$682[ebp]
  01f63	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T550[ebp]
  01f69	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01f6e	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  01f73	8b d0		 mov	 edx, eax
  01f75	c6 45 fc 2b	 mov	 BYTE PTR __$EHRec$[ebp+8], 43 ; 0000002bH
  01f79	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T551[ebp]
  01f7f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01f84	83 c4 0c	 add	 esp, 12			; 0000000cH
  01f87	8b f0		 mov	 esi, eax
  01f89	c6 45 fc 2c	 mov	 BYTE PTR __$EHRec$[ebp+8], 44 ; 0000002cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  01f8d	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 3870 : 	_Left.push_back(_Right);

  01f90	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR tv12363[ebp]
  01f96	88 4d b8	 mov	 BYTE PTR __Ch$[ebp], cl

; 2977 : 		if (_Old_size < _My_data._Myres)

  01f99	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  01f9c	73 1a		 jae	 SHORT $LN3704@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01f9e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2979 : 			_My_data._Mysize = _Old_size + 1;

  01fa2	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  01fa5	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  01fa8	8b c6		 mov	 eax, esi

; 1583 : 		if (_Large_string_engaged())

  01faa	72 02		 jb	 SHORT $LN3713@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01fac	8b 06		 mov	 eax, DWORD PTR [esi]
$LN3713@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01fae	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  01fb1	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  01fb6	eb 18		 jmp	 SHORT $LN3703@Sprawd_P
$LN3704@Sprawd_P:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  01fb8	ff 75 b8	 push	 DWORD PTR __Ch$[ebp]
  01fbb	c6 85 78 fe ff
	ff 00		 mov	 BYTE PTR $T555[ebp], 0
  01fc2	ff b5 78 fe ff
	ff		 push	 DWORD PTR $T555[ebp]
  01fc8	51		 push	 ecx
  01fc9	8b ce		 mov	 ecx, esi
  01fcb	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN3703@Sprawd_P:

; 3871 : 	return (_STD move(_Left));

  01fd0	81 8d 94 fe ff
	ff c0 00 00 00	 or	 DWORD PTR $T670[ebp], 192 ; 000000c0H

; 1563 : 		_Mysize(0),

  01fda	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T561[ebp+16], 0

; 1564 : 		_Myres(0)

  01fe4	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T561[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01fee	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  01ff1	0f 11 85 b4 fe
	ff ff		 movups	 XMMWORD PTR $T561[ebp], xmm0
  01ff8	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  01ffd	66 0f d6 85 c4
	fe ff ff	 movq	 QWORD PTR $T561[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  02005	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0200c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  02013	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 940  : 					auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), (G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  02016	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  0201b	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR $T561[ebp]
  02021	c6 45 fc 2d	 mov	 BYTE PTR __$EHRec$[ebp+8], 45 ; 0000002dH
  02025	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T569[ebp]
  0202b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02030	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  02033	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  02037	72 02		 jb	 SHORT $LN3693@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  02039	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN3693@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0203b	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0203f	72 02		 jb	 SHORT $LN3796@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  02041	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3796@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 940  : 					auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), (G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  02043	6a 00		 push	 0
  02045	6a 00		 push	 0
  02047	57		 push	 edi
  02048	50		 push	 eax
  02049	6a 00		 push	 0
  0204b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  02051	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T569[ebp]
  02057	8b f0		 mov	 esi, eax
  02059	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0205e	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T561[ebp]
  02064	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02069	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T551[ebp]
  0206f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02074	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T550[ebp]
  0207a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0207f	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T548[ebp]
  02085	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0208a	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T540[ebp]
  02090	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02095	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T530[ebp]
  0209b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0209f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 941  : 					if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  020a4	85 f6		 test	 esi, esi
  020a6	0f 85 e0 0b 00
	00		 jne	 $LN4540@Sprawd_P
  020ac	8b bd 94 fe ff
	ff		 mov	 edi, DWORD PTR $T670[ebp]
$LN4@Sprawd_P:

; 919  : 				{
; 920  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 921  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 922  : 					return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 923  : 				}
; 924  : 			}
; 925  : 		}
; 926  : 
; 927  : 		for (unsigned short i = 1; i <= 3; ++i) //Pêtla licz¹ca od 1 do 3

  020b2	8b 45 ec	 mov	 eax, DWORD PTR _i$1$[ebp]
  020b5	40		 inc	 eax
  020b6	89 45 ec	 mov	 DWORD PTR _i$1$[ebp], eax
  020b9	66 83 f8 03	 cmp	 ax, 3
  020bd	0f 86 0d f7 ff
	ff		 jbe	 $LL6@Sprawd_P

; 942  : 					{
; 943  : 						cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 944  : 						G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 945  : 						return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 946  : 					}
; 947  : 				}
; 948  : 			}
; 949  : 		}
; 950  : 
; 951  : 		for (unsigned short i = 1; i <= 12; ++i) //Pêtla licz¹ca od 1 do 12

  020c3	be 01 00 00 00	 mov	 esi, 1
  020c8	89 b5 98 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  020ce	66 90		 npad	 2
$LL9@Sprawd_P:
  020d0	68 b0 00 00 00	 push	 176			; 000000b0H
  020d5	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _numers$681[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 590  : 		{	// construct empty character buffer

  020db	89 bd 74 fe ff
	ff		 mov	 DWORD PTR tv12476[ebp], edi
  020e1	6a 00		 push	 0
  020e3	50		 push	 eax
  020e4	e8 00 00 00 00	 call	 _memset
  020e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  020ec	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$681[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  020f6	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp+104]
  020fc	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$681[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  02106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  0210c	6a 00		 push	 0
  0210e	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _numers$681[ebp+24]
  02114	c6 45 fc 2e	 mov	 BYTE PTR __$EHRec$[ebp+8], 46 ; 0000002eH
  02118	81 cf 00 01 00
	00		 or	 edi, 256		; 00000100H
  0211e	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp]
  02124	50		 push	 eax
  02125	89 bd 78 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], edi
  0212b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  02131	c7 45 fc 2f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 47 ; 0000002fH
  02138	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _numers$681[ebp]
  0213e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  02141	c7 84 05 e8 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$681[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0214c	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _numers$681[ebp]
  02152	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02155	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  02158	89 84 0d e4 fe
	ff ff		 mov	 DWORD PTR _numers$681[ebp+ecx-4], eax
  0215f	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _numers$681[ebp+24]

; 30   : 		{	// construct empty character buffer from mode

  02165	8b c8		 mov	 ecx, eax

; 589  : 			_Stringbuffer(_Mode)

  02167	89 45 b4	 mov	 DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

  0216a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  02170	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$681[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

  0217a	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$681[ebp+80], 0

; 312  : 		_Mystate = _State;

  02184	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$681[ebp+84], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 954  : 			numers << i; //Wpisanie do typu wartoci z obrotu pêtli

  0218e	56		 push	 esi
  0218f	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp+16]
  02195	c6 45 fc 31	 mov	 BYTE PTR __$EHRec$[ebp+8], 49 ; 00000031H
  02199	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 644  : 		return (_Stringbuffer.str());

  0219f	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR $T578[ebp]
  021a5	50		 push	 eax
  021a6	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp+24]
  021ac	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 955  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  021b1	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  021b6	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  021bb	c6 45 fc 32	 mov	 BYTE PTR __$EHRec$[ebp+8], 50 ; 00000032H
  021bf	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T579[ebp]
  021c5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  021ca	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T578[ebp]
  021d0	c6 45 fc 33	 mov	 BYTE PTR __$EHRec$[ebp+8], 51 ; 00000033H
  021d4	51		 push	 ecx
  021d5	8b d0		 mov	 edx, eax
  021d7	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T580[ebp]
  021dd	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  021e2	83 c4 08	 add	 esp, 8
  021e5	8b f0		 mov	 esi, eax
  021e7	c6 45 fc 34	 mov	 BYTE PTR __$EHRec$[ebp+8], 52 ; 00000034H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  021eb	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  021ee	8b c1		 mov	 eax, ecx
  021f0	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  021f3	2b c7		 sub	 eax, edi
  021f5	83 f8 04	 cmp	 eax, 4
  021f8	72 32		 jb	 SHORT $LN4188@Sprawd_P

; 1582 : 		value_type * _Result = _Bx._Buf;

  021fa	89 75 ec	 mov	 DWORD PTR __Result$1$[ebp], esi

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  021fd	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  02200	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  02203	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  02205	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  02208	72 05		 jb	 SHORT $LN4197@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0220a	8b 06		 mov	 eax, DWORD PTR [esi]
  0220c	89 45 ec	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN4197@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0220f	6a 04		 push	 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  02211	03 c7		 add	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  02213	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  02218	50		 push	 eax
  02219	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 442  : 		_Left = _Right;

  0221f	8b 45 ec	 mov	 eax, DWORD PTR __Result$1$[ebp]

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  02222	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  02225	c6 44 38 04 00	 mov	 BYTE PTR [eax+edi+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0222a	eb 19		 jmp	 SHORT $LN4187@Sprawd_P
$LN4188@Sprawd_P:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  0222c	6a 04		 push	 4
  0222e	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  02233	c6 45 b8 00	 mov	 BYTE PTR $T586[ebp], 0
  02237	8b ce		 mov	 ecx, esi
  02239	ff 75 b8	 push	 DWORD PTR $T586[ebp]
  0223c	6a 04		 push	 4
  0223e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  02243	8b f0		 mov	 esi, eax
$LN4187@Sprawd_P:

; 3860 : 	return (_STD move(_Left.append(_Right)));

  02245	8b bd 74 fe ff
	ff		 mov	 edi, DWORD PTR tv12476[ebp]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0224b	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR $T592[ebp]

; 1563 : 		_Mysize(0),

  02251	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T592[ebp+16], 0

; 3860 : 	return (_STD move(_Left.append(_Right)));

  0225b	81 cf 00 0b 00
	00		 or	 edi, 2816		; 00000b00H

; 1564 : 		_Myres(0)

  02261	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T592[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0226b	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 955  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0226e	6a 00		 push	 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3860 : 	return (_STD move(_Left.append(_Right)));

  02270	89 bd 94 fe ff
	ff		 mov	 DWORD PTR $T670[ebp], edi

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  02276	0f 11 85 cc fe
	ff ff		 movups	 XMMWORD PTR $T592[ebp], xmm0
  0227d	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  02282	66 0f d6 85 dc
	fe ff ff	 movq	 QWORD PTR $T592[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  0228a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  02291	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  02298	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0229b	83 bd e0 fe ff
	ff 10		 cmp	 DWORD PTR $T592[ebp+20], 16 ; 00000010H

; 1594 : 		if (_Large_string_engaged())

  022a2	0f 43 85 cc fe
	ff ff		 cmovae	 eax, DWORD PTR $T592[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 955  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  022a9	50		 push	 eax
  022aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  022b0	8b b5 e0 fe ff
	ff		 mov	 esi, DWORD PTR $T592[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 955  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  022b6	83 c4 08	 add	 esp, 8
  022b9	89 85 78 fe ff
	ff		 mov	 DWORD PTR $T669[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  022bf	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  022c2	72 4a		 jb	 SHORT $LN4313@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  022c4	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR $T592[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  022ca	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  022cb	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  022cd	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  022d3	72 2f		 jb	 SHORT $LN4316@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  022d5	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  022d8	3b c6		 cmp	 eax, esi
  022da	0f 86 a8 e1 ff
	ff		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  022e0	8b f0		 mov	 esi, eax
  022e2	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  022e5	0f 85 9d e1 ff
	ff		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  022eb	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  022ee	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  022f0	0f 83 92 e1 ff
	ff		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  022f6	2b ca		 sub	 ecx, edx
  022f8	83 e9 04	 sub	 ecx, 4
  022fb	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  022fe	0f 87 84 e1 ff
	ff		 ja	 $_Invalid_parameter$4562
$LN4316@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  02304	56		 push	 esi
  02305	52		 push	 edx
  02306	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0230b	83 c4 08	 add	 esp, 8
$LN4313@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 955  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0230e	c6 45 fc 33	 mov	 BYTE PTR __$EHRec$[ebp+8], 51 ; 00000033H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  02312	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T580[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  02318	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T592[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  02322	c7 85 e0 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T592[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0232c	c6 85 cc fe ff
	ff 00		 mov	 BYTE PTR $T592[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  02333	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  02336	72 4a		 jb	 SHORT $LN4373@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  02338	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T580[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0233e	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0233f	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  02341	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  02347	72 2f		 jb	 SHORT $LN4376@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  02349	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  0234c	3b f2		 cmp	 esi, edx
  0234e	0f 86 34 e1 ff
	ff		 jbe	 $_Invalid_parameter$4562

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  02354	8b d6		 mov	 edx, esi
  02356	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  02359	0f 85 29 e1 ff
	ff		 jne	 $_Invalid_parameter$4562

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0235f	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  02362	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  02364	0f 83 1e e1 ff
	ff		 jae	 $_Invalid_parameter$4562

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0236a	2b c8		 sub	 ecx, eax
  0236c	83 e9 04	 sub	 ecx, 4
  0236f	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  02372	0f 87 10 e1 ff
	ff		 ja	 $_Invalid_parameter$4562
$LN4376@Sprawd_P:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  02378	52		 push	 edx
  02379	50		 push	 eax
  0237a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0237f	83 c4 08	 add	 esp, 8
$LN4373@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  02382	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR $T579[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  02388	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T580[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  02392	c7 85 c8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T580[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0239c	c6 85 b4 fe ff
	ff 00		 mov	 BYTE PTR $T580[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  023a3	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  023a6	72 12		 jb	 SHORT $LN4410@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  023a8	51		 push	 ecx
  023a9	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR $T579[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  023af	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  023b0	6a 01		 push	 1
  023b2	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXIII@Z ; std::_Deallocate
  023b7	83 c4 08	 add	 esp, 8
$LN4410@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 955  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  023ba	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T578[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  023c0	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T579[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  023ca	c7 85 90 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T579[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  023d4	c6 85 7c fe ff
	ff 00		 mov	 BYTE PTR $T579[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 955  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  023db	c6 45 fc 31	 mov	 BYTE PTR __$EHRec$[ebp+8], 49 ; 00000031H
  023df	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  023e4	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR $T669[ebp], 0
  023eb	0f 84 2c 03 00
	00		 je	 $LN83@Sprawd_P

; 956  : 			{
; 957  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  023f1	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  023f8	0f 85 92 00 00
	00		 jne	 $LN81@Sprawd_P

; 958  : 				{
; 959  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  023fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  02404	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  02409	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0240e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  02413	8b c8		 mov	 ecx, eax
  02415	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 960  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 961  : 					Wyci¹gnij_z_Programu((g³os3 + ".rar"), Numer_zasobu_rar.at(g³os3));

  0241b	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  02420	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  02423	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  0242a	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T617[ebp]
  02430	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02435	83 c4 04	 add	 esp, 4
  02438	8b f0		 mov	 esi, eax
  0243a	8d 45 d4	 lea	 eax, DWORD PTR _g³os3$684[ebp]
  0243d	c6 45 fc 35	 mov	 BYTE PTR __$EHRec$[ebp+8], 53 ; 00000035H
  02441	50		 push	 eax
  02442	e8 00 00 00 00	 call	 ?at@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QBEABGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::at
  02447	8b ce		 mov	 ecx, esi
  02449	66 8b 10	 mov	 dx, WORD PTR [eax]
  0244c	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
  02451	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T617[ebp]
  02457	c6 45 fc 31	 mov	 BYTE PTR __$EHRec$[ebp+8], 49 ; 00000031H
  0245b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 962  : 					Wypakuj_Rar(g³os3 + ".rar");

  02460	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  02465	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  02468	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T618[ebp]
  0246e	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02473	83 c4 04	 add	 esp, 4
  02476	8b c8		 mov	 ecx, eax
  02478	c6 45 fc 36	 mov	 BYTE PTR __$EHRec$[ebp+8], 54 ; 00000036H
  0247c	e8 00 00 00 00	 call	 ?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Wypakuj_Rar
  02481	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T618[ebp]
  02487	c6 45 fc 31	 mov	 BYTE PTR __$EHRec$[ebp+8], 49 ; 00000031H
  0248b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN81@Sprawd_P:

; 963  : 				}
; 964  : 				if (!Przenie_Plik(g³os2 + "w" + numers.str() + ".wav", G³os + "w" + numers.str() + ".wav"))

  02490	8d 85 2c fe ff
	ff		 lea	 eax, DWORD PTR $T619[ebp]
  02496	50		 push	 eax
  02497	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp]
  0249d	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  024a2	8b f0		 mov	 esi, eax
  024a4	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  024a9	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  024ae	c6 45 fc 37	 mov	 BYTE PTR __$EHRec$[ebp+8], 55 ; 00000037H
  024b2	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T620[ebp]
  024b8	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  024bd	56		 push	 esi
  024be	8b d0		 mov	 edx, eax
  024c0	c6 45 fc 38	 mov	 BYTE PTR __$EHRec$[ebp+8], 56 ; 00000038H
  024c4	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T621[ebp]
  024ca	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  024cf	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  024d4	8b d0		 mov	 edx, eax
  024d6	c6 45 fc 39	 mov	 BYTE PTR __$EHRec$[ebp+8], 57 ; 00000039H
  024da	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T622[ebp]
  024e0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  024e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  024e8	8b f8		 mov	 edi, eax
  024ea	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR $T623[ebp]
  024f0	c6 45 fc 3a	 mov	 BYTE PTR __$EHRec$[ebp+8], 58 ; 0000003aH
  024f4	50		 push	 eax
  024f5	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp]
  024fb	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  02500	8b f0		 mov	 esi, eax
  02502	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  02507	8d 55 bc	 lea	 edx, DWORD PTR _g³os2$683[ebp]
  0250a	c6 45 fc 3b	 mov	 BYTE PTR __$EHRec$[ebp+8], 59 ; 0000003bH
  0250e	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T624[ebp]
  02514	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02519	56		 push	 esi
  0251a	8b d0		 mov	 edx, eax
  0251c	c6 45 fc 3c	 mov	 BYTE PTR __$EHRec$[ebp+8], 60 ; 0000003cH
  02520	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T625[ebp]
  02526	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0252b	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  02530	8b d0		 mov	 edx, eax
  02532	c6 45 fc 3d	 mov	 BYTE PTR __$EHRec$[ebp+8], 61 ; 0000003dH
  02536	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T626[ebp]
  0253c	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02541	83 c4 0c	 add	 esp, 12			; 0000000cH
  02544	8b d7		 mov	 edx, edi
  02546	8b c8		 mov	 ecx, eax
  02548	e8 00 00 00 00	 call	 ?Przenie_Plik@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Przenie_Plik
  0254d	84 c0		 test	 al, al
  0254f	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T626[ebp]
  02555	0f 94 85 e6 fe
	ff ff		 sete	 BYTE PTR $T672[ebp]
  0255c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02561	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T625[ebp]
  02567	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0256c	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T624[ebp]
  02572	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02577	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T623[ebp]
  0257d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02582	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T622[ebp]
  02588	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0258d	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T621[ebp]
  02593	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02598	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T620[ebp]
  0259e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  025a3	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T619[ebp]
  025a9	c6 45 fc 31	 mov	 BYTE PTR __$EHRec$[ebp+8], 49 ; 00000031H
  025ad	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  025b2	80 bd e6 fe ff
	ff 00		 cmp	 BYTE PTR $T672[ebp], 0
  025b9	0f 84 58 01 00
	00		 je	 $LN4531@Sprawd_P

; 965  : 				{
; 966  : 					auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), (G³os + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  025bf	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR $T628[ebp]
  025c5	50		 push	 eax
  025c6	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp]
  025cc	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  025d1	8b f0		 mov	 esi, eax
  025d3	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  025d8	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  025dd	c6 45 fc 3e	 mov	 BYTE PTR __$EHRec$[ebp+8], 62 ; 0000003eH
  025e1	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T629[ebp]
  025e7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  025ec	56		 push	 esi
  025ed	8b d0		 mov	 edx, eax
  025ef	c6 45 fc 3f	 mov	 BYTE PTR __$EHRec$[ebp+8], 63 ; 0000003fH
  025f3	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T630[ebp]
  025f9	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  025fe	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  02603	8b d0		 mov	 edx, eax
  02605	c6 45 fc 40	 mov	 BYTE PTR __$EHRec$[ebp+8], 64 ; 00000040H
  02609	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T631[ebp]
  0260f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02614	83 c4 0c	 add	 esp, 12			; 0000000cH
  02617	8b f8		 mov	 edi, eax
  02619	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR $T632[ebp]
  0261f	c6 45 fc 41	 mov	 BYTE PTR __$EHRec$[ebp+8], 65 ; 00000041H
  02623	50		 push	 eax
  02624	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp]
  0262a	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  0262f	8b f0		 mov	 esi, eax
  02631	8d 45 bc	 lea	 eax, DWORD PTR _g³os2$683[ebp]
  02634	c6 45 fc 42	 mov	 BYTE PTR __$EHRec$[ebp+8], 66 ; 00000042H
  02638	50		 push	 eax
  02639	8d 55 9c	 lea	 edx, DWORD PTR _link$682[ebp]
  0263c	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T633[ebp]
  02642	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02647	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  0264c	8b d0		 mov	 edx, eax
  0264e	c6 45 fc 43	 mov	 BYTE PTR __$EHRec$[ebp+8], 67 ; 00000043H
  02652	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T634[ebp]
  02658	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0265d	56		 push	 esi
  0265e	8b d0		 mov	 edx, eax
  02660	c6 45 fc 44	 mov	 BYTE PTR __$EHRec$[ebp+8], 68 ; 00000044H
  02664	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T635[ebp]
  0266a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0266f	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  02674	8b d0		 mov	 edx, eax
  02676	c6 45 fc 45	 mov	 BYTE PTR __$EHRec$[ebp+8], 69 ; 00000045H
  0267a	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T636[ebp]
  02680	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02685	83 c4 10	 add	 esp, 16			; 00000010H
  02688	8b cf		 mov	 ecx, edi
  0268a	8b d0		 mov	 edx, eax
  0268c	6a 00		 push	 0
  0268e	6a 00		 push	 0
  02690	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  02695	50		 push	 eax
  02696	8b ca		 mov	 ecx, edx
  02698	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0269d	50		 push	 eax
  0269e	6a 00		 push	 0
  026a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  026a6	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T636[ebp]
  026ac	8b f0		 mov	 esi, eax
  026ae	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  026b3	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T635[ebp]
  026b9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  026be	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T634[ebp]
  026c4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  026c9	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T633[ebp]
  026cf	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  026d4	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T632[ebp]
  026da	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  026df	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T631[ebp]
  026e5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  026ea	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T630[ebp]
  026f0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  026f5	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T629[ebp]
  026fb	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02700	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T628[ebp]
  02706	c6 45 fc 31	 mov	 BYTE PTR __$EHRec$[ebp+8], 49 ; 00000031H
  0270a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 967  : 					if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0270f	85 f6		 test	 esi, esi
  02711	0f 85 9b 05 00
	00		 jne	 $LN4507@Sprawd_P
$LN4531@Sprawd_P:

; 963  : 				}
; 964  : 				if (!Przenie_Plik(g³os2 + "w" + numers.str() + ".wav", G³os + "w" + numers.str() + ".wav"))

  02717	8b bd 94 fe ff
	ff		 mov	 edi, DWORD PTR $T670[ebp]
$LN83@Sprawd_P:

; 968  : 					{
; 969  : 						cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 970  : 						G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 971  : 						return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 		}

  0271d	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp]
  02723	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  02727	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  0272c	8b b5 98 fe ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
  02732	46		 inc	 esi
  02733	89 b5 98 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  02739	66 83 fe 0c	 cmp	 si, 12			; 0000000cH
  0273d	0f 86 8d f9 ff
	ff		 jbe	 $LL9@Sprawd_P

; 976  : 
; 977  : 		for (unsigned short i = 0; i <= 36; ++i) //Pêtla licz¹ca od 0 do 36

  02743	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp___access
  02749	33 f6		 xor	 esi, esi
  0274b	89 75 ec	 mov	 DWORD PTR _i$1$[ebp], esi
  0274e	66 90		 npad	 2
$LL12@Sprawd_P:

; 978  : 		{
; 979  : 			stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  02750	51		 push	 ecx
  02751	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$680[ebp]
  02757	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
  0275c	83 ec 08	 sub	 esp, 8
  0275f	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$680[ebp]
  02765	e8 00 00 00 00	 call	 ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >

; 980  : 			numers << i; //Wpisanie do typu wartoci z obrotu pêtli

  0276a	56		 push	 esi
  0276b	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$680[ebp+16]
  02771	c6 45 fc 46	 mov	 BYTE PTR __$EHRec$[ebp+8], 70 ; 00000046H
  02775	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z

; 981  : 			if ((_access((G³os + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0277b	8d 85 44 fe ff
	ff		 lea	 eax, DWORD PTR $T637[ebp]
  02781	50		 push	 eax
  02782	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$680[ebp]
  02788	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  0278d	50		 push	 eax
  0278e	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  02793	c6 45 fc 47	 mov	 BYTE PTR __$EHRec$[ebp+8], 71 ; 00000047H
  02797	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T638[ebp]
  0279d	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  027a2	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  027a7	8b d0		 mov	 edx, eax
  027a9	c6 45 fc 48	 mov	 BYTE PTR __$EHRec$[ebp+8], 72 ; 00000048H
  027ad	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T639[ebp]
  027b3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  027b8	83 c4 08	 add	 esp, 8
  027bb	8b c8		 mov	 ecx, eax
  027bd	6a 00		 push	 0
  027bf	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  027c4	50		 push	 eax
  027c5	ff d7		 call	 edi
  027c7	83 c4 08	 add	 esp, 8
  027ca	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T639[ebp]
  027d0	8b f0		 mov	 esi, eax
  027d2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  027d7	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T638[ebp]
  027dd	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  027e2	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T637[ebp]
  027e8	c6 45 fc 46	 mov	 BYTE PTR __$EHRec$[ebp+8], 70 ; 00000046H
  027ec	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  027f1	85 f6		 test	 esi, esi
  027f3	0f 84 a2 02 00
	00		 je	 $LN87@Sprawd_P

; 982  : 			{
; 983  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  027f9	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  02800	0f 85 92 00 00
	00		 jne	 $LN85@Sprawd_P

; 984  : 				{
; 985  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  02806	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0280c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  02811	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  02816	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0281b	8b c8		 mov	 ecx, eax
  0281d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 986  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 987  : 					Wyci¹gnij_z_Programu((g³os3 + ".rar"), Numer_zasobu_rar.at(g³os3));

  02823	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  02828	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  0282b	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  02832	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T641[ebp]
  02838	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0283d	83 c4 04	 add	 esp, 4
  02840	8b f0		 mov	 esi, eax
  02842	8d 45 d4	 lea	 eax, DWORD PTR _g³os3$684[ebp]
  02845	c6 45 fc 49	 mov	 BYTE PTR __$EHRec$[ebp+8], 73 ; 00000049H
  02849	50		 push	 eax
  0284a	e8 00 00 00 00	 call	 ?at@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QBEABGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::at
  0284f	8b ce		 mov	 ecx, esi
  02851	66 8b 10	 mov	 dx, WORD PTR [eax]
  02854	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
  02859	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T641[ebp]
  0285f	c6 45 fc 46	 mov	 BYTE PTR __$EHRec$[ebp+8], 70 ; 00000046H
  02863	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 988  : 					Wypakuj_Rar(g³os3 + ".rar");

  02868	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  0286d	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  02870	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T642[ebp]
  02876	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0287b	83 c4 04	 add	 esp, 4
  0287e	8b c8		 mov	 ecx, eax
  02880	c6 45 fc 4a	 mov	 BYTE PTR __$EHRec$[ebp+8], 74 ; 0000004aH
  02884	e8 00 00 00 00	 call	 ?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Wypakuj_Rar
  02889	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T642[ebp]
  0288f	c6 45 fc 46	 mov	 BYTE PTR __$EHRec$[ebp+8], 70 ; 00000046H
  02893	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN85@Sprawd_P:

; 989  : 				}
; 990  : 				if (!Przenie_Plik(g³os2 + numers.str() + ".wav", G³os + numers.str() + ".wav"))

  02898	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR $T643[ebp]
  0289e	50		 push	 eax
  0289f	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$680[ebp]
  028a5	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  028aa	50		 push	 eax
  028ab	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  028b0	c6 45 fc 4b	 mov	 BYTE PTR __$EHRec$[ebp+8], 75 ; 0000004bH
  028b4	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T644[ebp]
  028ba	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  028bf	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  028c4	8b d0		 mov	 edx, eax
  028c6	c6 45 fc 4c	 mov	 BYTE PTR __$EHRec$[ebp+8], 76 ; 0000004cH
  028ca	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T645[ebp]
  028d0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  028d5	83 c4 08	 add	 esp, 8
  028d8	8b f0		 mov	 esi, eax
  028da	8d 85 44 fe ff
	ff		 lea	 eax, DWORD PTR $T646[ebp]
  028e0	c6 45 fc 4d	 mov	 BYTE PTR __$EHRec$[ebp+8], 77 ; 0000004dH
  028e4	50		 push	 eax
  028e5	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$680[ebp]
  028eb	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  028f0	50		 push	 eax
  028f1	8d 55 bc	 lea	 edx, DWORD PTR _g³os2$683[ebp]
  028f4	c6 45 fc 4e	 mov	 BYTE PTR __$EHRec$[ebp+8], 78 ; 0000004eH
  028f8	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T647[ebp]
  028fe	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02903	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  02908	8b d0		 mov	 edx, eax
  0290a	c6 45 fc 4f	 mov	 BYTE PTR __$EHRec$[ebp+8], 79 ; 0000004fH
  0290e	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T648[ebp]
  02914	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02919	83 c4 08	 add	 esp, 8
  0291c	8b d6		 mov	 edx, esi
  0291e	8b c8		 mov	 ecx, eax
  02920	e8 00 00 00 00	 call	 ?Przenie_Plik@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Przenie_Plik
  02925	84 c0		 test	 al, al
  02927	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T648[ebp]
  0292d	0f 94 85 e6 fe
	ff ff		 sete	 BYTE PTR $T671[ebp]
  02934	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02939	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T647[ebp]
  0293f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02944	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T646[ebp]
  0294a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0294f	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T645[ebp]
  02955	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0295a	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T644[ebp]
  02960	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02965	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T643[ebp]
  0296b	c6 45 fc 46	 mov	 BYTE PTR __$EHRec$[ebp+8], 70 ; 00000046H
  0296f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02974	80 bd e6 fe ff
	ff 00		 cmp	 BYTE PTR $T671[ebp], 0
  0297b	0f 84 1a 01 00
	00		 je	 $LN87@Sprawd_P

; 991  : 				{
; 992  : 					auto res = URLDownloadToFileA(nullptr, (link + g³os2 + numers.str() + ".wav").c_str(), (G³os + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  02981	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR $T650[ebp]
  02987	50		 push	 eax
  02988	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$680[ebp]
  0298e	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  02993	50		 push	 eax
  02994	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  02999	c6 45 fc 50	 mov	 BYTE PTR __$EHRec$[ebp+8], 80 ; 00000050H
  0299d	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T651[ebp]
  029a3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  029a8	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  029ad	8b d0		 mov	 edx, eax
  029af	c6 45 fc 51	 mov	 BYTE PTR __$EHRec$[ebp+8], 81 ; 00000051H
  029b3	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T652[ebp]
  029b9	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  029be	83 c4 08	 add	 esp, 8
  029c1	8b f8		 mov	 edi, eax
  029c3	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T653[ebp]
  029c9	c6 45 fc 52	 mov	 BYTE PTR __$EHRec$[ebp+8], 82 ; 00000052H
  029cd	50		 push	 eax
  029ce	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$680[ebp]
  029d4	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  029d9	8b f0		 mov	 esi, eax
  029db	8d 45 bc	 lea	 eax, DWORD PTR _g³os2$683[ebp]
  029de	c6 45 fc 53	 mov	 BYTE PTR __$EHRec$[ebp+8], 83 ; 00000053H
  029e2	50		 push	 eax
  029e3	8d 55 9c	 lea	 edx, DWORD PTR _link$682[ebp]
  029e6	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T654[ebp]
  029ec	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  029f1	56		 push	 esi
  029f2	8b d0		 mov	 edx, eax
  029f4	c6 45 fc 54	 mov	 BYTE PTR __$EHRec$[ebp+8], 84 ; 00000054H
  029f8	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T655[ebp]
  029fe	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02a03	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  02a08	8b d0		 mov	 edx, eax
  02a0a	c6 45 fc 55	 mov	 BYTE PTR __$EHRec$[ebp+8], 85 ; 00000055H
  02a0e	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T656[ebp]
  02a14	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02a19	83 c4 0c	 add	 esp, 12			; 0000000cH
  02a1c	8b cf		 mov	 ecx, edi
  02a1e	8b d0		 mov	 edx, eax
  02a20	6a 00		 push	 0
  02a22	6a 00		 push	 0
  02a24	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  02a29	50		 push	 eax
  02a2a	8b ca		 mov	 ecx, edx
  02a2c	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  02a31	50		 push	 eax
  02a32	6a 00		 push	 0
  02a34	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  02a3a	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T656[ebp]
  02a40	8b f0		 mov	 esi, eax
  02a42	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02a47	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T655[ebp]
  02a4d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02a52	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T654[ebp]
  02a58	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02a5d	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T653[ebp]
  02a63	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02a68	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T652[ebp]
  02a6e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02a73	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T651[ebp]
  02a79	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02a7e	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T650[ebp]
  02a84	c6 45 fc 46	 mov	 BYTE PTR __$EHRec$[ebp+8], 70 ; 00000046H
  02a88	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 993  : 					if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  02a8d	85 f6		 test	 esi, esi
  02a8f	0f 85 1d 02 00
	00		 jne	 $LN4507@Sprawd_P
  02a95	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp___access
$LN87@Sprawd_P:

; 998  : 					}
; 999  : 				}
; 1000 : 			}
; 1001 : 		}

  02a9b	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$680[ebp]
  02aa1	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  02aa5	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  02aaa	8b 75 ec	 mov	 esi, DWORD PTR _i$1$[ebp]
  02aad	46		 inc	 esi
  02aae	89 75 ec	 mov	 DWORD PTR _i$1$[ebp], esi
  02ab1	66 83 fe 24	 cmp	 si, 36			; 00000024H
  02ab5	0f 86 95 fc ff
	ff		 jbe	 $LL12@Sprawd_P

; 1002 : 
; 1003 : 		if ((_access((G³os + "win.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  02abb	68 00 00 00 00	 push	 OFFSET ??_C@_07KIPBKJCE@win?4wav?$AA@
  02ac0	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  02ac5	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T657[ebp]
  02acb	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02ad0	83 c4 04	 add	 esp, 4
  02ad3	8b c8		 mov	 ecx, eax
  02ad5	6a 00		 push	 0
  02ad7	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  02adc	50		 push	 eax
  02add	ff d7		 call	 edi
  02adf	83 c4 08	 add	 esp, 8
  02ae2	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T657[ebp]
  02ae8	8b f0		 mov	 esi, eax
  02aea	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02aef	85 f6		 test	 esi, esi
  02af1	0f 84 ec 01 00
	00		 je	 $LN91@Sprawd_P

; 1004 : 		{
; 1005 : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  02af7	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  02afe	0f 85 92 00 00
	00		 jne	 $LN89@Sprawd_P

; 1006 : 			{
; 1007 : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  02b04	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  02b0a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  02b0f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  02b14	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  02b19	8b c8		 mov	 ecx, eax
  02b1b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1008 : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 1009 : 				Wyci¹gnij_z_Programu((g³os3 + ".rar"), Numer_zasobu_rar.at(g³os3));

  02b21	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  02b26	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  02b29	c6 85 e7 fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  02b30	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T659[ebp]
  02b36	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02b3b	83 c4 04	 add	 esp, 4
  02b3e	8b f0		 mov	 esi, eax
  02b40	8d 45 d4	 lea	 eax, DWORD PTR _g³os3$684[ebp]
  02b43	c6 45 fc 56	 mov	 BYTE PTR __$EHRec$[ebp+8], 86 ; 00000056H
  02b47	50		 push	 eax
  02b48	e8 00 00 00 00	 call	 ?at@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@GU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@std@@@2@@std@@QBEABGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned short,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned short> > >::at
  02b4d	8b ce		 mov	 ecx, esi
  02b4f	66 8b 10	 mov	 dx, WORD PTR [eax]
  02b52	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
  02b57	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T659[ebp]
  02b5d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  02b61	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1010 : 				Wypakuj_Rar(g³os3 + ".rar");

  02b66	68 00 00 00 00	 push	 OFFSET ??_C@_04NCAGELPD@?4rar?$AA@
  02b6b	8d 55 d4	 lea	 edx, DWORD PTR _g³os3$684[ebp]
  02b6e	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T660[ebp]
  02b74	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02b79	83 c4 04	 add	 esp, 4
  02b7c	8b c8		 mov	 ecx, eax
  02b7e	c6 45 fc 57	 mov	 BYTE PTR __$EHRec$[ebp+8], 87 ; 00000057H
  02b82	e8 00 00 00 00	 call	 ?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Wypakuj_Rar
  02b87	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T660[ebp]
  02b8d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  02b91	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN89@Sprawd_P:

; 1011 : 			}
; 1012 : 			if (!Przenie_Plik(g³os2 + "win.wav", G³os + "win.wav"))

  02b96	68 00 00 00 00	 push	 OFFSET ??_C@_07KIPBKJCE@win?4wav?$AA@
  02b9b	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  02ba0	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T661[ebp]
  02ba6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02bab	8b f0		 mov	 esi, eax
  02bad	68 00 00 00 00	 push	 OFFSET ??_C@_07KIPBKJCE@win?4wav?$AA@
  02bb2	8d 55 bc	 lea	 edx, DWORD PTR _g³os2$683[ebp]
  02bb5	c6 45 fc 58	 mov	 BYTE PTR __$EHRec$[ebp+8], 88 ; 00000058H
  02bb9	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T662[ebp]
  02bbf	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02bc4	83 c4 08	 add	 esp, 8
  02bc7	8b d6		 mov	 edx, esi
  02bc9	8b c8		 mov	 ecx, eax
  02bcb	e8 00 00 00 00	 call	 ?Przenie_Plik@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Przenie_Plik
  02bd0	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T662[ebp]
  02bd6	88 85 e6 fe ff
	ff		 mov	 BYTE PTR tv12576[ebp], al
  02bdc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02be1	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T661[ebp]
  02be7	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  02beb	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02bf0	80 bd e6 fe ff
	ff 00		 cmp	 BYTE PTR tv12576[ebp], 0
  02bf7	0f 85 e6 00 00
	00		 jne	 $LN91@Sprawd_P

; 1013 : 			{
; 1014 : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "win.wav").c_str(), (G³os + "win.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  02bfd	68 00 00 00 00	 push	 OFFSET ??_C@_07KIPBKJCE@win?4wav?$AA@
  02c02	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  02c07	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T664[ebp]
  02c0d	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02c12	8b f0		 mov	 esi, eax
  02c14	8d 45 bc	 lea	 eax, DWORD PTR _g³os2$683[ebp]
  02c17	c6 45 fc 59	 mov	 BYTE PTR __$EHRec$[ebp+8], 89 ; 00000059H
  02c1b	50		 push	 eax
  02c1c	8d 55 9c	 lea	 edx, DWORD PTR _link$682[ebp]
  02c1f	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T665[ebp]
  02c25	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02c2a	68 00 00 00 00	 push	 OFFSET ??_C@_07KIPBKJCE@win?4wav?$AA@
  02c2f	8b d0		 mov	 edx, eax
  02c31	c6 45 fc 5a	 mov	 BYTE PTR __$EHRec$[ebp+8], 90 ; 0000005aH
  02c35	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T666[ebp]
  02c3b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02c40	83 c4 0c	 add	 esp, 12			; 0000000cH
  02c43	8b ce		 mov	 ecx, esi
  02c45	8b d0		 mov	 edx, eax
  02c47	6a 00		 push	 0
  02c49	6a 00		 push	 0
  02c4b	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  02c50	50		 push	 eax
  02c51	8b ca		 mov	 ecx, edx
  02c53	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  02c58	50		 push	 eax
  02c59	6a 00		 push	 0
  02c5b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  02c61	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T666[ebp]
  02c67	8b f0		 mov	 esi, eax
  02c69	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02c6e	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T665[ebp]
  02c74	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02c79	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T664[ebp]
  02c7f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  02c83	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1015 : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  02c88	85 f6		 test	 esi, esi
  02c8a	74 57		 je	 SHORT $LN91@Sprawd_P
$LN4540@Sprawd_P:

; 1016 : 				{
; 1017 : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  02c8c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  02c92	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  02c97	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  02c9c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  02ca1	8b c8		 mov	 ecx, eax
  02ca3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1018 : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio

  02ca9	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne

; 1019 : 					return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej

  02cb0	eb 6c		 jmp	 SHORT $LN92@Sprawd_P
$LN4507@Sprawd_P:

; 994  : 					{
; 995  : 						cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  02cb2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  02cb8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  02cbd	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  02cc2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  02cc7	8b c8		 mov	 ecx, eax
  02cc9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 996  : 						G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 997  : 						return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej

  02ccf	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$680[ebp]
  02cd5	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  02cdc	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  02ce1	eb 3b		 jmp	 SHORT $LN92@Sprawd_P
$LN91@Sprawd_P:

; 1020 : 				}
; 1021 : 			}
; 1022 : 		}
; 1023 : 
; 1024 : 		if (czy_pobierano)

  02ce3	80 bd e7 fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  02cea	74 32		 je	 SHORT $LN92@Sprawd_P

; 1025 : 		{
; 1026 : 			cout << endl << "Pobrano brakuj¹ce pliki g³osów" << endl; //Poinformowanie o ukoñczonu pobierania plików

  02cec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  02cf2	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  02cf7	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  02cfc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  02d02	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@
  02d07	8b c8		 mov	 ecx, eax
  02d09	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  02d0e	8b c8		 mov	 ecx, eax
  02d10	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1027 : 			Usuñ_Folder_Wypakowany_i_Winrar(g³os2);

  02d16	8d 4d bc	 lea	 ecx, DWORD PTR _g³os2$683[ebp]
  02d19	e8 00 00 00 00	 call	 ?Usuñ_Folder_Wypakowany_i_Winrar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Usuñ_Folder_Wypakowany_i_Winrar
$LN92@Sprawd_P:

; 1028 : 		}
; 1029 : 	}

  02d1e	8d 4d d4	 lea	 ecx, DWORD PTR _g³os3$684[ebp]
  02d21	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02d26	8d 4d bc	 lea	 ecx, DWORD PTR _g³os2$683[ebp]
  02d29	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02d2e	8d 4d 9c	 lea	 ecx, DWORD PTR _link$682[ebp]
  02d31	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN39@Sprawd_P:

; 1030 : }

  02d36	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02d39	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  02d40	59		 pop	 ecx
  02d41	5f		 pop	 edi
  02d42	5e		 pop	 esi
  02d43	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02d46	33 cd		 xor	 ecx, ebp
  02d48	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02d4d	8b e5		 mov	 esp, ebp
  02d4f	5d		 pop	 ebp
  02d50	c3		 ret	 0
$LN4545@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1611 : 			_Xran();

  02d51	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN4561@Sprawd_P:
$LN4534@Sprawd_P:
  02d56	66 90		 npad	 2
$LN4547@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1030 : }

  02d58	00 00 00 00	 DD	 $LN40@Sprawd_P
  02d5c	00 00 00 00	 DD	 $LN41@Sprawd_P
  02d60	00 00 00 00	 DD	 $LN42@Sprawd_P
  02d64	00 00 00 00	 DD	 $LN43@Sprawd_P
  02d68	00 00 00 00	 DD	 $LN44@Sprawd_P
  02d6c	00 00 00 00	 DD	 $LN45@Sprawd_P
  02d70	00 00 00 00	 DD	 $LN46@Sprawd_P
  02d74	00 00 00 00	 DD	 $LN47@Sprawd_P
  02d78	00 00 00 00	 DD	 $LN48@Sprawd_P
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$4:
  00000	8d 4d 9c	 lea	 ecx, DWORD PTR _link$682[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$5:
  00008	8d 4d bc	 lea	 ecx, DWORD PTR _g³os2$683[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$6:
  00010	8d 4d d4	 lea	 ecx, DWORD PTR _g³os3$684[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$8:
  00018	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T151[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$9:
  00023	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T158[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$10:
  0002e	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T165[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$12:
  00039	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T188[ebp]
  0003f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$13:
  00044	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T190[ebp]
  0004a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$16:
  0004f	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T247[ebp]
  00055	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$17:
  0005a	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T254[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$18:
  00065	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T261[ebp]
  0006b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$20:
  00070	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T278[ebp]
  00076	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$21:
  0007b	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T280[ebp]
  00081	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$24:
  00086	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T295[ebp]
  0008c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$25:
  00091	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T296[ebp]
  00097	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$26:
  0009c	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T297[ebp]
  000a2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$28:
  000a7	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T308[ebp]
  000ad	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$29:
  000b2	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T310[ebp]
  000b8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$32:
  000bd	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T325[ebp]
  000c3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$33:
  000c8	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T326[ebp]
  000ce	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$34:
  000d3	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T327[ebp]
  000d9	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$36:
  000de	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T338[ebp]
  000e4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$37:
  000e9	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T340[ebp]
  000ef	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$40:
  000f4	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T355[ebp]
  000fa	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$41:
  000ff	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T356[ebp]
  00105	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$42:
  0010a	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T357[ebp]
  00110	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$44:
  00115	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T368[ebp]
  0011b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$45:
  00120	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T370[ebp]
  00126	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$48:
  0012b	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T385[ebp]
  00131	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$49:
  00136	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T386[ebp]
  0013c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$50:
  00141	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T387[ebp]
  00147	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$52:
  0014c	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T398[ebp]
  00152	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$53:
  00157	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T400[ebp]
  0015d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$55:
  00162	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T409[ebp]
  00168	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$56:
  0016d	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T419[ebp]
  00173	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$58:
  00178	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T463[ebp]
  0017e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$59:
  00183	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T464[ebp]
  00189	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$60:
  0018e	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T465[ebp]
  00194	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$61:
  00199	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T477[ebp]
  0019f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$62:
  001a4	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T486[ebp]
  001aa	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$64:
  001af	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T530[ebp]
  001b5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$65:
  001ba	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T540[ebp]
  001c0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$66:
  001c5	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T548[ebp]
  001cb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$67:
  001d0	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T550[ebp]
  001d6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$68:
  001db	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T551[ebp]
  001e1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$69:
  001e6	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T561[ebp]
  001ec	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$826:
  001f1	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  001f7	25 00 01 00 00	 and	 eax, 256		; 00000100H
  001fc	0f 84 16 00 00
	00		 je	 $LN3809@Sprawd_P
  00202	81 a5 78 fe ff
	ff ff fe ff ff	 and	 DWORD PTR $T1[ebp], -257 ; fffffeffH
  0020c	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp+104]
  00212	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN3809@Sprawd_P:
  00218	c3		 ret	 0
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$827:
  00219	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp+32]
  0021f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$829:
  00225	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00228	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$71:
  0022e	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$681[ebp]
  00234	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$72:
  00239	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T578[ebp]
  0023f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$73:
  00244	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T579[ebp]
  0024a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$74:
  0024f	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T580[ebp]
  00255	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$76:
  0025a	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T617[ebp]
  00260	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$77:
  00265	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T618[ebp]
  0026b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$78:
  00270	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T619[ebp]
  00276	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$79:
  0027b	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T620[ebp]
  00281	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$80:
  00286	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T621[ebp]
  0028c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$81:
  00291	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T622[ebp]
  00297	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$82:
  0029c	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T623[ebp]
  002a2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$83:
  002a7	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T624[ebp]
  002ad	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$84:
  002b2	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T625[ebp]
  002b8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$86:
  002bd	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T628[ebp]
  002c3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$87:
  002c8	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T629[ebp]
  002ce	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$88:
  002d3	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T630[ebp]
  002d9	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$89:
  002de	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T631[ebp]
  002e4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$90:
  002e9	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T632[ebp]
  002ef	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$91:
  002f4	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T633[ebp]
  002fa	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$92:
  002ff	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T634[ebp]
  00305	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$93:
  0030a	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T635[ebp]
  00310	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$95:
  00315	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$680[ebp]
  0031b	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$96:
  00320	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T637[ebp]
  00326	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$97:
  0032b	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T638[ebp]
  00331	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$99:
  00336	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T641[ebp]
  0033c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$100:
  00341	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T642[ebp]
  00347	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$101:
  0034c	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T643[ebp]
  00352	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$102:
  00357	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T644[ebp]
  0035d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$103:
  00362	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T645[ebp]
  00368	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$104:
  0036d	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T646[ebp]
  00373	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$105:
  00378	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T647[ebp]
  0037e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$107:
  00383	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T650[ebp]
  00389	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$108:
  0038e	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T651[ebp]
  00394	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$109:
  00399	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T652[ebp]
  0039f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$110:
  003a4	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T653[ebp]
  003aa	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$111:
  003af	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T654[ebp]
  003b5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$112:
  003ba	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T655[ebp]
  003c0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$115:
  003c5	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T659[ebp]
  003cb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$116:
  003d0	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T660[ebp]
  003d6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$117:
  003db	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T661[ebp]
  003e1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$119:
  003e6	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T664[ebp]
  003ec	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$120:
  003f1	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T665[ebp]
  003f7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Sprawd_Pliki@@YAXXZ:
  003fc	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00400	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00403	8b 8a e8 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-536]
  00409	33 c8		 xor	 ecx, eax
  0040b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00410	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00413	33 c8		 xor	 ecx, eax
  00415	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Sprawd_Pliki@@YAXXZ
  0041f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Sprawd_Pliki@@YAXXZ ENDP				; Sprawd_Pliki
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Sprawd_Ustawienia@@YAXXZ
_TEXT	SEGMENT
_this$ = -408						; size = 4
$T1 = -404						; size = 4
_ustawienia$13 = -400					; size = 184
_ustawienia$14 = -216					; size = 176
_buf$15 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Sprawd_Ustawienia@@YAXXZ PROC				; Sprawd_Ustawienia, COMDAT

; 1033 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Sprawd_Ustawienia@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1034 : 	if (!_access("setting.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  0002d	6a 00		 push	 0
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COFBHHKL@setting?4txt?$AA@
  00034	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  00044	83 c4 08	 add	 esp, 8
  00047	85 c0		 test	 eax, eax
  00049	0f 85 43 02 00
	00		 jne	 $LN4@Sprawd_U
  0004f	68 b8 00 00 00	 push	 184			; 000000b8H
  00054	50		 push	 eax
  00055	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _ustawienia$13[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _memset
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 771  : 		{	// construct unopened

  00064	c7 85 70 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$13[ebp], OFFSET ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  0006e	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+112]
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  0007a	6a 00		 push	 0
  0007c	6a 00		 push	 0
  0007e	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR _ustawienia$13[ebp+16]
  00084	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008b	50		 push	 eax
  0008c	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp]
  00092	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T1[ebp], 1
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  000a2	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000a9	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$13[ebp]
  000af	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b2	c7 84 05 70 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ustawienia$13[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  000bd	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$13[ebp]
  000c3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c6	8d 41 90	 lea	 eax, DWORD PTR [ecx-112]
  000c9	89 84 0d 6c fe
	ff ff		 mov	 DWORD PTR _ustawienia$13[ebp+ecx-4], eax
  000d0	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR _ustawienia$13[ebp+16]

; 155  : 		: _Mysb()

  000d6	8b c8		 mov	 ecx, eax

; 771  : 		{	// construct unopened

  000d8	89 85 68 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 155  : 		: _Mysb()

  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  000e4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  000e8	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+16]

; 156  : 		{	// construct from pointer to C stream

  000ee	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$13[ebp+16], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 636  : 		_Closef = _Which == _Openfl;

  000f8	c6 85 c8 fe ff
	ff 00		 mov	 BYTE PTR _ustawienia$13[ebp+88], 0

; 637  : 		_Wrotesome = false;

  000ff	c6 85 bd fe ff
	ff 00		 mov	 BYTE PTR _ustawienia$13[ebp+77], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;
; 663  : 		_State = _Stinit;

  0010c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  00111	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _ustawienia$13[ebp+80], eax
  00117	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  0011c	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$13[ebp+92], 0
  00126	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _ustawienia$13[ebp+84], eax

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  0012c	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$13[ebp+72], 0

; 934  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00136	51		 push	 ecx
  00137	6a 01		 push	 1
  00139	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COFBHHKL@setting?4txt?$AA@
  0013e	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1036 : 		ifstream ustawienia; //Utworzenie typu do celu odczytu z pliku

  00144	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 934  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  0014b	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00150	85 c0		 test	 eax, eax

; 935  : 			_Myios::setstate(ios_base::failbit);

  00152	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp]
  00158	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$13[ebp]
  0015e	6a 00		 push	 0
  00160	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00163	75 0c		 jne	 SHORT $LN47@Sprawd_U
  00165	6a 02		 push	 2
  00167	03 c8		 add	 ecx, eax
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 936  : 		else

  0016f	eb 0a		 jmp	 SHORT $LN48@Sprawd_U
$LN47@Sprawd_U:

; 937  : 			_Myios::clear();	// added with C++11

  00171	6a 00		 push	 0
  00173	03 c8		 add	 ecx, eax
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN48@Sprawd_U:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0017b	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  00180	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _buf$15[ebp+16], 0
  00187	89 55 ec	 mov	 DWORD PTR _buf$15[ebp+20], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0018a	c6 45 d8 00	 mov	 BYTE PTR _buf$15[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1038 : 		string buf; //Utworzenie buforu do odczytu z pliku

  0018e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  00192	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _ustawienia$13[ebp]
  00198	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  0019b	f6 84 05 7c fe
	ff ff 01	 test	 BYTE PTR _ustawienia$13[ebp+eax+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1039 : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  001a3	75 43		 jne	 SHORT $LN3@Sprawd_U
$LL2@Sprawd_U:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  001a5	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp]
  001ab	6a 0a		 push	 10			; 0000000aH
  001ad	03 c8		 add	 ecx, eax
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  001b5	0f b6 c0	 movzx	 eax, al
  001b8	8d 55 d8	 lea	 edx, DWORD PTR _buf$15[ebp]
  001bb	50		 push	 eax
  001bc	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp]
  001c2	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  001c7	83 c4 04	 add	 esp, 4
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1042 : 			Ustaw_Ustawienia(buf); //Zamiana wczytanej lini na ustawienie programu

  001ca	8d 4d d8	 lea	 ecx, DWORD PTR _buf$15[ebp]
  001cd	e8 00 00 00 00	 call	 ?Ustaw_Ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ustaw_Ustawienia
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  001d2	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _ustawienia$13[ebp]
  001d8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  001db	f6 84 05 7c fe
	ff ff 01	 test	 BYTE PTR _ustawienia$13[ebp+eax+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1039 : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  001e3	74 c0		 je	 SHORT $LL2@Sprawd_U
  001e5	8b 55 ec	 mov	 edx, DWORD PTR _buf$15[ebp+20]
$LN3@Sprawd_U:

; 1044 : 	}

  001e8	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001ec	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  001ef	72 45		 jb	 SHORT $LN120@Sprawd_U
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001f1	8b 45 d8	 mov	 eax, DWORD PTR _buf$15[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001f4	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001f5	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001f7	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001fd	72 27		 jb	 SHORT $LN123@Sprawd_U

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001ff	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00202	3b f2		 cmp	 esi, edx
  00204	76 1a		 jbe	 SHORT $_Invalid_parameter$183

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00206	8b d6		 mov	 edx, esi
  00208	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0020b	75 13		 jne	 SHORT $_Invalid_parameter$183

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0020d	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00210	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00212	73 0c		 jae	 SHORT $_Invalid_parameter$183

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00214	2b c8		 sub	 ecx, eax
  00216	83 f9 04	 cmp	 ecx, 4
  00219	72 05		 jb	 SHORT $_Invalid_parameter$183

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0021b	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0021e	76 06		 jbe	 SHORT $LN123@Sprawd_U
$_Invalid_parameter$183:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00220	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN182@Sprawd_U:
$LN123@Sprawd_U:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00226	52		 push	 edx
  00227	50		 push	 eax
  00228	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0022d	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _ustawienia$13[ebp]
  00233	83 c4 08	 add	 esp, 8
$LN120@Sprawd_U:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1044 : 	}

  00236	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  0023d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _buf$15[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00244	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _buf$15[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0024b	c6 45 d8 00	 mov	 BYTE PTR _buf$15[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 917  : 		{	// destroy the object

  0024f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00252	c7 84 05 70 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ustawienia$13[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  0025d	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$13[ebp]
  00263	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00266	8d 41 90	 lea	 eax, DWORD PTR [ecx-112]
  00269	89 84 0d 6c fe
	ff ff		 mov	 DWORD PTR _ustawienia$13[ebp+ecx-4], eax

; 918  : 		}

  00270	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+16]
  00276	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0027b	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+24]
  00281	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00287	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+112]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1045 : 	else

  0028d	e9 e6 01 00 00	 jmp	 $LN180@Sprawd_U
$LN4@Sprawd_U:
  00292	68 b0 00 00 00	 push	 176			; 000000b0H
  00297	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _ustawienia$14[ebp]
  0029d	6a 00		 push	 0
  0029f	50		 push	 eax
  002a0	e8 00 00 00 00	 call	 _memset

; 1047 : 		ofstream ustawienia; //Utworzenie typu do celu zapisu do pliku

  002a5	83 c4 08	 add	 esp, 8
  002a8	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  002ae	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  002b3	51		 push	 ecx
  002b4	6a 02		 push	 2
  002b6	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COFBHHKL@setting?4txt?$AA@
  002bb	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp+4]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1047 : 		ofstream ustawienia; //Utworzenie typu do celu zapisu do pliku

  002c1	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  002c8	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  002cd	85 c0		 test	 eax, eax

; 1150 : 			_Myios::setstate(ios_base::failbit);

  002cf	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  002d5	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _ustawienia$14[ebp]
  002db	6a 00		 push	 0
  002dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002e0	75 0c		 jne	 SHORT $LN164@Sprawd_U
  002e2	6a 02		 push	 2
  002e4	03 c8		 add	 ecx, eax
  002e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1151 : 		else

  002ec	eb 0a		 jmp	 SHORT $LN165@Sprawd_U
$LN164@Sprawd_U:

; 1152 : 			_Myios::clear();	// added with C++11

  002ee	6a 00		 push	 0
  002f0	03 c8		 add	 ecx, eax
  002f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN165@Sprawd_U:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1049 : 		ustawienia << "iloæ_minimalna_obrotów_ruletki 2" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych iloæ_minimalna_obrotów_ruletki

  002f8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@
  002fd	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00303	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00308	b2 0a		 mov	 dl, 10			; 0000000aH
  0030a	8b c8		 mov	 ecx, eax
  0030c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1050 : 		ustawienia << "iloæ_max_dodatkowych_obrotów_ruletki 3" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych iloæ_max_dodatkowych_obrotów_ruletki

  00311	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
  00316	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  0031c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00321	b2 0a		 mov	 dl, 10			; 0000000aH
  00323	8b c8		 mov	 ecx, eax
  00325	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1051 : 		ustawienia << "czas_przeskoku_kulki_szybki 50" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czas_przeskoku_kulki_szybki

  0032a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@
  0032f	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00335	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0033a	b2 0a		 mov	 dl, 10			; 0000000aH
  0033c	8b c8		 mov	 ecx, eax
  0033e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1052 : 		ustawienia << "czas_przeskoku_kulki_wolny 75" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czas_przeskoku_kulki_wolny

  00343	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@
  00348	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  0034e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00353	b2 0a		 mov	 dl, 10			; 0000000aH
  00355	8b c8		 mov	 ecx, eax
  00357	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1053 : 		ustawienia << "czas_przerwy_dzwiêku 500" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czas_przerwy_dzwiêku

  0035c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@
  00361	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00367	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0036c	b2 0a		 mov	 dl, 10			; 0000000aH
  0036e	8b c8		 mov	 ecx, eax
  00370	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1054 : 		ustawienia << "styl_liczenia_wygranej 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych styl_liczenia_wygranej

  00375	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@
  0037a	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00380	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00385	b2 0a		 mov	 dl, 10			; 0000000aH
  00387	8b c8		 mov	 ecx, eax
  00389	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1055 : 		ustawienia << "kwota_pocz¹tkowa 1000" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych kwota_pocz¹tkowa

  0038e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@
  00393	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00399	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0039e	b2 0a		 mov	 dl, 10			; 0000000aH
  003a0	8b c8		 mov	 ecx, eax
  003a2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1056 : 		ustawienia << "stan_dwiêków 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych stan_dwiêków

  003a7	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@
  003ac	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  003b2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003b7	b2 0a		 mov	 dl, 10			; 0000000aH
  003b9	8b c8		 mov	 ecx, eax
  003bb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1057 : 		ustawienia << "czy_kontynuowaæ_grê 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czy_kontynuowaæ_grê

  003c0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@
  003c5	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  003cb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003d0	b2 0a		 mov	 dl, 10			; 0000000aH
  003d2	8b c8		 mov	 ecx, eax
  003d4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1058 : 		ustawienia << "g³os_odczytu_numeru 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych g³os_odczytu_numeru

  003d9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@
  003de	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  003e4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003e9	b2 0a		 mov	 dl, 10			; 0000000aH
  003eb	8b c8		 mov	 ecx, eax
  003ed	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1059 : 		ustawienia << "g³os_szybkoæ_odczytu_numeru 4" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych g³os_szybkoæ_odczytu_numeru

  003f2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@
  003f7	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  003fd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00402	b2 0a		 mov	 dl, 10			; 0000000aH
  00404	8b c8		 mov	 ecx, eax
  00406	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1060 : 		ustawienia << "efekty_dwiêkowe 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych efekty_dwiêkowe

  0040b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@
  00410	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00416	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0041b	b2 0a		 mov	 dl, 10			; 0000000aH
  0041d	8b c8		 mov	 ecx, eax
  0041f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1061 : 		ustawienia.flush(); //Zapisanie do pliku setting.txt danych wpisanych do bufora danych

  00424	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  0042a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1062 : 	}

  00430	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1132 : 		{	// destroy the object

  00437	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _ustawienia$14[ebp]
  0043d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00440	c7 84 05 28 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ustawienia$14[ebp+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  0044b	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _ustawienia$14[ebp]
  00451	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00454	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00457	89 84 0d 24 ff
	ff ff		 mov	 DWORD PTR _ustawienia$14[ebp+ecx-4], eax

; 1133 : 		}

  0045e	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp+4]
  00464	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00469	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp+8]
  0046f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00475	8d 4d 90	 lea	 ecx, DWORD PTR _ustawienia$14[ebp+104]
$LN180@Sprawd_U:
  00478	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1064 : 	if (Ustawienia.czas_przeskoku_kulki_wolny < Ustawienia.czas_przeskoku_kulki_szybki) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0047e	66 a1 06 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+6
  00484	66 3b 05 04 00
	00 00		 cmp	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4
  0048b	7d 49		 jge	 SHORT $LN6@Sprawd_U

; 1065 : 	{
; 1066 : 		cout << "Wartoæ wolnego czasu przeskoku kulki musi byæ ni¿sza ni¿ wartoæ szybkiego czasu przeskoku kulki" << endl; //(Wartoci tych zmiennych to czas opónienia wiêc im jest wy¿szy tym d³u¿sza przerwa)

  0048d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00493	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@
  00498	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0049d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004a2	8b c8		 mov	 ecx, eax
  004a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1067 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  004aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004b0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  004b5	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  004ba	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004bf	8b c8		 mov	 ecx, eax
  004c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1068 : 		Ustawienia.czas_przeskoku_kulki_szybki = 50; //Ustawienie wartoci domylnej

  004c7	c7 05 04 00 00
	00 32 00 4b 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+4, 4915250 ; 004b0032H

; 1069 : 		Ustawienia.czas_przeskoku_kulki_wolny = 75; //Ustawienie wartoci domylnej

  004d1	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
$LN6@Sprawd_U:

; 1070 : 	}
; 1071 : 	if (Ustawienia.iloæ_minimalna_obrotów_ruletki < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  004d6	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A
  004dc	be 02 00 00 00	 mov	 esi, 2
  004e1	66 85 c0	 test	 ax, ax
  004e4	79 42		 jns	 SHORT $LN7@Sprawd_U

; 1072 : 	{
; 1073 : 		cout << "Iloæ minimalna obrotów ruletki nie mo¿e byæ mniejsza od 0" << endl;

  004e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004ec	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@
  004f1	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  004f6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004fb	8b c8		 mov	 ecx, eax
  004fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1074 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00503	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00509	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0050e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00513	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00518	8b c8		 mov	 ecx, eax
  0051a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1075 : 		Ustawienia.iloæ_minimalna_obrotów_ruletki = 2; //Ustawienie wartoci domylnej

  00520	8b c6		 mov	 eax, esi
  00522	66 a3 00 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A, ax
$LN7@Sprawd_U:

; 1076 : 	}
; 1077 : 	if (Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00528	66 8b 0d 02 00
	00 00		 mov	 cx, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2
  0052f	bf 03 00 00 00	 mov	 edi, 3
  00534	66 85 c9	 test	 cx, cx
  00537	79 49		 jns	 SHORT $LN8@Sprawd_U

; 1078 : 	{
; 1079 : 		cout << "Iloæ max obrotów ruletki nie mo¿e byæ mniejsza od 0" << endl;

  00539	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0053f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@
  00544	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00549	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0054e	8b c8		 mov	 ecx, eax
  00550	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1080 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00556	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0055c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00561	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00566	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0056b	8b c8		 mov	 ecx, eax
  0056d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1081 : 		Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = 3; //Ustawienie wartoci domylnej

  00573	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A
  00579	8b cf		 mov	 ecx, edi
  0057b	66 89 0d 02 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2, cx
$LN8@Sprawd_U:

; 1082 : 	}
; 1083 : 	if ((Ustawienia.iloæ_minimalna_obrotów_ruletki == 0) && (Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki == 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00582	66 85 c0	 test	 ax, ax
  00585	75 49		 jne	 SHORT $LN9@Sprawd_U
  00587	66 85 c9	 test	 cx, cx
  0058a	75 44		 jne	 SHORT $LN9@Sprawd_U

; 1084 : 	{
; 1085 : 		cout << "Jedna z deklaracji w sprawie obrotów ruletki musi byæ wiêksza od zera" << endl;

  0058c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00592	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@
  00597	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0059c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005a1	8b c8		 mov	 ecx, eax
  005a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1086 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  005a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005af	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  005b4	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  005b9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005be	8b c8		 mov	 ecx, eax
  005c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1087 : 		Ustawienia.iloæ_minimalna_obrotów_ruletki = 2; //Ustawienie wartoci domylnej

  005c6	c7 05 00 00 00
	00 02 00 03 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A, 196610 ; 00030002H
$LN9@Sprawd_U:

; 1088 : 		Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = 3; //Ustawienie wartoci domylnej
; 1089 : 	}
; 1090 : 	if (((Ustawienia.styl_liczenia_wygranej > 1) || (Ustawienia.styl_liczenia_wygranej < 0))) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  005d0	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10
  005d6	be 01 00 00 00	 mov	 esi, 1
  005db	66 3b c6	 cmp	 ax, si
  005de	7f 05		 jg	 SHORT $LN11@Sprawd_U
  005e0	66 85 c0	 test	 ax, ax
  005e3	79 41		 jns	 SHORT $LN10@Sprawd_U
$LN11@Sprawd_U:

; 1091 : 	{
; 1092 : 		cout << "Styl liczeia wygranej przyjmuje wartoci tylko 0 lub 1" << endl;

  005e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005eb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@
  005f0	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  005f5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005fa	8b c8		 mov	 ecx, eax
  005fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1093 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00602	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00608	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0060d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00612	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00617	8b c8		 mov	 ecx, eax
  00619	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1094 : 		Ustawienia.styl_liczenia_wygranej = 1; //Ustawienie wartoci domylnej

  0061f	66 89 35 0a 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, si
$LN10@Sprawd_U:

; 1095 : 	}
; 1096 : 	if (Ustawienia.czas_przerwy_dzwiêku < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00626	66 83 3d 08 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8, 0
  0062e	7d 45		 jge	 SHORT $LN12@Sprawd_U

; 1097 : 	{
; 1098 : 		cout << "Czas przerwy dwiêku nie mo¿e byæ mniejszy od zera" << endl;

  00630	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00636	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@
  0063b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00640	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00645	8b c8		 mov	 ecx, eax
  00647	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1099 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  0064d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00653	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00658	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0065d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00662	8b c8		 mov	 ecx, eax
  00664	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1100 : 		Ustawienia.czas_przerwy_dzwiêku = 500; //Ustawienie wartoci domylnej

  0066a	b8 f4 01 00 00	 mov	 eax, 500		; 000001f4H
  0066f	66 a3 08 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8, ax
$LN12@Sprawd_U:

; 1101 : 	}
; 1102 : 	if (Ustawienia.kwota_pocz¹tkowa < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00675	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, 0
  0067c	7d 44		 jge	 SHORT $LN13@Sprawd_U

; 1103 : 	{
; 1104 : 		cout << "Kwota pocz¹tkowa nie mo¿e byæ mniejsza od zera" << endl;

  0067e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00684	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@
  00689	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0068e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00693	8b c8		 mov	 ecx, eax
  00695	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1105 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  0069b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006a1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  006a6	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  006ab	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  006b0	8b c8		 mov	 ecx, eax
  006b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1106 : 		Ustawienia.kwota_pocz¹tkowa = 1000; //Ustawienie wartoci domylnej

  006b8	c7 05 0c 00 00
	00 e8 03 00 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, 1000 ; 000003e8H
$LN13@Sprawd_U:

; 1107 : 	}
; 1108 : 	if ((Ustawienia.stan_dwiêków > 1) || (Ustawienia.stan_dwiêków < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  006c2	66 a1 10 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16
  006c8	66 83 f8 01	 cmp	 ax, 1
  006cc	7f 05		 jg	 SHORT $LN15@Sprawd_U
  006ce	66 85 c0	 test	 ax, ax
  006d1	79 41		 jns	 SHORT $LN14@Sprawd_U
$LN15@Sprawd_U:

; 1109 : 	{
; 1110 : 		cout << "Stan dwiêków przyjmuje wartoci tylko 0 lub 1" << endl;

  006d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006d9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@
  006de	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  006e3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  006e8	8b c8		 mov	 ecx, eax
  006ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1111 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  006f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006f6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  006fb	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00700	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00705	8b c8		 mov	 ecx, eax
  00707	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1112 : 		Ustawienia.stan_dwiêków = 1; //Ustawienie wartoci domylnej

  0070d	66 89 35 10 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, si
$LN14@Sprawd_U:

; 1113 : 	}
; 1114 : 	if ((Ustawienia.czy_kontynuowaæ_grê > 1) || (Ustawienia.czy_kontynuowaæ_grê < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00714	66 a1 12 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18
  0071a	66 83 f8 01	 cmp	 ax, 1
  0071e	7f 05		 jg	 SHORT $LN17@Sprawd_U
  00720	66 85 c0	 test	 ax, ax
  00723	79 41		 jns	 SHORT $LN16@Sprawd_U
$LN17@Sprawd_U:

; 1115 : 	{
; 1116 : 		cout << "Opcja kontynuowania gry przyjmuje wartoci tylko 0 lub 1" << endl;

  00725	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0072b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@
  00730	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00735	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0073a	8b c8		 mov	 ecx, eax
  0073c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1117 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00742	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00748	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0074d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00752	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00757	8b c8		 mov	 ecx, eax
  00759	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1118 : 		Ustawienia.czy_kontynuowaæ_grê = 1; //Ustawienie wartoci domylnej

  0075f	66 89 35 12 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, si
$LN16@Sprawd_U:

; 1119 : 	}
; 1120 : 	if ((Ustawienia.g³os_odczytu_numeru > 10) || (Ustawienia.g³os_odczytu_numeru < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00766	66 a1 14 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20
  0076c	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00770	7f 05		 jg	 SHORT $LN19@Sprawd_U
  00772	66 85 c0	 test	 ax, ax
  00775	79 41		 jns	 SHORT $LN18@Sprawd_U
$LN19@Sprawd_U:

; 1121 : 	{
; 1122 : 		cout << "Opcja g³os odczytu numeru przyjmuje wartoci w przedziale [0;10]" << endl;

  00777	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0077d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@
  00782	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00787	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0078c	8b c8		 mov	 ecx, eax
  0078e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1123 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00794	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0079a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0079f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  007a4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  007a9	8b c8		 mov	 ecx, eax
  007ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1124 : 		Ustawienia.g³os_odczytu_numeru = 1; //Ustawienie wartoci domylnej

  007b1	66 89 35 14 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, si
$LN18@Sprawd_U:

; 1125 : 	}
; 1126 : 	if ((Ustawienia.g³os_szybkoæ_odczytu_numeru > 5) || (Ustawienia.g³os_szybkoæ_odczytu_numeru < 1)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  007b8	66 a1 16 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22
  007be	66 83 f8 05	 cmp	 ax, 5
  007c2	7f 06		 jg	 SHORT $LN21@Sprawd_U
  007c4	66 83 f8 01	 cmp	 ax, 1
  007c8	7d 45		 jge	 SHORT $LN20@Sprawd_U
$LN21@Sprawd_U:

; 1127 : 	{
; 1128 : 		cout << "Opcja szybkoæ g³osu odczytu przyjmuje wartoci w przedziale [1;5]" << endl;

  007ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007d0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@
  007d5	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  007da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  007df	8b c8		 mov	 ecx, eax
  007e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1129 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  007e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007ed	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  007f2	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  007f7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  007fc	8b c8		 mov	 ecx, eax
  007fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1130 : 		Ustawienia.g³os_szybkoæ_odczytu_numeru = 4; //Ustawienie wartoci domylnej

  00804	b8 04 00 00 00	 mov	 eax, 4
  00809	66 a3 16 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax
$LN20@Sprawd_U:

; 1131 : 	}
; 1132 : 	if ((Ustawienia.efekty_dwiêkowe > 1) || (Ustawienia.efekty_dwiêkowe < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0080f	66 a1 18 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24
  00815	66 83 f8 01	 cmp	 ax, 1
  00819	7f 11		 jg	 SHORT $LN23@Sprawd_U
  0081b	66 85 c0	 test	 ax, ax
  0081e	78 0c		 js	 SHORT $LN23@Sprawd_U

; 1137 : 	}
; 1138 : 	if (Ustawienia.efekty_dwiêkowe == 1 && Ustawienia.stan_dwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00820	66 83 f8 01	 cmp	 ax, 1
  00824	0f 85 8e 00 00
	00		 jne	 $LN24@Sprawd_U
  0082a	eb 41		 jmp	 SHORT $LN177@Sprawd_U
$LN23@Sprawd_U:

; 1133 : 	{
; 1134 : 		cout << "Opcja efekty dwiêkowe przyjmuje wartoci 0 lub 1" << endl;

  0082c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00832	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@
  00837	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0083c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00841	8b c8		 mov	 ecx, eax
  00843	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1135 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00849	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0084f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00854	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00859	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0085e	8b c8		 mov	 ecx, eax
  00860	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1136 : 		Ustawienia.efekty_dwiêkowe = 1; //Ustawienie wartoci domylnej

  00866	66 89 35 18 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, si
$LN177@Sprawd_U:

; 1137 : 	}
; 1138 : 	if (Ustawienia.efekty_dwiêkowe == 1 && Ustawienia.stan_dwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0086d	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  00875	75 41		 jne	 SHORT $LN24@Sprawd_U

; 1139 : 	{
; 1140 : 		cout << "Nie mo¿esz mieæ wy³¹czonych dwiêków i w³¹czonych efektów dwiêkowych" << endl;

  00877	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0087d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
  00882	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00887	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0088c	8b c8		 mov	 ecx, eax
  0088e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1141 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00894	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0089a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0089f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  008a4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  008a9	8b c8		 mov	 ecx, eax
  008ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1142 : 		Ustawienia.stan_dwiêków = 1; //Ustawienie wartoci domylnej

  008b1	66 89 35 10 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, si
$LN24@Sprawd_U:

; 1143 : 	}
; 1144 : 	if (Ustawienia.g³os_odczytu_numeru > 0 && Ustawienia.stan_dwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  008b8	66 83 3d 14 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, 0
  008c0	7e 4b		 jle	 SHORT $LN25@Sprawd_U
  008c2	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  008ca	75 41		 jne	 SHORT $LN25@Sprawd_U

; 1145 : 	{
; 1146 : 		cout << "Nie mo¿esz mieæ wy³¹czonych dwiêków i w³¹czon¹ mowê" << endl;

  008cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008d2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
  008d7	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  008dc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  008e1	8b c8		 mov	 ecx, eax
  008e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1147 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  008e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008ef	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  008f4	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  008f9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  008fe	8b c8		 mov	 ecx, eax
  00900	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1148 : 		Ustawienia.stan_dwiêków = 1; //Ustawienie wartoci domylnej

  00906	66 89 35 10 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, si
$LN25@Sprawd_U:

; 1149 : 	}
; 1150 : }

  0090d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00910	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00917	59		 pop	 ecx
  00918	5f		 pop	 edi
  00919	5e		 pop	 esi
  0091a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0091d	33 cd		 xor	 ecx, ebp
  0091f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00924	8b e5		 mov	 esp, ebp
  00926	5d		 pop	 ebp
  00927	c3		 ret	 0
$LN181@Sprawd_U:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$4:
  00000	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00006	83 e0 01	 and	 eax, 1
  00009	0f 84 13 00 00
	00		 je	 $LN37@Sprawd_U
  0000f	83 a5 6c fe ff
	ff fe		 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00016	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+112]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN37@Sprawd_U:
  00022	c3		 ret	 0
__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$5:
  00023	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+24]
  00029	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$7:
  0002f	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00035	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$0:
  0003b	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp]
  00041	e9 00 00 00 00	 jmp	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$1:
  00046	8d 4d d8	 lea	 ecx, DWORD PTR _buf$15[ebp]
  00049	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Ustawienia@@YAXXZ$2:
  0004e	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00054	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__ehhandler$?Sprawd_Ustawienia@@YAXXZ:
  00059	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00060	8b 8a 68 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-408]
  00066	33 c8		 xor	 ecx, eax
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00070	33 c8		 xor	 ecx, eax
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Sprawd_Ustawienia@@YAXXZ
  0007c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Sprawd_Ustawienia@@YAXXZ ENDP				; Sprawd_Ustawienia
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Og³o_Wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 24
_kwota_zak³adu$1$ = -12					; size = 4
_wygrana$1$ = -8					; size = 4
_iloæ_pieniêdzy$ = 8					; size = 4
_log_ogólny$ = 12					; size = 4
_log$ = 16						; size = 4
?Og³o_Wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z PROC ; Og³o_Wynik, COMDAT
; _wygrana$ = ecx
; _kwota_zak³adu$ = edx

; 1153 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1154 : 	if (wygrana >= kwota_zak³adu) //Je¿eli wygrana jest wiêksza lub równa kwocie zak³adu to znaczy, ¿e siê wygra³o zak³ad

  00008	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000a	57		 push	 edi
  0000b	8b 3a		 mov	 edi, DWORD PTR [edx]
  0000d	89 55 f4	 mov	 DWORD PTR _kwota_zak³adu$1$[ebp], edx
  00010	89 4d f8	 mov	 DWORD PTR _wygrana$1$[ebp], ecx
  00013	3b f7		 cmp	 esi, edi
  00015	0f 8c be 01 00
	00		 jl	 $LN2@Og?

; 1155 : 	{
; 1156 : 		iloæ_pieniêdzy += wygrana; //Dopisanie do salda kwoty wygranej z zak³adu

  0001b	8b 5d 08	 mov	 ebx, DWORD PTR _iloæ_pieniêdzy$[ebp]
  0001e	03 33		 add	 esi, DWORD PTR [ebx]
  00020	89 33		 mov	 DWORD PTR [ebx], esi

; 1157 : 		if (Ustawienia.styl_liczenia_wygranej) iloæ_pieniêdzy += kwota_zak³adu; //Dopisanie do salda kwoty zak³adu

  00022	66 83 3d 0a 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, 0
  0002a	74 06		 je	 SHORT $LN4@Og?
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	03 c6		 add	 eax, esi
  00030	89 03		 mov	 DWORD PTR [ebx], eax
$LN4@Og?:

; 1158 : 		log << " Wygrywasz " << wygrana << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie wygranej zak³adu

  00032	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  00035	33 d2		 xor	 edx, edx
  00037	ff 31		 push	 DWORD PTR [ecx]
  00039	85 c0		 test	 eax, eax
  0003b	51		 push	 ecx
  0003c	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0003f	8b f7		 mov	 esi, edi
  00041	0f 44 f2	 cmove	 esi, edx
  00044	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00050	83 c4 04	 add	 esp, 4
  00053	8b c8		 mov	 ecx, eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0005b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00060	8b c8		 mov	 ecx, eax
  00062	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1159 : 		log << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  00067	ff 33		 push	 DWORD PTR [ebx]
  00069	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  0006e	51		 push	 ecx
  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00076	83 c4 04	 add	 esp, 4
  00079	8b c8		 mov	 ecx, eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00081	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00086	8b c8		 mov	 ecx, eax
  00088	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0008d	b2 0a		 mov	 dl, 10			; 0000000aH
  0008f	8b c8		 mov	 ecx, eax
  00091	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1160 : 		log_ogólny << " Wygrywasz " << wygrana << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie wygranej zak³adu

  00096	8b 45 f8	 mov	 eax, DWORD PTR _wygrana$1$[ebp]
  00099	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
  0009e	8b 75 0c	 mov	 esi, DWORD PTR _log_ogólny$[ebp]
  000a1	ff 30		 push	 DWORD PTR [eax]
  000a3	51		 push	 ecx
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000ab	83 c4 04	 add	 esp, 4
  000ae	8b c8		 mov	 ecx, eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000b6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000bb	8b c8		 mov	 ecx, eax
  000bd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1161 : 		log_ogólny << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  000c2	ff 33		 push	 DWORD PTR [ebx]
  000c4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  000c9	51		 push	 ecx
  000ca	8b ce		 mov	 ecx, esi
  000cc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000d1	83 c4 04	 add	 esp, 4
  000d4	8b c8		 mov	 ecx, eax
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000dc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000e1	8b c8		 mov	 ecx, eax
  000e3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000e8	b2 0a		 mov	 dl, 10			; 0000000aH
  000ea	8b c8		 mov	 ecx, eax
  000ec	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1162 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  000f1	8b cf		 mov	 ecx, edi
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1163 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000f9	8b ce		 mov	 ecx, esi
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1164 : 		if (Ustawienia.stan_dwiêków) //Je¿eli stan_dwiêków == 1

  00101	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  00109	0f 84 f0 02 00
	00		 je	 $LN14@Og?

; 1165 : 		{
; 1166 : 			if (G³osyKompletne) //Je¿eli s¹ wszystkie pliki g³osów to

  0010f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  00116	74 79		 je	 SHORT $LN6@Og?

; 1168 : 				PlaySound((G³os + "win.wav").c_str(), nullptr, SND_SYNC); //Odtworzenie efektu wygrania zak³adu

  00118	68 00 00 00 00	 push	 OFFSET ??_C@_07KIPBKJCE@win?4wav?$AA@
  0011d	ba 00 00 00 00	 mov	 edx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00122	8d 4d dc	 lea	 ecx, DWORD PTR $T1[ebp]
  00125	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0012a	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0012d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00131	72 02		 jb	 SHORT $LN39@Og?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00133	8b 00		 mov	 eax, DWORD PTR [eax]
$LN39@Og?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1168 : 				PlaySound((G³os + "win.wav").c_str(), nullptr, SND_SYNC); //Odtworzenie efektu wygrania zak³adu

  00135	6a 00		 push	 0
  00137	6a 00		 push	 0
  00139	50		 push	 eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PlaySoundA@12
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00140	8b 55 f0	 mov	 edx, DWORD PTR $T1[ebp+20]
  00143	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00146	0f 82 b3 02 00
	00		 jb	 $LN14@Og?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0014c	8b 4d dc	 mov	 ecx, DWORD PTR $T1[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0014f	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00150	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00152	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00158	72 26		 jb	 SHORT $LN86@Og?

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0015a	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  0015d	3b f2		 cmp	 esi, edx
  0015f	76 19		 jbe	 SHORT $_Invalid_parameter$121

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00161	8b d6		 mov	 edx, esi
  00163	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00165	75 13		 jne	 SHORT $_Invalid_parameter$121

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00167	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0016a	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0016c	73 0c		 jae	 SHORT $_Invalid_parameter$121

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0016e	2b c1		 sub	 eax, ecx
  00170	83 f8 04	 cmp	 eax, 4
  00173	72 05		 jb	 SHORT $_Invalid_parameter$121

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00175	83 f8 23	 cmp	 eax, 35			; 00000023H
  00178	76 06		 jbe	 SHORT $LN86@Og?
$_Invalid_parameter$121:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN120@Og?:
$LN86@Og?:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00180	52		 push	 edx
  00181	51		 push	 ecx
  00182	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00187	83 c4 08	 add	 esp, 8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1208 : }

  0018a	5f		 pop	 edi
  0018b	5e		 pop	 esi
  0018c	5b		 pop	 ebx
  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
$LN6@Og?:

; 1169 : 			}
; 1170 : 			else
; 1171 : 			{
; 1172 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku

  00191	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00197	b2 07		 mov	 dl, 7
  00199	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1173 : 				Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  0019e	0f bf 05 08 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8
  001a5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__Sleep@4
  001ab	50		 push	 eax
  001ac	ff d6		 call	 esi

; 1174 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku

  001ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001b4	b2 07		 mov	 dl, 7
  001b6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1175 : 				Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  001bb	0f bf 05 08 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8
  001c2	50		 push	 eax
  001c3	ff d6		 call	 esi

; 1206 : 			if (!G³osyKompletne) cout << '\a';  //Je¿eli nie ma wszystkich plików g³osów to wywo³anie pikniêcia w g³oniku

  001c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001cb	b2 07		 mov	 dl, 7
  001cd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1208 : }

  001d2	5f		 pop	 edi
  001d3	5e		 pop	 esi
  001d4	5b		 pop	 ebx
  001d5	8b e5		 mov	 esp, ebp
  001d7	5d		 pop	 ebp
  001d8	c3		 ret	 0
$LN2@Og?:

; 1176 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku
; 1177 : 			}
; 1178 : 		}
; 1179 : 	}
; 1180 : 	else if (wygrana == (kwota_zak³adu / 2)) //Je¿eli wygrana jest równa po³owie kwocie zak³adu to znaczy, ¿e dostaje siê zwrot po³owy kwoty zak³adu

  001d9	8b c7		 mov	 eax, edi
  001db	99		 cdq
  001dc	2b c2		 sub	 eax, edx
  001de	d1 f8		 sar	 eax, 1
  001e0	3b f0		 cmp	 esi, eax
  001e2	0f 85 1e 01 00
	00		 jne	 $LN8@Og?

; 1181 : 	{
; 1182 : 		iloæ_pieniêdzy += wygrana; //Dopisanie do salda kwoty zwrotu z zak³adu
; 1183 : 		log << " Dostajesz polowe zak³adu " << wygrana << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie zwrotu zak³adu

  001e8	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  001eb	33 d2		 xor	 edx, edx
  001ed	8b 7d 08	 mov	 edi, DWORD PTR _iloæ_pieniêdzy$[ebp]
  001f0	8d 58 10	 lea	 ebx, DWORD PTR [eax+16]
  001f3	01 37		 add	 DWORD PTR [edi], esi
  001f5	85 c0		 test	 eax, eax
  001f7	ff 31		 push	 DWORD PTR [ecx]
  001f9	8b f3		 mov	 esi, ebx
  001fb	0f 44 f2	 cmove	 esi, edx
  001fe	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
  00203	51		 push	 ecx
  00204	8b ce		 mov	 ecx, esi
  00206	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0020b	83 c4 04	 add	 esp, 4
  0020e	8b c8		 mov	 ecx, eax
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00216	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0021b	8b c8		 mov	 ecx, eax
  0021d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1184 : 		log << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  00222	ff 37		 push	 DWORD PTR [edi]
  00224	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00229	51		 push	 ecx
  0022a	8b ce		 mov	 ecx, esi
  0022c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00231	83 c4 04	 add	 esp, 4
  00234	8b c8		 mov	 ecx, eax
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0023c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00241	8b c8		 mov	 ecx, eax
  00243	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00248	b2 0a		 mov	 dl, 10			; 0000000aH
  0024a	8b c8		 mov	 ecx, eax
  0024c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1185 : 		log_ogólny << " Dostajesz polowe zak³adu " << wygrana << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie zwrotu zak³adu

  00251	8b 45 f8	 mov	 eax, DWORD PTR _wygrana$1$[ebp]
  00254	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
  00259	8b 75 0c	 mov	 esi, DWORD PTR _log_ogólny$[ebp]
  0025c	ff 30		 push	 DWORD PTR [eax]
  0025e	51		 push	 ecx
  0025f	8b ce		 mov	 ecx, esi
  00261	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00266	83 c4 04	 add	 esp, 4
  00269	8b c8		 mov	 ecx, eax
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00271	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00276	8b c8		 mov	 ecx, eax
  00278	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1186 : 		log_ogólny << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  0027d	ff 37		 push	 DWORD PTR [edi]
  0027f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00284	51		 push	 ecx
  00285	8b ce		 mov	 ecx, esi
  00287	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0028c	83 c4 04	 add	 esp, 4
  0028f	8b c8		 mov	 ecx, eax
  00291	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00297	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0029c	8b c8		 mov	 ecx, eax
  0029e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002a3	b2 0a		 mov	 dl, 10			; 0000000aH
  002a5	8b c8		 mov	 ecx, eax
  002a7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1187 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  002ac	8b cb		 mov	 ecx, ebx
  002ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1188 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  002b4	8b ce		 mov	 ecx, esi
  002b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1189 : 		if (Ustawienia.stan_dwiêków) //Je¿eli stan_dwiêków == 1

  002bc	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  002c4	0f 84 35 01 00
	00		 je	 $LN14@Og?

; 1190 : 			if (!G³osyKompletne) //Je¿eli nie ma wszystkich plików g³osów to

  002ca	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  002d1	0f 85 28 01 00
	00		 jne	 $LN14@Og?

; 1191 : 			{
; 1192 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku

  002d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002dd	b2 07		 mov	 dl, 7
  002df	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1193 : 				Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  002e4	0f bf 05 08 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8
  002eb	50		 push	 eax
  002ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 1206 : 			if (!G³osyKompletne) cout << '\a';  //Je¿eli nie ma wszystkich plików g³osów to wywo³anie pikniêcia w g³oniku

  002f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002f8	b2 07		 mov	 dl, 7
  002fa	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1208 : }

  002ff	5f		 pop	 edi
  00300	5e		 pop	 esi
  00301	5b		 pop	 ebx
  00302	8b e5		 mov	 esp, ebp
  00304	5d		 pop	 ebp
  00305	c3		 ret	 0
$LN8@Og?:

; 1194 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku
; 1195 : 			}
; 1196 : 	}
; 1197 : 	else if (wygrana == 0) //Je¿eli wygrana jest równa 0 to znaczy, ¿e siê zak³ad przegra³o

  00306	85 f6		 test	 esi, esi
  00308	0f 85 f1 00 00
	00		 jne	 $LN14@Og?

; 1198 : 	{
; 1199 : 		log << " Przegrales " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o przegranej kwocie

  0030e	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  00311	33 c9		 xor	 ecx, ecx
  00313	85 c0		 test	 eax, eax
  00315	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
  0031a	57		 push	 edi
  0031b	51		 push	 ecx
  0031c	8d 58 10	 lea	 ebx, DWORD PTR [eax+16]
  0031f	8b f3		 mov	 esi, ebx
  00321	0f 44 f1	 cmove	 esi, ecx
  00324	8b ce		 mov	 ecx, esi
  00326	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0032b	83 c4 04	 add	 esp, 4
  0032e	8b c8		 mov	 ecx, eax
  00330	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00336	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0033b	8b c8		 mov	 ecx, eax
  0033d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1200 : 		log << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  00342	8b 7d 08	 mov	 edi, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00345	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  0034a	ff 37		 push	 DWORD PTR [edi]
  0034c	51		 push	 ecx
  0034d	8b ce		 mov	 ecx, esi
  0034f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00354	83 c4 04	 add	 esp, 4
  00357	8b c8		 mov	 ecx, eax
  00359	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0035f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00364	8b c8		 mov	 ecx, eax
  00366	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0036b	b2 0a		 mov	 dl, 10			; 0000000aH
  0036d	8b c8		 mov	 ecx, eax
  0036f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1201 : 		log_ogólny << " Przegrales " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o przegranej kwocie

  00374	8b 45 f4	 mov	 eax, DWORD PTR _kwota_zak³adu$1$[ebp]
  00377	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
  0037c	8b 75 0c	 mov	 esi, DWORD PTR _log_ogólny$[ebp]
  0037f	ff 30		 push	 DWORD PTR [eax]
  00381	51		 push	 ecx
  00382	8b ce		 mov	 ecx, esi
  00384	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00389	83 c4 04	 add	 esp, 4
  0038c	8b c8		 mov	 ecx, eax
  0038e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00394	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00399	8b c8		 mov	 ecx, eax
  0039b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1202 : 		log_ogólny << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  003a0	ff 37		 push	 DWORD PTR [edi]
  003a2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  003a7	51		 push	 ecx
  003a8	8b ce		 mov	 ecx, esi
  003aa	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003af	83 c4 04	 add	 esp, 4
  003b2	8b c8		 mov	 ecx, eax
  003b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  003ba	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  003bf	8b c8		 mov	 ecx, eax
  003c1	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003c6	b2 0a		 mov	 dl, 10			; 0000000aH
  003c8	8b c8		 mov	 ecx, eax
  003ca	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1203 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  003cf	8b cb		 mov	 ecx, ebx
  003d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1204 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  003d7	8b ce		 mov	 ecx, esi
  003d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1205 : 		if (Ustawienia.stan_dwiêków)

  003df	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  003e7	74 16		 je	 SHORT $LN14@Og?

; 1206 : 			if (!G³osyKompletne) cout << '\a';  //Je¿eli nie ma wszystkich plików g³osów to wywo³anie pikniêcia w g³oniku

  003e9	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  003f0	75 0d		 jne	 SHORT $LN14@Og?
  003f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  003f8	b2 07		 mov	 dl, 7
  003fa	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
$LN14@Og?:

; 1208 : }

  003ff	5f		 pop	 edi
  00400	5e		 pop	 esi
  00401	5b		 pop	 ebx
  00402	8b e5		 mov	 esp, ebp
  00404	5d		 pop	 ebp
  00405	c3		 ret	 0
$LN119@Og?:
?Og³o_Wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ENDP ; Og³o_Wynik
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Koniec_Gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z
_TEXT	SEGMENT
_iloæ_pieniêdzy$ = 8					; size = 4
?Koniec_Gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z PROC ; Koniec_Gry, COMDAT
; _log_ogólny$ = ecx
; _log$ = edx

; 1211 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx

; 1212 : 	cout << endl << "Koñczysz grê z wynikiem " << iloæ_pieniêdzy << "$" << endl; //Poinformowanie u¿ytkownika o saldzie konta

  00007	8b 45 08	 mov	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00012	ff 30		 push	 DWORD PTR [eax]
  00014	8b f9		 mov	 edi, ecx
  00016	8b da		 mov	 ebx, edx
  00018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0001e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00029	51		 push	 ecx
  0002a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  0002f	8b c8		 mov	 ecx, eax
  00031	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00036	83 c4 04	 add	 esp, 4
  00039	8b c8		 mov	 ecx, eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00041	51		 push	 ecx
  00042	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00047	8b c8		 mov	 ecx, eax
  00049	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0004e	83 c4 04	 add	 esp, 4
  00051	8b c8		 mov	 ecx, eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1213 : 	log << '\n' << "Koñczysz grê z wynikiem " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  00059	8b 45 08	 mov	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  0005c	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  0005f	b2 0a		 mov	 dl, 10			; 0000000aH
  00061	ff 30		 push	 DWORD PTR [eax]
  00063	33 c0		 xor	 eax, eax
  00065	85 db		 test	 ebx, ebx
  00067	0f 44 c8	 cmove	 ecx, eax
  0006a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
  0006f	51		 push	 ecx
  00070	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  00075	8b c8		 mov	 ecx, eax
  00077	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0007c	83 c4 04	 add	 esp, 4
  0007f	8b c8		 mov	 ecx, eax
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00087	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0008c	8b c8		 mov	 ecx, eax
  0008e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00093	b2 0a		 mov	 dl, 10			; 0000000aH
  00095	8b c8		 mov	 ecx, eax
  00097	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1214 : 	log_ogólny << "Koñczysz grê z wynikiem " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  0009c	8b 45 08	 mov	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  0009f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  000a4	ff 30		 push	 DWORD PTR [eax]
  000a6	51		 push	 ecx
  000a7	8b cf		 mov	 ecx, edi
  000a9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000ae	83 c4 04	 add	 esp, 4
  000b1	8b c8		 mov	 ecx, eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000b9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000be	8b c8		 mov	 ecx, eax
  000c0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000c5	b2 0a		 mov	 dl, 10			; 0000000aH
  000c7	8b c8		 mov	 ecx, eax
  000c9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1215 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  000ce	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1216 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000d7	8b cf		 mov	 ecx, edi
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1217 : 	log.close(); //Zamkniêcie pliku log aktualny

  000df	8b cb		 mov	 ecx, ebx
  000e1	e8 00 00 00 00	 call	 ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::close

; 1218 : 	remove("log_aktualny.txt"); //Usuniêcie pliku log aktualny poniewa¿ skoñczy³o siê grê

  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__remove

; 1219 : 
; 1220 : 	if (Ustawienia.stan_dwiêków == 1) //Je¿eli stan_dwiêków == 1

  000f1	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__PlaySoundA@12
  000f7	83 c4 04	 add	 esp, 4
  000fa	66 83 3d 10 00
	00 00 01	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 1

; 1221 : 		if (iloæ_pieniêdzy == 0) //Je¿eli bud¿et jest równy 0 to

  00102	8b 75 08	 mov	 esi, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00105	75 48		 jne	 SHORT $LN3@Koniec_Gry
  00107	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0010a	75 43		 jne	 SHORT $LN3@Koniec_Gry

; 1222 : 			if (EfektyKompletne) PlaySound("Efekty_dwiêkowe/bankrut.wav", nullptr, SND_SYNC); //Je¿eli pliki efektów s¹ dostêpne, odtworzenie efektu bankruta

  0010c	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  00113	74 0d		 je	 SHORT $LN7@Koniec_Gry
  00115	6a 00		 push	 0
  00117	6a 00		 push	 0
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  0011e	ff d3		 call	 ebx

; 1223 : 			else //W przeciwym wypadku

  00120	eb 2d		 jmp	 SHORT $LN3@Koniec_Gry
$LN7@Koniec_Gry:

; 1224 : 				for (unsigned short i = 0; i < 5; ++i) //Rozpoczêcie pêtli która wykona 5 obrotów

  00122	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Sleep@4
  00128	be 05 00 00 00	 mov	 esi, 5
  0012d	0f 1f 00	 npad	 3
$LL4@Koniec_Gry:

; 1225 : 				{
; 1226 : 					cout << '\a'; //Wywo³anie pikniêcia w g³oniku

  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00136	b2 07		 mov	 dl, 7
  00138	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1227 : 					Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem //Przerwa przed kolejnym pikniêciem

  0013d	0f bf 05 08 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8
  00144	50		 push	 eax
  00145	ff d7		 call	 edi
  00147	83 ee 01	 sub	 esi, 1
  0014a	75 e4		 jne	 SHORT $LL4@Koniec_Gry

; 1219 : 
; 1220 : 	if (Ustawienia.stan_dwiêków == 1) //Je¿eli stan_dwiêków == 1

  0014c	8b 75 08	 mov	 esi, DWORD PTR _iloæ_pieniêdzy$[ebp]
$LN3@Koniec_Gry:

; 1228 : 				}
; 1229 : 
; 1230 : 	if (iloæ_pieniêdzy > Ustawienia.kwota_pocz¹tkowa && iloæ_pieniêdzy < Ustawienia.kwota_pocz¹tkowa * 2) //Sprawdzenie czy zwiêkszy³o siê bud¿et

  0014f	8b 16		 mov	 edx, DWORD PTR [esi]
  00151	8b 35 0c 00 00
	00		 mov	 esi, DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12
  00157	3b d6		 cmp	 edx, esi
  00159	7e 49		 jle	 SHORT $LN9@Koniec_Gry
  0015b	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  0015e	3b d0		 cmp	 edx, eax
  00160	7d 42		 jge	 SHORT $LN9@Koniec_Gry

; 1231 : 	{
; 1232 : 		cout << "Gratuluje zwiêkszy³e swój zasób finansowy" << endl; //Wywietlenie gratulacji z powodu zwiêkszenia bud¿etu

  00162	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00167	51		 push	 ecx
  00168	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@
  00173	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00178	83 c4 04	 add	 esp, 4
  0017b	8b c8		 mov	 ecx, eax
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1233 : 		if (EfektyKompletne) //Je¿eli pliki efektów s¹ dostêpne

  00183	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  0018a	74 72		 je	 SHORT $LN15@Koniec_Gry

; 1234 : 			if (rand() % 1) PlaySound("Efekty_dwiêkowe/wygrana1.wav", nullptr, SND_SYNC); //Wylosowanie numeru otworzonego efektu, odtworzenie je¿eli wylosowano efekt 0

  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand

; 1235 : 			else PlaySound("Efekty_dwiêkowe/wygrana2.wav", nullptr, SND_SYNC); //Odtworzenie je¿eli wylosowano efekt 1

  00192	6a 00		 push	 0
  00194	6a 00		 push	 0
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@

; 1240 : 		if (EfektyKompletne) PlaySound("Efekty_dwiêkowe/zwielokrotnenie.wav", nullptr, SND_SYNC); //Odtworzenie efektu dwiêkowego wzamian za zwielokrotnienie bud¿etu, je¿eli pliki efektów s¹ dostêpne

  0019b	ff d3		 call	 ebx

; 1241 : 	}
; 1242 : }

  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	5b		 pop	 ebx
  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c3		 ret	 0
$LN9@Koniec_Gry:

; 1236 : 	}
; 1237 : 	else if (iloæ_pieniêdzy >= Ustawienia.kwota_pocz¹tkowa * 2) //Sprawdzenie czy zwielokrotniono przynajmniej 2 razy bud¿et

  001a4	8d 0c 36	 lea	 ecx, DWORD PTR [esi+esi]
  001a7	3b d1		 cmp	 edx, ecx
  001a9	7c 53		 jl	 SHORT $LN15@Koniec_Gry

; 1238 : 	{
; 1239 : 		cout << "Gratuluje zwiêkszy³e " << iloæ_pieniêdzy / Ustawienia.kwota_pocz¹tkowa << " krotnie swój zasób finansowy" << endl; //Wywietlenie gratulacji z powodu zwielokrotnienia przynajmniej 2 razy bud¿etu

  001ab	8b c2		 mov	 eax, edx
  001ad	99		 cdq
  001ae	f7 fe		 idiv	 esi
  001b0	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001b5	50		 push	 eax
  001b6	51		 push	 ecx
  001b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001bd	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@
  001c2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001c7	83 c4 04	 add	 esp, 4
  001ca	8b c8		 mov	 ecx, eax
  001cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  001d2	51		 push	 ecx
  001d3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@
  001d8	8b c8		 mov	 ecx, eax
  001da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001df	83 c4 04	 add	 esp, 4
  001e2	8b c8		 mov	 ecx, eax
  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1240 : 		if (EfektyKompletne) PlaySound("Efekty_dwiêkowe/zwielokrotnenie.wav", nullptr, SND_SYNC); //Odtworzenie efektu dwiêkowego wzamian za zwielokrotnienie bud¿etu, je¿eli pliki efektów s¹ dostêpne

  001ea	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  001f1	74 0b		 je	 SHORT $LN15@Koniec_Gry
  001f3	6a 00		 push	 0
  001f5	6a 00		 push	 0
  001f7	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  001fc	ff d3		 call	 ebx
$LN15@Koniec_Gry:

; 1241 : 	}
; 1242 : }

  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
  00200	5b		 pop	 ebx
  00201	8b e5		 mov	 esp, ebp
  00203	5d		 pop	 ebp
  00204	c3		 ret	 0
?Koniec_Gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z ENDP ; Koniec_Gry
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Pêtla_G³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
$T43 = -36						; size = 4
_kwota_zak³adu$1$ = -32					; size = 4
_wygrana$1$ = -28					; size = 4
$T1 = -24						; size = 24
_iloæ_pieniêdzy$ = 8					; size = 4
_log_ogólny$ = 12					; size = 4
_log$ = 16						; size = 4
_co_kontynuowaæ$ = 20					; size = 4
_typ_zak³adu$ = 24					; size = 4
_wylosowana_liczba$ = 28				; size = 4
?Pêtla_G³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; Pêtla_G³ówna, COMDAT
; _wygrana$ = ecx
; _kwota_zak³adu$ = edx

; 1245 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 24	 sub	 esp, 36			; 00000024H

; 1246 : 	if (co_kontynuowaæ == 'n') Wczytaj_Kwotê_Zak³adu(kwota_zak³adu, iloæ_pieniêdzy); //Przypisanie do zmiennej pobranej od u¿ytkownika kwoty zak³adu

  00009	8b 45 08	 mov	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b 75 14	 mov	 esi, DWORD PTR _co_kontynuowaæ$[ebp]
  00011	8b da		 mov	 ebx, edx
  00013	57		 push	 edi
  00014	89 5c 24 10	 mov	 DWORD PTR _kwota_zak³adu$1$[esp+48], ebx
  00018	89 4c 24 14	 mov	 DWORD PTR _wygrana$1$[esp+48], ecx
  0001c	80 3e 6e	 cmp	 BYTE PTR [esi], 110	; 0000006eH
  0001f	75 0b		 jne	 SHORT $LN2@P?
  00021	8b d0		 mov	 edx, eax
  00023	8b cb		 mov	 ecx, ebx
  00025	e8 00 00 00 00	 call	 ?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z ; Wczytaj_Kwotê_Zak³adu

; 1247 : 	else

  0002a	eb 76		 jmp	 SHORT $LN3@P?
$LN2@P?:

; 1248 : 	{
; 1249 : 		cout << "Masz " << iloæ_pieniêdzy << "$" << endl; //Wypisanie wczytanej informacji o posiadanej iloci pieniêdzy

  0002c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00031	ff 30		 push	 DWORD PTR [eax]
  00033	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05OMMBNPEF@Masz?5?$AA@
  00038	51		 push	 ecx
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0003f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00044	83 c4 04	 add	 esp, 4
  00047	8b c8		 mov	 ecx, eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0004f	51		 push	 ecx
  00050	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00055	8b c8		 mov	 ecx, eax
  00057	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0005c	83 c4 04	 add	 esp, 4
  0005f	8b c8		 mov	 ecx, eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1250 : 		cout << "Obstawiono za " << kwota_zak³adu << "$" << endl; //Wypisanie wczytanej kwoty zak³adu

  00067	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0006c	ff 33		 push	 DWORD PTR [ebx]
  0006e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  00073	51		 push	 ecx
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0007a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0007f	83 c4 04	 add	 esp, 4
  00082	8b c8		 mov	 ecx, eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0008a	51		 push	 ecx
  0008b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00090	8b c8		 mov	 ecx, eax
  00092	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00097	83 c4 04	 add	 esp, 4
  0009a	8b c8		 mov	 ecx, eax
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN3@P?:

; 1251 : 	}
; 1252 : 	if (co_kontynuowaæ == 'n') log << "Obstawiono za " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie obstawionego zak³adu

  000a2	8b 55 10	 mov	 edx, DWORD PTR _log$[ebp]
  000a5	8a 06		 mov	 al, BYTE PTR [esi]
  000a7	8d 7a 10	 lea	 edi, DWORD PTR [edx+16]
  000aa	89 7c 24 0c	 mov	 DWORD PTR $T43[esp+48], edi
  000ae	3c 6e		 cmp	 al, 110			; 0000006eH
  000b0	75 31		 jne	 SHORT $LN266@P?
  000b2	ff 33		 push	 DWORD PTR [ebx]
  000b4	33 c0		 xor	 eax, eax
  000b6	8b cf		 mov	 ecx, edi
  000b8	85 d2		 test	 edx, edx
  000ba	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  000bf	0f 44 c8	 cmove	 ecx, eax
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000c8	83 c4 04	 add	 esp, 4
  000cb	8b c8		 mov	 ecx, eax
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000d3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000d8	8b c8		 mov	 ecx, eax
  000da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000df	8a 06		 mov	 al, BYTE PTR [esi]
  000e1	eb 04		 jmp	 SHORT $LN4@P?
$LN266@P?:
  000e3	89 7c 24 0c	 mov	 DWORD PTR $T43[esp+48], edi
$LN4@P?:

; 1253 : 	if (co_kontynuowaæ == 'n') log_ogólny << "Obstawiono za " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie obstawionego zak³adu

  000e7	8b 5d 0c	 mov	 ebx, DWORD PTR _log_ogólny$[ebp]
  000ea	3c 6e		 cmp	 al, 110			; 0000006eH
  000ec	75 2e		 jne	 SHORT $LN5@P?
  000ee	8b 44 24 10	 mov	 eax, DWORD PTR _kwota_zak³adu$1$[esp+48]
  000f2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  000f7	ff 30		 push	 DWORD PTR [eax]
  000f9	51		 push	 ecx
  000fa	8b cb		 mov	 ecx, ebx
  000fc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00101	83 c4 04	 add	 esp, 4
  00104	8b c8		 mov	 ecx, eax
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0010c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00111	8b c8		 mov	 ecx, eax
  00113	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00118	89 7c 24 0c	 mov	 DWORD PTR $T43[esp+48], edi
$LN5@P?:

; 1254 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0011c	8b cf		 mov	 ecx, edi
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1255 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00124	8b cb		 mov	 ecx, ebx
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1256 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  0012c	8a 06		 mov	 al, BYTE PTR [esi]
  0012e	3c 6e		 cmp	 al, 110			; 0000006eH
  00130	74 41		 je	 SHORT $LN8@P?
  00132	3c 6b		 cmp	 al, 107			; 0000006bH
  00134	74 3d		 je	 SHORT $LN8@P?

; 1257 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  00136	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0013c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@
  00141	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3047 : 		return (this->_Get_data()._Mysize);

  00146	8b 5d 18	 mov	 ebx, DWORD PTR _typ_zak³adu$[ebp]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00149	8b d3		 mov	 edx, ebx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0014b	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0014f	72 02		 jb	 SHORT $LN267@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00151	8b 13		 mov	 edx, DWORD PTR [ebx]
$LN267@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1257 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  00153	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  00158	51		 push	 ecx
  00159	ff 73 10	 push	 DWORD PTR [ebx+16]
  0015c	8b c8		 mov	 ecx, eax
  0015e	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  00163	83 c4 08	 add	 esp, 8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1257 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  00166	8b c8		 mov	 ecx, eax
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0016e	e9 86 00 00 00	 jmp	 $LN145@P?
$LN8@P?:

; 1256 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  00173	8d 4c 24 18	 lea	 ecx, DWORD PTR $T1[esp+48]
  00177	e8 00 00 00 00	 call	 ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2071 : 		if (this != _STD addressof(_Right))

  0017c	8b 5d 18	 mov	 ebx, DWORD PTR _typ_zak³adu$[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1256 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  0017f	8b f8		 mov	 edi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2071 : 		if (this != _STD addressof(_Right))

  00181	3b df		 cmp	 ebx, edi
  00183	74 28		 je	 SHORT $LN105@P?

; 2072 : 			{	// different, assign it
; 2073 : 			_Tidy_deallocate();

  00185	8b cb		 mov	 ecx, ebx
  00187	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0018c	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  0018f	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  00192	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  00197	66 0f d6 43 10	 movq	 QWORD PTR [ebx+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  0019c	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001a3	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  001aa	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN105@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001ad	8b 54 24 2c	 mov	 edx, DWORD PTR $T1[esp+68]
  001b1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  001b4	72 3f		 jb	 SHORT $LN269@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001b6	8b 4c 24 18	 mov	 ecx, DWORD PTR $T1[esp+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001ba	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001bb	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001bd	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001c3	72 26		 jb	 SHORT $LN148@P?

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001c5	8d 7a 23	 lea	 edi, DWORD PTR [edx+35]
  001c8	3b fa		 cmp	 edi, edx
  001ca	76 19		 jbe	 SHORT $_Invalid_parameter$275

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001cc	8b d7		 mov	 edx, edi
  001ce	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001d0	75 13		 jne	 SHORT $_Invalid_parameter$275

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001d2	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001d5	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  001d7	73 0c		 jae	 SHORT $_Invalid_parameter$275

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001d9	2b c1		 sub	 eax, ecx
  001db	83 f8 04	 cmp	 eax, 4
  001de	72 05		 jb	 SHORT $_Invalid_parameter$275

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  001e0	83 f8 23	 cmp	 eax, 35			; 00000023H
  001e3	76 06		 jbe	 SHORT $LN148@P?
$_Invalid_parameter$275:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN274@P?:
$LN148@P?:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  001eb	52		 push	 edx
  001ec	51		 push	 ecx
  001ed	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001f2	83 c4 08	 add	 esp, 8
$LN269@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3694 : 		if (_My_data._Large_string_engaged())

  001f5	8b 7c 24 0c	 mov	 edi, DWORD PTR $T43[esp+48]
$LN145@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1258 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') log << " Obstawiono zaklad " << typ_zak³adu; //Zapisanie do bufora pliku logu aktualnego informacji o typie obstawionego zak³adu

  001f9	8a 06		 mov	 al, BYTE PTR [esi]
  001fb	3c 6e		 cmp	 al, 110			; 0000006eH
  001fd	74 04		 je	 SHORT $LN10@P?
  001ff	3c 6b		 cmp	 al, 107			; 0000006bH
  00201	75 2d		 jne	 SHORT $LN9@P?
$LN10@P?:
  00203	33 c0		 xor	 eax, eax
  00205	8b cf		 mov	 ecx, edi
  00207	39 45 10	 cmp	 DWORD PTR _log$[ebp], eax
  0020a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
  0020f	0f 44 c8	 cmove	 ecx, eax
  00212	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00217	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0021b	8b d3		 mov	 edx, ebx

; 1594 : 		if (_Large_string_engaged())

  0021d	72 02		 jb	 SHORT $LN268@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0021f	8b 13		 mov	 edx, DWORD PTR [ebx]
$LN268@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  00221	ff 73 10	 push	 DWORD PTR [ebx+16]
  00224	8b c8		 mov	 ecx, eax
  00226	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  0022b	8a 06		 mov	 al, BYTE PTR [esi]
  0022d	83 c4 04	 add	 esp, 4
$LN9@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1259 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') log_ogólny << " Obstawiono zaklad " << typ_zak³adu; //Zapisanie do bufora pliku logu ogólnego informacji o typie obstawionego zak³adu

  00230	3c 6e		 cmp	 al, 110			; 0000006eH
  00232	74 04		 je	 SHORT $LN12@P?
  00234	3c 6b		 cmp	 al, 107			; 0000006bH
  00236	75 24		 jne	 SHORT $LN11@P?
$LN12@P?:
  00238	8b 4d 0c	 mov	 ecx, DWORD PTR _log_ogólny$[ebp]
  0023b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
  00240	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00245	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00249	8b d3		 mov	 edx, ebx

; 1594 : 		if (_Large_string_engaged())

  0024b	72 02		 jb	 SHORT $LN254@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0024d	8b 13		 mov	 edx, DWORD PTR [ebx]
$LN254@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  0024f	ff 73 10	 push	 DWORD PTR [ebx+16]
  00252	8b c8		 mov	 ecx, eax
  00254	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  00259	83 c4 04	 add	 esp, 4
$LN11@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1260 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0025c	8b cf		 mov	 ecx, edi
  0025e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1261 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00264	8b 4d 0c	 mov	 ecx, DWORD PTR _log_ogólny$[ebp]
  00267	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1262 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') iloæ_pieniêdzy -= kwota_zak³adu; //Odjêcie od iloci pieniêdzy kwoty zak³adu

  0026d	8a 06		 mov	 al, BYTE PTR [esi]
  0026f	3c 6e		 cmp	 al, 110			; 0000006eH
  00271	74 0c		 je	 SHORT $LN14@P?
  00273	3c 6b		 cmp	 al, 107			; 0000006bH
  00275	74 08		 je	 SHORT $LN14@P?
  00277	3c 74		 cmp	 al, 116			; 00000074H
  00279	74 04		 je	 SHORT $LN14@P?
  0027b	3c 77		 cmp	 al, 119			; 00000077H
  0027d	75 0d		 jne	 SHORT $LN13@P?
$LN14@P?:
  0027f	8b 44 24 10	 mov	 eax, DWORD PTR _kwota_zak³adu$1$[esp+48]
  00283	8b 4d 08	 mov	 ecx, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00286	8b 00		 mov	 eax, DWORD PTR [eax]
  00288	29 01		 sub	 DWORD PTR [ecx], eax
  0028a	8a 06		 mov	 al, BYTE PTR [esi]
$LN13@P?:

; 1263 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') cout << "Kulka w grze, zaczekaj na wylosowanie numeru..." << endl; //Poinformowanie u¿ytkownika o rozpoczêciu losowania

  0028c	3c 6e		 cmp	 al, 110			; 0000006eH
  0028e	74 08		 je	 SHORT $LN16@P?
  00290	3c 6b		 cmp	 al, 107			; 0000006bH
  00292	74 04		 je	 SHORT $LN16@P?
  00294	3c 74		 cmp	 al, 116			; 00000074H
  00296	75 23		 jne	 SHORT $LN15@P?
$LN16@P?:
  00298	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0029d	51		 push	 ecx
  0029e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002a4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@
  002a9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002ae	83 c4 04	 add	 esp, 4
  002b1	8b c8		 mov	 ecx, eax
  002b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  002b9	8a 06		 mov	 al, BYTE PTR [esi]
$LN15@P?:

; 1264 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') wylosowana_liczba = Zakrêæ_Ruletk¹(); //Wylosowanie i przypisanie do zmiennej liczby bêdêcej na  wylosowanej pozycji na kole ruletki

  002bb	3c 6e		 cmp	 al, 110			; 0000006eH
  002bd	74 6f		 je	 SHORT $LN19@P?
  002bf	3c 6b		 cmp	 al, 107			; 0000006bH
  002c1	74 6b		 je	 SHORT $LN19@P?
  002c3	3c 74		 cmp	 al, 116			; 00000074H
  002c5	74 67		 je	 SHORT $LN19@P?

; 1265 : 	else {
; 1266 : 		cout << "Wylosowano numer "; //Poinformowaniu o wylosowaniu liczby

  002c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002cd	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
  002d2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1267 : 		Change_Col(Ruletka_plansza_kolor_col[wylosowana_liczba]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  002d7	8b 45 1c	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]

; 386  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  002da	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetStdHandle@4
  002e0	6a f5		 push	 -11			; fffffff5H

; 1267 : 		Change_Col(Ruletka_plansza_kolor_col[wylosowana_liczba]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  002e2	8b 00		 mov	 eax, DWORD PTR [eax]
  002e4	0f b7 34 45 00
	00 00 00	 movzx	 esi, WORD PTR ?Ruletka_plansza_kolor_col@@3QBGB[eax*2]

; 386  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  002ec	ff d7		 call	 edi

; 387  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  002ee	56		 push	 esi
  002ef	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetConsoleTextAttribute@8
  002f5	50		 push	 eax
  002f6	ff d6		 call	 esi

; 1268 : 		cout << wylosowana_liczba; //Wypisanie wylosowanej liczby

  002f8	8b 45 1c	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  002fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00301	ff 30		 push	 DWORD PTR [eax]
  00303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z

; 386  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00309	6a f5		 push	 -11			; fffffff5H
  0030b	ff d7		 call	 edi

; 387  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0030d	6a 07		 push	 7
  0030f	50		 push	 eax
  00310	ff d6		 call	 esi

; 1269 : 		Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 1270 : 		cout << ". "; //Wypisanie kropki koñcz¹cej zdanie

  00312	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00318	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KHOJGJKF@?4?5?$AA@
  0031d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00322	8b 75 14	 mov	 esi, DWORD PTR _co_kontynuowaæ$[ebp]
  00325	8b 7c 24 0c	 mov	 edi, DWORD PTR $T43[esp+48]
  00329	8b 4d 1c	 mov	 ecx, DWORD PTR _wylosowana_liczba$[ebp]
  0032c	eb 0a		 jmp	 SHORT $LN18@P?
$LN19@P?:

; 1264 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') wylosowana_liczba = Zakrêæ_Ruletk¹(); //Wylosowanie i przypisanie do zmiennej liczby bêdêcej na  wylosowanej pozycji na kole ruletki

  0032e	e8 00 00 00 00	 call	 ?Zakrêæ_Ruletk¹@@YAHXZ	; Zakrêæ_Ruletk¹
  00333	8b 4d 1c	 mov	 ecx, DWORD PTR _wylosowana_liczba$[ebp]
  00336	89 01		 mov	 DWORD PTR [ecx], eax
$LN18@P?:

; 1271 : 	}
; 1272 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') log << " Wylosowano " << wylosowana_liczba; //Zapisanie do bufora pliku logu aktualnego informacji o wylosowanej liczbie

  00338	8a 06		 mov	 al, BYTE PTR [esi]
  0033a	3c 6e		 cmp	 al, 110			; 0000006eH
  0033c	74 08		 je	 SHORT $LN21@P?
  0033e	3c 6b		 cmp	 al, 107			; 0000006bH
  00340	74 04		 je	 SHORT $LN21@P?
  00342	3c 74		 cmp	 al, 116			; 00000074H
  00344	75 24		 jne	 SHORT $LN20@P?
$LN21@P?:
  00346	ff 31		 push	 DWORD PTR [ecx]
  00348	33 c0		 xor	 eax, eax
  0034a	8b cf		 mov	 ecx, edi
  0034c	39 45 10	 cmp	 DWORD PTR _log$[ebp], eax
  0034f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
  00354	0f 44 c8	 cmove	 ecx, eax
  00357	51		 push	 ecx
  00358	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0035d	83 c4 04	 add	 esp, 4
  00360	8b c8		 mov	 ecx, eax
  00362	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00368	8a 06		 mov	 al, BYTE PTR [esi]
$LN20@P?:

; 1273 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') log_ogólny << " Wylosowano " << wylosowana_liczba; //Zapisanie do bufora pliku logu ogólnego informacji o wylosowanej liczbie

  0036a	3c 6e		 cmp	 al, 110			; 0000006eH
  0036c	74 08		 je	 SHORT $LN23@P?
  0036e	3c 6b		 cmp	 al, 107			; 0000006bH
  00370	74 04		 je	 SHORT $LN23@P?
  00372	3c 74		 cmp	 al, 116			; 00000074H
  00374	75 1e		 jne	 SHORT $LN22@P?
$LN23@P?:
  00376	8b 45 1c	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00379	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
  0037e	ff 30		 push	 DWORD PTR [eax]
  00380	51		 push	 ecx
  00381	8b 4d 0c	 mov	 ecx, DWORD PTR _log_ogólny$[ebp]
  00384	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00389	83 c4 04	 add	 esp, 4
  0038c	8b c8		 mov	 ecx, eax
  0038e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
$LN22@P?:

; 1274 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  00394	8b cf		 mov	 ecx, edi
  00396	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1275 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  0039c	8b 4d 0c	 mov	 ecx, DWORD PTR _log_ogólny$[ebp]
  0039f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1276 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') Odczytaj_Liczbê(wylosowana_liczba, typ_zak³adu);

  003a5	8a 06		 mov	 al, BYTE PTR [esi]
  003a7	3c 6e		 cmp	 al, 110			; 0000006eH
  003a9	74 08		 je	 SHORT $LN25@P?
  003ab	3c 6b		 cmp	 al, 107			; 0000006bH
  003ad	74 04		 je	 SHORT $LN25@P?
  003af	3c 74		 cmp	 al, 116			; 00000074H
  003b1	75 10		 jne	 SHORT $LN270@P?
$LN25@P?:
  003b3	8b 7d 1c	 mov	 edi, DWORD PTR _wylosowana_liczba$[ebp]
  003b6	8b d3		 mov	 edx, ebx
  003b8	8b cf		 mov	 ecx, edi
  003ba	e8 00 00 00 00	 call	 ?Odczytaj_Liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Odczytaj_Liczbê
  003bf	8a 06		 mov	 al, BYTE PTR [esi]
  003c1	eb 03		 jmp	 SHORT $LN24@P?
$LN270@P?:
  003c3	8b 7d 1c	 mov	 edi, DWORD PTR _wylosowana_liczba$[ebp]
$LN24@P?:

; 1277 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') wygrana = Sprawd_Zak³ad(kwota_zak³adu, typ_zak³adu, wylosowana_liczba); //Przypisanie do wygranej kwoty zgodnej z wygran¹, je¿eli siê cowygra³o

  003c6	3c 6e		 cmp	 al, 110			; 0000006eH
  003c8	74 0c		 je	 SHORT $LN27@P?
  003ca	3c 6b		 cmp	 al, 107			; 0000006bH
  003cc	74 08		 je	 SHORT $LN27@P?
  003ce	3c 74		 cmp	 al, 116			; 00000074H
  003d0	74 04		 je	 SHORT $LN27@P?
  003d2	3c 77		 cmp	 al, 119			; 00000077H
  003d4	75 1b		 jne	 SHORT $LN271@P?
$LN27@P?:
  003d6	8b d3		 mov	 edx, ebx
  003d8	8b 5c 24 10	 mov	 ebx, DWORD PTR _kwota_zak³adu$1$[esp+48]
  003dc	57		 push	 edi
  003dd	8b cb		 mov	 ecx, ebx
  003df	e8 00 00 00 00	 call	 ?Sprawd_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Sprawd_Zak³ad
  003e4	8b 4c 24 18	 mov	 ecx, DWORD PTR _wygrana$1$[esp+52]
  003e8	83 c4 04	 add	 esp, 4
  003eb	89 01		 mov	 DWORD PTR [ecx], eax
  003ed	8a 06		 mov	 al, BYTE PTR [esi]
  003ef	eb 08		 jmp	 SHORT $LN26@P?
$LN271@P?:
  003f1	8b 5c 24 10	 mov	 ebx, DWORD PTR _kwota_zak³adu$1$[esp+48]
  003f5	8b 4c 24 14	 mov	 ecx, DWORD PTR _wygrana$1$[esp+48]
$LN26@P?:

; 1278 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') Og³o_Wynik(wygrana, kwota_zak³adu, iloæ_pieniêdzy, log_ogólny, log); //Funkcja informuj¹ca u¿ytkownika czy wygra³ zak³ad

  003f9	3c 6e		 cmp	 al, 110			; 0000006eH
  003fb	74 0c		 je	 SHORT $LN29@P?
  003fd	3c 6b		 cmp	 al, 107			; 0000006bH
  003ff	74 08		 je	 SHORT $LN29@P?
  00401	3c 74		 cmp	 al, 116			; 00000074H
  00403	74 04		 je	 SHORT $LN29@P?
  00405	3c 77		 cmp	 al, 119			; 00000077H
  00407	75 13		 jne	 SHORT $LN28@P?
$LN29@P?:
  00409	ff 75 10	 push	 DWORD PTR _log$[ebp]
  0040c	8b d3		 mov	 edx, ebx
  0040e	ff 75 0c	 push	 DWORD PTR _log_ogólny$[ebp]
  00411	ff 75 08	 push	 DWORD PTR _iloæ_pieniêdzy$[ebp]
  00414	e8 00 00 00 00	 call	 ?Og³o_Wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ; Og³o_Wynik
  00419	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@P?:

; 1279 : }

  0041c	5f		 pop	 edi
  0041d	5e		 pop	 esi
  0041e	5b		 pop	 ebx
  0041f	8b e5		 mov	 esp, ebp
  00421	5d		 pop	 ebp
  00422	c3		 ret	 0
$LN273@P?:
?Pêtla_G³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; Pêtla_G³ówna
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Ustaw_Ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
?Ustaw_Ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Ustaw_Ustawienia, COMDAT
; _tekst$ = ecx

; 1281 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 1282 : 	if (tekst.find("iloæ_minimalna_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00003	51		 push	 ecx
  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00010	83 f8 ff	 cmp	 eax, -1
  00013	0f 84 93 00 00
	00		 je	 $LN35@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00019	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0001c	8d 5e 10	 lea	 ebx, DWORD PTR [esi+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0001f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00024	8b d6		 mov	 edx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00026	3b c1		 cmp	 eax, ecx
  00028	0f 42 c8	 cmovb	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0002b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1583 : 		if (_Large_string_engaged())

  0002f	72 02		 jb	 SHORT $LN963@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00031	8b 16		 mov	 edx, DWORD PTR [esi]
$LN963@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00033	2b c1		 sub	 eax, ecx

; 2607 : 		_My_data._Mysize = _New_size;

  00035	89 03		 mov	 DWORD PTR [ebx], eax

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00037	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00038	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00039	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0003c	50		 push	 eax
  0003d	52		 push	 edx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00047	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00049	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0004d	72 02		 jb	 SHORT $LN964@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN964@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1285 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_minimalna_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00051	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00057	50		 push	 eax
  00058	ff d7		 call	 edi
  0005a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0005d	83 c4 04	 add	 esp, 4
  00060	85 c0		 test	 eax, eax
  00062	74 17		 je	 SHORT $LN37@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00064	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00067	72 02		 jb	 SHORT $LN148@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00069	8b 36		 mov	 esi, DWORD PTR [esi]
$LN148@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1285 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_minimalna_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0006b	56		 push	 esi
  0006c	ff d7		 call	 edi
  0006e	83 c4 04	 add	 esp, 4
  00071	66 a3 00 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A, ax
  00077	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	c3		 ret	 0
$LN37@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0007b	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0007d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00080	72 04		 jb	 SHORT $LN180@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00082	8b 06		 mov	 eax, DWORD PTR [esi]
  00084	8b f0		 mov	 esi, eax
$LN180@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00086	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00088	03 ce		 add	 ecx, esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1288 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  0008a	3b c1		 cmp	 eax, ecx
  0008c	0f 84 f2 04 00
	00		 je	 $LN30@Ustaw_Usta
$LL4@Ustaw_Usta:

; 1289 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00092	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00095	0f 85 77 05 00
	00		 jne	 $LN87@Ustaw_Usta

; 1288 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  0009b	40		 inc	 eax
  0009c	3b c1		 cmp	 eax, ecx
  0009e	75 f2		 jne	 SHORT $LL4@Ustaw_Usta

; 1290 : 			Ustawienia.g³os_szybkoæ_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  000a0	5f		 pop	 edi
  000a1	33 c0		 xor	 eax, eax

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  000a3	5e		 pop	 esi
  000a4	66 a3 16 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax
  000aa	5b		 pop	 ebx
  000ab	c3		 ret	 0
$LN35@Ustaw_Usta:

; 1291 : 		}
; 1292 : 	}
; 1293 : 	else if (tekst.find("iloæ_max_dodatkowych_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  000ac	51		 push	 ecx
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
  000b2	8b ce		 mov	 ecx, esi
  000b4	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  000b9	83 f8 ff	 cmp	 eax, -1
  000bc	0f 84 8f 00 00
	00		 je	 $LN40@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  000c2	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000c5	8d 5e 10	 lea	 ebx, DWORD PTR [esi+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  000c8	b9 26 00 00 00	 mov	 ecx, 38			; 00000026H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  000cd	8b d6		 mov	 edx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  000cf	3b c1		 cmp	 eax, ecx
  000d1	0f 42 c8	 cmovb	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000d4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1583 : 		if (_Large_string_engaged())

  000d8	72 02		 jb	 SHORT $LN966@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000da	8b 16		 mov	 edx, DWORD PTR [esi]
$LN966@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  000dc	2b c1		 sub	 eax, ecx

; 2607 : 		_My_data._Mysize = _New_size;

  000de	89 03		 mov	 DWORD PTR [ebx], eax

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  000e0	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000e1	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  000e2	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000e5	50		 push	 eax
  000e6	52		 push	 edx
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  000f0	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000f2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  000f6	72 02		 jb	 SHORT $LN967@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000f8	8b 06		 mov	 eax, DWORD PTR [esi]
$LN967@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1296 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  000fa	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00100	50		 push	 eax
  00101	ff d7		 call	 edi
  00103	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00106	83 c4 04	 add	 esp, 4
  00109	85 c0		 test	 eax, eax
  0010b	74 17		 je	 SHORT $LN42@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0010d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00110	72 02		 jb	 SHORT $LN243@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00112	8b 36		 mov	 esi, DWORD PTR [esi]
$LN243@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1296 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00114	56		 push	 esi
  00115	ff d7		 call	 edi
  00117	83 c4 04	 add	 esp, 4
  0011a	66 a3 02 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2, ax
  00120	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	c3		 ret	 0
$LN42@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00124	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00126	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00129	72 04		 jb	 SHORT $LN275@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0012b	8b 06		 mov	 eax, DWORD PTR [esi]
  0012d	8b f0		 mov	 esi, eax
$LN275@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0012f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00131	03 ce		 add	 ecx, esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1299 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  00133	3b c1		 cmp	 eax, ecx
  00135	74 0e		 je	 SHORT $LN6@Ustaw_Usta
$LL7@Ustaw_Usta:

; 1300 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00137	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  0013a	0f 85 d2 04 00
	00		 jne	 $LN87@Ustaw_Usta

; 1299 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  00140	40		 inc	 eax
  00141	3b c1		 cmp	 eax, ecx
  00143	75 f2		 jne	 SHORT $LL7@Ustaw_Usta
$LN6@Ustaw_Usta:
  00145	5f		 pop	 edi

; 1301 : 			Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00146	33 c0		 xor	 eax, eax

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00148	5e		 pop	 esi
  00149	66 a3 02 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2, ax
  0014f	5b		 pop	 ebx
  00150	c3		 ret	 0
$LN40@Ustaw_Usta:

; 1302 : 		}
; 1303 : 	}
; 1304 : 	else if (tekst.find("czas_przeskoku_kulki_szybki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00151	51		 push	 ecx
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@
  00157	8b ce		 mov	 ecx, esi
  00159	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0015e	83 f8 ff	 cmp	 eax, -1
  00161	74 77		 je	 SHORT $LN45@Ustaw_Usta

; 1305 : 	{
; 1306 : 		tekst.erase(0, size("czas_przeskoku_kulki_szybki")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  00163	6a 1c		 push	 28			; 0000001cH
  00165	6a 00		 push	 0
  00167	8b ce		 mov	 ecx, esi
  00169	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0016e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00172	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  00174	72 02		 jb	 SHORT $LN969@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00176	8b 06		 mov	 eax, DWORD PTR [esi]
$LN969@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1307 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_szybki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00178	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  0017e	50		 push	 eax
  0017f	ff d7		 call	 edi
  00181	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00184	83 c4 04	 add	 esp, 4
  00187	85 c0		 test	 eax, eax
  00189	74 17		 je	 SHORT $LN47@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0018b	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0018e	72 02		 jb	 SHORT $LN310@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00190	8b 36		 mov	 esi, DWORD PTR [esi]
$LN310@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1307 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_szybki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00192	56		 push	 esi
  00193	ff d7		 call	 edi
  00195	83 c4 04	 add	 esp, 4
  00198	66 a3 04 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4, ax
  0019e	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  0019f	5e		 pop	 esi
  001a0	5b		 pop	 ebx
  001a1	c3		 ret	 0
$LN47@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  001a2	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001a4	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  001a7	72 02		 jb	 SHORT $LN970@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001a9	8b 06		 mov	 eax, DWORD PTR [esi]
$LN970@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  001ab	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001ad	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  001b0	72 02		 jb	 SHORT $LN342@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001b2	8b 16		 mov	 edx, DWORD PTR [esi]
$LN342@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  001b4	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001b7	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1310 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  001b9	3b c1		 cmp	 eax, ecx
  001bb	74 11		 je	 SHORT $LN9@Ustaw_Usta
  001bd	0f 1f 00	 npad	 3
$LL10@Ustaw_Usta:

; 1311 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  001c0	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  001c3	0f 85 49 04 00
	00		 jne	 $LN87@Ustaw_Usta

; 1310 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  001c9	40		 inc	 eax
  001ca	3b c1		 cmp	 eax, ecx
  001cc	75 f2		 jne	 SHORT $LL10@Ustaw_Usta
$LN9@Ustaw_Usta:
  001ce	5f		 pop	 edi

; 1312 : 			Ustawienia.czas_przeskoku_kulki_szybki = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  001cf	33 c0		 xor	 eax, eax

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  001d1	5e		 pop	 esi
  001d2	66 a3 04 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4, ax
  001d8	5b		 pop	 ebx
  001d9	c3		 ret	 0
$LN45@Ustaw_Usta:

; 1313 : 		}
; 1314 : 	}
; 1315 : 	else if (tekst.find("czas_przeskoku_kulki_wolny") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  001da	51		 push	 ecx
  001db	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@
  001e0	8b ce		 mov	 ecx, esi
  001e2	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  001e7	83 f8 ff	 cmp	 eax, -1
  001ea	74 74		 je	 SHORT $LN50@Ustaw_Usta

; 1316 : 	{
; 1317 : 		tekst.erase(0, size("czas_przeskoku_kulki_wolny")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  001ec	6a 1b		 push	 27			; 0000001bH
  001ee	6a 00		 push	 0
  001f0	8b ce		 mov	 ecx, esi
  001f2	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001f7	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001fb	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  001fd	72 02		 jb	 SHORT $LN971@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001ff	8b 06		 mov	 eax, DWORD PTR [esi]
$LN971@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1318 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_wolny = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00201	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00207	50		 push	 eax
  00208	ff d7		 call	 edi
  0020a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0020d	83 c4 04	 add	 esp, 4
  00210	85 c0		 test	 eax, eax
  00212	74 17		 je	 SHORT $LN52@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00214	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00217	72 02		 jb	 SHORT $LN377@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00219	8b 36		 mov	 esi, DWORD PTR [esi]
$LN377@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1318 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_wolny = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0021b	56		 push	 esi
  0021c	ff d7		 call	 edi
  0021e	83 c4 04	 add	 esp, 4
  00221	66 a3 06 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+6, ax
  00227	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00228	5e		 pop	 esi
  00229	5b		 pop	 ebx
  0022a	c3		 ret	 0
$LN52@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0022b	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0022d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00230	72 02		 jb	 SHORT $LN972@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00232	8b 06		 mov	 eax, DWORD PTR [esi]
$LN972@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00234	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00236	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00239	72 02		 jb	 SHORT $LN409@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0023b	8b 16		 mov	 edx, DWORD PTR [esi]
$LN409@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0023d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00240	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1321 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  00242	3b c1		 cmp	 eax, ecx
  00244	74 0e		 je	 SHORT $LN12@Ustaw_Usta
$LL13@Ustaw_Usta:

; 1322 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00246	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00249	0f 85 c3 03 00
	00		 jne	 $LN87@Ustaw_Usta

; 1321 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  0024f	40		 inc	 eax
  00250	3b c1		 cmp	 eax, ecx
  00252	75 f2		 jne	 SHORT $LL13@Ustaw_Usta
$LN12@Ustaw_Usta:
  00254	5f		 pop	 edi

; 1323 : 			Ustawienia.czas_przeskoku_kulki_wolny = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00255	33 c0		 xor	 eax, eax

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00257	5e		 pop	 esi
  00258	66 a3 06 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+6, ax
  0025e	5b		 pop	 ebx
  0025f	c3		 ret	 0
$LN50@Ustaw_Usta:

; 1324 : 		}
; 1325 : 	}
; 1326 : 	else if (tekst.find("styl_liczenia_wygranej") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00260	51		 push	 ecx
  00261	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@
  00266	8b ce		 mov	 ecx, esi
  00268	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0026d	83 f8 ff	 cmp	 eax, -1
  00270	74 78		 je	 SHORT $LN55@Ustaw_Usta

; 1327 : 	{
; 1328 : 		tekst.erase(0, size("styl_liczenia_wygranej")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  00272	6a 17		 push	 23			; 00000017H
  00274	6a 00		 push	 0
  00276	8b ce		 mov	 ecx, esi
  00278	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0027d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00281	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  00283	72 02		 jb	 SHORT $LN973@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00285	8b 06		 mov	 eax, DWORD PTR [esi]
$LN973@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1329 : 		if (atoi(tekst.c_str())) Ustawienia.styl_liczenia_wygranej = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00287	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  0028d	50		 push	 eax
  0028e	ff d7		 call	 edi
  00290	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00293	83 c4 04	 add	 esp, 4
  00296	85 c0		 test	 eax, eax
  00298	74 17		 je	 SHORT $LN57@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0029a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0029d	72 02		 jb	 SHORT $LN444@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0029f	8b 36		 mov	 esi, DWORD PTR [esi]
$LN444@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1329 : 		if (atoi(tekst.c_str())) Ustawienia.styl_liczenia_wygranej = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  002a1	56		 push	 esi
  002a2	ff d7		 call	 edi
  002a4	83 c4 04	 add	 esp, 4
  002a7	66 a3 0a 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, ax
  002ad	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  002ae	5e		 pop	 esi
  002af	5b		 pop	 ebx
  002b0	c3		 ret	 0
$LN57@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  002b1	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002b3	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  002b6	72 02		 jb	 SHORT $LN974@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  002b8	8b 06		 mov	 eax, DWORD PTR [esi]
$LN974@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  002ba	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002bc	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  002bf	72 02		 jb	 SHORT $LN476@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  002c1	8b 16		 mov	 edx, DWORD PTR [esi]
$LN476@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  002c3	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  002c6	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1332 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  002c8	3b c1		 cmp	 eax, ecx
  002ca	74 12		 je	 SHORT $LN15@Ustaw_Usta
  002cc	0f 1f 40 00	 npad	 4
$LL16@Ustaw_Usta:

; 1333 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  002d0	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  002d3	0f 85 39 03 00
	00		 jne	 $LN87@Ustaw_Usta

; 1332 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  002d9	40		 inc	 eax
  002da	3b c1		 cmp	 eax, ecx
  002dc	75 f2		 jne	 SHORT $LL16@Ustaw_Usta
$LN15@Ustaw_Usta:
  002de	5f		 pop	 edi

; 1334 : 			Ustawienia.styl_liczenia_wygranej = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  002df	33 c0		 xor	 eax, eax

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  002e1	5e		 pop	 esi
  002e2	66 a3 0a 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, ax
  002e8	5b		 pop	 ebx
  002e9	c3		 ret	 0
$LN55@Ustaw_Usta:

; 1335 : 		}
; 1336 : 	}
; 1337 : 	else if (tekst.find("kwota_pocz¹tkowa") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  002ea	51		 push	 ecx
  002eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@
  002f0	8b ce		 mov	 ecx, esi
  002f2	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  002f7	83 f8 ff	 cmp	 eax, -1
  002fa	74 75		 je	 SHORT $LN60@Ustaw_Usta

; 1338 : 	{
; 1339 : 		tekst.erase(0, size("kwota_pocz¹tkowa")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  002fc	6a 11		 push	 17			; 00000011H
  002fe	6a 00		 push	 0
  00300	8b ce		 mov	 ecx, esi
  00302	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00307	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0030b	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  0030d	72 02		 jb	 SHORT $LN975@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0030f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN975@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1340 : 		if (atoi(tekst.c_str())) Ustawienia.kwota_pocz¹tkowa = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00311	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00317	50		 push	 eax
  00318	ff d7		 call	 edi
  0031a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0031d	83 c4 04	 add	 esp, 4
  00320	85 c0		 test	 eax, eax
  00322	74 16		 je	 SHORT $LN62@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00324	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00327	72 02		 jb	 SHORT $LN511@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00329	8b 36		 mov	 esi, DWORD PTR [esi]
$LN511@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1340 : 		if (atoi(tekst.c_str())) Ustawienia.kwota_pocz¹tkowa = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0032b	56		 push	 esi
  0032c	ff d7		 call	 edi
  0032e	83 c4 04	 add	 esp, 4
  00331	a3 0c 00 00 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, eax
  00336	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00337	5e		 pop	 esi
  00338	5b		 pop	 ebx
  00339	c3		 ret	 0
$LN62@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0033a	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0033c	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  0033f	72 02		 jb	 SHORT $LN976@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00341	8b 06		 mov	 eax, DWORD PTR [esi]
$LN976@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00343	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00345	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00348	72 02		 jb	 SHORT $LN543@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0034a	8b 16		 mov	 edx, DWORD PTR [esi]
$LN543@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0034c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0034f	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1343 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  00351	3b c1		 cmp	 eax, ecx
  00353	74 0e		 je	 SHORT $LN18@Ustaw_Usta
$LL19@Ustaw_Usta:

; 1344 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00355	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00358	0f 85 b4 02 00
	00		 jne	 $LN87@Ustaw_Usta

; 1343 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  0035e	40		 inc	 eax
  0035f	3b c1		 cmp	 eax, ecx
  00361	75 f2		 jne	 SHORT $LL19@Ustaw_Usta
$LN18@Ustaw_Usta:
  00363	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00364	5e		 pop	 esi
  00365	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, 0
  0036f	5b		 pop	 ebx
  00370	c3		 ret	 0
$LN60@Ustaw_Usta:

; 1345 : 			Ustawienia.kwota_pocz¹tkowa = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0
; 1346 : 		}
; 1347 : 	}
; 1348 : 	else if (tekst.find("stan_dwiêków") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00371	51		 push	 ecx
  00372	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@
  00377	8b ce		 mov	 ecx, esi
  00379	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0037e	83 f8 ff	 cmp	 eax, -1
  00381	74 77		 je	 SHORT $LN65@Ustaw_Usta

; 1349 : 	{
; 1350 : 		tekst.erase(0, size("stan_dwiêków")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  00383	6a 0e		 push	 14			; 0000000eH
  00385	6a 00		 push	 0
  00387	8b ce		 mov	 ecx, esi
  00389	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0038e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00392	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  00394	72 02		 jb	 SHORT $LN977@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00396	8b 06		 mov	 eax, DWORD PTR [esi]
$LN977@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1351 : 		if (atoi(tekst.c_str())) Ustawienia.stan_dwiêków = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00398	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  0039e	50		 push	 eax
  0039f	ff d7		 call	 edi
  003a1	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  003a4	83 c4 04	 add	 esp, 4
  003a7	85 c0		 test	 eax, eax
  003a9	74 17		 je	 SHORT $LN67@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003ab	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  003ae	72 02		 jb	 SHORT $LN578@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  003b0	8b 36		 mov	 esi, DWORD PTR [esi]
$LN578@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1351 : 		if (atoi(tekst.c_str())) Ustawienia.stan_dwiêków = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  003b2	56		 push	 esi
  003b3	ff d7		 call	 edi
  003b5	83 c4 04	 add	 esp, 4
  003b8	66 a3 10 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, ax
  003be	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  003bf	5e		 pop	 esi
  003c0	5b		 pop	 ebx
  003c1	c3		 ret	 0
$LN67@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  003c2	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003c4	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  003c7	72 02		 jb	 SHORT $LN978@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  003c9	8b 06		 mov	 eax, DWORD PTR [esi]
$LN978@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  003cb	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003cd	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  003d0	72 02		 jb	 SHORT $LN610@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  003d2	8b 16		 mov	 edx, DWORD PTR [esi]
$LN610@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  003d4	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  003d7	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1354 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  003d9	3b c1		 cmp	 eax, ecx
  003db	74 11		 je	 SHORT $LN21@Ustaw_Usta
  003dd	0f 1f 00	 npad	 3
$LL22@Ustaw_Usta:

; 1355 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  003e0	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  003e3	0f 85 29 02 00
	00		 jne	 $LN87@Ustaw_Usta

; 1354 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  003e9	40		 inc	 eax
  003ea	3b c1		 cmp	 eax, ecx
  003ec	75 f2		 jne	 SHORT $LL22@Ustaw_Usta
$LN21@Ustaw_Usta:
  003ee	5f		 pop	 edi

; 1356 : 			Ustawienia.stan_dwiêków = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  003ef	33 c0		 xor	 eax, eax

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  003f1	5e		 pop	 esi
  003f2	66 a3 10 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, ax
  003f8	5b		 pop	 ebx
  003f9	c3		 ret	 0
$LN65@Ustaw_Usta:

; 1357 : 		}
; 1358 : 	}
; 1359 : 	else if (tekst.find("czy_kontynuowaæ_grê") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  003fa	51		 push	 ecx
  003fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@
  00400	8b ce		 mov	 ecx, esi
  00402	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00407	83 f8 ff	 cmp	 eax, -1
  0040a	74 74		 je	 SHORT $LN70@Ustaw_Usta

; 1360 : 	{
; 1361 : 		tekst.erase(0, size("czy_kontynuowaæ_grê")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  0040c	6a 14		 push	 20			; 00000014H
  0040e	6a 00		 push	 0
  00410	8b ce		 mov	 ecx, esi
  00412	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00417	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0041b	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  0041d	72 02		 jb	 SHORT $LN979@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0041f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN979@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1362 : 		if (atoi(tekst.c_str())) Ustawienia.czy_kontynuowaæ_grê = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00421	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00427	50		 push	 eax
  00428	ff d7		 call	 edi
  0042a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0042d	83 c4 04	 add	 esp, 4
  00430	85 c0		 test	 eax, eax
  00432	74 17		 je	 SHORT $LN72@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00434	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00437	72 02		 jb	 SHORT $LN645@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00439	8b 36		 mov	 esi, DWORD PTR [esi]
$LN645@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1362 : 		if (atoi(tekst.c_str())) Ustawienia.czy_kontynuowaæ_grê = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0043b	56		 push	 esi
  0043c	ff d7		 call	 edi
  0043e	83 c4 04	 add	 esp, 4
  00441	66 a3 12 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, ax
  00447	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00448	5e		 pop	 esi
  00449	5b		 pop	 ebx
  0044a	c3		 ret	 0
$LN72@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0044b	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0044d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00450	72 02		 jb	 SHORT $LN980@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00452	8b 06		 mov	 eax, DWORD PTR [esi]
$LN980@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00454	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00456	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00459	72 02		 jb	 SHORT $LN677@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0045b	8b 16		 mov	 edx, DWORD PTR [esi]
$LN677@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0045d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00460	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1365 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  00462	3b c1		 cmp	 eax, ecx
  00464	74 0e		 je	 SHORT $LN24@Ustaw_Usta
$LL25@Ustaw_Usta:

; 1366 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00466	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00469	0f 85 a3 01 00
	00		 jne	 $LN87@Ustaw_Usta

; 1365 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  0046f	40		 inc	 eax
  00470	3b c1		 cmp	 eax, ecx
  00472	75 f2		 jne	 SHORT $LL25@Ustaw_Usta
$LN24@Ustaw_Usta:
  00474	5f		 pop	 edi

; 1367 : 			Ustawienia.czy_kontynuowaæ_grê = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00475	33 c0		 xor	 eax, eax

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00477	5e		 pop	 esi
  00478	66 a3 12 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, ax
  0047e	5b		 pop	 ebx
  0047f	c3		 ret	 0
$LN70@Ustaw_Usta:

; 1368 : 		}
; 1369 : 	}
; 1370 : 	else if (tekst.find("g³os_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00480	51		 push	 ecx
  00481	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@
  00486	8b ce		 mov	 ecx, esi
  00488	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0048d	83 f8 ff	 cmp	 eax, -1
  00490	74 78		 je	 SHORT $LN75@Ustaw_Usta

; 1371 : 	{
; 1372 : 		tekst.erase(0, size("g³os_odczytu_numeru")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  00492	6a 14		 push	 20			; 00000014H
  00494	6a 00		 push	 0
  00496	8b ce		 mov	 ecx, esi
  00498	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0049d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  004a1	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  004a3	72 02		 jb	 SHORT $LN981@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004a5	8b 06		 mov	 eax, DWORD PTR [esi]
$LN981@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1373 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  004a7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  004ad	50		 push	 eax
  004ae	ff d7		 call	 edi
  004b0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  004b3	83 c4 04	 add	 esp, 4
  004b6	85 c0		 test	 eax, eax
  004b8	74 17		 je	 SHORT $LN77@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004ba	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  004bd	72 02		 jb	 SHORT $LN712@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004bf	8b 36		 mov	 esi, DWORD PTR [esi]
$LN712@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1373 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  004c1	56		 push	 esi
  004c2	ff d7		 call	 edi
  004c4	83 c4 04	 add	 esp, 4
  004c7	66 a3 14 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, ax
  004cd	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  004ce	5e		 pop	 esi
  004cf	5b		 pop	 ebx
  004d0	c3		 ret	 0
$LN77@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  004d1	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004d3	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  004d6	72 02		 jb	 SHORT $LN982@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004d8	8b 06		 mov	 eax, DWORD PTR [esi]
$LN982@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  004da	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004dc	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  004df	72 02		 jb	 SHORT $LN744@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004e1	8b 16		 mov	 edx, DWORD PTR [esi]
$LN744@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  004e3	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  004e6	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1376 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  004e8	3b c1		 cmp	 eax, ecx
  004ea	74 12		 je	 SHORT $LN27@Ustaw_Usta
  004ec	0f 1f 40 00	 npad	 4
$LL28@Ustaw_Usta:

; 1377 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  004f0	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  004f3	0f 85 19 01 00
	00		 jne	 $LN87@Ustaw_Usta

; 1376 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  004f9	40		 inc	 eax
  004fa	3b c1		 cmp	 eax, ecx
  004fc	75 f2		 jne	 SHORT $LL28@Ustaw_Usta
$LN27@Ustaw_Usta:
  004fe	5f		 pop	 edi

; 1378 : 			Ustawienia.g³os_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  004ff	33 c0		 xor	 eax, eax

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00501	5e		 pop	 esi
  00502	66 a3 14 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, ax
  00508	5b		 pop	 ebx
  00509	c3		 ret	 0
$LN75@Ustaw_Usta:

; 1379 : 		}
; 1380 : 	}
; 1381 : 	else if (tekst.find("g³os_szybkoæ_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0050a	51		 push	 ecx
  0050b	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@
  00510	8b ce		 mov	 ecx, esi
  00512	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00517	83 f8 ff	 cmp	 eax, -1
  0051a	74 74		 je	 SHORT $LN80@Ustaw_Usta

; 1382 : 	{
; 1383 : 		tekst.erase(0, size("g³os_szybkoæ_odczytu_numeru")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  0051c	6a 1d		 push	 29			; 0000001dH
  0051e	6a 00		 push	 0
  00520	8b ce		 mov	 ecx, esi
  00522	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00527	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0052b	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  0052d	72 02		 jb	 SHORT $LN983@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0052f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN983@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1384 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_szybkoæ_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00531	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00537	50		 push	 eax
  00538	ff d7		 call	 edi
  0053a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0053d	83 c4 04	 add	 esp, 4
  00540	85 c0		 test	 eax, eax
  00542	74 17		 je	 SHORT $LN82@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00544	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00547	72 02		 jb	 SHORT $LN779@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00549	8b 36		 mov	 esi, DWORD PTR [esi]
$LN779@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1384 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_szybkoæ_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0054b	56		 push	 esi
  0054c	ff d7		 call	 edi
  0054e	83 c4 04	 add	 esp, 4
  00551	66 a3 16 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax
  00557	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00558	5e		 pop	 esi
  00559	5b		 pop	 ebx
  0055a	c3		 ret	 0
$LN82@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0055b	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0055d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00560	72 02		 jb	 SHORT $LN984@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00562	8b 06		 mov	 eax, DWORD PTR [esi]
$LN984@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00564	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00566	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00569	72 02		 jb	 SHORT $LN811@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0056b	8b 16		 mov	 edx, DWORD PTR [esi]
$LN811@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0056d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00570	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1387 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  00572	3b c1		 cmp	 eax, ecx
  00574	74 0e		 je	 SHORT $LN30@Ustaw_Usta
$LL31@Ustaw_Usta:

; 1388 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00576	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00579	0f 85 93 00 00
	00		 jne	 $LN87@Ustaw_Usta

; 1387 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  0057f	40		 inc	 eax
  00580	3b c1		 cmp	 eax, ecx
  00582	75 f2		 jne	 SHORT $LL31@Ustaw_Usta
$LN30@Ustaw_Usta:
  00584	5f		 pop	 edi

; 1389 : 			Ustawienia.g³os_szybkoæ_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00585	33 c0		 xor	 eax, eax

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00587	5e		 pop	 esi
  00588	66 a3 16 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax
  0058e	5b		 pop	 ebx
  0058f	c3		 ret	 0
$LN80@Ustaw_Usta:

; 1390 : 		}
; 1391 : 	}
; 1392 : 	else if (tekst.find("efekty_dwiêkowe") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00590	51		 push	 ecx
  00591	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@
  00596	8b ce		 mov	 ecx, esi
  00598	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0059d	83 f8 ff	 cmp	 eax, -1
  005a0	74 70		 je	 SHORT $LN87@Ustaw_Usta

; 1393 : 	{
; 1394 : 		tekst.erase(0, size("efekty_dwiêkowe")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  005a2	6a 11		 push	 17			; 00000011H
  005a4	6a 00		 push	 0
  005a6	8b ce		 mov	 ecx, esi
  005a8	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005ad	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  005b1	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  005b3	72 02		 jb	 SHORT $LN985@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005b5	8b 06		 mov	 eax, DWORD PTR [esi]
$LN985@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1395 : 		if (atoi(tekst.c_str())) Ustawienia.efekty_dwiêkowe = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  005b7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  005bd	50		 push	 eax
  005be	ff d7		 call	 edi
  005c0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  005c3	83 c4 04	 add	 esp, 4
  005c6	85 c0		 test	 eax, eax
  005c8	74 17		 je	 SHORT $LN86@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005ca	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  005cd	72 02		 jb	 SHORT $LN846@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005cf	8b 36		 mov	 esi, DWORD PTR [esi]
$LN846@Ustaw_Usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1395 : 		if (atoi(tekst.c_str())) Ustawienia.efekty_dwiêkowe = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  005d1	56		 push	 esi
  005d2	ff d7		 call	 edi
  005d4	83 c4 04	 add	 esp, 4

; 1400 : 			Ustawienia.efekty_dwiêkowe = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  005d7	66 a3 18 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, ax
  005dd	5f		 pop	 edi

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  005de	5e		 pop	 esi
  005df	5b		 pop	 ebx
  005e0	c3		 ret	 0
$LN86@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  005e1	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005e3	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  005e6	72 02		 jb	 SHORT $LN986@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005e8	8b 06		 mov	 eax, DWORD PTR [esi]
$LN986@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  005ea	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005ec	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  005ef	72 02		 jb	 SHORT $LN878@Ustaw_Usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005f1	8b 16		 mov	 edx, DWORD PTR [esi]
$LN878@Ustaw_Usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  005f3	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  005f6	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1398 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  005f8	3b c1		 cmp	 eax, ecx
  005fa	74 0e		 je	 SHORT $LN33@Ustaw_Usta
  005fc	0f 1f 40 00	 npad	 4
$LL34@Ustaw_Usta:

; 1399 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00600	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00603	75 0d		 jne	 SHORT $LN87@Ustaw_Usta

; 1398 : 			for (const auto & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca adresowi tego pola adres zmiennej i

  00605	40		 inc	 eax
  00606	3b c1		 cmp	 eax, ecx
  00608	75 f6		 jne	 SHORT $LL34@Ustaw_Usta
$LN33@Ustaw_Usta:

; 1400 : 			Ustawienia.efekty_dwiêkowe = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  0060a	33 c0		 xor	 eax, eax
  0060c	66 a3 18 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, ax
$LN87@Ustaw_Usta:

; 1401 : 		}
; 1402 : 	}
; 1403 : }

  00612	5f		 pop	 edi
  00613	5e		 pop	 esi
  00614	5b		 pop	 ebx
  00615	c3		 ret	 0
?Ustaw_Ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Ustaw_Ustawienia
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Inicjacje_Pocz¹tkowe@@YAXXZ
_TEXT	SEGMENT
_hCCI$1 = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
?Inicjacje_Pocz¹tkowe@@YAXXZ PROC			; Inicjacje_Pocz¹tkowe, COMDAT

; 1406 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 1407 : 	//Inicjowanie ustawieñ programu
; 1408 : 	WNDCLASSEX wincl; //Utworzenie typu do zmiany w³aciwoci programu
; 1409 : 	wincl.hIcon = LoadIcon(GetModuleHandle(nullptr), MAKEINTRESOURCE(IDI_ICON1)); //Przypisanie ikony programu

  00011	6a 6d		 push	 109			; 0000006dH
  00013	6a 00		 push	 0
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__LoadIconA@8
  00021	50		 push	 eax
  00022	ff d6		 call	 esi

; 1410 : 	wincl.hIconSm = LoadIcon(GetModuleHandle(nullptr), MAKEINTRESOURCE(IDI_ICON1));//Przypisanie ma³ej ikony programu

  00024	6a 6d		 push	 109			; 0000006dH
  00026	6a 00		 push	 0
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  0002e	50		 push	 eax
  0002f	ff d6		 call	 esi

; 1411 : 
; 1412 : 	//Inicjowanie funkcji
; 1413 : 	setlocale(LC_ALL, "polish"); // W celu polskich liter w konsoli

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_06JGCGFIEG@polish?$AA@
  00036	6a 00		 push	 0
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setlocale
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h

; 535  :             return _time64(_Time);

  0003e	6a 00		 push	 0
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1414 : 	srand((unsigned int)time(nullptr)); //Zainicjowanie generatorza LCG (Liniowy Generator Kongruentny) dla ma³o wa¿nych liczb

  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 401  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00050	6a f5		 push	 -11			; fffffff5H
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  00058	8b f0		 mov	 esi, eax

; 402  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 403  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0005a	8d 45 f4	 lea	 eax, DWORD PTR _hCCI$1[ebp]
  0005d	50		 push	 eax
  0005e	56		 push	 esi
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 404  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoæ widocznoci kursorsora tekstego w konsoli jest ró¿na od prawdy

  00065	83 7d f8 01	 cmp	 DWORD PTR _hCCI$1[ebp+4], 1
  00069	74 12		 je	 SHORT $LN6@Inicjacje_

; 405  : 	{
; 406  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoci kursora na widoczny
; 407  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  0006b	8d 45 f4	 lea	 eax, DWORD PTR _hCCI$1[ebp]
  0006e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _hCCI$1[ebp+4], 1
  00075	50		 push	 eax
  00076	56		 push	 esi
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8
$LN6@Inicjacje_:

; 1415 : 	Show_Cursor(); //Pokazanie kursora tekstowego w konsoli
; 1416 : }

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	33 cd		 xor	 ecx, ebp
  00082	5e		 pop	 esi
  00083	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?Inicjacje_Pocz¹tkowe@@YAXXZ ENDP			; Inicjacje_Pocz¹tkowe
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z
_TEXT	SEGMENT
_pPlik$1$ = -12						; size = 4
_dwBajtyZapisane$4 = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z PROC ; Wyci¹gnij_z_Programu, COMDAT
; _cie¿ka$ = ecx
; _numer_zasobu$ = dx

; 1419 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1420 : 	HRSRC hPlik = FindResource(GetModuleHandle(nullptr), MAKEINTRESOURCE(numer_zasobu), RT_RCDATA); //Tworz¹ uchwyt do pliku znajudj¹cego siê w plikach zasobów

  00013	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetModuleHandleA@4
  00019	8b f1		 mov	 esi, ecx
  0001b	6a 0a		 push	 10			; 0000000aH
  0001d	0f b7 c2	 movzx	 eax, dx
  00020	50		 push	 eax
  00021	6a 00		 push	 0
  00023	ff d7		 call	 edi
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  0002c	8b d8		 mov	 ebx, eax

; 1421 : 	if (hPlik != nullptr) //Je¿eli uchyt nie jest pusty (Znalaz³o zasób)

  0002e	85 db		 test	 ebx, ebx
  00030	74 74		 je	 SHORT $LN2@Wyci?

; 1422 : 	{
; 1423 : 		auto pPlik = LoadResource(GetModuleHandle(nullptr), hPlik); //Przypisujê uchwytowi miejsce ród³owe pliku

  00032	53		 push	 ebx
  00033	6a 00		 push	 0
  00035	ff d7		 call	 edi
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8

; 1424 : 		auto dwDlugosc = SizeofResource(GetModuleHandle(nullptr), hPlik); //Przypisujê zmiennej wielkoæ pliku

  0003e	53		 push	 ebx
  0003f	6a 00		 push	 0
  00041	89 45 f4	 mov	 DWORD PTR _pPlik$1$[ebp], eax
  00044	ff d7		 call	 edi
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0004d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1424 : 		auto dwDlugosc = SizeofResource(GetModuleHandle(nullptr), hPlik); //Przypisujê zmiennej wielkoæ pliku

  00051	8b f8		 mov	 edi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1594 : 		if (_Large_string_engaged())

  00053	72 02		 jb	 SHORT $LN17@Wyci?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00055	8b 36		 mov	 esi, DWORD PTR [esi]
$LN17@Wyci?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1425 : 		auto hPlik = CreateFile(cie¿ka.c_str(), GENERIC_WRITE, NULL, nullptr, CREATE_NEW, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, nullptr); //Tworzê plik

  00057	6a 00		 push	 0
  00059	68 80 00 00 08	 push	 134217856		; 08000080H
  0005e	6a 01		 push	 1
  00060	6a 00		 push	 0
  00062	6a 00		 push	 0
  00064	68 00 00 00 40	 push	 1073741824		; 40000000H
  00069	56		 push	 esi
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28

; 1426 : 		DWORD dwBajtyZapisane; //Tworzê i inicjujê zmiennn¹ informuj¹c¹ o iloæi zapisanych danych
; 1427 : 		if (!WriteFile(hPlik, pPlik, dwDlugosc, &dwBajtyZapisane, nullptr)) //Je¿eli zapis do pliku siê nie uda³

  00070	6a 00		 push	 0
  00072	8b f0		 mov	 esi, eax
  00074	8d 45 f8	 lea	 eax, DWORD PTR _dwBajtyZapisane$4[ebp]
  00077	50		 push	 eax
  00078	57		 push	 edi
  00079	ff 75 f4	 push	 DWORD PTR _pPlik$1$[ebp]
  0007c	56		 push	 esi
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00083	85 c0		 test	 eax, eax
  00085	74 1f		 je	 SHORT $LN2@Wyci?

; 1428 : 			return false; //Zwróæ fa³sz
; 1429 : 		if (dwBajtyZapisane != dwDlugosc) //Je¿eli iloæ zapisanych danych jest inna ni¿ iloæ danych do zapisania

  00087	39 7d f8	 cmp	 DWORD PTR _dwBajtyZapisane$4[ebp], edi
  0008a	75 1a		 jne	 SHORT $LN2@Wyci?

; 1430 : 			return false; //Zwróæ fa³sz
; 1431 : 		CloseHandle(hPlik); //Zamykam uchwyt do pliku ród³owego

  0008c	56		 push	 esi
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00093	5f		 pop	 edi

; 1432 : 		return true; //Zwracam, ¿e zapis siê uda³
; 1433 : 	}
; 1434 : 	else return false; //W przeciwym wypadku zwracam fa³sz
; 1435 : }

  00094	5e		 pop	 esi
  00095	b0 01		 mov	 al, 1
  00097	5b		 pop	 ebx
  00098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009b	33 cd		 xor	 ecx, ebp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN2@Wyci?:
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a9	32 c0		 xor	 al, al
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	33 cd		 xor	 ecx, ebp
  000af	5b		 pop	 ebx
  000b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ENDP ; Wyci¹gnij_z_Programu
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 24
$T1 = -44						; size = 4
$T12 = -40						; size = 24
$T29 = -16						; size = 1
$T24 = -16						; size = 1
__$EHRec$ = -12						; size = 12
?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Wypakuj_Rar, COMDAT
; _nazwa_folderu$ = ecx

; 1438 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 1439 : 	if ((_access("Rar.exe", 0))) //Sprawdzenie czy plik nie istnieje

  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_07NGJEAPOI@Rar?4exe?$AA@
  00031	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  0003e	83 c4 08	 add	 esp, 8
  00041	85 c0		 test	 eax, eax
  00043	74 75		 je	 SHORT $LN73@Wypakuj_Ra
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00045	6a 07		 push	 7
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_07NGJEAPOI@Rar?4exe?$AA@
  0004c	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]

; 3683 : 		_My_data._Mysize = 0;

  0004f	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00056	c7 45 d0 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0005d	c6 45 bc 00	 mov	 BYTE PTR $T2[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00061	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1440 : 		Wyci¹gnij_z_Programu("Rar.exe", IDR_RAR); //Je¿eli nie istnieje to wyci¹gam z pamiêci

  00066	ba bd 00 00 00	 mov	 edx, 189		; 000000bdH
  0006b	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006e	e8 00 00 00 00	 call	 ?Wyci¹gnij_z_Programu@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z ; Wyci¹gnij_z_Programu
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00073	8b 55 d0	 mov	 edx, DWORD PTR $T2[ebp+20]
  00076	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00079	72 3f		 jb	 SHORT $LN73@Wypakuj_Ra
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0007b	8b 45 bc	 mov	 eax, DWORD PTR $T2[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0007e	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0007f	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00081	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00087	72 27		 jb	 SHORT $LN76@Wypakuj_Ra

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00089	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  0008c	3b f2		 cmp	 esi, edx
  0008e	76 1a		 jbe	 SHORT $_Invalid_parameter$310

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00090	8b d6		 mov	 edx, esi
  00092	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00095	75 13		 jne	 SHORT $_Invalid_parameter$310

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00097	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  0009a	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0009c	73 0c		 jae	 SHORT $_Invalid_parameter$310

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0009e	2b c8		 sub	 ecx, eax
  000a0	83 f9 04	 cmp	 ecx, 4
  000a3	72 05		 jb	 SHORT $_Invalid_parameter$310

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  000a5	83 f9 23	 cmp	 ecx, 35			; 00000023H
  000a8	76 06		 jbe	 SHORT $LN76@Wypakuj_Ra
$_Invalid_parameter$310:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN308@Wypakuj_Ra:
$LN76@Wypakuj_Ra:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  000b0	52		 push	 edx
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000b7	83 c4 08	 add	 esp, 8
$LN73@Wypakuj_Ra:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1441 : 	system(("Rar.exe x " + nazwa_folderu).c_str()); //Wydajê polecenie rozpakowania archiwum rar

  000ba	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3047 : 		return (this->_Get_data()._Mysize);

  000c1	8d 5f 10	 lea	 ebx, DWORD PTR [edi+16]

; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  000c4	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c6	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  000c9	83 c0 0a	 add	 eax, 10			; 0000000aH

; 3683 : 		_My_data._Mysize = 0;

  000cc	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T12[ebp+16], 0

; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  000d3	50		 push	 eax

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000d4	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T12[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000db	c6 45 d8 00	 mov	 BYTE PTR $T12[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3751 : 	return (_Ans);

  000df	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  000e6	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2335 : 		const size_type _Old_size = _My_data._Mysize;

  000eb	8b 55 ec	 mov	 edx, DWORD PTR $T12[ebp+20]
  000ee	8b c2		 mov	 eax, edx
  000f0	8b 4d e8	 mov	 ecx, DWORD PTR $T12[ebp+16]
  000f3	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000f5	6a 0a		 push	 10			; 0000000aH
  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LIFPHICI@Rar?4exe?5x?5?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  000fc	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000ff	72 22		 jb	 SHORT $LN158@Wypakuj_Ra

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00101	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00104	8d 75 d8	 lea	 esi, DWORD PTR $T12[ebp]

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00107	8d 41 0a	 lea	 eax, DWORD PTR [ecx+10]

; 1583 : 		if (_Large_string_engaged())

  0010a	0f 43 75 d8	 cmovae	 esi, DWORD PTR $T12[ebp]

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0010e	03 f1		 add	 esi, ecx
  00110	89 45 e8	 mov	 DWORD PTR $T12[ebp+16], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00113	56		 push	 esi
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0011a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  0011d	c6 46 0a 00	 mov	 BYTE PTR [esi+10], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  00121	eb 11		 jmp	 SHORT $LN157@Wypakuj_Ra
$LN158@Wypakuj_Ra:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  00123	c6 45 f0 00	 mov	 BYTE PTR $T24[ebp], 0
  00127	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  0012a	ff 75 f0	 push	 DWORD PTR $T24[ebp]
  0012d	6a 0a		 push	 10			; 0000000aH
  0012f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN157@Wypakuj_Ra:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00134	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00138	72 02		 jb	 SHORT $LN190@Wypakuj_Ra
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0013a	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN190@Wypakuj_Ra:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2335 : 		const size_type _Old_size = _My_data._Mysize;

  0013c	8b 55 ec	 mov	 edx, DWORD PTR $T12[ebp+20]
  0013f	8b c2		 mov	 eax, edx

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00141	8b 1b		 mov	 ebx, DWORD PTR [ebx]

; 2335 : 		const size_type _Old_size = _My_data._Mysize;

  00143	8b 4d e8	 mov	 ecx, DWORD PTR $T12[ebp+16]
  00146	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00148	53		 push	 ebx
  00149	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  0014a	3b d8		 cmp	 ebx, eax
  0014c	77 22		 ja	 SHORT $LN197@Wypakuj_Ra

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0014e	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00151	8d 75 d8	 lea	 esi, DWORD PTR $T12[ebp]

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00154	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]

; 1583 : 		if (_Large_string_engaged())

  00157	0f 43 75 d8	 cmovae	 esi, DWORD PTR $T12[ebp]

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0015b	03 f1		 add	 esi, ecx
  0015d	89 45 e8	 mov	 DWORD PTR $T12[ebp+16], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00160	56		 push	 esi
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00167	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  0016a	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0016e	eb 10		 jmp	 SHORT $LN196@Wypakuj_Ra
$LN197@Wypakuj_Ra:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  00170	c6 45 f0 00	 mov	 BYTE PTR $T29[ebp], 0
  00174	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  00177	ff 75 f0	 push	 DWORD PTR $T29[ebp]
  0017a	53		 push	 ebx
  0017b	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN196@Wypakuj_Ra:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00180	83 7d ec 10	 cmp	 DWORD PTR $T12[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00184	8d 45 d8	 lea	 eax, DWORD PTR $T12[ebp]

; 1594 : 		if (_Large_string_engaged())

  00187	0f 43 45 d8	 cmovae	 eax, DWORD PTR $T12[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1441 : 	system(("Rar.exe x " + nazwa_folderu).c_str()); //Wydajê polecenie rozpakowania archiwum rar

  0018b	50		 push	 eax
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__system
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00192	8b 55 ec	 mov	 edx, DWORD PTR $T12[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1441 : 	system(("Rar.exe x " + nazwa_folderu).c_str()); //Wydajê polecenie rozpakowania archiwum rar

  00195	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00198	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  0019b	72 3e		 jb	 SHORT $LN272@Wypakuj_Ra
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0019d	8b 4d d8	 mov	 ecx, DWORD PTR $T12[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001a0	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001a1	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001a3	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001a9	72 26		 jb	 SHORT $LN275@Wypakuj_Ra

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001ab	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  001ae	3b f2		 cmp	 esi, edx
  001b0	76 19		 jbe	 SHORT $_Invalid_parameter$311

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001b2	8b d6		 mov	 edx, esi
  001b4	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001b6	75 13		 jne	 SHORT $_Invalid_parameter$311

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001b8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001bb	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  001bd	73 0c		 jae	 SHORT $_Invalid_parameter$311

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001bf	2b c1		 sub	 eax, ecx
  001c1	83 f8 04	 cmp	 eax, 4
  001c4	72 05		 jb	 SHORT $_Invalid_parameter$311

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  001c6	83 f8 23	 cmp	 eax, 35			; 00000023H
  001c9	76 06		 jbe	 SHORT $LN275@Wypakuj_Ra
$_Invalid_parameter$311:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN309@Wypakuj_Ra:
$LN275@Wypakuj_Ra:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  001d1	52		 push	 edx
  001d2	51		 push	 ecx
  001d3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001d8	83 c4 08	 add	 esp, 8
$LN272@Wypakuj_Ra:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1442 : }

  001db	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001de	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e5	59		 pop	 ecx
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c3		 ret	 0
$LN307@Wypakuj_Ra:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$21:
  00000	8b 45 d4	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN110@Wypakuj_Ra
  0000c	83 65 d4 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN110@Wypakuj_Ra:
  00018	c3		 ret	 0
__ehhandler$?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Wypakuj_Rar@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Wypakuj_Rar
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Przenie_Plik@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
?Przenie_Plik@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; Przenie_Plik, COMDAT
; _z_pliku$ = ecx
; _do_pliku$ = edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00004	72 02		 jb	 SHORT $LN13@Przenie?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00006	8b 12		 mov	 edx, DWORD PTR [edx]
$LN13@Przenie?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00008	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0000c	72 02		 jb	 SHORT $LN29@Przenie?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000e	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN29@Przenie?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1446 : 	return MoveFile(z_pliku.c_str(), do_pliku.c_str()); //Zwracam wynik przenoszenia pliku

  00010	52		 push	 edx
  00011	51		 push	 ecx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8
  00018	85 c0		 test	 eax, eax
  0001a	0f 95 c0	 setne	 al

; 1447 : }

  0001d	c3		 ret	 0
?Przenie_Plik@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; Przenie_Plik
_TEXT	ENDS
END
