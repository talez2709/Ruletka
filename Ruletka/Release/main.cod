; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	f:\users\krzysztof\documents\szko?a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_06JGCGFIEG@polish?$AA@			; `string'
PUBLIC	??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@		; `string'
PUBLIC	??_C@_05PDJBBECF@pause?$AA@			; `string'
PUBLIC	??_C@_0DL@POFCNLON@Jak?$LJ?5opcje?5chcesz?5obstawi?f?$DP?5?$CIzgo@ ; `string'
PUBLIC	??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@		; `string'
PUBLIC	??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@	; `string'
PUBLIC	??_C@_0BD@LEDAOJLK@r?5?9?5czerwone?5?$CIred?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BD@EPLAAEJB@b?5?9?5czarne?5?$CIblack?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@ ; `string'
PUBLIC	??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@	; `string'
PUBLIC	??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@ ; `string'
PUBLIC	??_C@_0CK@OAIPJBPB@w1?0?5w2?0?5?4?4?4?5?0?5w12?5?9?5wiersz?5trzec@ ; `string'
PUBLIC	??_C@_0CN@CGIAAFPM@0?936?5?9?5pojedy?qcze?5pole?5o?5odpowie@ ; `string'
PUBLIC	??_C@_01JBBJJEPG@p?$AA@				; `string'
PUBLIC	??_C@_01EFFIKLCJ@n?$AA@				; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_01OJONOECF@b?$AA@				; `string'
PUBLIC	??_C@_01JEJKBAGA@g?$AA@				; `string'
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	??_C@_02ICGBAFJO@k1?$AA@			; `string'
PUBLIC	??_C@_02KJEMFGFN@k2?$AA@			; `string'
PUBLIC	??_C@_02LAFHGHBM@k3?$AA@			; `string'
PUBLIC	??_C@_02JHFNFPIK@w1?$AA@			; `string'
PUBLIC	??_C@_02LMHAAMEJ@w2?$AA@			; `string'
PUBLIC	??_C@_02KFGLDNAI@w3?$AA@			; `string'
PUBLIC	??_C@_02OKCKKLMP@w4?$AA@			; `string'
PUBLIC	??_C@_02PDDBJKIO@w5?$AA@			; `string'
PUBLIC	??_C@_02NIBMMJEN@w6?$AA@			; `string'
PUBLIC	??_C@_02MBAHPIAM@w7?$AA@			; `string'
PUBLIC	??_C@_02EGJPOEMD@w8?$AA@			; `string'
PUBLIC	??_C@_02FPIENFIC@w9?$AA@			; `string'
PUBLIC	??_C@_03NCLMABJC@w10?$AA@			; `string'
PUBLIC	??_C@_03MLKHDAND@w11?$AA@			; `string'
PUBLIC	??_C@_03OAIKGDBA@w12?$AA@			; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_01FDFGLJHB@2?$AA@				; `string'
PUBLIC	??_C@_01EKENIIDA@3?$AA@				; `string'
PUBLIC	??_C@_01FAMBOPH@4?$AA@				; `string'
PUBLIC	??_C@_01BMBHCPLG@5?$AA@				; `string'
PUBLIC	??_C@_01DHDKHMHF@6?$AA@				; `string'
PUBLIC	??_C@_01COCBENDE@7?$AA@				; `string'
PUBLIC	??_C@_01KJLJFBPL@8?$AA@				; `string'
PUBLIC	??_C@_01LAKCGALK@9?$AA@				; `string'
PUBLIC	??_C@_02PKFBJPLJ@10?$AA@			; `string'
PUBLIC	??_C@_02ODEKKOPI@11?$AA@			; `string'
PUBLIC	??_C@_02MIGHPNDL@12?$AA@			; `string'
PUBLIC	??_C@_02NBHMMMHK@13?$AA@			; `string'
PUBLIC	??_C@_02JODNFKLN@14?$AA@			; `string'
PUBLIC	??_C@_02IHCGGLPM@15?$AA@			; `string'
PUBLIC	??_C@_02KMALDIDP@16?$AA@			; `string'
PUBLIC	??_C@_02LFBAAJHO@17?$AA@			; `string'
PUBLIC	??_C@_02DCIIBFLB@18?$AA@			; `string'
PUBLIC	??_C@_02CLJDCEPA@19?$AA@			; `string'
PUBLIC	??_C@_02PIBHCBOA@20?$AA@			; `string'
PUBLIC	??_C@_02OBAMBAKB@21?$AA@			; `string'
PUBLIC	??_C@_02MKCBEDGC@22?$AA@			; `string'
PUBLIC	??_C@_02NDDKHCCD@23?$AA@			; `string'
PUBLIC	??_C@_02JMHLOEOE@24?$AA@			; `string'
PUBLIC	??_C@_02IFGANFKF@25?$AA@			; `string'
PUBLIC	??_C@_02KOENIGGG@26?$AA@			; `string'
PUBLIC	??_C@_02LHFGLHCH@27?$AA@			; `string'
PUBLIC	??_C@_02DAMOKLOI@28?$AA@			; `string'
PUBLIC	??_C@_02CJNFJKKJ@29?$AA@			; `string'
PUBLIC	??_C@_02PJNFELNH@30?$AA@			; `string'
PUBLIC	??_C@_02OAMOHKJG@31?$AA@			; `string'
PUBLIC	??_C@_02MLODCJFF@32?$AA@			; `string'
PUBLIC	??_C@_02NCPIBIBE@33?$AA@			; `string'
PUBLIC	??_C@_02JNLJIOND@34?$AA@			; `string'
PUBLIC	??_C@_02IEKCLPJC@35?$AA@			; `string'
PUBLIC	??_C@_02KPIPOMFB@36?$AA@			; `string'
PUBLIC	??_C@_0CF@MANFGHNE@$?0?5jak?$LJ?5kwot?$LJ?5chcesz?5obstawi?f?5wy@ ; `string'
PUBLIC	??_C@_05OMMBNPEF@Masz?5?$AA@			; `string'
PUBLIC	??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@ ; `string'
PUBLIC	??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@ ; `string'
PUBLIC	??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@ ; `string'
PUBLIC	??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@ ; `string'
PUBLIC	??_C@_02MGHEPNFN@?$AI?$AI?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@	; `string'
PUBLIC	??_C@_02KHOJGJKF@?4?5?$AA@			; `string'
PUBLIC	??_C@_02DEPNMBPN@$?4?$AA@			; `string'
PUBLIC	??_C@_0CB@GINPHDN@Obstawi?$LDe?$JM?5poprawnie?0?5wygrywasz?5@ ; `string'
PUBLIC	??_C@_0EF@MDKBMGPE@Obstawi?$LDe?$JM?5niepoprawnie?5lecz?5uda@ ; `string'
PUBLIC	??_C@_0CF@BAJKLKHM@Obstawi?$LDe?$JM?5niepoprawnie?0?5przegra@ ; `string'
PUBLIC	??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@ ; `string'
PUBLIC	??_C@_0CO@DOCNGCMI@$?0?5czy?5chcesz?5grac?5dalej?5?$CI?8t?8?9ta@ ; `string'
PUBLIC	??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@	; `string'
PUBLIC	??_C@_01PFHFFBPC@t?$AA@				; `string'
PUBLIC	??_C@_03PFPKAEFD@tak?$AA@			; `string'
PUBLIC	??_C@_03FFMIKLGN@Tak?$AA@			; `string'
PUBLIC	??_C@_03PIABMJCP@TAK?$AA@			; `string'
PUBLIC	??_C@_03FKMOMPJO@nie?$AA@			; `string'
PUBLIC	??_C@_03PKPMGAKA@Nie?$AA@			; `string'
PUBLIC	??_C@_03FHDFACOC@NIE?$AA@			; `string'
PUBLIC	??_C@_04IBLEHOMF@?4wav?$AA@			; `string'
PUBLIC	??_C@_05PNHGCFLK@p?4wav?$AA@			; `string'
PUBLIC	??_C@_05MEKKEGFB@n?4wav?$AA@			; `string'
PUBLIC	??_C@_05LALOIELB@r?4wav?$AA@			; `string'
PUBLIC	??_C@_05LDGIIGCK@b?4wav?$AA@			; `string'
PUBLIC	??_C@_05ODKFBHJJ@g?4wav?$AA@			; `string'
PUBLIC	??_C@_05GFDBGFDH@d?4wav?$AA@			; `string'
PUBLIC	??_C@_01DICPFPGM@k?$AA@				; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@	; `string'
PUBLIC	??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@ ; `string'
PUBLIC	??_C@_09LFKNBKJA@Posiadasz?$AA@			; `string'
PUBLIC	??_C@_0L@DAFLKCID@Wylosowano?$AA@		; `string'
PUBLIC	??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@		; `string'
PUBLIC	??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@	; `string'
PUBLIC	??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@		; `string'
PUBLIC	??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@	; `string'
PUBLIC	??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@	; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@ ; `string'
PUBLIC	??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@	; `string'
PUBLIC	??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@ ; `string'
PUBLIC	??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ ; `string'
PUBLIC	??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@ ; `string'
PUBLIC	??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@ ; `string'
PUBLIC	??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@ ; `string'
PUBLIC	??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@ ; `string'
PUBLIC	??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@ ; `string'
PUBLIC	??_C@_05CMOJBPHN@G?$LDos?1?$AA@			; `string'
PUBLIC	??_C@_05KFCKMKOB@Jacek?$AA@			; `string'
PUBLIC	??_C@_03FPCJKMNP@Ewa?$AA@			; `string'
PUBLIC	??_C@_04CDICBAGM@Maja?$AA@			; `string'
PUBLIC	??_C@_03JIHJHPIE@Jan?$AA@			; `string'
PUBLIC	??_C@_06DKNIKMFF@Jacek2?$AA@			; `string'
PUBLIC	??_C@_04PLEDLCJI@Ewa2?$AA@			; `string'
PUBLIC	??_C@_05KJFHPLBC@Maja2?$AA@			; `string'
PUBLIC	??_C@_04HDNGKDH@Jan2?$AA@			; `string'
PUBLIC	??_C@_05NKPCGME@Agata?$AA@			; `string'
PUBLIC	??_C@_01IDAFKMJL@_?$AA@				; `string'
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_04JLFAMLOH@G?$LDos?$AA@			; `string'
PUBLIC	??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ ; `string'
PUBLIC	??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@ ; `string'
PUBLIC	??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@ ; `string'
PUBLIC	??_C@_0M@COFBHHKL@setting?4txt?$AA@		; `string'
PUBLIC	??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@ ; `string'
PUBLIC	??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ ; `string'
PUBLIC	??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@ ; `string'
PUBLIC	??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@ ; `string'
PUBLIC	??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@ ; `string'
PUBLIC	??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@ ; `string'
PUBLIC	??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@	; `string'
PUBLIC	??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@	; `string'
PUBLIC	??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@ ; `string'
PUBLIC	??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@ ; `string'
PUBLIC	??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@	; `string'
PUBLIC	??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@ ; `string'
PUBLIC	??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@ ; `string'
PUBLIC	??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@ ; `string'
PUBLIC	??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@ ; `string'
PUBLIC	??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@ ; `string'
PUBLIC	??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@ ; `string'
PUBLIC	??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@ ; `string'
PUBLIC	??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@ ; `string'
PUBLIC	??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@ ; `string'
PUBLIC	??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@ ; `string'
PUBLIC	??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@ ; `string'
PUBLIC	??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@ ; `string'
PUBLIC	??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@ ; `string'
PUBLIC	??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ ; `string'
PUBLIC	??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ ; `string'
PUBLIC	??_C@_01EPMOAMKG@$?$AA@				; `string'
PUBLIC	??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@		; `string'
PUBLIC	??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@		; `string'
PUBLIC	??_C@_07KIPBKJCE@win?4wav?$AA@			; `string'
PUBLIC	??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@ ; `string'
PUBLIC	??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@		; `string'
PUBLIC	??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@ ; `string'
PUBLIC	??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@ ; `string'
PUBLIC	??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@ ; `string'
PUBLIC	??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@ ; `string'
PUBLIC	??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@		; `string'
PUBLIC	??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@	; `string'
PUBLIC	??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@	; `string'
PUBLIC	??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@ ; `string'
PUBLIC	??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@		; `string'
PUBLIC	??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@ ; `string'
PUBLIC	??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ ; `string'
PUBLIC	??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@ ; `string'
PUBLIC	??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@ ; `string'
PUBLIC	??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@	; `string'
PUBLIC	??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@	; `string'
PUBLIC	??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@	; `string'
PUBLIC	??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@	; `string'
PUBLIC	??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@	; `string'
PUBLIC	??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@ ; `string'
PUBLIC	??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	?EfektyKompletne@@3_NA				; EfektyKompletne
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Czas@@3U_SYSTEMTIME@@A				; Czas
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?G³osyKompletne@@3_NA				; G³osyKompletne
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?is@?$ctype@D@std@@QBE_NFD@Z:PROC
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?eof@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	__imp_?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC
EXTRN	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync
EXTRN	__imp_?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
EXTRN	__imp_?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC
EXTRN	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow
EXTRN	__imp_?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC
EXTRN	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:PROC
EXTRN	__imp___get_stream_buffer_pointers:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp___fseeki64:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp__GetSystemTime@4:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__fsetpos:PROC
EXTRN	__imp____std_terminate:PROC
EXTRN	__imp__ungetc:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp__memchr:PROC
EXTRN	__imp__setvbuf:PROC
EXTRN	__imp__fgetpos:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp___lock_file:PROC
EXTRN	__imp___unlock_file:PROC
EXTRN	__imp__SetConsoleCursorInfo@8:PROC
EXTRN	__imp___access:PROC
EXTRN	__imp__system:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__PlaySoundA@12:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp__fgetc:PROC
EXTRN	_atexit:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp__URLDownloadToFileA@20:PROC
EXTRN	__imp__remove:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Random_device@std@@YAIXZ:PROC
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_BADOFF@std@@3_JB:QWORD
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exceptions@std@@YAHXZ:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp__fclose:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp__fflush:PROC
EXTRN	__imp__GetConsoleCursorInfo@8:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp__GetStdHandle@4:PROC
EXTRN	__imp__SetConsoleTextAttribute@8:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp__fputc:PROC
EXTRN	__imp__setlocale:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp____CxxFrameHandler3:PROC
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
?Czas@@3U_SYSTEMTIME@@A DB 010H DUP (?)			; Czas
_BSS	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	078H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	078H
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	070H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	070H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
?EfektyKompletne@@3_NA DB 01H				; EfektyKompletne
?G³osyKompletne@@3_NA DB 01H				; G³osyKompletne
_DATA	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	058H
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	068H
?Ruletka_ko³o@@3QBGB DW 00H				; Ruletka_ko³o
	DW	020H
	DW	0fH
	DW	013H
	DW	04H
	DW	015H
	DW	02H
	DW	019H
	DW	011H
	DW	022H
	DW	06H
	DW	01bH
	DW	0dH
	DW	024H
	DW	0bH
	DW	01eH
	DW	08H
	DW	017H
	DW	0aH
	DW	05H
	DW	018H
	DW	010H
	DW	021H
	DW	01H
	DW	014H
	DW	0eH
	DW	01fH
	DW	09H
	DW	016H
	DW	012H
	DW	01dH
	DW	07H
	DW	01cH
	DW	0cH
	DW	023H
	DW	03H
	DW	01aH
	ORG $+6
?Ruletka_plansza_kolor_col@@3QBGB DW 02H		; Ruletka_plansza_kolor_col
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	ORG $+2
?Ruletka_plansza_kolor@@3QBDB DB 067H			; Ruletka_plansza_kolor
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$alloc'
	DB	'ator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@
CONST	SEGMENT
??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@ DB 'efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@
CONST	SEGMENT
??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@ DB 'g', 0b3H, 'o'
	DB	's_szybko', 09cH, 0e6H, '_odczytu_numeru', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@
CONST	SEGMENT
??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@ DB 'g', 0b3H, 'os_odczytu_n'
	DB	'umeru', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@
CONST	SEGMENT
??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@ DB 'czy_kontynuowa', 0e6H, '_'
	DB	'gr', 0eaH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@
CONST	SEGMENT
??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@ DB 'stan_d', 09fH, 'wi', 0eaH, 'k'
	DB	0f3H, 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@
CONST	SEGMENT
??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@ DB 'kwota_pocz', 0b9H, 'tkowa'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@
CONST	SEGMENT
??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@ DB 'styl_liczenia_wygranej'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@
CONST	SEGMENT
??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@ DB 'czas_przeskoku_kul'
	DB	'ki_wolny', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@
CONST	SEGMENT
??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@ DB 'czas_przeskoku_ku'
	DB	'lki_szybki', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
CONST	SEGMENT
??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ DB 'ilo', 09cH, 0e6H
	DB	'_max_dodatkowych_obrot', 0f3H, 'w_ruletki', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@
CONST	SEGMENT
??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@ DB 'ilo', 09cH
	DB	0e6H, '_minimalna_obrot', 0f3H, 'w_ruletki', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
CONST	SEGMENT
??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@ DB ' Wylosowano ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@
CONST	SEGMENT
??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@ DB 'Kulka w gr'
	DB	'ze, zaczekaj na wylosowanie numeru...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
CONST	SEGMENT
??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@ DB ' Obstawiono zaklad ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@
CONST	SEGMENT
??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@ DB 'Obstawiono zak', 0b3H
	DB	'ad ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
CONST	SEGMENT
??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@ DB 'Obstawiono za ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@
CONST	SEGMENT
??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@ DB 'Gratuluje zwi'
	DB	0eaH, 'kszy', 0b3H, 'e', 09cH, ' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@
CONST	SEGMENT
??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@ DB ' krotnie '
	DB	'sw', 0f3H, 'j zas', 0f3H, 'b finansowy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@
CONST	SEGMENT
??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@ DB 'Grat'
	DB	'uluje zwi', 0eaH, 'kszy', 0b3H, 'e', 09cH, ' sw', 0f3H, 'j za'
	DB	's', 0f3H, 'b finansowy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
CONST	SEGMENT
??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@ DB 'Ko', 0f1H, 'cz'
	DB	'ysz gr', 0eaH, ' z wynikiem ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
CONST	SEGMENT
??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@ DB ' Przegrales ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
CONST	SEGMENT
??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@ DB ' Dostajesz '
	DB	'polowe zak', 0b3H, 'adu ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KIPBKJCE@win?4wav?$AA@
CONST	SEGMENT
??_C@_07KIPBKJCE@win?4wav?$AA@ DB 'win.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
CONST	SEGMENT
??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@ DB ' Posiadasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
CONST	SEGMENT
??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@ DB ' Wygrywasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EPMOAMKG@$?$AA@
CONST	SEGMENT
??_C@_01EPMOAMKG@$?$AA@ DB '$', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
CONST	SEGMENT
??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ DB 'N'
	DB	'ie mo', 0bfH, 'esz mie', 0e6H, ' wy', 0b3H, 0b9H, 'czonych d', 09fH
	DB	'wi', 0eaH, 'k', 0f3H, 'w i w', 0b3H, 0b9H, 'czon', 0b9H, ' mo'
	DB	'w', 0eaH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
CONST	SEGMENT
??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ DB 'N'
	DB	'ie mo', 0bfH, 'esz mie', 0e6H, ' wy', 0b3H, 0b9H, 'czonych d', 09fH
	DB	'wi', 0eaH, 'k', 0f3H, 'w i w', 0b3H, 0b9H, 'czonych efekt', 0f3H
	DB	'w d', 09fH, 'wi', 0eaH, 'kowych', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@
CONST	SEGMENT
??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@ DB 'Opcja efe'
	DB	'kty d', 09fH, 'wi', 0eaH, 'kowe przyjmuje warto', 09cH, 'ci 0'
	DB	' lub 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@
CONST	SEGMENT
??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@ DB 'Opcja'
	DB	' szybko', 09cH, 0e6H, ' g', 0b3H, 'osu odczytu przyjmuje wart'
	DB	'o', 09cH, 'ci w przedziale [1;5]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@
CONST	SEGMENT
??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@ DB 'Opcja g', 0b3H
	DB	'os odczytu numeru przyjmuje warto', 09cH, 'ci w przedziale [0'
	DB	';10]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@
CONST	SEGMENT
??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@ DB 'Opcja kontynu'
	DB	'owania gry przyjmuje warto', 09cH, 'ci tylko 0 lub 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@
CONST	SEGMENT
??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@ DB 'Stan '
	DB	'd', 09fH, 'wi', 0eaH, 'k', 0f3H, 'w przyjmuje warto', 09cH, 'c'
	DB	'i tylko 0 lub 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@
CONST	SEGMENT
??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@ DB 'Kwot'
	DB	'a pocz', 0b9H, 'tkowa nie mo', 0bfH, 'e by', 0e6H, ' mniejsza'
	DB	' od zera', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@
CONST	SEGMENT
??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@ DB 'Czas'
	DB	' przerwy d', 09fH, 'wi', 0eaH, 'ku nie mo', 0bfH, 'e by', 0e6H
	DB	' mniejszy od zera', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@
CONST	SEGMENT
??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@ DB 'Styl liczeia '
	DB	'wygranej przyjmuje warto', 09cH, 'ci tylko 0 lub 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@
CONST	SEGMENT
??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@ DB 'Jedna z dek'
	DB	'laracji w sprawie obrot', 0f3H, 'w ruletki musi by', 0e6H, ' '
	DB	'wi', 0eaH, 'ksza od zera', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@
CONST	SEGMENT
??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@ DB 'Ilo', 09cH
	DB	0e6H, ' max obrot', 0f3H, 'w ruletki nie mo', 0bfH, 'e by', 0e6H
	DB	' mniejsza od 0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@
CONST	SEGMENT
??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@ DB 'Ilo', 09cH
	DB	0e6H, ' minimalna obrot', 0f3H, 'w ruletki nie mo', 0bfH, 'e b'
	DB	'y', 0e6H, ' mniejsza od 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
CONST	SEGMENT
??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@ DB 'Ustawiam do'
	DB	'my', 09cH, 'lne ustawienie', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@
CONST	SEGMENT
??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@ DB 'Warto', 09cH
	DB	0e6H, ' wolnego czasu przeskoku kulki musi by', 0e6H, ' ni', 0bfH
	DB	'sza ni', 0bfH, ' warto', 09cH, 0e6H, ' szybkiego czasu przesk'
	DB	'oku kulki', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@
CONST	SEGMENT
??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@ DB 'efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@
CONST	SEGMENT
??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@ DB 'g', 0b3H
	DB	'os_szybko', 09cH, 0e6H, '_odczytu_numeru 4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@
CONST	SEGMENT
??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@ DB 'g', 0b3H, 'os_odczyt'
	DB	'u_numeru 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@
CONST	SEGMENT
??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@ DB 'czy_kontynuowa', 0e6H
	DB	'_gr', 0eaH, ' 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@
CONST	SEGMENT
??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@ DB 'stan_d', 09fH, 'wi', 0eaH
	DB	'k', 0f3H, 'w 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@
CONST	SEGMENT
??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@ DB 'kwota_pocz', 0b9H, 't'
	DB	'kowa 1000', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@
CONST	SEGMENT
??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@ DB 'styl_liczenia_wygra'
	DB	'nej 1', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@
CONST	SEGMENT
??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@ DB 'czas_przerwy_dzwi', 0eaH
	DB	'ku 500', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@
CONST	SEGMENT
??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@ DB 'czas_przeskoku'
	DB	'_kulki_wolny 75', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@
CONST	SEGMENT
??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@ DB 'czas_przeskok'
	DB	'u_kulki_szybki 50', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
CONST	SEGMENT
??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ DB 'ilo', 09cH, 0e6H
	DB	'_max_dodatkowych_obrot', 0f3H, 'w_ruletki 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@
CONST	SEGMENT
??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@ DB 'ilo', 09cH
	DB	0e6H, '_minimalna_obrot', 0f3H, 'w_ruletki 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COFBHHKL@setting?4txt?$AA@
CONST	SEGMENT
??_C@_0M@COFBHHKL@setting?4txt?$AA@ DB 'setting.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@
CONST	SEGMENT
??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@ DB 'Pobr'
	DB	'ano brakuj', 0b9H, 'ce pliki g', 0b3H, 'os', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
CONST	SEGMENT
??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@ DB 'Brak p'
	DB	'lik', 0f3H, 'w dla g', 0b3H, 'osu oraz nie mo', 0bfH, 'na pob'
	DB	'ra', 0e6H, ' danych, wy', 0b3H, 0b9H, 'czono odczytywanie wyn'
	DB	'iku', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
CONST	SEGMENT
??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ DB 'Rozpoczynam'
	DB	' pobieranie brakuj', 0b9H, 'cych plik', 0f3H, 'w g', 0b3H, 'o'
	DB	's', 0f3H, 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLFAMLOH@G?$LDos?$AA@
CONST	SEGMENT
??_C@_04JLFAMLOH@G?$LDos?$AA@ DB 'G', 0b3H, 'os', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/G%C5%82os/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IDAFKMJL@_?$AA@
CONST	SEGMENT
??_C@_01IDAFKMJL@_?$AA@ DB '_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NKPCGME@Agata?$AA@
CONST	SEGMENT
??_C@_05NKPCGME@Agata?$AA@ DB 'Agata', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDNGKDH@Jan2?$AA@
CONST	SEGMENT
??_C@_04HDNGKDH@Jan2?$AA@ DB 'Jan2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KJFHPLBC@Maja2?$AA@
CONST	SEGMENT
??_C@_05KJFHPLBC@Maja2?$AA@ DB 'Maja2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PLEDLCJI@Ewa2?$AA@
CONST	SEGMENT
??_C@_04PLEDLCJI@Ewa2?$AA@ DB 'Ewa2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKNIKMFF@Jacek2?$AA@
CONST	SEGMENT
??_C@_06DKNIKMFF@Jacek2?$AA@ DB 'Jacek2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JIHJHPIE@Jan?$AA@
CONST	SEGMENT
??_C@_03JIHJHPIE@Jan?$AA@ DB 'Jan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CDICBAGM@Maja?$AA@
CONST	SEGMENT
??_C@_04CDICBAGM@Maja?$AA@ DB 'Maja', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FPCJKMNP@Ewa?$AA@
CONST	SEGMENT
??_C@_03FPCJKMNP@Ewa?$AA@ DB 'Ewa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFCKMKOB@Jacek?$AA@
CONST	SEGMENT
??_C@_05KFCKMKOB@Jacek?$AA@ DB 'Jacek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
CONST	SEGMENT
??_C@_05CMOJBPHN@G?$LDos?1?$AA@ DB 'G', 0b3H, 'os/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@
CONST	SEGMENT
??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@ DB 'Pobran'
	DB	'o brakuj', 0b9H, 'ce pliki efekt', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/zwielokrotnenie.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
CONST	SEGMENT
??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/zwielokrotnenie.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/wygrana2.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
CONST	SEGMENT
??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/wygrana2.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/wygrana1.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
CONST	SEGMENT
??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/wygrana1.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
CONST	SEGMENT
??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@ DB 'Brak p'
	DB	'lik', 0f3H, 'w dla efekt', 0f3H, 'w d', 09fH, 'wi', 0eaH, 'ko'
	DB	'wych oraz nie mo', 0bfH, 'na pobra', 0e6H, ' danych, wy', 0b3H
	DB	0b9H, 'czono efekty d', 09fH, 'wi', 0eaH, 'kowe muzyczne, w', 0b3H
	DB	0b9H, 'czono efekty systemowe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/bankrut.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
CONST	SEGMENT
??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ DB 'Rozpoczynam'
	DB	' pobieranie brakuj', 0b9H, 'cych plik', 0f3H, 'w efekt', 0f3H
	DB	'w', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
CONST	SEGMENT
??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/bankrut.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
CONST	SEGMENT
??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@ DB 'Efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@
CONST	SEGMENT
??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@ DB 'Nowa gra rozpoc'
	DB	'zeta dnia ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@
CONST	SEGMENT
??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@ DB 'Gra rozpoczeta dnia ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
CONST	SEGMENT
??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@ DB ' o godzinie ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@
CONST	SEGMENT
??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@ DB 'Gra rozpoczeta dnia', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@
CONST	SEGMENT
??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@ DB 'Obstawiono za', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
CONST	SEGMENT
??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@ DB 'Obstawiono zaklad', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
CONST	SEGMENT
??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@ DB ' Wylosowano', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DAFLKCID@Wylosowano?$AA@
CONST	SEGMENT
??_C@_0L@DAFLKCID@Wylosowano?$AA@ DB 'Wylosowano', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LFKNBKJA@Posiadasz?$AA@
CONST	SEGMENT
??_C@_09LFKNBKJA@Posiadasz?$AA@ DB 'Posiadasz', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@
CONST	SEGMENT
??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@ DB 'Uruch'
	DB	'omiono ponownie gr', 0eaH, ' z wy', 0b3H, 0b9H, 'czon', 0b9H, ' '
	DB	'opcj', 0b9H, ' kontynuowania', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
CONST	SEGMENT
??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@ DB 'log_aktualny.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DICPFPGM@k?$AA@
CONST	SEGMENT
??_C@_01DICPFPGM@k?$AA@ DB 'k', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFDBGFDH@d?4wav?$AA@
CONST	SEGMENT
??_C@_05GFDBGFDH@d?4wav?$AA@ DB 'd.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ODKFBHJJ@g?4wav?$AA@
CONST	SEGMENT
??_C@_05ODKFBHJJ@g?4wav?$AA@ DB 'g.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LDGIIGCK@b?4wav?$AA@
CONST	SEGMENT
??_C@_05LDGIIGCK@b?4wav?$AA@ DB 'b.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LALOIELB@r?4wav?$AA@
CONST	SEGMENT
??_C@_05LALOIELB@r?4wav?$AA@ DB 'r.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEKKEGFB@n?4wav?$AA@
CONST	SEGMENT
??_C@_05MEKKEGFB@n?4wav?$AA@ DB 'n.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PNHGCFLK@p?4wav?$AA@
CONST	SEGMENT
??_C@_05PNHGCFLK@p?4wav?$AA@ DB 'p.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBLEHOMF@?4wav?$AA@
CONST	SEGMENT
??_C@_04IBLEHOMF@?4wav?$AA@ DB '.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FHDFACOC@NIE?$AA@
CONST	SEGMENT
??_C@_03FHDFACOC@NIE?$AA@ DB 'NIE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PKPMGAKA@Nie?$AA@
CONST	SEGMENT
??_C@_03PKPMGAKA@Nie?$AA@ DB 'Nie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKMOMPJO@nie?$AA@
CONST	SEGMENT
??_C@_03FKMOMPJO@nie?$AA@ DB 'nie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PIABMJCP@TAK?$AA@
CONST	SEGMENT
??_C@_03PIABMJCP@TAK?$AA@ DB 'TAK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFMIKLGN@Tak?$AA@
CONST	SEGMENT
??_C@_03FFMIKLGN@Tak?$AA@ DB 'Tak', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFPKAEFD@tak?$AA@
CONST	SEGMENT
??_C@_03PFPKAEFD@tak?$AA@ DB 'tak', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PFHFFBPC@t?$AA@
CONST	SEGMENT
??_C@_01PFHFFBPC@t?$AA@ DB 't', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@
CONST	SEGMENT
??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@ DB 'Na koncie masz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DOCNGCMI@$?0?5czy?5chcesz?5grac?5dalej?5?$CI?8t?8?9ta@
CONST	SEGMENT
??_C@_0CO@DOCNGCMI@$?0?5czy?5chcesz?5grac?5dalej?5?$CI?8t?8?9ta@ DB '$, c'
	DB	'zy chcesz grac dalej (''t''-tak, ''n''-nie) ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@
CONST	SEGMENT
??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@ DB 'Nie m'
	DB	'o', 0bfH, 'esz kontynuowa', 0e6H, ', przegra', 0b3H, 'e', 09cH
	DB	' wszystko', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BAJKLKHM@Obstawi?$LDe?$JM?5niepoprawnie?0?5przegra@
CONST	SEGMENT
??_C@_0CF@BAJKLKHM@Obstawi?$LDe?$JM?5niepoprawnie?0?5przegra@ DB 'Obstawi'
	DB	0b3H, 'e', 09cH, ' niepoprawnie, przegra', 0b3H, 'e', 09cH, ' '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@MDKBMGPE@Obstawi?$LDe?$JM?5niepoprawnie?5lecz?5uda@
CONST	SEGMENT
??_C@_0EF@MDKBMGPE@Obstawi?$LDe?$JM?5niepoprawnie?5lecz?5uda@ DB 'Obstawi'
	DB	0b3H, 'e', 09cH, ' niepoprawnie lecz uda', 0b3H, 'o Ci si', 0eaH
	DB	', dostajesz po', 0b3H, 'ow', 0eaH, ' zak', 0b3H, 'adu ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GINPHDN@Obstawi?$LDe?$JM?5poprawnie?0?5wygrywasz?5@
CONST	SEGMENT
??_C@_0CB@GINPHDN@Obstawi?$LDe?$JM?5poprawnie?0?5wygrywasz?5@ DB 'Obstawi'
	DB	0b3H, 'e', 09cH, ' poprawnie, wygrywasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DEPNMBPN@$?4?$AA@
CONST	SEGMENT
??_C@_02DEPNMBPN@$?4?$AA@ DB '$.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KHOJGJKF@?4?5?$AA@
CONST	SEGMENT
??_C@_02KHOJGJKF@?4?5?$AA@ DB '. ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
CONST	SEGMENT
??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@ DB 'Wylosowano numer ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
CONST	SEGMENT
??_C@_02MGHEPNFN@?$AI?$AI?$AA@ DB 08H, 08H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@
CONST	SEGMENT
??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@ DB 'Ni'
	DB	'e mo', 0bfH, 'esz obstawi', 0e6H, ' ujemn', 0b9H, ' kwot', 0b9H
	DB	' zak', 0b3H, 'adu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@
CONST	SEGMENT
??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@ DB 'Nie masz tyle pie'
	DB	'ni', 0eaH, 'dzy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@
CONST	SEGMENT
??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@ DB 'Nie mo', 0bfH
	DB	'esz obstawi', 0e6H, ' zerowego zak', 0b3H, 'adu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@
CONST	SEGMENT
??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@ DB 'Wpro'
	DB	'wadzi', 0b3H, 'e', 0e6H, ' nieprawid', 0b3H, 'ow', 0b9H, ' wa'
	DB	'rto', 09cH, 0e6H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OMMBNPEF@Masz?5?$AA@
CONST	SEGMENT
??_C@_05OMMBNPEF@Masz?5?$AA@ DB 'Masz ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MANFGHNE@$?0?5jak?$LJ?5kwot?$LJ?5chcesz?5obstawi?f?5wy@
CONST	SEGMENT
??_C@_0CF@MANFGHNE@$?0?5jak?$LJ?5kwot?$LJ?5chcesz?5obstawi?f?5wy@ DB '$, '
	DB	'jak', 0b9H, ' kwot', 0b9H, ' chcesz obstawi', 0e6H, ' wynik?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPIPOMFB@36?$AA@
CONST	SEGMENT
??_C@_02KPIPOMFB@36?$AA@ DB '36', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IEKCLPJC@35?$AA@
CONST	SEGMENT
??_C@_02IEKCLPJC@35?$AA@ DB '35', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JNLJIOND@34?$AA@
CONST	SEGMENT
??_C@_02JNLJIOND@34?$AA@ DB '34', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NCPIBIBE@33?$AA@
CONST	SEGMENT
??_C@_02NCPIBIBE@33?$AA@ DB '33', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MLODCJFF@32?$AA@
CONST	SEGMENT
??_C@_02MLODCJFF@32?$AA@ DB '32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OAMOHKJG@31?$AA@
CONST	SEGMENT
??_C@_02OAMOHKJG@31?$AA@ DB '31', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PJNFELNH@30?$AA@
CONST	SEGMENT
??_C@_02PJNFELNH@30?$AA@ DB '30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CJNFJKKJ@29?$AA@
CONST	SEGMENT
??_C@_02CJNFJKKJ@29?$AA@ DB '29', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DAMOKLOI@28?$AA@
CONST	SEGMENT
??_C@_02DAMOKLOI@28?$AA@ DB '28', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LHFGLHCH@27?$AA@
CONST	SEGMENT
??_C@_02LHFGLHCH@27?$AA@ DB '27', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KOENIGGG@26?$AA@
CONST	SEGMENT
??_C@_02KOENIGGG@26?$AA@ DB '26', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IFGANFKF@25?$AA@
CONST	SEGMENT
??_C@_02IFGANFKF@25?$AA@ DB '25', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMHLOEOE@24?$AA@
CONST	SEGMENT
??_C@_02JMHLOEOE@24?$AA@ DB '24', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NDDKHCCD@23?$AA@
CONST	SEGMENT
??_C@_02NDDKHCCD@23?$AA@ DB '23', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MKCBEDGC@22?$AA@
CONST	SEGMENT
??_C@_02MKCBEDGC@22?$AA@ DB '22', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OBAMBAKB@21?$AA@
CONST	SEGMENT
??_C@_02OBAMBAKB@21?$AA@ DB '21', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PIBHCBOA@20?$AA@
CONST	SEGMENT
??_C@_02PIBHCBOA@20?$AA@ DB '20', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLJDCEPA@19?$AA@
CONST	SEGMENT
??_C@_02CLJDCEPA@19?$AA@ DB '19', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCIIBFLB@18?$AA@
CONST	SEGMENT
??_C@_02DCIIBFLB@18?$AA@ DB '18', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFBAAJHO@17?$AA@
CONST	SEGMENT
??_C@_02LFBAAJHO@17?$AA@ DB '17', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KMALDIDP@16?$AA@
CONST	SEGMENT
??_C@_02KMALDIDP@16?$AA@ DB '16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IHCGGLPM@15?$AA@
CONST	SEGMENT
??_C@_02IHCGGLPM@15?$AA@ DB '15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JODNFKLN@14?$AA@
CONST	SEGMENT
??_C@_02JODNFKLN@14?$AA@ DB '14', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NBHMMMHK@13?$AA@
CONST	SEGMENT
??_C@_02NBHMMMHK@13?$AA@ DB '13', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MIGHPNDL@12?$AA@
CONST	SEGMENT
??_C@_02MIGHPNDL@12?$AA@ DB '12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ODEKKOPI@11?$AA@
CONST	SEGMENT
??_C@_02ODEKKOPI@11?$AA@ DB '11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PKFBJPLJ@10?$AA@
CONST	SEGMENT
??_C@_02PKFBJPLJ@10?$AA@ DB '10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LAKCGALK@9?$AA@
CONST	SEGMENT
??_C@_01LAKCGALK@9?$AA@ DB '9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8?$AA@
CONST	SEGMENT
??_C@_01KJLJFBPL@8?$AA@ DB '8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01COCBENDE@7?$AA@
CONST	SEGMENT
??_C@_01COCBENDE@7?$AA@ DB '7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DHDKHMHF@6?$AA@
CONST	SEGMENT
??_C@_01DHDKHMHF@6?$AA@ DB '6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BMBHCPLG@5?$AA@
CONST	SEGMENT
??_C@_01BMBHCPLG@5?$AA@ DB '5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FAMBOPH@4?$AA@
CONST	SEGMENT
??_C@_01FAMBOPH@4?$AA@ DB '4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EKENIIDA@3?$AA@
CONST	SEGMENT
??_C@_01EKENIIDA@3?$AA@ DB '3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FDFGLJHB@2?$AA@
CONST	SEGMENT
??_C@_01FDFGLJHB@2?$AA@ DB '2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OAIKGDBA@w12?$AA@
CONST	SEGMENT
??_C@_03OAIKGDBA@w12?$AA@ DB 'w12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MLKHDAND@w11?$AA@
CONST	SEGMENT
??_C@_03MLKHDAND@w11?$AA@ DB 'w11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NCLMABJC@w10?$AA@
CONST	SEGMENT
??_C@_03NCLMABJC@w10?$AA@ DB 'w10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FPIENFIC@w9?$AA@
CONST	SEGMENT
??_C@_02FPIENFIC@w9?$AA@ DB 'w9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGJPOEMD@w8?$AA@
CONST	SEGMENT
??_C@_02EGJPOEMD@w8?$AA@ DB 'w8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MBAHPIAM@w7?$AA@
CONST	SEGMENT
??_C@_02MBAHPIAM@w7?$AA@ DB 'w7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NIBMMJEN@w6?$AA@
CONST	SEGMENT
??_C@_02NIBMMJEN@w6?$AA@ DB 'w6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDDBJKIO@w5?$AA@
CONST	SEGMENT
??_C@_02PDDBJKIO@w5?$AA@ DB 'w5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OKCKKLMP@w4?$AA@
CONST	SEGMENT
??_C@_02OKCKKLMP@w4?$AA@ DB 'w4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KFGLDNAI@w3?$AA@
CONST	SEGMENT
??_C@_02KFGLDNAI@w3?$AA@ DB 'w3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMHAAMEJ@w2?$AA@
CONST	SEGMENT
??_C@_02LMHAAMEJ@w2?$AA@ DB 'w2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JHFNFPIK@w1?$AA@
CONST	SEGMENT
??_C@_02JHFNFPIK@w1?$AA@ DB 'w1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LAFHGHBM@k3?$AA@
CONST	SEGMENT
??_C@_02LAFHGHBM@k3?$AA@ DB 'k3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KJEMFGFN@k2?$AA@
CONST	SEGMENT
??_C@_02KJEMFGFN@k2?$AA@ DB 'k2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ICGBAFJO@k1?$AA@
CONST	SEGMENT
??_C@_02ICGBAFJO@k1?$AA@ DB 'k1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JEJKBAGA@g?$AA@
CONST	SEGMENT
??_C@_01JEJKBAGA@g?$AA@ DB 'g', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OJONOECF@b?$AA@
CONST	SEGMENT
??_C@_01OJONOECF@b?$AA@ DB 'b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n?$AA@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n?$AA@ DB 'n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p?$AA@
CONST	SEGMENT
??_C@_01JBBJJEPG@p?$AA@ DB 'p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CGIAAFPM@0?936?5?9?5pojedy?qcze?5pole?5o?5odpowie@
CONST	SEGMENT
??_C@_0CN@CGIAAFPM@0?936?5?9?5pojedy?qcze?5pole?5o?5odpowie@ DB '0-36 - p'
	DB	'ojedy', 0f1H, 'cze pole o odpowiednim numerze', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OAIPJBPB@w1?0?5w2?0?5?4?4?4?5?0?5w12?5?9?5wiersz?5trzec@
CONST	SEGMENT
??_C@_0CK@OAIPJBPB@w1?0?5w2?0?5?4?4?4?5?0?5w12?5?9?5wiersz?5trzec@ DB 'w1'
	DB	', w2, ... , w12 - wiersz trzech numer', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@
CONST	SEGMENT
??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@ DB 'k1, k'
	DB	'2, k3 - kolumna 1, kolumna 2, kolumna 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@
CONST	SEGMENT
??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@ DB 'd - dolna po', 0b3H, 'o'
	DB	'wa', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@
CONST	SEGMENT
??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@ DB 'g - g', 0f3H, 'rna p'
	DB	'o', 0b3H, 'owa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EPLAAEJB@b?5?9?5czarne?5?$CIblack?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@EPLAAEJB@b?5?9?5czarne?5?$CIblack?$CJ?$AA@ DB 'b - czarne (blac'
	DB	'k)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LEDAOJLK@r?5?9?5czerwone?5?$CIred?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@LEDAOJLK@r?5?9?5czerwone?5?$CIred?$CJ?$AA@ DB 'r - czerwone (re'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@
CONST	SEGMENT
??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@ DB 'n - nieparzyste', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@
CONST	SEGMENT
??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@ DB 'p - parzyste', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@POFCNLON@Jak?$LJ?5opcje?5chcesz?5obstawi?f?$DP?5?$CIzgo@
CONST	SEGMENT
??_C@_0DL@POFCNLON@Jak?$LJ?5opcje?5chcesz?5obstawi?f?$DP?5?$CIzgo@ DB 'Ja'
	DB	'k', 0b9H, ' opcje chcesz obstawi', 0e6H, '? (zgodnie z poni', 0bfH
	DB	'szym opisem) :', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause?$AA@
CONST	SEGMENT
??_C@_05PDJBBECF@pause?$AA@ DB 'pause', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@
CONST	SEGMENT
??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@ DB 'log_og', 0f3H, 'lny.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGCGFIEG@polish?$AA@
CONST	SEGMENT
??_C@_06JGCGFIEG@polish?$AA@ DB 'polish', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ; std::uniform_int<int>::_Adjust
PUBLIC	?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAII@Z		; std::uniform_int<int>::_Adjust
PUBLIC	??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QAE@AAVrandom_device@1@@Z ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>
PUBLIC	??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEII@Z ; std::_Rng_from_urng<unsigned int,std::random_device>::operator()
PUBLIC	?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEIXZ ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z ; std::_Traits_equal<std::char_traits<char> >
PUBLIC	??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@ABEHAAVrandom_device@1@HH@Z ; std::uniform_int<int>::_Eval<std::random_device>
PUBLIC	??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
PUBLIC	?_Get_bytes@?$_Default_allocate_traits@$00@std@@SAPAXII@Z ; std::_Default_allocate_traits<1>::_Get_bytes
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPAXIII@Z ; std::_Allocate<std::_Default_allocate_traits<1> >
PUBLIC	??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
PUBLIC	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
PUBLIC	??$_Refancy@PAD$0A@@std@@YAPADPAD@Z		; std::_Refancy<char *,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$size@D$0BN@@std@@YAIAAY0BN@$$CBD@Z		; std::size<char,29>
PUBLIC	??$size@D$0BE@@std@@YAIAAY0BE@$$CBD@Z		; std::size<char,20>
PUBLIC	??$size@D$0O@@std@@YAIAAY0O@$$CBD@Z		; std::size<char,14>
PUBLIC	??$size@D$0BB@@std@@YAIAAY0BB@$$CBD@Z		; std::size<char,17>
PUBLIC	??$size@D$0BH@@std@@YAIAAY0BH@$$CBD@Z		; std::size<char,23>
PUBLIC	??$size@D$0BL@@std@@YAIAAY0BL@$$CBD@Z		; std::size<char,27>
PUBLIC	??$size@D$0BM@@std@@YAIAAY0BM@$$CBD@Z		; std::size<char,28>
PUBLIC	??$size@D$0CG@@std@@YAIAAY0CG@$$CBD@Z		; std::size<char,38>
PUBLIC	??$size@D$0CA@@std@@YAIAAY0CA@$$CBD@Z		; std::size<char,32>
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?RVrandom_device@std@@@?$uniform_int@H@std@@QBEHAAVrandom_device@1@@Z ; std::uniform_int<int>::operator()<std::random_device>
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z	; std::uniform_int<int>::param_type::_Init
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
PUBLIC	??0param_type@?$uniform_int@H@std@@QAE@HH@Z	; std::uniform_int<int>::param_type::param_type
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ	; std::fpos<_Mbstatet>::seekpos
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
PUBLIC	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
PUBLIC	?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
PUBLIC	?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
PUBLIC	?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
PUBLIC	??0?$uniform_int@H@std@@QAE@HH@Z		; std::uniform_int<int>::uniform_int<int>
PUBLIC	?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ; std::pointer_traits<char *>::pointer_to
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_fstream<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::close
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
PUBLIC	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
PUBLIC	??0?$uniform_int_distribution@H@std@@QAE@HH@Z	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
PUBLIC	?Ustaw_ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ustaw_ustawienia
PUBLIC	?Pêtla_g³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; Pêtla_g³ówna
PUBLIC	?Koniec_gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z ; Koniec_gry
PUBLIC	?Og³o_wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ; Og³o_wynik
PUBLIC	?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?Sprawd_ustawienia@@YAXXZ			; Sprawd_ustawienia
PUBLIC	?Sprawd_Pliki@@YAXXZ				; Sprawd_Pliki
PUBLIC	?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Wczytaj_z_pliku
PUBLIC	?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
PUBLIC	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Odczytaj_liczbê
PUBLIC	?Wylosuj@@YAHABH0@Z				; Wylosuj
PUBLIC	?Show_Cursor@@YAXXZ				; Show_Cursor
PUBLIC	?Hide_Cursor@@YAXXZ				; Hide_Cursor
PUBLIC	?Change_Col@@YAXABH@Z				; Change_Col
PUBLIC	?Czy_Kontynuowaæ@@YA_NABH@Z			; Czy_Kontynuowaæ
PUBLIC	?Sprawd_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Sprawd_Zak³ad
PUBLIC	?Zakrêæ_Ruletk¹@@YAHXZ				; Zakrêæ_Ruletk¹
PUBLIC	?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z		; Wczytaj_Kwotê_Zak³adu
PUBLIC	?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Obstaw
PUBLIC	?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	_main
PUBLIC	??0S_Ustawienia@@QAE@XZ				; S_Ustawienia::S_Ustawienia
PUBLIC	??Rrandom_device@std@@QAEIXZ			; std::random_device::operator()
PUBLIC	?entropy@random_device@std@@QBENXZ		; std::random_device::entropy
PUBLIC	?max@random_device@std@@SAIXZ			; std::random_device::max
PUBLIC	?min@random_device@std@@SAIXZ			; std::random_device::min
PUBLIC	??0random_device@std@@QAE@XZ			; std::random_device::random_device
PUBLIC	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z		; std::_Ungetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	?_Deallocate@std@@YAXPAXIII@Z			; std::_Deallocate
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?eq@?$char_traits@D@std@@SA_NABD0@Z		; std::char_traits<char>::eq
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAPADQADID@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?find@?$char_traits@D@std@@SAPBDQBDIABD@Z	; std::char_traits<char>::find
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	?compare@?$char_traits@D@std@@SAHQBD0I@Z	; std::char_traits<char>::compare
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
PUBLIC	?Ustawienia@@3US_Ustawienia@@A			; Ustawienia
PUBLIC	__real@4040000000000000
PUBLIC	__real@4042800000000000
EXTRN	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___std_terminate:PROC
EXTRN	__dtoui3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
CRT$XCU	SEGMENT
?G³os$initializer$@@3P6AXXZA DD FLAT:??__EG³os@@YAXXZ	; G³os$initializer$
CRT$XCU	ENDS
;	COMDAT __real@4042800000000000
CONST	SEGMENT
__real@4042800000000000 DQ 04042800000000000r	; 37
CONST	ENDS
;	COMDAT __real@4040000000000000
CONST	SEGMENT
__real@4040000000000000 DQ 04040000000000000r	; 32
	ORG $+2
?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; G³os
	DB	19 DUP(00H)
	DD	0fH
?Ustawienia@@3US_Ustawienia@@A DW 02H			; Ustawienia
	DW	03H
	DW	032H
	DW	04bH
	DW	01f4H
	DW	01H
	DD	03e8H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$5
	DD	01H
	DD	FLAT:__unwindfunclet$_main$6
	DD	02H
	DD	FLAT:__unwindfunclet$_main$8
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
	DD	04H
	DD	FLAT:__unwindfunclet$_main$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Czy_Kontynuowaæ@@YA_NABH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Czy_Kontynuowaæ@@YA_NABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Czy_Kontynuowaæ@@YA_NABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Czy_Kontynuowaæ@@YA_NABH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$19
	DD	00H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$20
	DD	01H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	04H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$10
	DD	06H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$11
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$406
	DD	08H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$407
	DD	09H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$409
	DD	03H
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$13
	DD	0bH
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$14
	DD	0cH
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$15
	DD	0dH
	DD	FLAT:__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Sprawd_Pliki@@YAXXZ DD 019930522H
	DD	037H
	DD	FLAT:__unwindtable$?Sprawd_Pliki@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Sprawd_Pliki@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$5
	DD	02H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$6
	DD	03H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$7
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$10
	DD	05H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$11
	DD	06H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$12
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$15
	DD	08H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$16
	DD	09H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$17
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$20
	DD	0bH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$21
	DD	0cH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$22
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$25
	DD	0eH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$26
	DD	0fH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$27
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$30
	DD	011H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$31
	DD	012H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$32
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$34
	DD	014H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$35
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$37
	DD	016H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$38
	DD	017H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$39
	DD	018H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$40
	DD	019H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$41
	DD	01aH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$42
	DD	01bH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$43
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$645
	DD	01dH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$646
	DD	01eH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$648
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$45
	DD	020H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$46
	DD	021H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$47
	DD	022H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$48
	DD	020H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$50
	DD	024H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$51
	DD	025H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$52
	DD	026H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$53
	DD	027H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$54
	DD	028H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$55
	DD	029H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$56
	DD	02aH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$57
	DD	02bH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$58
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$60
	DD	02dH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$61
	DD	02eH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$62
	DD	02dH
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$64
	DD	030H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$65
	DD	031H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$66
	DD	032H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$67
	DD	033H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$68
	DD	034H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$69
	DD	035H
	DD	FLAT:__unwindfunclet$?Sprawd_Pliki@@YAXXZ$70
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Sprawd_ustawienia@@YAXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Sprawd_ustawienia@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Sprawd_ustawienia@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$0
	DD	03H
	DD	FLAT:__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$12
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$11
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$35
__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$35 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$30
__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$30 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$10
__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$dead$ = ecx

; 535  :             return _time64(_Time);

  00000	6a 00		 push	 0
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00008	83 c4 04	 add	 esp, 4

; 536  :         }

  0000b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
;	COMDAT _memcpy_s
_TEXT	SEGMENT
__Source$ = 8						; size = 4
__SourceSize$dead$ = 12					; size = 4
_memcpy_s PROC						; COMDAT
; __Destination$ = ecx
; __DestinationSize$dead$ = edx

; 41   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   :         if (_SourceSize == 0)
; 43   :         {
; 44   :             return 0;
; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  00003	85 c9		 test	 ecx, ecx
  00005	74 12		 je	 SHORT $LN10@memcpy_s

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00007	8b 45 08	 mov	 eax, DWORD PTR __Source$[ebp]
  0000a	85 c0		 test	 eax, eax
  0000c	74 08		 je	 SHORT $LN5@memcpy_s

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;
; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

  0000e	8a 00		 mov	 al, BYTE PTR [eax]
  00010	88 01		 mov	 BYTE PTR [ecx], al

; 60   :         return 0;

  00012	33 c0		 xor	 eax, eax

; 61   :     }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  00016	c6 01 00	 mov	 BYTE PTR [ecx], 0
$LN10@memcpy_s:

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0001f	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  0002b	b8 16 00 00 00	 mov	 eax, 22			; 00000016H

; 61   :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_memcpy_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 60   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 61   :         _Data._What = _Message;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  0000f	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0
  00014	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 62   :     }

  00017	8b c1		 mov	 eax, ecx
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_copy
  00024	83 c4 08	 add	 esp, 8

; 68   :     }

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00010	59		 pop	 ecx

; 85   :     }

  00011	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 90   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 83   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 84   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00016	83 c4 04	 add	 esp, 4
  00019	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001d	74 0b		 je	 SHORT $LN6@scalar
  0001f	6a 0c		 push	 12			; 0000000cH
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN6@scalar:
  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 683  : 		return (INT_MAX);

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 684  : 		}

  00005	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Size$dead$ = ecx
; __Where$ = edx

; 179  :         (void)_Size;
; 180  :         return _Where;

  00000	8b c2		 mov	 eax, edx

; 181  :     }

  00002	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHQBD0I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?compare@?$char_traits@D@std@@SAHQBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 399  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  00007	83 ee 04	 sub	 esi, 4
  0000a	72 15		 jb	 SHORT $LN5@compare
  0000c	0f 1f 40 00	 npad	 4
$LL6@compare:
  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	3b 02		 cmp	 eax, DWORD PTR [edx]
  00014	75 10		 jne	 SHORT $LN4@compare
  00016	83 c1 04	 add	 ecx, 4
  00019	83 c2 04	 add	 edx, 4
  0001c	83 ee 04	 sub	 esi, 4
  0001f	73 ef		 jae	 SHORT $LL6@compare
$LN5@compare:
  00021	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00024	74 35		 je	 SHORT $LN3@compare
$LN4@compare:
  00026	8a 01		 mov	 al, BYTE PTR [ecx]
  00028	3a 02		 cmp	 al, BYTE PTR [edx]
  0002a	75 27		 jne	 SHORT $LN7@compare
  0002c	83 fe fd	 cmp	 esi, -3			; fffffffdH
  0002f	74 2a		 je	 SHORT $LN3@compare
  00031	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00034	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  00037	75 1a		 jne	 SHORT $LN7@compare
  00039	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0003c	74 1d		 je	 SHORT $LN3@compare
  0003e	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00041	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  00044	75 0d		 jne	 SHORT $LN7@compare
  00046	83 fe ff	 cmp	 esi, -1
  00049	74 10		 je	 SHORT $LN3@compare
  0004b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0004e	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00051	74 08		 je	 SHORT $LN3@compare
$LN7@compare:
  00053	1b c0		 sbb	 eax, eax
  00055	83 c8 01	 or	 eax, 1
  00058	5e		 pop	 esi

; 401  : 		}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN3@compare:

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 401  : 		}

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHQBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT
; __First$ = ecx

; 405  : 		return (_CSTD strlen(_First));

  00000	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL3@length:
  00003	8a 01		 mov	 al, BYTE PTR [ecx]
  00005	41		 inc	 ecx
  00006	84 c0		 test	 al, al
  00008	75 f9		 jne	 SHORT $LL3@length
  0000a	2b ca		 sub	 ecx, edx
  0000c	8b c1		 mov	 eax, ecx

; 406  : 		}

  0000e	c3		 ret	 0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 410  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00003	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00006	52		 push	 edx
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memcpy
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 412  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?find@?$char_traits@D@std@@SAPBDQBDIABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?find@?$char_traits@D@std@@SAPBDQBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT
; __First$ = ecx
; __Count$ = edx

; 424  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	52		 push	 edx
  00007	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 426  : 		}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?find@?$char_traits@D@std@@SAPBDQBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 430  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00003	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00006	52		 push	 edx
  00007	51		 push	 ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADQADID@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?assign@?$char_traits@D@std@@SAPADQADID@Z PROC		; std::char_traits<char>::assign, COMDAT
; __First$ = ecx
; __Count$ = edx

; 436  : 		{	// assign _Count * _Ch to [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00003	0f be 45 08	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00007	52		 push	 edx
  00008	50		 push	 eax
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 _memset
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 438  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPADQADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 442  : 		_Left = _Right;

  00000	8a 02		 mov	 al, BYTE PTR [edx]
  00002	88 01		 mov	 BYTE PTR [ecx], al

; 443  : 		}

  00004	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT
?eq@?$char_traits@D@std@@SA_NABD0@Z PROC		; std::char_traits<char>::eq, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 447  : 		return (_Left == _Right);

  00000	8a 01		 mov	 al, BYTE PTR [ecx]
  00002	3a 02		 cmp	 al, BYTE PTR [edx]
  00004	0f 94 c0	 sete	 al

; 448  : 		}

  00007	c3		 ret	 0
?eq@?$char_traits@D@std@@SA_NABD0@Z ENDP		; std::char_traits<char>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT
; __Meta$ = ecx

; 457  : 		return (static_cast<char>(_Meta));

  00000	8a 01		 mov	 al, BYTE PTR [ecx]

; 458  : 		}

  00002	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT
; __Ch$ = ecx

; 462  : 		return (static_cast<unsigned char>(_Ch));

  00000	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 463  : 		}

  00003	c3		 ret	 0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 467  : 		return (_Left == _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 02		 cmp	 eax, DWORD PTR [edx]
  00004	0f 94 c0	 sete	 al

; 468  : 		}

  00007	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT
; __Meta$ = ecx

; 471  : 		{	// return anything but EOF

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 472  : 		return (_Meta != eof() ? _Meta : !eof());

  00002	33 c9		 xor	 ecx, ecx
  00004	83 f8 ff	 cmp	 eax, -1
  00007	0f 44 c1	 cmove	 eax, ecx

; 473  : 		}

  0000a	c3		 ret	 0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 477  : 		return (EOF);

  00000	83 c8 ff	 or	 eax, -1

; 478  : 		}

  00003	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 74   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$dead$ = ecx

; 85   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXIII@Z
_TEXT	SEGMENT
__Sz$dead$ = 8						; size = 4
__Align$dead$ = 12					; size = 4
?_Deallocate@std@@YAXPAXIII@Z PROC			; std::_Deallocate, COMDAT
; __Ptr$ = ecx
; __Count$ = edx

; 144  : 	(void)_Align;
; 145  : 
; 146  : 	if (_Count > static_cast<size_t>(-1) / _Sz)
; 147  : 		{
; 148  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 149  : 		}
; 150  : 
; 151  : 		{
; 152  : 		size_t _Allocated_size = _Count * _Sz;
; 153  : 
; 154  : #if defined(_M_IX86) || defined(_M_X64)
; 155  : 		// Boost the alignment of big allocations to help autovectorization.
; 156  :  #pragma warning(push)
; 157  :  #pragma warning(disable: 4127) // conditional expression is constant
; 158  :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00000	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00006	72 23		 jb	 SHORT $LN4@Deallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00008	8d 42 23	 lea	 eax, DWORD PTR [edx+35]
  0000b	3b c2		 cmp	 eax, edx
  0000d	76 27		 jbe	 SHORT $_Invalid_parameter$17

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0000f	8b d0		 mov	 edx, eax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00011	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00014	75 20		 jne	 SHORT $_Invalid_parameter$17

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00016	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00019	3b c1		 cmp	 eax, ecx
  0001b	73 19		 jae	 SHORT $_Invalid_parameter$17

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0001d	2b c8		 sub	 ecx, eax
  0001f	83 f9 04	 cmp	 ecx, 4
  00022	72 12		 jb	 SHORT $_Invalid_parameter$17

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00024	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00027	77 0d		 ja	 SHORT $_Invalid_parameter$17

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c8		 mov	 ecx, eax
$LN4@Deallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0002b	52		 push	 edx
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8

; 245  : 	}

  00035	c3		 ret	 0
$_Invalid_parameter$17:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00036	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Deallocate@std@@YAXPAXIII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT
; __Len$ = ecx

; 1259 : 	return (_Len);

  00000	8b c1		 mov	 eax, ecx

; 1260 : 	}

  00002	c3		 ret	 0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_typeinfo.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 127  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 128  :     }

  00003	8b c1		 mov	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h

; 59   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 60   :     {
; 61   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_typeinfo.h

; 127  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@

; 128  :     }

  00017	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 83   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 84   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00016	83 c4 04	 add	 esp, 4
  00019	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001d	74 0b		 je	 SHORT $LN9@scalar
  0001f	6a 0c		 push	 12			; 0000000cH
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN9@scalar:
  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00010	59		 pop	 ecx
  00011	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 402  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1locale@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 403  : 		if (_Ptr != 0)

  00022	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00025	85 c9		 test	 ecx, ecx
  00027	74 11		 je	 SHORT $LN4@locale

; 404  : 			delete _Ptr->_Decref();

  00029	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002b	ff 50 08	 call	 DWORD PTR [eax+8]
  0002e	85 c0		 test	 eax, eax
  00030	74 08		 je	 SHORT $LN4@locale
  00032	8b 10		 mov	 edx, DWORD PTR [eax]
  00034	8b c8		 mov	 ecx, eax
  00036	6a 01		 push	 1
  00038	ff 12		 call	 DWORD PTR [edx]
$LN4@locale:

; 405  : 		}

  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1locale@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1locale@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 429  : 		{	// look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __Id$[ebp]
  0000a	3b 71 0c	 cmp	 esi, DWORD PTR [ecx+12]
  0000d	73 0c		 jae	 SHORT $LN6@Getfacet
  0000f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00012	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00015	85 c0		 test	 eax, eax
  00017	75 22		 jne	 SHORT $LN3@Getfacet
  00019	eb 02		 jmp	 SHORT $LN10@Getfacet
$LN6@Getfacet:

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0001b	33 c0		 xor	 eax, eax
$LN10@Getfacet:

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0001d	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00021	74 18		 je	 SHORT $LN3@Getfacet

; 433  : 			return (_Facptr);	// found facet or not transparent
; 434  : 		else
; 435  : 			{	// look in current locale
; 436  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 437  : 			return (_Id < _Ptr0->_Facetcount

  00029	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  0002c	73 0b		 jae	 SHORT $LN8@Getfacet
  0002e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00031	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00034	5e		 pop	 esi

; 438  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 439  : 				: 0);	// no entry in current locale
; 440  : 			}
; 441  : 		}

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN8@Getfacet:

; 437  : 			return (_Id < _Ptr0->_Facetcount

  00039	33 c0		 xor	 eax, eax
$LN3@Getfacet:
  0003b	5e		 pop	 esi

; 438  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 439  : 				: 0);	// no entry in current locale
; 440  : 			}
; 441  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT
; __Byte$ = ecx
; __File$ = edx

; 47   : 	{	// get a char element from a C stream

  00000	56		 push	 esi

; 48   : 	int _Meta;
; 49   : 	if ((_Meta = fgetc(_File)) == EOF)

  00001	52		 push	 edx
  00002	8b f1		 mov	 esi, ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  0000a	83 c4 04	 add	 esp, 4
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	75 04		 jne	 SHORT $LN2@Fgetc

; 50   : 		return (false);

  00012	32 c0		 xor	 al, al
  00014	5e		 pop	 esi

; 55   : 		}
; 56   : 	}

  00015	c3		 ret	 0
$LN2@Fgetc:

; 51   : 	else
; 52   : 		{	// got one, convert to char
; 53   : 		_Byte = (char)_Meta;

  00016	88 06		 mov	 BYTE PTR [esi], al

; 54   : 		return (true);

  00018	b0 01		 mov	 al, 1
  0001a	5e		 pop	 esi

; 55   : 		}
; 56   : 	}

  0001b	c3		 ret	 0
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT
; __Byte$ = cl
; __File$ = edx

; 93   : 	return (fputc(_Byte, _File) != EOF);

  00000	52		 push	 edx
  00001	0f be c1	 movsx	 eax, cl
  00004	50		 push	 eax
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputc
  0000b	83 c4 08	 add	 esp, 8
  0000e	83 f8 ff	 cmp	 eax, -1
  00011	0f 95 c0	 setne	 al

; 94   : 	}

  00014	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT
; __Byte$ = ecx
; __File$ = edx

; 117  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  00000	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00003	52		 push	 edx
  00004	50		 push	 eax
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ungetc
  0000b	83 c4 08	 add	 esp, 8
  0000e	83 f8 ff	 cmp	 eax, -1
  00011	0f 95 c0	 setne	 al

; 118  : 	}

  00014	c3		 ret	 0
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0random_device@std@@QAE@XZ
_TEXT	SEGMENT
??0random_device@std@@QAE@XZ PROC			; std::random_device::random_device, COMDAT
; _this$ = ecx

; 6386 : 		{	// construct
; 6387 : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0random_device@std@@QAE@XZ ENDP			; std::random_device::random_device
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?min@random_device@std@@SAIXZ
_TEXT	SEGMENT
?min@random_device@std@@SAIXZ PROC			; std::random_device::min, COMDAT

; 6395 : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 6396 : 		}

  00002	c3		 ret	 0
?min@random_device@std@@SAIXZ ENDP			; std::random_device::min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?max@random_device@std@@SAIXZ
_TEXT	SEGMENT
?max@random_device@std@@SAIXZ PROC			; std::random_device::max, COMDAT

; 6400 : 		return (static_cast<result_type>(-1));

  00000	83 c8 ff	 or	 eax, -1

; 6401 : 		}

  00003	c3		 ret	 0
?max@random_device@std@@SAIXZ ENDP			; std::random_device::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?entropy@random_device@std@@QBENXZ
_TEXT	SEGMENT
?entropy@random_device@std@@QBENXZ PROC			; std::random_device::entropy, COMDAT
; _this$dead$ = ecx

; 6405 : 		return (32.0);

  00000	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4040000000000000

; 6406 : 		}

  00008	c3		 ret	 0
?entropy@random_device@std@@QBENXZ ENDP			; std::random_device::entropy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??Rrandom_device@std@@QAEIXZ
_TEXT	SEGMENT
??Rrandom_device@std@@QAEIXZ PROC			; std::random_device::operator(), COMDAT
; _this$dead$ = ecx

; 6410 : 		return (_Random_device());

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?_Random_device@std@@YAIXZ
??Rrandom_device@std@@QAEIXZ ENDP			; std::random_device::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ??__EG³os@@YAXXZ
text$di	SEGMENT
??__EG³os@@YAXXZ PROC					; `dynamic initializer for 'G³os'', COMDAT

; 72   : string G³os;

  00000	68 00 00 00 00	 push	 OFFSET ??__FG³os@@YAXXZ	; `dynamic atexit destructor for 'G³os''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__EG³os@@YAXXZ ENDP					; `dynamic initializer for 'G³os''
text$di	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??__FG³os@@YAXXZ
text$yd	SEGMENT
??__FG³os@@YAXXZ PROC					; `dynamic atexit destructor for 'G³os'', COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00009	72 3a		 jb	 SHORT $LN41@dynamic
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00010	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 22		 jb	 SHORT $LN44@dynamic

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00019	8d 51 23	 lea	 edx, DWORD PTR [ecx+35]
  0001c	3b d1		 cmp	 edx, ecx
  0001e	76 41		 jbe	 SHORT $_Invalid_parameter$76

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00020	8b ca		 mov	 ecx, edx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00022	a8 1f		 test	 al, 31			; 0000001fH
  00024	75 3b		 jne	 SHORT $_Invalid_parameter$76

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00026	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00029	3b d0		 cmp	 edx, eax
  0002b	73 34		 jae	 SHORT $_Invalid_parameter$76

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0002d	2b c2		 sub	 eax, edx
  0002f	83 f8 04	 cmp	 eax, 4
  00032	72 2d		 jb	 SHORT $_Invalid_parameter$76

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00034	83 f8 23	 cmp	 eax, 35			; 00000023H
  00037	77 28		 ja	 SHORT $_Invalid_parameter$76

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00039	8b c2		 mov	 eax, edx
$LN44@dynamic:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0003b	51		 push	 ecx
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00042	83 c4 08	 add	 esp, 8
$LN41@dynamic:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00045	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0004f	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00059	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00060	c3		 ret	 0
$_Invalid_parameter$76:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00061	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
??__FG³os@@YAXXZ ENDP					; `dynamic atexit destructor for 'G³os''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0S_Ustawienia@@QAE@XZ
_TEXT	SEGMENT
??0S_Ustawienia@@QAE@XZ PROC				; S_Ustawienia::S_Ustawienia, COMDAT
; _this$dead$ = ecx
  00000	b9 01 00 00 00	 mov	 ecx, 1
  00005	c7 05 00 00 00
	00 02 00 03 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A, 196610 ; 00030002H
  0000f	c7 05 04 00 00
	00 32 00 4b 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+4, 4915250 ; 004b0032H
  00019	b8 00 00 00 00	 mov	 eax, OFFSET ?Ustawienia@@3US_Ustawienia@@A ; Ustawienia
  0001e	c7 05 08 00 00
	00 f4 01 01 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+8, 66036 ; 000101f4H
  00028	c7 05 0c 00 00
	00 e8 03 00 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, 1000 ; 000003e8H
  00032	c7 05 10 00 00
	00 01 00 01 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 65537 ; 00010001H
  0003c	c7 05 14 00 00
	00 01 00 04 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, 262145 ; 00040001H
  00046	66 89 0d 18 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, cx
  0004d	c3		 ret	 0
??0S_Ustawienia@@QAE@XZ ENDP				; S_Ustawienia::S_Ustawienia
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_wylosowana_liczba$ = -432				; size = 4
_this$ = -428						; size = 4
_kwota_zak³adu$ = -428					; size = 4
$T1 = -424						; size = 4
_iloæ_pieniêdzy$ = -424				; size = 4
_co_kontynuowaæ$ = -417					; size = 1
_log_ogólny$ = -416					; size = 176
_log$ = -240						; size = 192
_typ_zak³adu$ = -48					; size = 24
_hCCI$12 = -24						; size = 8
_wygrana$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_main
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a4 01 00
	00		 sub	 esp, 420		; 000001a4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 78   : 	//Inicjowanie funkcji
; 79   : 	setlocale(LC_ALL, "polish"); // W celu polskich liter w konsoli

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_06JGCGFIEG@polish?$AA@
  00031	6a 00		 push	 0
  00033	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setlocale
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00043	6a 00		 push	 0
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 80   : 	srand((unsigned int)time(nullptr)); //Zainicjowanie generatorza LCG (Liniowy Generator Kongruentny) dla ma³o wa¿nych liczb

  0004b	50		 push	 eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand
  00052	83 c4 10	 add	 esp, 16			; 00000010H

; 396  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00055	6a f5		 push	 -11			; fffffff5H
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  0005d	8b f0		 mov	 esi, eax

; 397  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 398  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0005f	8d 45 e8	 lea	 eax, DWORD PTR _hCCI$12[ebp]
  00062	50		 push	 eax
  00063	56		 push	 esi
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 399  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoæ widocznoci kursorsora tekstego w konsoli jest ró¿na od prawdy

  0006a	83 7d ec 01	 cmp	 DWORD PTR _hCCI$12[ebp+4], 1
  0006e	74 12		 je	 SHORT $LN12@main

; 400  : 	{
; 401  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoci kursora na widoczny
; 402  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  00070	8d 45 e8	 lea	 eax, DWORD PTR _hCCI$12[ebp]
  00073	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _hCCI$12[ebp+4], 1
  0007a	50		 push	 eax
  0007b	56		 push	 esi
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8
$LN12@main:

; 81   : 	Show_Cursor(); //Pokazanie kursora tekstowego w konsoli
; 82   : 
; 83   : 	Sprawd_ustawienia(); //Wczytanie ustawieñ z pliku

  00082	e8 00 00 00 00	 call	 ?Sprawd_ustawienia@@YAXXZ ; Sprawd_ustawienia

; 84   : 	Sprawd_Pliki(); //Wczytanie plików audio

  00087	e8 00 00 00 00	 call	 ?Sprawd_Pliki@@YAXXZ	; Sprawd_Pliki
  0008c	68 b0 00 00 00	 push	 176			; 000000b0H
  00091	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _log_ogólny$[ebp]
  00097	6a 00		 push	 0
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _memset

; 87   : 	ofstream log_ogólny; //Utworzenie typu do celu zapisu do pliku

  0009f	83 c4 08	 add	 esp, 8
  000a2	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  000a8	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000ad	51		 push	 ecx
  000ae	6a 0a		 push	 10			; 0000000aH
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@
  000b5	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+4]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 87   : 	ofstream log_ogólny; //Utworzenie typu do celu zapisu do pliku

  000bb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000c2	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  000c7	85 c0		 test	 eax, eax

; 1150 : 			_Myios::setstate(ios_base::failbit);

  000c9	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  000cf	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _log_ogólny$[ebp]
  000d5	6a 00		 push	 0
  000d7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000da	75 0c		 jne	 SHORT $LN18@main
  000dc	6a 02		 push	 2
  000de	03 c8		 add	 ecx, eax
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1151 : 		else

  000e6	eb 0a		 jmp	 SHORT $LN19@main
$LN18@main:

; 1152 : 			_Myios::clear();	// added with C++11

  000e8	6a 00		 push	 0
  000ea	03 c8		 add	 ecx, eax
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN19@main:
  000f2	68 c0 00 00 00	 push	 192			; 000000c0H
  000f7	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp]
  000fd	6a 00		 push	 0
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _memset
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1206 : 		{	// construct unopened

  00108	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00112	8d 4d 88	 lea	 ecx, DWORD PTR _log$[ebp+120]
  00115	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+16], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00125	6a 00		 push	 0
  00127	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp+24]
  0012d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00131	50		 push	 eax
  00132	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp]
  00138	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T1[ebp], 1
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00148	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0014f	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
  00155	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00158	c7 84 05 10 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _log$[ebp+eax], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00163	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
  00169	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016c	8d 41 88	 lea	 eax, DWORD PTR [ecx-120]
  0016f	89 84 0d 0c ff
	ff ff		 mov	 DWORD PTR _log$[ebp+ecx-4], eax
  00176	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp+24]

; 155  : 		: _Mysb()

  0017c	8b c8		 mov	 ecx, eax

; 1206 : 		{	// construct unopened

  0017e	89 85 54 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 155  : 		: _Mysb()

  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0018a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  0018e	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+24]

; 156  : 		{	// construct from pointer to C stream

  00194	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+24], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 636  : 		_Closef = _Which == _Openfl;

  0019e	c6 85 70 ff ff
	ff 00		 mov	 BYTE PTR _log$[ebp+96], 0

; 637  : 		_Wrotesome = false;

  001a5	c6 85 65 ff ff
	ff 00		 mov	 BYTE PTR _log$[ebp+85], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;
; 663  : 		_State = _Stinit;

  001b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  001b7	89 85 68 ff ff
	ff		 mov	 DWORD PTR _log$[ebp+88], eax
  001bd	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  001c2	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+100], 0
  001cc	89 85 6c ff ff
	ff		 mov	 DWORD PTR _log$[ebp+92], eax

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  001d2	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _log$[ebp+80], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 90   : 	int iloæ_pieniêdzy = Ustawienia.kwota_pocz¹tkowa, kwota_zak³adu, wylosowana_liczba, wygrana; //Zmienne do których wczytuje siê wartoci liczbowe pobrane od u¿ytkownika takie jak kwota zak³adu a przechowuje iloæ posiadanych pieniêdzy a tak¿e przechowuje wyniki funkcji losowania liczby z ruletki i kwote wygran¹ z zak³adu

  001dc	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12
  001e1	89 85 58 fe ff
	ff		 mov	 DWORD PTR _iloæ_pieniêdzy$[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  001e7	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001ee	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  001f5	c6 45 d0 00	 mov	 BYTE PTR _typ_zak³adu$[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 94   : 	Wczytaj_z_pliku(log_ogólny, log, co_kontynuowaæ, iloæ_pieniêdzy, kwota_zak³adu, wylosowana_liczba, typ_zak³adu); //Wczytanie stanu gry z pliku

  001f9	8d 45 d0	 lea	 eax, DWORD PTR _typ_zak³adu$[ebp]
  001fc	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00200	50		 push	 eax
  00201	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00207	50		 push	 eax
  00208	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _kwota_zak³adu$[ebp]
  0020e	50		 push	 eax
  0020f	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00215	50		 push	 eax
  00216	8d 85 5f fe ff
	ff		 lea	 eax, DWORD PTR _co_kontynuowaæ$[ebp]
  0021c	50		 push	 eax
  0021d	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR _log$[ebp]
  00223	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  00229	e8 00 00 00 00	 call	 ?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Wczytaj_z_pliku
  0022e	83 c4 14	 add	 esp, 20			; 00000014H
$LL4@main:

; 95   : 
; 96   : 	do
; 97   : 	{
; 98   : 		Pêtla_g³ówna(wygrana, kwota_zak³adu, iloæ_pieniêdzy, log_ogólny, log, co_kontynuowaæ, typ_zak³adu, wylosowana_liczba); //Funkcja obs³uguj¹ca wszystkie elementy gry

  00231	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00237	50		 push	 eax
  00238	8d 45 d0	 lea	 eax, DWORD PTR _typ_zak³adu$[ebp]
  0023b	50		 push	 eax
  0023c	8d 85 5f fe ff
	ff		 lea	 eax, DWORD PTR _co_kontynuowaæ$[ebp]
  00242	50		 push	 eax
  00243	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _log$[ebp]
  00249	50		 push	 eax
  0024a	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _log_ogólny$[ebp]
  00250	50		 push	 eax
  00251	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00257	50		 push	 eax
  00258	8d 95 54 fe ff
	ff		 lea	 edx, DWORD PTR _kwota_zak³adu$[ebp]
  0025e	8d 4d ec	 lea	 ecx, DWORD PTR _wygrana$[ebp]
  00261	e8 00 00 00 00	 call	 ?Pêtla_g³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; Pêtla_g³ówna
  00266	83 c4 18	 add	 esp, 24			; 00000018H

; 99   : 		co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  00269	c6 85 5f fe ff
	ff 6e		 mov	 BYTE PTR _co_kontynuowaæ$[ebp], 110 ; 0000006eH

; 100  : 	} while (Czy_Kontynuowaæ(iloæ_pieniêdzy)); //Pêtla dza³aj¹ca do czasu wartoci fa³sz zwróconej przez funkcjê Czy_kontynuowaæ

  00270	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00276	e8 00 00 00 00	 call	 ?Czy_Kontynuowaæ@@YA_NABH@Z ; Czy_Kontynuowaæ
  0027b	84 c0		 test	 al, al
  0027d	75 b2		 jne	 SHORT $LL4@main

; 101  : 
; 102  : 	Koniec_gry(log_ogólny, log, iloæ_pieniêdzy); //Zakoñczenie gry i wskazanie wyniku

  0027f	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00285	50		 push	 eax
  00286	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR _log$[ebp]
  0028c	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  00292	e8 00 00 00 00	 call	 ?Koniec_gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z ; Koniec_gry

; 104  : 	system("pause"); //Wywo³anie funkcji wymagaj¹cej do zamkniêcia naciniêcie dowolnego klawisza

  00297	68 00 00 00 00	 push	 OFFSET ??_C@_05PDJBBECF@pause?$AA@
  0029c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__system
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002a2	8b 55 e4	 mov	 edx, DWORD PTR _typ_zak³adu$[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 104  : 	system("pause"); //Wywo³anie funkcji wymagaj¹cej do zamkniêcia naciniêcie dowolnego klawisza

  002a5	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002a8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  002ab	72 3e		 jb	 SHORT $LN98@main
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002ad	8b 4d d0	 mov	 ecx, DWORD PTR _typ_zak³adu$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002b0	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002b1	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  002b3	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002b9	72 26		 jb	 SHORT $LN101@main

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  002bb	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  002be	3b f2		 cmp	 esi, edx
  002c0	76 19		 jbe	 SHORT $_Invalid_parameter$151

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  002c2	8b d6		 mov	 edx, esi
  002c4	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  002c6	75 13		 jne	 SHORT $_Invalid_parameter$151

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002c8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002cb	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  002cd	73 0c		 jae	 SHORT $_Invalid_parameter$151

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  002cf	2b c1		 sub	 eax, ecx
  002d1	83 f8 04	 cmp	 eax, 4
  002d4	72 05		 jb	 SHORT $_Invalid_parameter$151

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  002d6	83 f8 23	 cmp	 eax, 35			; 00000023H
  002d9	76 06		 jbe	 SHORT $LN101@main
$_Invalid_parameter$151:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN150@main:
$LN101@main:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  002e1	52		 push	 edx
  002e2	51		 push	 ecx
  002e3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002e8	83 c4 08	 add	 esp, 8
$LN98@main:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1352 : 		{	// destroy the object

  002eb	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  002f1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  002f8	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR _typ_zak³adu$[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  002ff	c6 45 d0 00	 mov	 BYTE PTR _typ_zak³adu$[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1352 : 		{	// destroy the object

  00303	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00306	c7 84 05 10 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _log$[ebp+eax], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00311	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _log$[ebp]
  00317	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0031a	8d 41 88	 lea	 eax, DWORD PTR [ecx-120]
  0031d	89 84 0d 0c ff
	ff ff		 mov	 DWORD PTR _log$[ebp+ecx-4], eax

; 1353 : 		}

  00324	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+24]
  0032a	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0032f	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+32]
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0033b	8d 4d 88	 lea	 ecx, DWORD PTR _log$[ebp+120]
  0033e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ

; 1132 : 		{	// destroy the object

  00344	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _log_ogólny$[ebp]
  0034a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0034d	c7 84 05 60 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _log_ogólny$[ebp+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00358	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _log_ogólny$[ebp]
  0035e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00361	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00364	89 84 0d 5c fe
	ff ff		 mov	 DWORD PTR _log_ogólny$[ebp+ecx-4], eax

; 1133 : 		}

  0036b	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+4]
  00371	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00376	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+8]
  0037c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00382	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp+104]
  00388	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 106  : 	return 0; //Zwrócenie wartoæ 0, czyli porogram zakoñczy³ siê bez b³êdu

  0038e	33 c0		 xor	 eax, eax

; 107  : }

  00390	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00393	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0039a	59		 pop	 ecx
  0039b	5e		 pop	 esi
  0039c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039f	33 cd		 xor	 ecx, ebp
  003a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a6	8b e5		 mov	 esp, ebp
  003a8	5d		 pop	 ebp
  003a9	c3		 ret	 0
$LN149@main:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
  00000	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _log_ogólny$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$_main$5:
  0000b	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00011	83 e0 01	 and	 eax, 1
  00014	0f 84 10 00 00
	00		 je	 $LN28@main
  0001a	83 a5 58 fe ff
	ff fe		 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00021	8d 4d 88	 lea	 ecx, DWORD PTR _log$[ebp+120]
  00024	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN28@main:
  0002a	c3		 ret	 0
__unwindfunclet$_main$6:
  0002b	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp+32]
  00031	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$_main$8:
  00037	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$_main$1:
  00043	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _log$[ebp]
  00049	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$_main$2:
  0004e	8d 4d d0	 lea	 ecx, DWORD PTR _typ_zak³adu$[ebp]
  00051	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$_main:
  00056	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0005d	8b 8a 54 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-428]
  00063	33 c8		 xor	 ecx, eax
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0006d	33 c8		 xor	 ecx, eax
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_main
  00079	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 1132 : 		{	// destroy the object

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8d 71 68	 lea	 esi, DWORD PTR [ecx+104]

; 1133 : 		}

  00006	8d 4e 9c	 lea	 ecx, DWORD PTR [esi-100]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  0001d	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0002f	8b ce		 mov	 ecx, esi
  00031	5e		 pop	 esi
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	68 b0 00 00 00	 push	 176			; 000000b0H
  00005	6a 00		 push	 0
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memset
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00010	c2 04 00	 ret	 4
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 1352 : 		{	// destroy the object

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8d 71 78	 lea	 esi, DWORD PTR [ecx+120]

; 1353 : 		}

  00006	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 88 00
	00 00 00	 mov	 DWORD PTR [eax+esi-120], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 88	 mov	 eax, DWORD PTR [esi-120]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 88	 lea	 eax, DWORD PTR [edx-120]
  0001d	89 44 32 84	 mov	 DWORD PTR [edx+esi-124], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0002f	8b ce		 mov	 ecx, esi
  00031	5e		 pop	 esi
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	68 c0 00 00 00	 push	 192			; 000000c0H
  00005	6a 00		 push	 0
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memset
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00010	c2 04 00	 ret	 4
?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = -20					; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Obstaw, COMDAT
; ___$ReturnUdt$ = ecx

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx
  00029	89 75 ec	 mov	 DWORD PTR ___$ReturnUdt$[ebp], esi
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00033	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00041	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 186  : 	return zaklad_typ; //Zwracam typ zak³adu podany przez u¿ytkownika

  00044	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004b	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
$LL4@Obstaw:

; 111  : 	string zaklad_typ; //Deklaracja zmiennej typu string przechowywuj¹cej typ zak³adu
; 112  : 
; 113  : 	do { //Pêtla do aby wykona³a siê conajmniej raz
; 114  : 		cout << "Jak¹ opcje chcesz obstawiæ? (zgodnie z poni¿szym opisem) :" << endl; //Zadanie pytania u¿ytkownikowi

  00052	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00057	51		 push	 ecx
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0005e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DL@POFCNLON@Jak?$LJ?5opcje?5chcesz?5obstawi?f?$DP?5?$CIzgo@
  00063	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00068	83 c4 04	 add	 esp, 4
  0006b	8b c8		 mov	 ecx, eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 115  : 		cout << "p - parzyste" << endl; //Wskazaæ mo¿liw¹ odpowied

  00073	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00078	51		 push	 ecx
  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0007f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@
  00084	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00089	83 c4 04	 add	 esp, 4
  0008c	8b c8		 mov	 ecx, eax
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 116  : 		cout << "n - nieparzyste" << endl; //Wskazaæ mo¿liw¹ odpowied

  00094	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00099	51		 push	 ecx
  0009a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000a0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@
  000a5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b c8		 mov	 ecx, eax
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 117  : 		cout << "r - czerwone (red)" << endl; //Wskazaæ mo¿liw¹ odpowied

  000b5	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000ba	51		 push	 ecx
  000bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000c1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BD@LEDAOJLK@r?5?9?5czerwone?5?$CIred?$CJ?$AA@
  000c6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000cb	83 c4 04	 add	 esp, 4
  000ce	8b c8		 mov	 ecx, eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 118  : 		cout << "b - czarne (black)" << endl; //Wskazaæ mo¿liw¹ odpowied

  000d6	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000db	51		 push	 ecx
  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000e2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BD@EPLAAEJB@b?5?9?5czarne?5?$CIblack?$CJ?$AA@
  000e7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000ec	83 c4 04	 add	 esp, 4
  000ef	8b c8		 mov	 ecx, eax
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 119  : 		cout << "g - górna po³owa" << endl; //Wskazaæ mo¿liw¹ odpowied

  000f7	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000fc	51		 push	 ecx
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00103	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@
  00108	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0010d	83 c4 04	 add	 esp, 4
  00110	8b c8		 mov	 ecx, eax
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 120  : 		cout << "d - dolna po³owa" << endl; //Wskazaæ mo¿liw¹ odpowied

  00118	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0011d	51		 push	 ecx
  0011e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00124	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@
  00129	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0012e	83 c4 04	 add	 esp, 4
  00131	8b c8		 mov	 ecx, eax
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 121  : 		cout << "k1, k2, k3 - kolumna 1, kolumna 2, kolumna 3" << endl; //Wskazaæ mo¿liw¹ odpowied

  00139	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0013e	51		 push	 ecx
  0013f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00145	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@
  0014a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0014f	83 c4 04	 add	 esp, 4
  00152	8b c8		 mov	 ecx, eax
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 122  : 		cout << "w1, w2, ... , w12 - wiersz trzech numerów" << endl; //Wskazaæ mo¿liw¹ odpowied

  0015a	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0015f	51		 push	 ecx
  00160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00166	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CK@OAIPJBPB@w1?0?5w2?0?5?4?4?4?5?0?5w12?5?9?5wiersz?5trzec@
  0016b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00170	83 c4 04	 add	 esp, 4
  00173	8b c8		 mov	 ecx, eax
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 123  : 		cout << "0-36 - pojedyñcze pole o odpowiednim numerze" << endl; //Wskazaæ mo¿liw¹ odpowied

  0017b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00180	51		 push	 ecx
  00181	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00187	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CN@CGIAAFPM@0?936?5?9?5pojedy?qcze?5pole?5o?5odpowie@
  0018c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00191	83 c4 04	 add	 esp, 4
  00194	8b c8		 mov	 ecx, eax
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  0019c	8b d6		 mov	 edx, esi
  0019e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  001a4	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001a9	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001ac	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001ae	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  001b1	72 02		 jb	 SHORT $LN1838@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001b3	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1838@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  001b5	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001b8	83 f8 01	 cmp	 eax, 1
  001bb	75 19		 jne	 SHORT $LN62@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001bd	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  001c0	80 f9 70	 cmp	 cl, 112			; 00000070H
  001c3	75 04		 jne	 SHORT $LN2011@Obstaw
  001c5	33 c9		 xor	 ecx, ecx
  001c7	eb 05		 jmp	 SHORT $LN2012@Obstaw
$LN2011@Obstaw:
  001c9	1b c9		 sbb	 ecx, ecx
  001cb	83 c9 01	 or	 ecx, 1
$LN2012@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001ce	85 c9		 test	 ecx, ecx
  001d0	0f 84 b5 09 00
	00		 je	 $LN5@Obstaw
$LN62@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001d6	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001d8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  001db	72 02		 jb	 SHORT $LN1839@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001dd	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1839@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001df	83 f8 01	 cmp	 eax, 1
  001e2	75 19		 jne	 SHORT $LN93@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001e4	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  001e7	80 f9 6e	 cmp	 cl, 110			; 0000006eH
  001ea	75 04		 jne	 SHORT $LN2013@Obstaw
  001ec	33 c9		 xor	 ecx, ecx
  001ee	eb 05		 jmp	 SHORT $LN2014@Obstaw
$LN2013@Obstaw:
  001f0	1b c9		 sbb	 ecx, ecx
  001f2	83 c9 01	 or	 ecx, 1
$LN2014@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001f5	85 c9		 test	 ecx, ecx
  001f7	0f 84 8e 09 00
	00		 je	 $LN5@Obstaw
$LN93@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001fd	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001ff	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00202	72 02		 jb	 SHORT $LN1840@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00204	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1840@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00206	83 f8 01	 cmp	 eax, 1
  00209	75 19		 jne	 SHORT $LN124@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0020b	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  0020e	80 f9 72	 cmp	 cl, 114			; 00000072H
  00211	75 04		 jne	 SHORT $LN2015@Obstaw
  00213	33 c9		 xor	 ecx, ecx
  00215	eb 05		 jmp	 SHORT $LN2016@Obstaw
$LN2015@Obstaw:
  00217	1b c9		 sbb	 ecx, ecx
  00219	83 c9 01	 or	 ecx, 1
$LN2016@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0021c	85 c9		 test	 ecx, ecx
  0021e	0f 84 67 09 00
	00		 je	 $LN5@Obstaw
$LN124@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00224	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00226	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00229	72 02		 jb	 SHORT $LN1841@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0022b	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1841@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0022d	83 f8 01	 cmp	 eax, 1
  00230	75 19		 jne	 SHORT $LN155@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00232	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00235	80 f9 62	 cmp	 cl, 98			; 00000062H
  00238	75 04		 jne	 SHORT $LN2017@Obstaw
  0023a	33 c9		 xor	 ecx, ecx
  0023c	eb 05		 jmp	 SHORT $LN2018@Obstaw
$LN2017@Obstaw:
  0023e	1b c9		 sbb	 ecx, ecx
  00240	83 c9 01	 or	 ecx, 1
$LN2018@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00243	85 c9		 test	 ecx, ecx
  00245	0f 84 40 09 00
	00		 je	 $LN5@Obstaw
$LN155@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0024b	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0024d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00250	72 02		 jb	 SHORT $LN1842@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00252	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1842@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00254	83 f8 01	 cmp	 eax, 1
  00257	75 19		 jne	 SHORT $LN186@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00259	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  0025c	80 f9 67	 cmp	 cl, 103			; 00000067H
  0025f	75 04		 jne	 SHORT $LN2019@Obstaw
  00261	33 c9		 xor	 ecx, ecx
  00263	eb 05		 jmp	 SHORT $LN2020@Obstaw
$LN2019@Obstaw:
  00265	1b c9		 sbb	 ecx, ecx
  00267	83 c9 01	 or	 ecx, 1
$LN2020@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0026a	85 c9		 test	 ecx, ecx
  0026c	0f 84 19 09 00
	00		 je	 $LN5@Obstaw
$LN186@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00272	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00274	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00277	72 02		 jb	 SHORT $LN1843@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00279	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1843@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0027b	83 f8 01	 cmp	 eax, 1
  0027e	75 19		 jne	 SHORT $LN217@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00280	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00283	80 f9 64	 cmp	 cl, 100			; 00000064H
  00286	75 04		 jne	 SHORT $LN2021@Obstaw
  00288	33 c9		 xor	 ecx, ecx
  0028a	eb 05		 jmp	 SHORT $LN2022@Obstaw
$LN2021@Obstaw:
  0028c	1b c9		 sbb	 ecx, ecx
  0028e	83 c9 01	 or	 ecx, 1
$LN2022@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00291	85 c9		 test	 ecx, ecx
  00293	0f 84 f2 08 00
	00		 je	 $LN5@Obstaw
$LN217@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00299	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0029b	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0029e	72 02		 jb	 SHORT $LN1844@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  002a0	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1844@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002a2	83 f8 02	 cmp	 eax, 2
  002a5	75 1f		 jne	 SHORT $LN248@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002a7	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  002aa	80 f9 6b	 cmp	 cl, 107			; 0000006bH
  002ad	75 0a		 jne	 SHORT $LN2023@Obstaw
  002af	80 7f 01 31	 cmp	 BYTE PTR [edi+1], 49	; 00000031H
  002b3	75 04		 jne	 SHORT $LN2023@Obstaw
  002b5	33 c9		 xor	 ecx, ecx
  002b7	eb 05		 jmp	 SHORT $LN2024@Obstaw
$LN2023@Obstaw:
  002b9	1b c9		 sbb	 ecx, ecx
  002bb	83 c9 01	 or	 ecx, 1
$LN2024@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002be	85 c9		 test	 ecx, ecx
  002c0	0f 84 c5 08 00
	00		 je	 $LN5@Obstaw
$LN248@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  002c6	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002c8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  002cb	72 02		 jb	 SHORT $LN1845@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  002cd	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1845@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002cf	83 f8 02	 cmp	 eax, 2
  002d2	75 1f		 jne	 SHORT $LN279@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002d4	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  002d7	80 f9 6b	 cmp	 cl, 107			; 0000006bH
  002da	75 0a		 jne	 SHORT $LN2025@Obstaw
  002dc	80 7f 01 32	 cmp	 BYTE PTR [edi+1], 50	; 00000032H
  002e0	75 04		 jne	 SHORT $LN2025@Obstaw
  002e2	33 c9		 xor	 ecx, ecx
  002e4	eb 05		 jmp	 SHORT $LN2026@Obstaw
$LN2025@Obstaw:
  002e6	1b c9		 sbb	 ecx, ecx
  002e8	83 c9 01	 or	 ecx, 1
$LN2026@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002eb	85 c9		 test	 ecx, ecx
  002ed	0f 84 98 08 00
	00		 je	 $LN5@Obstaw
$LN279@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  002f3	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002f5	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  002f8	72 02		 jb	 SHORT $LN1846@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  002fa	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1846@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002fc	83 f8 02	 cmp	 eax, 2
  002ff	75 1f		 jne	 SHORT $LN310@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00301	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00304	80 f9 6b	 cmp	 cl, 107			; 0000006bH
  00307	75 0a		 jne	 SHORT $LN2027@Obstaw
  00309	80 7f 01 33	 cmp	 BYTE PTR [edi+1], 51	; 00000033H
  0030d	75 04		 jne	 SHORT $LN2027@Obstaw
  0030f	33 c9		 xor	 ecx, ecx
  00311	eb 05		 jmp	 SHORT $LN2028@Obstaw
$LN2027@Obstaw:
  00313	1b c9		 sbb	 ecx, ecx
  00315	83 c9 01	 or	 ecx, 1
$LN2028@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00318	85 c9		 test	 ecx, ecx
  0031a	0f 84 6b 08 00
	00		 je	 $LN5@Obstaw
$LN310@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00320	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00322	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00325	72 02		 jb	 SHORT $LN1847@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00327	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1847@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00329	83 f8 02	 cmp	 eax, 2
  0032c	75 1f		 jne	 SHORT $LN341@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0032e	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00331	80 f9 77	 cmp	 cl, 119			; 00000077H
  00334	75 0a		 jne	 SHORT $LN2029@Obstaw
  00336	80 7f 01 31	 cmp	 BYTE PTR [edi+1], 49	; 00000031H
  0033a	75 04		 jne	 SHORT $LN2029@Obstaw
  0033c	33 c9		 xor	 ecx, ecx
  0033e	eb 05		 jmp	 SHORT $LN2030@Obstaw
$LN2029@Obstaw:
  00340	1b c9		 sbb	 ecx, ecx
  00342	83 c9 01	 or	 ecx, 1
$LN2030@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00345	85 c9		 test	 ecx, ecx
  00347	0f 84 3e 08 00
	00		 je	 $LN5@Obstaw
$LN341@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0034d	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0034f	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00352	72 02		 jb	 SHORT $LN1848@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00354	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1848@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00356	83 f8 02	 cmp	 eax, 2
  00359	75 1f		 jne	 SHORT $LN372@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0035b	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0035e	80 f9 77	 cmp	 cl, 119			; 00000077H
  00361	75 0a		 jne	 SHORT $LN2031@Obstaw
  00363	80 7f 01 32	 cmp	 BYTE PTR [edi+1], 50	; 00000032H
  00367	75 04		 jne	 SHORT $LN2031@Obstaw
  00369	33 c9		 xor	 ecx, ecx
  0036b	eb 05		 jmp	 SHORT $LN2032@Obstaw
$LN2031@Obstaw:
  0036d	1b c9		 sbb	 ecx, ecx
  0036f	83 c9 01	 or	 ecx, 1
$LN2032@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00372	85 c9		 test	 ecx, ecx
  00374	0f 84 11 08 00
	00		 je	 $LN5@Obstaw
$LN372@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0037a	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0037c	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0037f	72 02		 jb	 SHORT $LN1849@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00381	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1849@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00383	83 f8 02	 cmp	 eax, 2
  00386	75 1f		 jne	 SHORT $LN403@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00388	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0038b	80 f9 77	 cmp	 cl, 119			; 00000077H
  0038e	75 0a		 jne	 SHORT $LN2033@Obstaw
  00390	80 7f 01 33	 cmp	 BYTE PTR [edi+1], 51	; 00000033H
  00394	75 04		 jne	 SHORT $LN2033@Obstaw
  00396	33 c9		 xor	 ecx, ecx
  00398	eb 05		 jmp	 SHORT $LN2034@Obstaw
$LN2033@Obstaw:
  0039a	1b c9		 sbb	 ecx, ecx
  0039c	83 c9 01	 or	 ecx, 1
$LN2034@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0039f	85 c9		 test	 ecx, ecx
  003a1	0f 84 e4 07 00
	00		 je	 $LN5@Obstaw
$LN403@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  003a7	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003a9	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  003ac	72 02		 jb	 SHORT $LN1850@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  003ae	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1850@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  003b0	83 f8 02	 cmp	 eax, 2
  003b3	75 1f		 jne	 SHORT $LN434@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  003b5	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  003b8	80 f9 77	 cmp	 cl, 119			; 00000077H
  003bb	75 0a		 jne	 SHORT $LN2035@Obstaw
  003bd	80 7f 01 34	 cmp	 BYTE PTR [edi+1], 52	; 00000034H
  003c1	75 04		 jne	 SHORT $LN2035@Obstaw
  003c3	33 c9		 xor	 ecx, ecx
  003c5	eb 05		 jmp	 SHORT $LN2036@Obstaw
$LN2035@Obstaw:
  003c7	1b c9		 sbb	 ecx, ecx
  003c9	83 c9 01	 or	 ecx, 1
$LN2036@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  003cc	85 c9		 test	 ecx, ecx
  003ce	0f 84 b7 07 00
	00		 je	 $LN5@Obstaw
$LN434@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  003d4	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003d6	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  003d9	72 02		 jb	 SHORT $LN1851@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  003db	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1851@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  003dd	83 f8 02	 cmp	 eax, 2
  003e0	75 1f		 jne	 SHORT $LN465@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  003e2	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  003e5	80 f9 77	 cmp	 cl, 119			; 00000077H
  003e8	75 0a		 jne	 SHORT $LN2037@Obstaw
  003ea	80 7f 01 35	 cmp	 BYTE PTR [edi+1], 53	; 00000035H
  003ee	75 04		 jne	 SHORT $LN2037@Obstaw
  003f0	33 c9		 xor	 ecx, ecx
  003f2	eb 05		 jmp	 SHORT $LN2038@Obstaw
$LN2037@Obstaw:
  003f4	1b c9		 sbb	 ecx, ecx
  003f6	83 c9 01	 or	 ecx, 1
$LN2038@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  003f9	85 c9		 test	 ecx, ecx
  003fb	0f 84 8a 07 00
	00		 je	 $LN5@Obstaw
$LN465@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00401	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00403	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00406	72 02		 jb	 SHORT $LN1852@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00408	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1852@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0040a	83 f8 02	 cmp	 eax, 2
  0040d	75 1f		 jne	 SHORT $LN496@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0040f	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00412	80 f9 77	 cmp	 cl, 119			; 00000077H
  00415	75 0a		 jne	 SHORT $LN2039@Obstaw
  00417	80 7f 01 36	 cmp	 BYTE PTR [edi+1], 54	; 00000036H
  0041b	75 04		 jne	 SHORT $LN2039@Obstaw
  0041d	33 c9		 xor	 ecx, ecx
  0041f	eb 05		 jmp	 SHORT $LN2040@Obstaw
$LN2039@Obstaw:
  00421	1b c9		 sbb	 ecx, ecx
  00423	83 c9 01	 or	 ecx, 1
$LN2040@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00426	85 c9		 test	 ecx, ecx
  00428	0f 84 5d 07 00
	00		 je	 $LN5@Obstaw
$LN496@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0042e	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00430	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00433	72 02		 jb	 SHORT $LN1853@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00435	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1853@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00437	83 f8 02	 cmp	 eax, 2
  0043a	75 1f		 jne	 SHORT $LN527@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0043c	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0043f	80 f9 77	 cmp	 cl, 119			; 00000077H
  00442	75 0a		 jne	 SHORT $LN2041@Obstaw
  00444	80 7f 01 37	 cmp	 BYTE PTR [edi+1], 55	; 00000037H
  00448	75 04		 jne	 SHORT $LN2041@Obstaw
  0044a	33 c9		 xor	 ecx, ecx
  0044c	eb 05		 jmp	 SHORT $LN2042@Obstaw
$LN2041@Obstaw:
  0044e	1b c9		 sbb	 ecx, ecx
  00450	83 c9 01	 or	 ecx, 1
$LN2042@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00453	85 c9		 test	 ecx, ecx
  00455	0f 84 30 07 00
	00		 je	 $LN5@Obstaw
$LN527@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0045b	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0045d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00460	72 02		 jb	 SHORT $LN1854@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00462	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1854@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00464	83 f8 02	 cmp	 eax, 2
  00467	75 1f		 jne	 SHORT $LN558@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00469	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0046c	80 f9 77	 cmp	 cl, 119			; 00000077H
  0046f	75 0a		 jne	 SHORT $LN2043@Obstaw
  00471	80 7f 01 38	 cmp	 BYTE PTR [edi+1], 56	; 00000038H
  00475	75 04		 jne	 SHORT $LN2043@Obstaw
  00477	33 c9		 xor	 ecx, ecx
  00479	eb 05		 jmp	 SHORT $LN2044@Obstaw
$LN2043@Obstaw:
  0047b	1b c9		 sbb	 ecx, ecx
  0047d	83 c9 01	 or	 ecx, 1
$LN2044@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00480	85 c9		 test	 ecx, ecx
  00482	0f 84 03 07 00
	00		 je	 $LN5@Obstaw
$LN558@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00488	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0048a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0048d	72 02		 jb	 SHORT $LN1855@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0048f	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1855@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00491	83 f8 02	 cmp	 eax, 2
  00494	75 1f		 jne	 SHORT $LN589@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00496	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00499	80 f9 77	 cmp	 cl, 119			; 00000077H
  0049c	75 0a		 jne	 SHORT $LN2045@Obstaw
  0049e	80 7f 01 39	 cmp	 BYTE PTR [edi+1], 57	; 00000039H
  004a2	75 04		 jne	 SHORT $LN2045@Obstaw
  004a4	33 c9		 xor	 ecx, ecx
  004a6	eb 05		 jmp	 SHORT $LN2046@Obstaw
$LN2045@Obstaw:
  004a8	1b c9		 sbb	 ecx, ecx
  004aa	83 c9 01	 or	 ecx, 1
$LN2046@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  004ad	85 c9		 test	 ecx, ecx
  004af	0f 84 d6 06 00
	00		 je	 $LN5@Obstaw
$LN589@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  004b5	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004b7	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  004ba	72 02		 jb	 SHORT $LN1856@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004bc	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1856@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  004be	83 f8 03	 cmp	 eax, 3
  004c1	75 25		 jne	 SHORT $LN620@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  004c3	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  004c6	80 f9 77	 cmp	 cl, 119			; 00000077H
  004c9	75 10		 jne	 SHORT $LN2047@Obstaw
  004cb	80 7f 01 31	 cmp	 BYTE PTR [edi+1], 49	; 00000031H
  004cf	75 0a		 jne	 SHORT $LN2047@Obstaw
  004d1	80 7f 02 30	 cmp	 BYTE PTR [edi+2], 48	; 00000030H
  004d5	75 04		 jne	 SHORT $LN2047@Obstaw
  004d7	33 c9		 xor	 ecx, ecx
  004d9	eb 05		 jmp	 SHORT $LN2048@Obstaw
$LN2047@Obstaw:
  004db	1b c9		 sbb	 ecx, ecx
  004dd	83 c9 01	 or	 ecx, 1
$LN2048@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  004e0	85 c9		 test	 ecx, ecx
  004e2	0f 84 a3 06 00
	00		 je	 $LN5@Obstaw
$LN620@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  004e8	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004ea	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  004ed	72 02		 jb	 SHORT $LN1857@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004ef	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1857@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  004f1	83 f8 03	 cmp	 eax, 3
  004f4	75 25		 jne	 SHORT $LN651@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  004f6	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  004f9	80 f9 77	 cmp	 cl, 119			; 00000077H
  004fc	75 10		 jne	 SHORT $LN2049@Obstaw
  004fe	80 7f 01 31	 cmp	 BYTE PTR [edi+1], 49	; 00000031H
  00502	75 0a		 jne	 SHORT $LN2049@Obstaw
  00504	80 7f 02 31	 cmp	 BYTE PTR [edi+2], 49	; 00000031H
  00508	75 04		 jne	 SHORT $LN2049@Obstaw
  0050a	33 c9		 xor	 ecx, ecx
  0050c	eb 05		 jmp	 SHORT $LN2050@Obstaw
$LN2049@Obstaw:
  0050e	1b c9		 sbb	 ecx, ecx
  00510	83 c9 01	 or	 ecx, 1
$LN2050@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00513	85 c9		 test	 ecx, ecx
  00515	0f 84 70 06 00
	00		 je	 $LN5@Obstaw
$LN651@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0051b	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0051d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00520	72 02		 jb	 SHORT $LN1858@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00522	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1858@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00524	83 f8 03	 cmp	 eax, 3
  00527	75 25		 jne	 SHORT $LN682@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00529	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0052c	80 f9 77	 cmp	 cl, 119			; 00000077H
  0052f	75 10		 jne	 SHORT $LN2051@Obstaw
  00531	80 7f 01 31	 cmp	 BYTE PTR [edi+1], 49	; 00000031H
  00535	75 0a		 jne	 SHORT $LN2051@Obstaw
  00537	80 7f 02 32	 cmp	 BYTE PTR [edi+2], 50	; 00000032H
  0053b	75 04		 jne	 SHORT $LN2051@Obstaw
  0053d	33 c9		 xor	 ecx, ecx
  0053f	eb 05		 jmp	 SHORT $LN2052@Obstaw
$LN2051@Obstaw:
  00541	1b c9		 sbb	 ecx, ecx
  00543	83 c9 01	 or	 ecx, 1
$LN2052@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00546	85 c9		 test	 ecx, ecx
  00548	0f 84 3d 06 00
	00		 je	 $LN5@Obstaw
$LN682@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0054e	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00550	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00553	72 02		 jb	 SHORT $LN1859@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00555	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1859@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00557	83 f8 01	 cmp	 eax, 1
  0055a	75 19		 jne	 SHORT $LN713@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0055c	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  0055f	80 f9 30	 cmp	 cl, 48			; 00000030H
  00562	75 04		 jne	 SHORT $LN2053@Obstaw
  00564	33 c9		 xor	 ecx, ecx
  00566	eb 05		 jmp	 SHORT $LN2054@Obstaw
$LN2053@Obstaw:
  00568	1b c9		 sbb	 ecx, ecx
  0056a	83 c9 01	 or	 ecx, 1
$LN2054@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0056d	85 c9		 test	 ecx, ecx
  0056f	0f 84 16 06 00
	00		 je	 $LN5@Obstaw
$LN713@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00575	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00577	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0057a	72 02		 jb	 SHORT $LN1860@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0057c	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1860@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0057e	83 f8 01	 cmp	 eax, 1
  00581	75 19		 jne	 SHORT $LN744@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00583	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00586	80 f9 31	 cmp	 cl, 49			; 00000031H
  00589	75 04		 jne	 SHORT $LN2055@Obstaw
  0058b	33 c9		 xor	 ecx, ecx
  0058d	eb 05		 jmp	 SHORT $LN2056@Obstaw
$LN2055@Obstaw:
  0058f	1b c9		 sbb	 ecx, ecx
  00591	83 c9 01	 or	 ecx, 1
$LN2056@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00594	85 c9		 test	 ecx, ecx
  00596	0f 84 ef 05 00
	00		 je	 $LN5@Obstaw
$LN744@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0059c	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0059e	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  005a1	72 02		 jb	 SHORT $LN1861@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005a3	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1861@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005a5	83 f8 01	 cmp	 eax, 1
  005a8	75 19		 jne	 SHORT $LN775@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005aa	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  005ad	80 f9 32	 cmp	 cl, 50			; 00000032H
  005b0	75 04		 jne	 SHORT $LN2057@Obstaw
  005b2	33 c9		 xor	 ecx, ecx
  005b4	eb 05		 jmp	 SHORT $LN2058@Obstaw
$LN2057@Obstaw:
  005b6	1b c9		 sbb	 ecx, ecx
  005b8	83 c9 01	 or	 ecx, 1
$LN2058@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005bb	85 c9		 test	 ecx, ecx
  005bd	0f 84 c8 05 00
	00		 je	 $LN5@Obstaw
$LN775@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  005c3	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005c5	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  005c8	72 02		 jb	 SHORT $LN1862@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005ca	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1862@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005cc	83 f8 01	 cmp	 eax, 1
  005cf	75 19		 jne	 SHORT $LN806@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005d1	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  005d4	80 f9 33	 cmp	 cl, 51			; 00000033H
  005d7	75 04		 jne	 SHORT $LN2059@Obstaw
  005d9	33 c9		 xor	 ecx, ecx
  005db	eb 05		 jmp	 SHORT $LN2060@Obstaw
$LN2059@Obstaw:
  005dd	1b c9		 sbb	 ecx, ecx
  005df	83 c9 01	 or	 ecx, 1
$LN2060@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005e2	85 c9		 test	 ecx, ecx
  005e4	0f 84 a1 05 00
	00		 je	 $LN5@Obstaw
$LN806@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  005ea	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005ec	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  005ef	72 02		 jb	 SHORT $LN1863@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005f1	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1863@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005f3	83 f8 01	 cmp	 eax, 1
  005f6	75 19		 jne	 SHORT $LN837@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005f8	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  005fb	80 f9 34	 cmp	 cl, 52			; 00000034H
  005fe	75 04		 jne	 SHORT $LN2061@Obstaw
  00600	33 c9		 xor	 ecx, ecx
  00602	eb 05		 jmp	 SHORT $LN2062@Obstaw
$LN2061@Obstaw:
  00604	1b c9		 sbb	 ecx, ecx
  00606	83 c9 01	 or	 ecx, 1
$LN2062@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00609	85 c9		 test	 ecx, ecx
  0060b	0f 84 7a 05 00
	00		 je	 $LN5@Obstaw
$LN837@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00611	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00613	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00616	72 02		 jb	 SHORT $LN1864@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00618	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1864@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0061a	83 f8 01	 cmp	 eax, 1
  0061d	75 19		 jne	 SHORT $LN868@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0061f	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00622	80 f9 35	 cmp	 cl, 53			; 00000035H
  00625	75 04		 jne	 SHORT $LN2063@Obstaw
  00627	33 c9		 xor	 ecx, ecx
  00629	eb 05		 jmp	 SHORT $LN2064@Obstaw
$LN2063@Obstaw:
  0062b	1b c9		 sbb	 ecx, ecx
  0062d	83 c9 01	 or	 ecx, 1
$LN2064@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00630	85 c9		 test	 ecx, ecx
  00632	0f 84 53 05 00
	00		 je	 $LN5@Obstaw
$LN868@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00638	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0063a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0063d	72 02		 jb	 SHORT $LN1865@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0063f	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1865@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00641	83 f8 01	 cmp	 eax, 1
  00644	75 19		 jne	 SHORT $LN899@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00646	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00649	80 f9 36	 cmp	 cl, 54			; 00000036H
  0064c	75 04		 jne	 SHORT $LN2065@Obstaw
  0064e	33 c9		 xor	 ecx, ecx
  00650	eb 05		 jmp	 SHORT $LN2066@Obstaw
$LN2065@Obstaw:
  00652	1b c9		 sbb	 ecx, ecx
  00654	83 c9 01	 or	 ecx, 1
$LN2066@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00657	85 c9		 test	 ecx, ecx
  00659	0f 84 2c 05 00
	00		 je	 $LN5@Obstaw
$LN899@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0065f	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00661	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00664	72 02		 jb	 SHORT $LN1866@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00666	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1866@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00668	83 f8 01	 cmp	 eax, 1
  0066b	75 19		 jne	 SHORT $LN930@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0066d	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00670	80 f9 37	 cmp	 cl, 55			; 00000037H
  00673	75 04		 jne	 SHORT $LN2067@Obstaw
  00675	33 c9		 xor	 ecx, ecx
  00677	eb 05		 jmp	 SHORT $LN2068@Obstaw
$LN2067@Obstaw:
  00679	1b c9		 sbb	 ecx, ecx
  0067b	83 c9 01	 or	 ecx, 1
$LN2068@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0067e	85 c9		 test	 ecx, ecx
  00680	0f 84 05 05 00
	00		 je	 $LN5@Obstaw
$LN930@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00686	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00688	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0068b	72 02		 jb	 SHORT $LN1867@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0068d	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1867@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0068f	83 f8 01	 cmp	 eax, 1
  00692	75 19		 jne	 SHORT $LN961@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00694	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00697	80 f9 38	 cmp	 cl, 56			; 00000038H
  0069a	75 04		 jne	 SHORT $LN2069@Obstaw
  0069c	33 c9		 xor	 ecx, ecx
  0069e	eb 05		 jmp	 SHORT $LN2070@Obstaw
$LN2069@Obstaw:
  006a0	1b c9		 sbb	 ecx, ecx
  006a2	83 c9 01	 or	 ecx, 1
$LN2070@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  006a5	85 c9		 test	 ecx, ecx
  006a7	0f 84 de 04 00
	00		 je	 $LN5@Obstaw
$LN961@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  006ad	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006af	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  006b2	72 02		 jb	 SHORT $LN1868@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  006b4	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1868@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  006b6	83 f8 01	 cmp	 eax, 1
  006b9	75 19		 jne	 SHORT $LN992@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  006bb	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  006be	80 f9 39	 cmp	 cl, 57			; 00000039H
  006c1	75 04		 jne	 SHORT $LN2071@Obstaw
  006c3	33 c9		 xor	 ecx, ecx
  006c5	eb 05		 jmp	 SHORT $LN2072@Obstaw
$LN2071@Obstaw:
  006c7	1b c9		 sbb	 ecx, ecx
  006c9	83 c9 01	 or	 ecx, 1
$LN2072@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  006cc	85 c9		 test	 ecx, ecx
  006ce	0f 84 b7 04 00
	00		 je	 $LN5@Obstaw
$LN992@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  006d4	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006d6	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  006d9	72 02		 jb	 SHORT $LN1869@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  006db	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1869@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  006dd	83 f8 02	 cmp	 eax, 2
  006e0	75 1f		 jne	 SHORT $LN1023@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  006e2	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  006e5	80 f9 31	 cmp	 cl, 49			; 00000031H
  006e8	75 0a		 jne	 SHORT $LN2073@Obstaw
  006ea	80 7f 01 30	 cmp	 BYTE PTR [edi+1], 48	; 00000030H
  006ee	75 04		 jne	 SHORT $LN2073@Obstaw
  006f0	33 c9		 xor	 ecx, ecx
  006f2	eb 05		 jmp	 SHORT $LN2074@Obstaw
$LN2073@Obstaw:
  006f4	1b c9		 sbb	 ecx, ecx
  006f6	83 c9 01	 or	 ecx, 1
$LN2074@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  006f9	85 c9		 test	 ecx, ecx
  006fb	0f 84 8a 04 00
	00		 je	 $LN5@Obstaw
$LN1023@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00701	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00703	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00706	72 02		 jb	 SHORT $LN1870@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00708	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1870@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0070a	83 f8 02	 cmp	 eax, 2
  0070d	75 1e		 jne	 SHORT $LN1054@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0070f	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00712	80 f9 31	 cmp	 cl, 49			; 00000031H
  00715	75 09		 jne	 SHORT $LN2075@Obstaw
  00717	38 4f 01	 cmp	 BYTE PTR [edi+1], cl
  0071a	75 04		 jne	 SHORT $LN2075@Obstaw
  0071c	33 c9		 xor	 ecx, ecx
  0071e	eb 05		 jmp	 SHORT $LN2076@Obstaw
$LN2075@Obstaw:
  00720	1b c9		 sbb	 ecx, ecx
  00722	83 c9 01	 or	 ecx, 1
$LN2076@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00725	85 c9		 test	 ecx, ecx
  00727	0f 84 5e 04 00
	00		 je	 $LN5@Obstaw
$LN1054@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0072d	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0072f	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00732	72 02		 jb	 SHORT $LN1871@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00734	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1871@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00736	83 f8 02	 cmp	 eax, 2
  00739	75 1f		 jne	 SHORT $LN1085@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0073b	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0073e	80 f9 31	 cmp	 cl, 49			; 00000031H
  00741	75 0a		 jne	 SHORT $LN2077@Obstaw
  00743	80 7f 01 32	 cmp	 BYTE PTR [edi+1], 50	; 00000032H
  00747	75 04		 jne	 SHORT $LN2077@Obstaw
  00749	33 c9		 xor	 ecx, ecx
  0074b	eb 05		 jmp	 SHORT $LN2078@Obstaw
$LN2077@Obstaw:
  0074d	1b c9		 sbb	 ecx, ecx
  0074f	83 c9 01	 or	 ecx, 1
$LN2078@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00752	85 c9		 test	 ecx, ecx
  00754	0f 84 31 04 00
	00		 je	 $LN5@Obstaw
$LN1085@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0075a	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0075c	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0075f	72 02		 jb	 SHORT $LN1872@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00761	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1872@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00763	83 f8 02	 cmp	 eax, 2
  00766	75 1f		 jne	 SHORT $LN1116@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00768	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0076b	80 f9 31	 cmp	 cl, 49			; 00000031H
  0076e	75 0a		 jne	 SHORT $LN2079@Obstaw
  00770	80 7f 01 33	 cmp	 BYTE PTR [edi+1], 51	; 00000033H
  00774	75 04		 jne	 SHORT $LN2079@Obstaw
  00776	33 c9		 xor	 ecx, ecx
  00778	eb 05		 jmp	 SHORT $LN2080@Obstaw
$LN2079@Obstaw:
  0077a	1b c9		 sbb	 ecx, ecx
  0077c	83 c9 01	 or	 ecx, 1
$LN2080@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0077f	85 c9		 test	 ecx, ecx
  00781	0f 84 04 04 00
	00		 je	 $LN5@Obstaw
$LN1116@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00787	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00789	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0078c	72 02		 jb	 SHORT $LN1873@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0078e	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1873@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00790	83 f8 02	 cmp	 eax, 2
  00793	75 1f		 jne	 SHORT $LN1147@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00795	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00798	80 f9 31	 cmp	 cl, 49			; 00000031H
  0079b	75 0a		 jne	 SHORT $LN2081@Obstaw
  0079d	80 7f 01 34	 cmp	 BYTE PTR [edi+1], 52	; 00000034H
  007a1	75 04		 jne	 SHORT $LN2081@Obstaw
  007a3	33 c9		 xor	 ecx, ecx
  007a5	eb 05		 jmp	 SHORT $LN2082@Obstaw
$LN2081@Obstaw:
  007a7	1b c9		 sbb	 ecx, ecx
  007a9	83 c9 01	 or	 ecx, 1
$LN2082@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  007ac	85 c9		 test	 ecx, ecx
  007ae	0f 84 d7 03 00
	00		 je	 $LN5@Obstaw
$LN1147@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  007b4	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007b6	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  007b9	72 02		 jb	 SHORT $LN1874@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  007bb	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1874@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  007bd	83 f8 02	 cmp	 eax, 2
  007c0	75 1f		 jne	 SHORT $LN1178@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  007c2	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  007c5	80 f9 31	 cmp	 cl, 49			; 00000031H
  007c8	75 0a		 jne	 SHORT $LN2083@Obstaw
  007ca	80 7f 01 35	 cmp	 BYTE PTR [edi+1], 53	; 00000035H
  007ce	75 04		 jne	 SHORT $LN2083@Obstaw
  007d0	33 c9		 xor	 ecx, ecx
  007d2	eb 05		 jmp	 SHORT $LN2084@Obstaw
$LN2083@Obstaw:
  007d4	1b c9		 sbb	 ecx, ecx
  007d6	83 c9 01	 or	 ecx, 1
$LN2084@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  007d9	85 c9		 test	 ecx, ecx
  007db	0f 84 aa 03 00
	00		 je	 $LN5@Obstaw
$LN1178@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  007e1	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007e3	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  007e6	72 02		 jb	 SHORT $LN1875@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  007e8	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1875@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  007ea	83 f8 02	 cmp	 eax, 2
  007ed	75 1f		 jne	 SHORT $LN1209@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  007ef	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  007f2	80 f9 31	 cmp	 cl, 49			; 00000031H
  007f5	75 0a		 jne	 SHORT $LN2085@Obstaw
  007f7	80 7f 01 36	 cmp	 BYTE PTR [edi+1], 54	; 00000036H
  007fb	75 04		 jne	 SHORT $LN2085@Obstaw
  007fd	33 c9		 xor	 ecx, ecx
  007ff	eb 05		 jmp	 SHORT $LN2086@Obstaw
$LN2085@Obstaw:
  00801	1b c9		 sbb	 ecx, ecx
  00803	83 c9 01	 or	 ecx, 1
$LN2086@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00806	85 c9		 test	 ecx, ecx
  00808	0f 84 7d 03 00
	00		 je	 $LN5@Obstaw
$LN1209@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0080e	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00810	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00813	72 02		 jb	 SHORT $LN1876@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00815	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1876@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00817	83 f8 02	 cmp	 eax, 2
  0081a	75 1f		 jne	 SHORT $LN1240@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0081c	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0081f	80 f9 31	 cmp	 cl, 49			; 00000031H
  00822	75 0a		 jne	 SHORT $LN2087@Obstaw
  00824	80 7f 01 37	 cmp	 BYTE PTR [edi+1], 55	; 00000037H
  00828	75 04		 jne	 SHORT $LN2087@Obstaw
  0082a	33 c9		 xor	 ecx, ecx
  0082c	eb 05		 jmp	 SHORT $LN2088@Obstaw
$LN2087@Obstaw:
  0082e	1b c9		 sbb	 ecx, ecx
  00830	83 c9 01	 or	 ecx, 1
$LN2088@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00833	85 c9		 test	 ecx, ecx
  00835	0f 84 50 03 00
	00		 je	 $LN5@Obstaw
$LN1240@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0083b	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0083d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00840	72 02		 jb	 SHORT $LN1877@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00842	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1877@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00844	83 f8 02	 cmp	 eax, 2
  00847	75 1f		 jne	 SHORT $LN1271@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00849	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0084c	80 f9 31	 cmp	 cl, 49			; 00000031H
  0084f	75 0a		 jne	 SHORT $LN2089@Obstaw
  00851	80 7f 01 38	 cmp	 BYTE PTR [edi+1], 56	; 00000038H
  00855	75 04		 jne	 SHORT $LN2089@Obstaw
  00857	33 c9		 xor	 ecx, ecx
  00859	eb 05		 jmp	 SHORT $LN2090@Obstaw
$LN2089@Obstaw:
  0085b	1b c9		 sbb	 ecx, ecx
  0085d	83 c9 01	 or	 ecx, 1
$LN2090@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00860	85 c9		 test	 ecx, ecx
  00862	0f 84 23 03 00
	00		 je	 $LN5@Obstaw
$LN1271@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00868	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0086a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0086d	72 02		 jb	 SHORT $LN1878@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0086f	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1878@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00871	83 f8 02	 cmp	 eax, 2
  00874	75 1f		 jne	 SHORT $LN1302@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00876	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00879	80 f9 31	 cmp	 cl, 49			; 00000031H
  0087c	75 0a		 jne	 SHORT $LN2091@Obstaw
  0087e	80 7f 01 39	 cmp	 BYTE PTR [edi+1], 57	; 00000039H
  00882	75 04		 jne	 SHORT $LN2091@Obstaw
  00884	33 c9		 xor	 ecx, ecx
  00886	eb 05		 jmp	 SHORT $LN2092@Obstaw
$LN2091@Obstaw:
  00888	1b c9		 sbb	 ecx, ecx
  0088a	83 c9 01	 or	 ecx, 1
$LN2092@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0088d	85 c9		 test	 ecx, ecx
  0088f	0f 84 f6 02 00
	00		 je	 $LN5@Obstaw
$LN1302@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00895	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00897	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0089a	72 02		 jb	 SHORT $LN1879@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0089c	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1879@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0089e	83 f8 02	 cmp	 eax, 2
  008a1	75 1f		 jne	 SHORT $LN1333@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  008a3	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  008a6	80 f9 32	 cmp	 cl, 50			; 00000032H
  008a9	75 0a		 jne	 SHORT $LN2093@Obstaw
  008ab	80 7f 01 30	 cmp	 BYTE PTR [edi+1], 48	; 00000030H
  008af	75 04		 jne	 SHORT $LN2093@Obstaw
  008b1	33 c9		 xor	 ecx, ecx
  008b3	eb 05		 jmp	 SHORT $LN2094@Obstaw
$LN2093@Obstaw:
  008b5	1b c9		 sbb	 ecx, ecx
  008b7	83 c9 01	 or	 ecx, 1
$LN2094@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  008ba	85 c9		 test	 ecx, ecx
  008bc	0f 84 c9 02 00
	00		 je	 $LN5@Obstaw
$LN1333@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008c2	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008c4	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  008c7	72 02		 jb	 SHORT $LN1880@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  008c9	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1880@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  008cb	83 f8 02	 cmp	 eax, 2
  008ce	75 1f		 jne	 SHORT $LN1364@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  008d0	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  008d3	80 f9 32	 cmp	 cl, 50			; 00000032H
  008d6	75 0a		 jne	 SHORT $LN2095@Obstaw
  008d8	80 7f 01 31	 cmp	 BYTE PTR [edi+1], 49	; 00000031H
  008dc	75 04		 jne	 SHORT $LN2095@Obstaw
  008de	33 c9		 xor	 ecx, ecx
  008e0	eb 05		 jmp	 SHORT $LN2096@Obstaw
$LN2095@Obstaw:
  008e2	1b c9		 sbb	 ecx, ecx
  008e4	83 c9 01	 or	 ecx, 1
$LN2096@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  008e7	85 c9		 test	 ecx, ecx
  008e9	0f 84 9c 02 00
	00		 je	 $LN5@Obstaw
$LN1364@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008ef	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008f1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  008f4	72 02		 jb	 SHORT $LN1881@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  008f6	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1881@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  008f8	83 f8 02	 cmp	 eax, 2
  008fb	75 1e		 jne	 SHORT $LN1395@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  008fd	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00900	80 f9 32	 cmp	 cl, 50			; 00000032H
  00903	75 09		 jne	 SHORT $LN2097@Obstaw
  00905	38 4f 01	 cmp	 BYTE PTR [edi+1], cl
  00908	75 04		 jne	 SHORT $LN2097@Obstaw
  0090a	33 c9		 xor	 ecx, ecx
  0090c	eb 05		 jmp	 SHORT $LN2098@Obstaw
$LN2097@Obstaw:
  0090e	1b c9		 sbb	 ecx, ecx
  00910	83 c9 01	 or	 ecx, 1
$LN2098@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00913	85 c9		 test	 ecx, ecx
  00915	0f 84 70 02 00
	00		 je	 $LN5@Obstaw
$LN1395@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0091b	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0091d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00920	72 02		 jb	 SHORT $LN1882@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00922	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1882@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00924	83 f8 02	 cmp	 eax, 2
  00927	75 1f		 jne	 SHORT $LN1426@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00929	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0092c	80 f9 32	 cmp	 cl, 50			; 00000032H
  0092f	75 0a		 jne	 SHORT $LN2099@Obstaw
  00931	80 7f 01 33	 cmp	 BYTE PTR [edi+1], 51	; 00000033H
  00935	75 04		 jne	 SHORT $LN2099@Obstaw
  00937	33 c9		 xor	 ecx, ecx
  00939	eb 05		 jmp	 SHORT $LN2100@Obstaw
$LN2099@Obstaw:
  0093b	1b c9		 sbb	 ecx, ecx
  0093d	83 c9 01	 or	 ecx, 1
$LN2100@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00940	85 c9		 test	 ecx, ecx
  00942	0f 84 43 02 00
	00		 je	 $LN5@Obstaw
$LN1426@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00948	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0094a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0094d	72 02		 jb	 SHORT $LN1883@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0094f	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1883@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00951	83 f8 02	 cmp	 eax, 2
  00954	75 1f		 jne	 SHORT $LN1457@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00956	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00959	80 f9 32	 cmp	 cl, 50			; 00000032H
  0095c	75 0a		 jne	 SHORT $LN2101@Obstaw
  0095e	80 7f 01 34	 cmp	 BYTE PTR [edi+1], 52	; 00000034H
  00962	75 04		 jne	 SHORT $LN2101@Obstaw
  00964	33 c9		 xor	 ecx, ecx
  00966	eb 05		 jmp	 SHORT $LN2102@Obstaw
$LN2101@Obstaw:
  00968	1b c9		 sbb	 ecx, ecx
  0096a	83 c9 01	 or	 ecx, 1
$LN2102@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0096d	85 c9		 test	 ecx, ecx
  0096f	0f 84 16 02 00
	00		 je	 $LN5@Obstaw
$LN1457@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00975	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00977	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0097a	72 02		 jb	 SHORT $LN1884@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0097c	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1884@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0097e	83 f8 02	 cmp	 eax, 2
  00981	75 1f		 jne	 SHORT $LN1488@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00983	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00986	80 f9 32	 cmp	 cl, 50			; 00000032H
  00989	75 0a		 jne	 SHORT $LN2103@Obstaw
  0098b	80 7f 01 35	 cmp	 BYTE PTR [edi+1], 53	; 00000035H
  0098f	75 04		 jne	 SHORT $LN2103@Obstaw
  00991	33 c9		 xor	 ecx, ecx
  00993	eb 05		 jmp	 SHORT $LN2104@Obstaw
$LN2103@Obstaw:
  00995	1b c9		 sbb	 ecx, ecx
  00997	83 c9 01	 or	 ecx, 1
$LN2104@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0099a	85 c9		 test	 ecx, ecx
  0099c	0f 84 e9 01 00
	00		 je	 $LN5@Obstaw
$LN1488@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  009a2	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009a4	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  009a7	72 02		 jb	 SHORT $LN1885@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  009a9	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1885@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  009ab	83 f8 02	 cmp	 eax, 2
  009ae	75 1f		 jne	 SHORT $LN1519@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  009b0	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  009b3	80 f9 32	 cmp	 cl, 50			; 00000032H
  009b6	75 0a		 jne	 SHORT $LN2105@Obstaw
  009b8	80 7f 01 36	 cmp	 BYTE PTR [edi+1], 54	; 00000036H
  009bc	75 04		 jne	 SHORT $LN2105@Obstaw
  009be	33 c9		 xor	 ecx, ecx
  009c0	eb 05		 jmp	 SHORT $LN2106@Obstaw
$LN2105@Obstaw:
  009c2	1b c9		 sbb	 ecx, ecx
  009c4	83 c9 01	 or	 ecx, 1
$LN2106@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  009c7	85 c9		 test	 ecx, ecx
  009c9	0f 84 bc 01 00
	00		 je	 $LN5@Obstaw
$LN1519@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  009cf	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009d1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  009d4	72 02		 jb	 SHORT $LN1886@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  009d6	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1886@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  009d8	83 f8 02	 cmp	 eax, 2
  009db	75 1f		 jne	 SHORT $LN1550@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  009dd	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  009e0	80 f9 32	 cmp	 cl, 50			; 00000032H
  009e3	75 0a		 jne	 SHORT $LN2107@Obstaw
  009e5	80 7f 01 37	 cmp	 BYTE PTR [edi+1], 55	; 00000037H
  009e9	75 04		 jne	 SHORT $LN2107@Obstaw
  009eb	33 c9		 xor	 ecx, ecx
  009ed	eb 05		 jmp	 SHORT $LN2108@Obstaw
$LN2107@Obstaw:
  009ef	1b c9		 sbb	 ecx, ecx
  009f1	83 c9 01	 or	 ecx, 1
$LN2108@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  009f4	85 c9		 test	 ecx, ecx
  009f6	0f 84 8f 01 00
	00		 je	 $LN5@Obstaw
$LN1550@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  009fc	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009fe	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00a01	72 02		 jb	 SHORT $LN1887@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a03	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1887@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00a05	83 f8 02	 cmp	 eax, 2
  00a08	75 1f		 jne	 SHORT $LN1581@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00a0a	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00a0d	80 f9 32	 cmp	 cl, 50			; 00000032H
  00a10	75 0a		 jne	 SHORT $LN2109@Obstaw
  00a12	80 7f 01 38	 cmp	 BYTE PTR [edi+1], 56	; 00000038H
  00a16	75 04		 jne	 SHORT $LN2109@Obstaw
  00a18	33 c9		 xor	 ecx, ecx
  00a1a	eb 05		 jmp	 SHORT $LN2110@Obstaw
$LN2109@Obstaw:
  00a1c	1b c9		 sbb	 ecx, ecx
  00a1e	83 c9 01	 or	 ecx, 1
$LN2110@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00a21	85 c9		 test	 ecx, ecx
  00a23	0f 84 62 01 00
	00		 je	 $LN5@Obstaw
$LN1581@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00a29	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a2b	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00a2e	72 02		 jb	 SHORT $LN1888@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a30	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1888@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00a32	83 f8 02	 cmp	 eax, 2
  00a35	75 1f		 jne	 SHORT $LN1612@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00a37	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00a3a	80 f9 32	 cmp	 cl, 50			; 00000032H
  00a3d	75 0a		 jne	 SHORT $LN2111@Obstaw
  00a3f	80 7f 01 39	 cmp	 BYTE PTR [edi+1], 57	; 00000039H
  00a43	75 04		 jne	 SHORT $LN2111@Obstaw
  00a45	33 c9		 xor	 ecx, ecx
  00a47	eb 05		 jmp	 SHORT $LN2112@Obstaw
$LN2111@Obstaw:
  00a49	1b c9		 sbb	 ecx, ecx
  00a4b	83 c9 01	 or	 ecx, 1
$LN2112@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00a4e	85 c9		 test	 ecx, ecx
  00a50	0f 84 35 01 00
	00		 je	 $LN5@Obstaw
$LN1612@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00a56	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a58	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00a5b	72 02		 jb	 SHORT $LN1889@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a5d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1889@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00a5f	83 f8 02	 cmp	 eax, 2
  00a62	75 1f		 jne	 SHORT $LN1643@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00a64	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00a67	80 f9 33	 cmp	 cl, 51			; 00000033H
  00a6a	75 0a		 jne	 SHORT $LN2113@Obstaw
  00a6c	80 7f 01 30	 cmp	 BYTE PTR [edi+1], 48	; 00000030H
  00a70	75 04		 jne	 SHORT $LN2113@Obstaw
  00a72	33 c9		 xor	 ecx, ecx
  00a74	eb 05		 jmp	 SHORT $LN2114@Obstaw
$LN2113@Obstaw:
  00a76	1b c9		 sbb	 ecx, ecx
  00a78	83 c9 01	 or	 ecx, 1
$LN2114@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00a7b	85 c9		 test	 ecx, ecx
  00a7d	0f 84 08 01 00
	00		 je	 $LN5@Obstaw
$LN1643@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00a83	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a85	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00a88	72 02		 jb	 SHORT $LN1890@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a8a	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1890@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00a8c	83 f8 02	 cmp	 eax, 2
  00a8f	75 1f		 jne	 SHORT $LN1674@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00a91	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00a94	80 f9 33	 cmp	 cl, 51			; 00000033H
  00a97	75 0a		 jne	 SHORT $LN2115@Obstaw
  00a99	80 7f 01 31	 cmp	 BYTE PTR [edi+1], 49	; 00000031H
  00a9d	75 04		 jne	 SHORT $LN2115@Obstaw
  00a9f	33 c9		 xor	 ecx, ecx
  00aa1	eb 05		 jmp	 SHORT $LN2116@Obstaw
$LN2115@Obstaw:
  00aa3	1b c9		 sbb	 ecx, ecx
  00aa5	83 c9 01	 or	 ecx, 1
$LN2116@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00aa8	85 c9		 test	 ecx, ecx
  00aaa	0f 84 db 00 00
	00		 je	 $LN5@Obstaw
$LN1674@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00ab0	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ab2	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00ab5	72 02		 jb	 SHORT $LN1891@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00ab7	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1891@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00ab9	83 f8 02	 cmp	 eax, 2
  00abc	75 1f		 jne	 SHORT $LN1705@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00abe	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00ac1	80 f9 33	 cmp	 cl, 51			; 00000033H
  00ac4	75 0a		 jne	 SHORT $LN2117@Obstaw
  00ac6	80 7f 01 32	 cmp	 BYTE PTR [edi+1], 50	; 00000032H
  00aca	75 04		 jne	 SHORT $LN2117@Obstaw
  00acc	33 c9		 xor	 ecx, ecx
  00ace	eb 05		 jmp	 SHORT $LN2118@Obstaw
$LN2117@Obstaw:
  00ad0	1b c9		 sbb	 ecx, ecx
  00ad2	83 c9 01	 or	 ecx, 1
$LN2118@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00ad5	85 c9		 test	 ecx, ecx
  00ad7	0f 84 ae 00 00
	00		 je	 $LN5@Obstaw
$LN1705@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00add	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00adf	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00ae2	72 02		 jb	 SHORT $LN1892@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00ae4	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1892@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00ae6	83 f8 02	 cmp	 eax, 2
  00ae9	75 1e		 jne	 SHORT $LN1736@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00aeb	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00aee	80 f9 33	 cmp	 cl, 51			; 00000033H
  00af1	75 09		 jne	 SHORT $LN2119@Obstaw
  00af3	38 4f 01	 cmp	 BYTE PTR [edi+1], cl
  00af6	75 04		 jne	 SHORT $LN2119@Obstaw
  00af8	33 c9		 xor	 ecx, ecx
  00afa	eb 05		 jmp	 SHORT $LN2120@Obstaw
$LN2119@Obstaw:
  00afc	1b c9		 sbb	 ecx, ecx
  00afe	83 c9 01	 or	 ecx, 1
$LN2120@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00b01	85 c9		 test	 ecx, ecx
  00b03	0f 84 82 00 00
	00		 je	 $LN5@Obstaw
$LN1736@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00b09	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b0b	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00b0e	72 02		 jb	 SHORT $LN1893@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00b10	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1893@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00b12	83 f8 02	 cmp	 eax, 2
  00b15	75 1b		 jne	 SHORT $LN1767@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00b17	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00b1a	80 f9 33	 cmp	 cl, 51			; 00000033H
  00b1d	75 0a		 jne	 SHORT $LN2121@Obstaw
  00b1f	80 7f 01 34	 cmp	 BYTE PTR [edi+1], 52	; 00000034H
  00b23	75 04		 jne	 SHORT $LN2121@Obstaw
  00b25	33 c9		 xor	 ecx, ecx
  00b27	eb 05		 jmp	 SHORT $LN2122@Obstaw
$LN2121@Obstaw:
  00b29	1b c9		 sbb	 ecx, ecx
  00b2b	83 c9 01	 or	 ecx, 1
$LN2122@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00b2e	85 c9		 test	 ecx, ecx
  00b30	74 59		 je	 SHORT $LN5@Obstaw
$LN1767@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00b32	8b fe		 mov	 edi, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b34	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00b37	72 02		 jb	 SHORT $LN1894@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00b39	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN1894@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00b3b	83 f8 02	 cmp	 eax, 2
  00b3e	75 1b		 jne	 SHORT $LN1798@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00b40	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00b43	80 f9 33	 cmp	 cl, 51			; 00000033H
  00b46	75 0a		 jne	 SHORT $LN2123@Obstaw
  00b48	80 7f 01 35	 cmp	 BYTE PTR [edi+1], 53	; 00000035H
  00b4c	75 04		 jne	 SHORT $LN2123@Obstaw
  00b4e	33 c9		 xor	 ecx, ecx
  00b50	eb 05		 jmp	 SHORT $LN2124@Obstaw
$LN2123@Obstaw:
  00b52	1b c9		 sbb	 ecx, ecx
  00b54	83 c9 01	 or	 ecx, 1
$LN2124@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00b57	85 c9		 test	 ecx, ecx
  00b59	74 30		 je	 SHORT $LN5@Obstaw
$LN1798@Obstaw:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00b5b	8b ce		 mov	 ecx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b5d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00b60	72 02		 jb	 SHORT $LN1837@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00b62	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN1837@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00b64	83 f8 02	 cmp	 eax, 2
  00b67	0f 85 e5 f4 ff
	ff		 jne	 $LL4@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00b6d	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00b70	3c 33		 cmp	 al, 51			; 00000033H
  00b72	75 0a		 jne	 SHORT $LN2125@Obstaw
  00b74	80 79 01 36	 cmp	 BYTE PTR [ecx+1], 54	; 00000036H
  00b78	75 04		 jne	 SHORT $LN2125@Obstaw
  00b7a	33 c0		 xor	 eax, eax
  00b7c	eb 05		 jmp	 SHORT $LN2126@Obstaw
$LN2125@Obstaw:
  00b7e	1b c0		 sbb	 eax, eax
  00b80	83 c8 01	 or	 eax, 1
$LN2126@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00b83	85 c0		 test	 eax, eax
  00b85	0f 85 c7 f4 ff
	ff		 jne	 $LL4@Obstaw
$LN5@Obstaw:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 186  : 	return zaklad_typ; //Zwracam typ zak³adu podany przez u¿ytkownika

  00b8b	8b c6		 mov	 eax, esi

; 187  : }

  00b8d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00b90	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00b97	59		 pop	 ecx
  00b98	5f		 pop	 edi
  00b99	5e		 pop	 esi
  00b9a	8b e5		 mov	 esp, ebp
  00b9c	5d		 pop	 ebp
  00b9d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@Obstaw
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@Obstaw:
  00018	c3		 ret	 0
__ehhandler$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Obstaw
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z
_TEXT	SEGMENT
_iloæ_pieniêdzy$GSCopy$1$ = -48			; size = 4
_kwota_zak³adu$GSCopy$1$ = -44				; size = 4
_kwota_zak³adu_s$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z PROC		; Wczytaj_Kwotê_Zak³adu, COMDAT
; _kwota_zak³adu$ = ecx
; _iloæ_pieniêdzy$ = edx

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b da		 mov	 ebx, edx
  0002d	89 5d d0	 mov	 DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp], ebx
  00030	8b f1		 mov	 esi, ecx
  00032	89 75 d4	 mov	 DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00035	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _kwota_zak³adu_s$[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _kwota_zak³adu_s$[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00043	c6 45 d8 00	 mov	 BYTE PTR _kwota_zak³adu_s$[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 191  : 	string kwota_zak³adu_s; //Deklaracja zmiennej typu string do wczytywania kwoty aby zabezpieczyæ siê przed b³êdem wpisania do zmiennej liczbowej litery

  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004e	66 90		 npad	 2
$LL2@Wczytaj_Kw:

; 192  : 
; 193  : 	while (true) //Rozpoczêcie pêtli nieskoñczonej
; 194  : 	{
; 195  : 		cout << "Masz " << iloæ_pieniêdzy << "$, jak¹ kwot¹ chcesz obstawiæ wynik?" << endl; //Podanie akualnego stanu konta i zadanie pytania o kwotê zak³adu

  00050	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00055	ff 33		 push	 DWORD PTR [ebx]
  00057	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05OMMBNPEF@Masz?5?$AA@
  0005c	51		 push	 ecx
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00063	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00068	83 c4 04	 add	 esp, 4
  0006b	8b c8		 mov	 ecx, eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00073	51		 push	 ecx
  00074	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CF@MANFGHNE@$?0?5jak?$LJ?5kwot?$LJ?5chcesz?5obstawi?f?5wy@
  00079	8b c8		 mov	 ecx, eax
  0007b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00080	83 c4 04	 add	 esp, 4
  00083	8b c8		 mov	 ecx, eax
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  00091	8d 55 d8	 lea	 edx, DWORD PTR _kwota_zak³adu_s$[ebp]
  00094	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00099	83 7d ec 10	 cmp	 DWORD PTR _kwota_zak³adu_s$[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0009d	8d 45 d8	 lea	 eax, DWORD PTR _kwota_zak³adu_s$[ebp]

; 1594 : 		if (_Large_string_engaged())

  000a0	0f 43 45 d8	 cmovae	 eax, DWORD PTR _kwota_zak³adu_s$[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 197  : 		kwota_zak³adu = atoi(kwota_zak³adu_s.c_str()); //Zmiana stringa na inta i wpisanie do zmiennej kwota_zak³adu

  000a4	50		 push	 eax
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  000ab	83 c4 04	 add	 esp, 4
  000ae	89 06		 mov	 DWORD PTR [esi], eax
  000b0	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 198  : 		if ((kwota_zak³adu > 0) && (kwota_zak³adu <= iloæ_pieniêdzy)) //Sprawdzenie czy kwota zak³¹du jest wiêksza od zeri i mniejsza lub równa dostêpnej gotówce

  000b2	85 c0		 test	 eax, eax
  000b4	7e 0a		 jle	 SHORT $LN180@Wczytaj_Kw
  000b6	3b c1		 cmp	 eax, ecx
  000b8	0f 8e d5 00 00
	00		 jle	 $LN166@Wczytaj_Kw

; 199  : 			break; //Je¿eli tak to zatrzymuje pêtle
; 200  : 		else //W przeciwym wypadku
; 201  : 			if (kwota_zak³adu == 0) //Je¿eli wynikiem zamiany na liczbê jest zero (wynikiem zamiany jest zero kiedy tekst to zero lub kiedy jest b³¹d zamiany) to

  000be	85 c0		 test	 eax, eax
$LN180@Wczytaj_Kw:
  000c0	75 7d		 jne	 SHORT $LN9@Wczytaj_Kw

; 202  : 			{
; 203  : 				bool czy_zero = true; //Utworzenie zmiennej informuj¹cej czy znaleziono zero w tekcie i przypisanie jej wartoci true
; 204  : 				for (unsigned short i = 0; i < (unsigned short)kwota_zak³adu_s.size(); ++i) //Rozpoczêcie pêtli numerowanej przez zmienn¹ i przez wszystkie znaki wczytanego tekst

  000c2	66 8b 75 e8	 mov	 si, WORD PTR _kwota_zak³adu_s$[ebp+16]
  000c6	33 c9		 xor	 ecx, ecx
  000c8	33 c0		 xor	 eax, eax
  000ca	66 3b ce	 cmp	 cx, si
  000cd	73 21		 jae	 SHORT $LN173@Wczytaj_Kw
  000cf	8b 7d ec	 mov	 edi, DWORD PTR _kwota_zak³adu_s$[ebp+20]
  000d2	8b 5d d8	 mov	 ebx, DWORD PTR _kwota_zak³adu_s$[ebp]
$LL6@Wczytaj_Kw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000d5	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 205  : 					if (kwota_zak³adu_s[i] != '0') //Je¿eli znak na i-tej pozycji

  000d8	0f b7 c8	 movzx	 ecx, ax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  000db	8d 55 d8	 lea	 edx, DWORD PTR _kwota_zak³adu_s$[ebp]

; 1583 : 		if (_Large_string_engaged())

  000de	0f 43 d3	 cmovae	 edx, ebx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 205  : 					if (kwota_zak³adu_s[i] != '0') //Je¿eli znak na i-tej pozycji

  000e1	80 3c 11 30	 cmp	 BYTE PTR [ecx+edx], 48	; 00000030H
  000e5	75 2f		 jne	 SHORT $LN165@Wczytaj_Kw

; 202  : 			{
; 203  : 				bool czy_zero = true; //Utworzenie zmiennej informuj¹cej czy znaleziono zero w tekcie i przypisanie jej wartoci true
; 204  : 				for (unsigned short i = 0; i < (unsigned short)kwota_zak³adu_s.size(); ++i) //Rozpoczêcie pêtli numerowanej przez zmienn¹ i przez wszystkie znaki wczytanego tekst

  000e7	40		 inc	 eax
  000e8	66 3b c6	 cmp	 ax, si
  000eb	72 e8		 jb	 SHORT $LL6@Wczytaj_Kw

; 198  : 		if ((kwota_zak³adu > 0) && (kwota_zak³adu <= iloæ_pieniêdzy)) //Sprawdzenie czy kwota zak³¹du jest wiêksza od zeri i mniejsza lub równa dostêpnej gotówce

  000ed	8b 5d d0	 mov	 ebx, DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp]
$LN173@Wczytaj_Kw:

; 213  : 				{
; 214  : 					cout << "Nie mo¿esz obstawiæ zerowego zak³adu" << endl; //Poinformowanie u¿ytkownika, ¿e nie mo¿e obstawiæ zerowego zak³adu

  000f0	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000f5	51		 push	 ecx
  000f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000fc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@
  00101	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00106	83 c4 04	 add	 esp, 4
  00109	8b c8		 mov	 ecx, eax
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 215  : 					if (Ustawienia.stan_dwiêków) cout << '\a'; //Je¿eli stan_dwiêków == 1 to wywo³anie pikniêcia w g³oniku

  00111	8b 75 d4	 mov	 esi, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]

; 216  : 				}
; 217  : 			}

  00114	eb 5d		 jmp	 SHORT $LN181@Wczytaj_Kw
$LN165@Wczytaj_Kw:

; 206  : 					{
; 207  : 						cout << "Wprowadzi³eæ nieprawid³ow¹ wartoæ" << endl; //Poinformowanie u¿ytkownika, ¿e nie mo¿e obstawiæ tekstowego

  00116	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0011b	51		 push	 ecx
  0011c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00122	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@
  00127	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0012c	83 c4 04	 add	 esp, 4
  0012f	8b c8		 mov	 ecx, eax
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 208  : 						if (Ustawienia.stan_dwiêków) cout << '\a'; //Je¿eli stan_dwiêków == 1 to wywo³anie pikniêcia w g³oniku

  00137	8b 5d d0	 mov	 ebx, DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp]
  0013a	8b 75 d4	 mov	 esi, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]

; 209  : 						czy_zero = false; //Zmiana wartoci zmiennej czy znaleziono zero w tekcie na false
; 210  : 						break; //Zatrzymanie pêtli
; 211  : 					}
; 212  : 				if (czy_zero) //Sprawdzenie czy znaleziono same zera w tekcie, je¿eli tak to

  0013d	eb 34		 jmp	 SHORT $LN181@Wczytaj_Kw
$LN9@Wczytaj_Kw:

; 218  : 			else if (kwota_zak³adu > iloæ_pieniêdzy) //Je¿eli u¿ytkownik chce obstawiæ za wiêcej ni¿ ma, to

  0013f	3b c1		 cmp	 eax, ecx
  00141	7e 07		 jle	 SHORT $LN15@Wczytaj_Kw

; 219  : 			{
; 220  : 				cout << "Nie masz tyle pieniêdzy" << endl; //Poinformowanie go o tym

  00143	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@

; 221  : 				if (Ustawienia.stan_dwiêków) cout << '\a'; //Je¿eli stan_dwiêków == 1 to wywo³anie pikniêcia w g³oniku
; 222  : 			}

  00148	eb 0d		 jmp	 SHORT $LN182@Wczytaj_Kw
$LN15@Wczytaj_Kw:

; 223  : 			else if (kwota_zak³adu < 0) //Je¿eli u¿ytkownik chce obstawiæ za ujemn¹ kwotê, to

  0014a	85 c0		 test	 eax, eax
  0014c	0f 89 fe fe ff
	ff		 jns	 $LL2@Wczytaj_Kw

; 224  : 			{
; 225  : 				cout << "Nie mo¿esz obstawiæ ujemn¹ kwot¹ zak³adu" << endl; //Poinformowanie go o tym

  00152	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@
$LN182@Wczytaj_Kw:
  00157	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0015c	51		 push	 ecx
  0015d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00163	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00168	83 c4 04	 add	 esp, 4
  0016b	8b c8		 mov	 ecx, eax
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN181@Wczytaj_Kw:

; 226  : 				if (Ustawienia.stan_dwiêków) cout << '\a'; //Je¿eli stan_dwiêków == 1 to wywo³anie pikniêcia w g³oniku

  00173	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  0017b	0f 84 cf fe ff
	ff		 je	 $LL2@Wczytaj_Kw
  00181	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00187	b2 07		 mov	 dl, 7
  00189	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 227  : 			}
; 228  : 	}

  0018e	e9 bd fe ff ff	 jmp	 $LL2@Wczytaj_Kw
$LN166@Wczytaj_Kw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00193	8b 55 ec	 mov	 edx, DWORD PTR _kwota_zak³adu_s$[ebp+20]
  00196	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00199	72 3e		 jb	 SHORT $LN128@Wczytaj_Kw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0019b	8b 4d d8	 mov	 ecx, DWORD PTR _kwota_zak³adu_s$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0019e	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0019f	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001a1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001a7	72 26		 jb	 SHORT $LN131@Wczytaj_Kw

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001a9	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  001ac	3b f2		 cmp	 esi, edx
  001ae	76 19		 jbe	 SHORT $_Invalid_parameter$185

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001b0	8b d6		 mov	 edx, esi
  001b2	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001b4	75 13		 jne	 SHORT $_Invalid_parameter$185

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001b6	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001b9	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  001bb	73 0c		 jae	 SHORT $_Invalid_parameter$185

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001bd	2b c1		 sub	 eax, ecx
  001bf	83 f8 04	 cmp	 eax, 4
  001c2	72 05		 jb	 SHORT $_Invalid_parameter$185

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  001c4	83 f8 23	 cmp	 eax, 35			; 00000023H
  001c7	76 06		 jbe	 SHORT $LN131@Wczytaj_Kw
$_Invalid_parameter$185:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN184@Wczytaj_Kw:
$LN131@Wczytaj_Kw:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  001cf	52		 push	 edx
  001d0	51		 push	 ecx
  001d1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001d6	83 c4 08	 add	 esp, 8
$LN128@Wczytaj_Kw:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 229  : }

  001d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e3	59		 pop	 ecx
  001e4	5f		 pop	 edi
  001e5	5e		 pop	 esi
  001e6	5b		 pop	 ebx
  001e7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ea	33 cd		 xor	 ecx, ebp
  001ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f1	8b e5		 mov	 esp, ebp
  001f3	5d		 pop	 ebp
  001f4	c3		 ret	 0
$LN183@Wczytaj_Kw:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _kwota_zak³adu_s$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z ENDP		; Wczytaj_Kwotê_Zak³adu
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Zakrêæ_Ruletk¹@@YAHXZ
_TEXT	SEGMENT
_czas_przeskoku_kulki_wolny_przyspieszenie$1$ = -32	; size = 8
_czas_przeskoku_kulki_szybki_opónienie$1$ = -32	; size = 8
_i$1$ = -20						; size = 4
_iloæ_zakrêceñ$1$ = -20				; size = 4
$T3 = -20						; size = 4
tv835 = -16						; size = 8
_hCCI$17 = -16						; size = 8
_hCCI$18 = -16						; size = 8
$T4 = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?Zakrêæ_Ruletk¹@@YAHXZ PROC				; Zakrêæ_Ruletk¹, COMDAT

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 233  : 	int iloæ_zakrêceñ = rand() % (Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki + 1) + Ustawienia.iloæ_minimalna_obrotów_ruletki; //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ pseudolosow¹ (o niskiej pseoudolosowoci) iloæ obrotów ruletk¹ ((od 0 do max dodatkowych obrotów ruletki) + minimalna iloæ obrotów ruletki) zanim nastêpi finalny obrót

  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00019	0f bf 0d 02 00
	00 00		 movsx	 ecx, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2
  00020	41		 inc	 ecx
  00021	99		 cdq
  00022	f7 f9		 idiv	 ecx
  00024	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?Ustawienia@@3US_Ustawienia@@A

; 234  : 	double czas_przeskoku_kulki_szybki_opónienie = Ustawienia.czas_przeskoku_kulki_szybki / (iloæ_zakrêceñ * 37.0); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoæ na kole ruletki powinna byæ szybciej pokazana

  0002b	0f bf 05 04 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4
  00032	03 ca		 add	 ecx, edx

; 387  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00034	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetStdHandle@4
  0003a	6a f5		 push	 -11			; fffffff5H

; 233  : 	int iloæ_zakrêceñ = rand() % (Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki + 1) + Ustawienia.iloæ_minimalna_obrotów_ruletki; //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ pseudolosow¹ (o niskiej pseoudolosowoci) iloæ obrotów ruletk¹ ((od 0 do max dodatkowych obrotów ruletki) + minimalna iloæ obrotów ruletki) zanim nastêpi finalny obrót

  0003c	89 4d ec	 mov	 DWORD PTR _iloæ_zakrêceñ$1$[ebp], ecx
  0003f	66 0f 6e c1	 movd	 xmm0, ecx

; 234  : 	double czas_przeskoku_kulki_szybki_opónienie = Ustawienia.czas_przeskoku_kulki_szybki / (iloæ_zakrêceñ * 37.0); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoæ na kole ruletki powinna byæ szybciej pokazana

  00043	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00047	66 0f 6e c8	 movd	 xmm1, eax
  0004b	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4042800000000000
  00053	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00057	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0005b	f2 0f 11 4d e0	 movsd	 QWORD PTR _czas_przeskoku_kulki_szybki_opónienie$1$[ebp], xmm1

; 387  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00060	ff d7		 call	 edi
  00062	8b f0		 mov	 esi, eax

; 388  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 389  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  00064	8d 45 f0	 lea	 eax, DWORD PTR _hCCI$18[ebp]
  00067	50		 push	 eax
  00068	56		 push	 esi
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 390  : 	hCCI.bVisible = FALSE; //Zmiena widocznoci kursora na niewidoczny
; 391  : 	SetConsoleCursorInfo(hConsoleOut, &hCCI); //Ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  0006f	8d 45 f0	 lea	 eax, DWORD PTR _hCCI$18[ebp]
  00072	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hCCI$18[ebp+4], 0
  00079	50		 push	 eax
  0007a	56		 push	 esi
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8

; 233  : 	int iloæ_zakrêceñ = rand() % (Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki + 1) + Ustawienia.iloæ_minimalna_obrotów_ruletki; //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ pseudolosow¹ (o niskiej pseoudolosowoci) iloæ obrotów ruletk¹ ((od 0 do max dodatkowych obrotów ruletki) + minimalna iloæ obrotów ruletki) zanim nastêpi finalny obrót

  00081	33 db		 xor	 ebx, ebx

; 235  : 	Hide_Cursor(); //Ukrycie kursora tekstowego w konsoli
; 236  : 	for (int i = 0; i < iloæ_zakrêceñ; ++i) //Wykonanie iloæ_zakrêceñ obrotów ruletk¹

  00083	39 5d ec	 cmp	 DWORD PTR _iloæ_zakrêceñ$1$[ebp], ebx
  00086	0f 8e c8 00 00
	00		 jle	 $LN3@Zakr?
  0008c	0f 1f 40 00	 npad	 4
$LL4@Zakr?:
  00090	66 0f 6e c3	 movd	 xmm0, ebx

; 237  : 		for (int ii = 0; ii < 37; ++ii) //Przejcie przez wszystkie pozycje ruletki

  00094	33 ff		 xor	 edi, edi
  00096	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0009a	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4042800000000000
  000a2	f2 0f 11 45 f0	 movsd	 QWORD PTR tv835[ebp], xmm0
  000a7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@Zakr?:

; 238  : 		{
; 239  : 			Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[ii]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  000b0	0f b7 04 7d 00
	00 00 00	 movzx	 eax, WORD PTR ?Ruletka_ko³o@@3QBGB[edi*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  000b8	6a f5		 push	 -11			; fffffff5H

; 238  : 		{
; 239  : 			Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[ii]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  000ba	0f b7 34 45 00
	00 00 00	 movzx	 esi, WORD PTR ?Ruletka_plansza_kolor_col@@3QBGB[eax*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  000c8	56		 push	 esi
  000c9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetConsoleTextAttribute@8
  000cf	50		 push	 eax
  000d0	ff d6		 call	 esi

; 240  : 			cout << Ruletka_ko³o[ii]; //Wypisanie numeru na kole ruletki na którym znajduje siê pêtla

  000d2	0f b7 04 7d 00
	00 00 00	 movzx	 eax, WORD PTR ?Ruletka_ko³o@@3QBGB[edi*2]
  000da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000e0	50		 push	 eax
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  000e7	66 0f 6e c7	 movd	 xmm0, edi

; 241  : 			Sleep((DWORD)(czas_przeskoku_kulki_szybki_opónienie*((double)i*37.0 + (double)ii))); //Przestój który zwiêksza siê co zmianê pozycji pêtli

  000eb	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000ef	f2 0f 58 45 f0	 addsd	 xmm0, QWORD PTR tv835[ebp]
  000f4	f2 0f 59 45 e0	 mulsd	 xmm0, QWORD PTR _czas_przeskoku_kulki_szybki_opónienie$1$[ebp]
  000f9	e8 00 00 00 00	 call	 __dtoui3
  000fe	50		 push	 eax
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00105	6a f5		 push	 -11			; fffffff5H
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0010d	6a 07		 push	 7
  0010f	50		 push	 eax
  00110	ff d6		 call	 esi

; 242  : 			Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 243  : 			cout << "\b\b" << "  " << "\b\b"; //Cofniêcie kursora tekstowego do lewej strony konsoli aby zape³niæ podem spacjami czyli niewidocznym znakiem wiersza konsoli aby widaæ przejcie pomiêdzy liczbami na ruletce

  00112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00118	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  0011d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00122	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
  00127	8b c8		 mov	 ecx, eax
  00129	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0012e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  00133	8b c8		 mov	 ecx, eax
  00135	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0013a	47		 inc	 edi
  0013b	83 ff 25	 cmp	 edi, 37			; 00000025H
  0013e	0f 8c 6c ff ff
	ff		 jl	 $LL7@Zakr?

; 235  : 	Hide_Cursor(); //Ukrycie kursora tekstowego w konsoli
; 236  : 	for (int i = 0; i < iloæ_zakrêceñ; ++i) //Wykonanie iloæ_zakrêceñ obrotów ruletk¹

  00144	43		 inc	 ebx
  00145	3b 5d ec	 cmp	 ebx, DWORD PTR _iloæ_zakrêceñ$1$[ebp]
  00148	0f 8c 42 ff ff
	ff		 jl	 $LL4@Zakr?
  0014e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetStdHandle@4
$LN3@Zakr?:

; 244  : 		}
; 245  : 	int wylosowana_pozycja = Wylosuj(0, 36); //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ losow¹ lub pseudolosow¹ liczbê (o wysokiej pseoudolosowoci) pozycjê na ruletce

  00154	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?_Random_device@std@@YAIXZ
  0015a	c7 45 ec 24 00
	00 00		 mov	 DWORD PTR $T3[ebp], 36	; 00000024H
  00161	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], 0
$LL89@Zakr?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  00168	ff d3		 call	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3987 : 			_Udiff _Val = _Ref() - (_Urng::min)();

  0016a	8b f0		 mov	 esi, eax

; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  0016c	b8 4d 91 cf ba	 mov	 eax, -1160801971	; bacf914dH
  00171	f7 e6		 mul	 esi
  00173	8b ce		 mov	 ecx, esi
  00175	2b ca		 sub	 ecx, edx
  00177	d1 e9		 shr	 ecx, 1
  00179	03 ca		 add	 ecx, edx
  0017b	c1 e9 05	 shr	 ecx, 5
  0017e	81 f9 45 3e eb
	06		 cmp	 ecx, 116080197		; 06eb3e45H
  00184	73 e2		 jae	 SHORT $LL89@Zakr?

; 3960 : 				return (_Ret % _Index);

  00186	33 d2		 xor	 edx, edx
  00188	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H
  0018d	8b c6		 mov	 eax, esi
  0018f	f7 f1		 div	 ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 246  : 	double czas_przeskoku_kulki_wolny_przyspieszenie = (Ustawienia.czas_przeskoku_kulki_wolny - Ustawienia.czas_przeskoku_kulki_szybki) / (double)(wylosowana_pozycja); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoæ na kole ruletki powinna byæ szybciej pokazana

  00191	0f bf 05 04 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4
  00198	0f bf 0d 06 00
	00 00		 movsx	 ecx, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+6
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3960 : 				return (_Ret % _Index);

  0019f	8b da		 mov	 ebx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 246  : 	double czas_przeskoku_kulki_wolny_przyspieszenie = (Ustawienia.czas_przeskoku_kulki_wolny - Ustawienia.czas_przeskoku_kulki_szybki) / (double)(wylosowana_pozycja); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoæ na kole ruletki powinna byæ szybciej pokazana

  001a1	2b c8		 sub	 ecx, eax
  001a3	33 c0		 xor	 eax, eax
  001a5	89 45 ec	 mov	 DWORD PTR _i$1$[ebp], eax
  001a8	66 0f 6e c3	 movd	 xmm0, ebx
  001ac	66 0f 6e c9	 movd	 xmm1, ecx
  001b0	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  001b4	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001b8	f2 0f 5e c8	 divsd	 xmm1, xmm0
  001bc	f2 0f 11 4d e0	 movsd	 QWORD PTR _czas_przeskoku_kulki_wolny_przyspieszenie$1$[ebp], xmm1

; 247  : 	for (int i = 0; i < wylosowana_pozycja; ++i) //Przejcie przez pozycje do pozycji o 1 mniejszej od wylosowanej pozyji na ruletce

  001c1	85 db		 test	 ebx, ebx
  001c3	0f 8e aa 00 00
	00		 jle	 $LN9@Zakr?
  001c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@Zakr?:

; 248  : 	{
; 249  : 		Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[i]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  001d0	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?Ruletka_ko³o@@3QBGB[eax*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  001d8	6a f5		 push	 -11			; fffffff5H

; 248  : 	{
; 249  : 		Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[i]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  001da	0f b7 34 45 00
	00 00 00	 movzx	 esi, WORD PTR ?Ruletka_plansza_kolor_col@@3QBGB[eax*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  001e2	ff d7		 call	 edi

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  001e4	56		 push	 esi
  001e5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetConsoleTextAttribute@8
  001eb	50		 push	 eax
  001ec	ff d6		 call	 esi

; 250  : 		cout << Ruletka_ko³o[i]; //Wypisanie numeru na kole ruletki na którym znajduje siê pêtla

  001ee	8b 4d ec	 mov	 ecx, DWORD PTR _i$1$[ebp]
  001f1	0f b7 04 4d 00
	00 00 00	 movzx	 eax, WORD PTR ?Ruletka_ko³o@@3QBGB[ecx*2]
  001f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001ff	50		 push	 eax
  00200	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00206	66 0f 6e 45 ec	 movd	 xmm0, DWORD PTR _i$1$[ebp]

; 251  : 		Sleep((DWORD)(Ustawienia.czas_przeskoku_kulki_szybki + (czas_przeskoku_kulki_wolny_przyspieszenie*i))); //Przestój który zwiêksza siê co zmianê pozycji pêtli

  0020b	0f bf 05 04 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4
  00212	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00216	66 0f 6e c8	 movd	 xmm1, eax
  0021a	f2 0f 59 45 e0	 mulsd	 xmm0, QWORD PTR _czas_przeskoku_kulki_wolny_przyspieszenie$1$[ebp]
  0021f	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00223	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00227	e8 00 00 00 00	 call	 __dtoui3
  0022c	50		 push	 eax
  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00233	6a f5		 push	 -11			; fffffff5H
  00235	ff d7		 call	 edi

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00237	6a 07		 push	 7
  00239	50		 push	 eax
  0023a	ff d6		 call	 esi

; 252  : 		Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 253  : 		cout << "\b\b" << "  " << "\b\b"; //Cofniêcie kursora tekstowego do lewej strony konsoli aby zape³niæ podem spacjami czyli niewidocznym znakiem wiersza konsoli aby widaæ przejcie pomiêdzy liczbami na ruletce

  0023c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00242	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  00247	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0024c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
  00251	8b c8		 mov	 ecx, eax
  00253	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00258	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  0025d	8b c8		 mov	 ecx, eax
  0025f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00264	8b 45 ec	 mov	 eax, DWORD PTR _i$1$[ebp]
  00267	40		 inc	 eax
  00268	89 45 ec	 mov	 DWORD PTR _i$1$[ebp], eax
  0026b	3b c3		 cmp	 eax, ebx
  0026d	0f 8c 5d ff ff
	ff		 jl	 $LL10@Zakr?
$LN9@Zakr?:

; 254  : 	}
; 255  : 	cout << "Wylosowano numer "; //Poinformowanie o zakoñczeniu (wywietlania) losowania

  00273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00279	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
  0027e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 256  : 	Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[wylosowana_pozycja]]);//Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  00283	0f b7 04 5d 00
	00 00 00	 movzx	 eax, WORD PTR ?Ruletka_ko³o@@3QBGB[ebx*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  0028b	6a f5		 push	 -11			; fffffff5H

; 256  : 	Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[wylosowana_pozycja]]);//Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  0028d	0f b7 34 45 00
	00 00 00	 movzx	 esi, WORD PTR ?Ruletka_plansza_kolor_col@@3QBGB[eax*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00295	ff d7		 call	 edi

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00297	56		 push	 esi
  00298	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetConsoleTextAttribute@8
  0029e	50		 push	 eax
  0029f	ff d6		 call	 esi

; 257  : 	cout << Ruletka_ko³o[wylosowana_pozycja]; //Wypisanie liczby na wylosowanej pozycji ruletki

  002a1	0f b7 04 5d 00
	00 00 00	 movzx	 eax, WORD PTR ?Ruletka_ko³o@@3QBGB[ebx*2]
  002a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002af	50		 push	 eax
  002b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  002b6	6a f5		 push	 -11			; fffffff5H
  002b8	ff d7		 call	 edi

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  002ba	6a 07		 push	 7
  002bc	50		 push	 eax
  002bd	ff d6		 call	 esi

; 258  : 	Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 259  : 	cout << ". "; //Zakoñczenie tekstu kropk¹

  002bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002c5	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KHOJGJKF@?4?5?$AA@
  002ca	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 396  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  002cf	6a f5		 push	 -11			; fffffff5H
  002d1	ff d7		 call	 edi
  002d3	8b f0		 mov	 esi, eax

; 397  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 398  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  002d5	8d 45 f0	 lea	 eax, DWORD PTR _hCCI$17[ebp]
  002d8	50		 push	 eax
  002d9	56		 push	 esi
  002da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 399  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoæ widocznoci kursorsora tekstego w konsoli jest ró¿na od prawdy

  002e0	83 7d f4 01	 cmp	 DWORD PTR _hCCI$17[ebp+4], 1
  002e4	74 12		 je	 SHORT $LN164@Zakr?

; 400  : 	{
; 401  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoci kursora na widoczny
; 402  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  002e6	8d 45 f0	 lea	 eax, DWORD PTR _hCCI$17[ebp]
  002e9	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _hCCI$17[ebp+4], 1
  002f0	50		 push	 eax
  002f1	56		 push	 esi
  002f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8
$LN164@Zakr?:

; 260  : 	Show_Cursor(); //Pokazanie kursora tekstowego w konsoli
; 261  : 
; 262  : 	return Ruletka_ko³o[wylosowana_pozycja]; //Zwracam wartoæ bêd¹c¹ na wylosowanym polu ruletki
; 263  : }

  002f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fb	0f b7 04 5d 00
	00 00 00	 movzx	 eax, WORD PTR ?Ruletka_ko³o@@3QBGB[ebx*2]
  00303	33 cd		 xor	 ecx, ebp
  00305	5f		 pop	 edi
  00306	5e		 pop	 esi
  00307	5b		 pop	 ebx
  00308	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030d	8b e5		 mov	 esp, ebp
  0030f	5d		 pop	 ebp
  00310	c3		 ret	 0
?Zakrêæ_Ruletk¹@@YAHXZ ENDP				; Zakrêæ_Ruletk¹
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Sprawd_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
_kwota$1$ = -4						; size = 4
_wylosowana_liczba$ = 8					; size = 4
?Sprawd_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; Sprawd_Zak³ad, COMDAT
; _kwota$ = ecx
; _typ_zak³adu$ = edx

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b c1		 mov	 eax, ecx
  00009	56		 push	 esi

; 267  : 	int wygrana = kwota; //Deklaracja zmiennej przechowywuj¹ca kwotê wygran¹ lub zwrócon¹ przy wylosowaniu 0
; 268  : 
; 269  : 	if (wylosowana_liczba == 0) //Warunek sprawdzaj¹cy czy wylosowano 0

  0000a	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  0000d	57		 push	 edi
  0000e	8b 38		 mov	 edi, DWORD PTR [eax]
  00010	89 45 fc	 mov	 DWORD PTR _kwota$1$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00016	8b 18		 mov	 ebx, DWORD PTR [eax]
  00018	85 db		 test	 ebx, ebx
  0001a	75 32		 jne	 SHORT $LN4@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0001c	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0001f	72 02		 jb	 SHORT $LN64@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00021	8b 12		 mov	 edx, DWORD PTR [edx]
$LN64@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 271  : 		switch (typ_zak³adu[0]) //Switch do obliczenia wygranej lub przegranej

  00023	0f be 0a	 movsx	 ecx, BYTE PTR [edx]
  00026	83 c1 d0	 add	 ecx, -48		; ffffffd0H
  00029	83 f9 47	 cmp	 ecx, 71			; 00000047H
  0002c	0f 87 cb 01 00
	00		 ja	 $LN49@Sprawd_Z
  00032	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN343@Sprawd_Z[ecx]
  00039	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN360@Sprawd_Z[ecx*4]
$LN6@Sprawd_Z:

; 272  : 		{
; 273  : 		case 'p':
; 274  : 		{
; 275  : 			wygrana /= 2; //Je¿eli typ zak³adu by³ p to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  00040	8b c7		 mov	 eax, edi
  00042	99		 cdq
  00043	2b c2		 sub	 eax, edx
  00045	8b f8		 mov	 edi, eax
  00047	d1 ff		 sar	 edi, 1

; 276  : 			break; //Wyjcie z switcha

  00049	e9 af 01 00 00	 jmp	 $LN49@Sprawd_Z
$LN4@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0004e	8b c2		 mov	 eax, edx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00050	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00053	72 02		 jb	 SHORT $LN335@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00055	8b 02		 mov	 eax, DWORD PTR [edx]
$LN335@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00057	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0005a	83 f9 01	 cmp	 ecx, 1
  0005d	75 1f		 jne	 SHORT $LN16@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0005f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00062	3c 70		 cmp	 al, 112			; 00000070H
  00064	75 04		 jne	 SHORT $LN344@Sprawd_Z
  00066	33 c0		 xor	 eax, eax
  00068	eb 05		 jmp	 SHORT $LN345@Sprawd_Z
$LN344@Sprawd_Z:
  0006a	1b c0		 sbb	 eax, eax
  0006c	83 c8 01	 or	 eax, 1
$LN345@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0006f	85 c0		 test	 eax, eax
  00071	75 0b		 jne	 SHORT $LN16@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 327  : 		else if (typ_zak³adu == "n") //Je¿eli typ zak³adu to n

  00073	f6 c3 01	 test	 bl, 1
  00076	0f 45 f8	 cmovne	 edi, eax
  00079	e9 7f 01 00 00	 jmp	 $LN49@Sprawd_Z
$LN16@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0007e	8b c2		 mov	 eax, edx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00080	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00083	72 02		 jb	 SHORT $LN336@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00085	8b 02		 mov	 eax, DWORD PTR [edx]
$LN336@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00087	83 f9 01	 cmp	 ecx, 1
  0008a	75 2e		 jne	 SHORT $LN20@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0008c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0008f	3c 6e		 cmp	 al, 110			; 0000006eH
  00091	75 04		 jne	 SHORT $LN346@Sprawd_Z
  00093	33 c0		 xor	 eax, eax
  00095	eb 05		 jmp	 SHORT $LN347@Sprawd_Z
$LN346@Sprawd_Z:
  00097	1b c0		 sbb	 eax, eax
  00099	83 c8 01	 or	 eax, 1
$LN347@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0009c	85 c0		 test	 eax, eax
  0009e	75 1a		 jne	 SHORT $LN20@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 328  : 			if (wylosowana_liczba % 2 == 1) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest nieparzysta, je¿eli tak to wygrana jest 1:1

  000a0	81 e3 01 00 00
	80		 and	 ebx, -2147483647	; 80000001H
  000a6	79 05		 jns	 SHORT $LN356@Sprawd_Z
  000a8	4b		 dec	 ebx
  000a9	83 cb fe	 or	 ebx, -2			; fffffffeH
  000ac	43		 inc	 ebx
$LN356@Sprawd_Z:

; 329  : 			else wygrana *= 0; //Je¿eli obstawiony numer nie jest nieparzysta to przegra³o siê zak³ad
; 330  : 		else if (typ_zak³adu == "r") //Je¿eli typ zak³adu to n

  000ad	33 c0		 xor	 eax, eax
  000af	83 fb 01	 cmp	 ebx, 1
  000b2	0f 45 f8	 cmovne	 edi, eax
  000b5	e9 43 01 00 00	 jmp	 $LN49@Sprawd_Z
$LN20@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  000ba	8b c2		 mov	 eax, edx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000bc	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  000bf	72 02		 jb	 SHORT $LN337@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000c1	8b 02		 mov	 eax, DWORD PTR [edx]
$LN337@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000c3	83 f9 01	 cmp	 ecx, 1
  000c6	75 23		 jne	 SHORT $LN24@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000c8	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000cb	3c 72		 cmp	 al, 114			; 00000072H
  000cd	75 04		 jne	 SHORT $LN348@Sprawd_Z
  000cf	33 c0		 xor	 eax, eax
  000d1	eb 05		 jmp	 SHORT $LN349@Sprawd_Z
$LN348@Sprawd_Z:
  000d3	1b c0		 sbb	 eax, eax
  000d5	83 c8 01	 or	 eax, 1
$LN349@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000d8	85 c0		 test	 eax, eax
  000da	75 0f		 jne	 SHORT $LN24@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 333  : 		else if (typ_zak³adu == "b") //Je¿eli typ zak³adu to n

  000dc	80 bb 00 00 00
	00 72		 cmp	 BYTE PTR ?Ruletka_plansza_kolor@@3QBDB[ebx], 114 ; 00000072H
  000e3	0f 45 f8	 cmovne	 edi, eax
  000e6	e9 12 01 00 00	 jmp	 $LN49@Sprawd_Z
$LN24@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  000eb	8b c2		 mov	 eax, edx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000ed	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  000f0	72 02		 jb	 SHORT $LN338@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000f2	8b 02		 mov	 eax, DWORD PTR [edx]
$LN338@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000f4	83 f9 01	 cmp	 ecx, 1
  000f7	75 23		 jne	 SHORT $LN28@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000f9	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000fc	3c 62		 cmp	 al, 98			; 00000062H
  000fe	75 04		 jne	 SHORT $LN350@Sprawd_Z
  00100	33 c0		 xor	 eax, eax
  00102	eb 05		 jmp	 SHORT $LN351@Sprawd_Z
$LN350@Sprawd_Z:
  00104	1b c0		 sbb	 eax, eax
  00106	83 c8 01	 or	 eax, 1
$LN351@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00109	85 c0		 test	 eax, eax
  0010b	75 0f		 jne	 SHORT $LN28@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 336  : 		else if (typ_zak³adu == "g") //Je¿eli typ zak³adu to g

  0010d	80 bb 00 00 00
	00 62		 cmp	 BYTE PTR ?Ruletka_plansza_kolor@@3QBDB[ebx], 98 ; 00000062H
  00114	0f 45 f8	 cmovne	 edi, eax
  00117	e9 e1 00 00 00	 jmp	 $LN49@Sprawd_Z
$LN28@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0011c	8b c2		 mov	 eax, edx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0011e	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00121	72 02		 jb	 SHORT $LN339@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00123	8b 02		 mov	 eax, DWORD PTR [edx]
$LN339@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00125	83 f9 01	 cmp	 ecx, 1
  00128	75 1f		 jne	 SHORT $LN32@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0012a	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0012d	3c 67		 cmp	 al, 103			; 00000067H
  0012f	75 04		 jne	 SHORT $LN352@Sprawd_Z
  00131	33 c0		 xor	 eax, eax
  00133	eb 05		 jmp	 SHORT $LN353@Sprawd_Z
$LN352@Sprawd_Z:
  00135	1b c0		 sbb	 eax, eax
  00137	83 c8 01	 or	 eax, 1
$LN353@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0013a	85 c0		 test	 eax, eax
  0013c	75 0b		 jne	 SHORT $LN32@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 339  : 		else if (typ_zak³adu == "d") //Je¿eli typ zak³adu to d

  0013e	83 fb 13	 cmp	 ebx, 19			; 00000013H
  00141	0f 4d f8	 cmovge	 edi, eax
  00144	e9 b4 00 00 00	 jmp	 $LN49@Sprawd_Z
$LN32@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00149	8b c2		 mov	 eax, edx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0014b	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0014e	72 02		 jb	 SHORT $LN340@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00150	8b 02		 mov	 eax, DWORD PTR [edx]
$LN340@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00152	83 f9 01	 cmp	 ecx, 1
  00155	75 1f		 jne	 SHORT $LN36@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00157	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0015a	3c 64		 cmp	 al, 100			; 00000064H
  0015c	75 04		 jne	 SHORT $LN354@Sprawd_Z
  0015e	33 c0		 xor	 eax, eax
  00160	eb 05		 jmp	 SHORT $LN355@Sprawd_Z
$LN354@Sprawd_Z:
  00162	1b c0		 sbb	 eax, eax
  00164	83 c8 01	 or	 eax, 1
$LN355@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00167	85 c0		 test	 eax, eax
  00169	75 0b		 jne	 SHORT $LN36@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 342  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  0016b	83 fb 12	 cmp	 ebx, 18			; 00000012H
  0016e	0f 4e f8	 cmovle	 edi, eax
  00171	e9 87 00 00 00	 jmp	 $LN49@Sprawd_Z
$LN36@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00176	8b c2		 mov	 eax, edx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00178	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0017b	72 02		 jb	 SHORT $LN341@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0017d	8b 02		 mov	 eax, DWORD PTR [edx]
$LN341@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 342  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  0017f	80 38 6b	 cmp	 BYTE PTR [eax], 107	; 0000006bH
  00182	75 24		 jne	 SHORT $LN40@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00184	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00187	72 02		 jb	 SHORT $LN268@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00189	8b 12		 mov	 edx, DWORD PTR [edx]
$LN268@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 343  : 			if ((wylosowana_liczba - 1) % 3 == typ_zak³adu[1] - 49) wygrana *= 2; //To sprawdzam czy wylosowana liczba jest z obstawionej kolumny, je¿eli tak to wygrana jest 2:1

  0018b	0f be 4a 01	 movsx	 ecx, BYTE PTR [edx+1]
  0018f	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00192	99		 cdq
  00193	be 03 00 00 00	 mov	 esi, 3
  00198	f7 fe		 idiv	 esi
  0019a	83 e9 31	 sub	 ecx, 49			; 00000031H

; 345  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  0019d	03 ff		 add	 edi, edi
  0019f	33 c0		 xor	 eax, eax
  001a1	3b d1		 cmp	 edx, ecx
  001a3	0f 45 f8	 cmovne	 edi, eax
  001a6	eb 55		 jmp	 SHORT $LN49@Sprawd_Z
$LN40@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001a8	8b c2		 mov	 eax, edx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001aa	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  001ad	72 02		 jb	 SHORT $LN342@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001af	8b 02		 mov	 eax, DWORD PTR [edx]
$LN342@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 345  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  001b1	80 38 77	 cmp	 BYTE PTR [eax], 119	; 00000077H
  001b4	75 28		 jne	 SHORT $LN44@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001b6	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  001b9	72 02		 jb	 SHORT $LN298@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001bb	8b 12		 mov	 edx, DWORD PTR [edx]
$LN298@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 346  : 			if (((wylosowana_liczba - 1) / 3 + 1) == typ_zak³adu[1] - 48) wygrana *= 11; //To sprawdzam czy wylosowana liczba jest z obstawionego wiersza, je¿eli tak to wygrana jest 11:1

  001bd	0f be 72 01	 movsx	 esi, BYTE PTR [edx+1]
  001c1	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  001c4	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001c9	83 ee 31	 sub	 esi, 49			; 00000031H
  001cc	f7 e9		 imul	 ecx
  001ce	8b c2		 mov	 eax, edx
  001d0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001d3	03 c2		 add	 eax, edx
  001d5	3b c6		 cmp	 eax, esi
  001d7	75 22		 jne	 SHORT $LN48@Sprawd_Z
  001d9	6b ff 0b	 imul	 edi, edi, 11

; 348  : 		else if (wylosowana_liczba == atoi(typ_zak³adu.c_str())) wygrana *= 35; //Je¿eli typ zak³adu to liczba, to sprawdzam czy wylosowana liczba jest równa obstawionej liczbie, je¿eli tak to wygrana jest 35:1

  001dc	eb 1f		 jmp	 SHORT $LN49@Sprawd_Z
$LN44@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001de	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  001e1	72 02		 jb	 SHORT $LN314@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001e3	8b 12		 mov	 edx, DWORD PTR [edx]
$LN314@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 348  : 		else if (wylosowana_liczba == atoi(typ_zak³adu.c_str())) wygrana *= 35; //Je¿eli typ zak³adu to liczba, to sprawdzam czy wylosowana liczba jest równa obstawionej liczbie, je¿eli tak to wygrana jest 35:1

  001e5	52		 push	 edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  001ec	8b 4d 08	 mov	 ecx, DWORD PTR _wylosowana_liczba$[ebp]
  001ef	83 c4 04	 add	 esp, 4
  001f2	39 01		 cmp	 DWORD PTR [ecx], eax
  001f4	75 05		 jne	 SHORT $LN48@Sprawd_Z
$LN14@Sprawd_Z:
  001f6	6b ff 23	 imul	 edi, edi, 35
  001f9	eb 02		 jmp	 SHORT $LN49@Sprawd_Z
$LN48@Sprawd_Z:

; 349  : 		else wygrana *= 0; //Je¿eli wylosowana liczba nie jest równa obstawionej liczbie to przegra³o siê zak³ad

  001fb	33 ff		 xor	 edi, edi
$LN49@Sprawd_Z:

; 350  : 	}
; 351  : 
; 352  : 	if (wygrana >= kwota) cout << "Obstawi³e poprawnie, wygrywasz " << wygrana << "$." << endl; //Je¿eli wygrana jest wiêksza lub równa obstawionej kwocie to informujê o tym, ¿e wygra³

  001fd	8b 4d fc	 mov	 ecx, DWORD PTR _kwota$1$[ebp]
  00200	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00205	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00207	3b f9		 cmp	 edi, ecx
  00209	7c 08		 jl	 SHORT $LN50@Sprawd_Z
  0020b	57		 push	 edi
  0020c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CB@GINPHDN@Obstawi?$LDe?$JM?5poprawnie?0?5wygrywasz?5@
  00211	eb 19		 jmp	 SHORT $LN358@Sprawd_Z
$LN50@Sprawd_Z:

; 353  : 	else if (wygrana == kwota / 2) cout << "Obstawi³e niepoprawnie lecz uda³o Ci siê, dostajesz po³owê zak³adu " << wygrana << "$." << endl; //Je¿eli wygrana jest równa po³owie obstawionej kwocie to informujê o tym, ¿e przegra³ po³owe stawki

  00213	8b c1		 mov	 eax, ecx
  00215	99		 cdq
  00216	2b c2		 sub	 eax, edx
  00218	d1 f8		 sar	 eax, 1
  0021a	3b f8		 cmp	 edi, eax
  0021c	75 08		 jne	 SHORT $LN52@Sprawd_Z
  0021e	57		 push	 edi
  0021f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EF@MDKBMGPE@Obstawi?$LDe?$JM?5niepoprawnie?5lecz?5uda@
  00224	eb 06		 jmp	 SHORT $LN358@Sprawd_Z
$LN52@Sprawd_Z:

; 354  : 	else cout << "Obstawi³e niepoprawnie, przegra³e " << kwota << "$." << endl; //Je¿eli wygrana jest równa zero to informujê o tym, ¿e przegra³

  00226	51		 push	 ecx
  00227	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CF@BAJKLKHM@Obstawi?$LDe?$JM?5niepoprawnie?0?5przegra@
$LN358@Sprawd_Z:
  0022c	51		 push	 ecx
  0022d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00233	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00238	83 c4 04	 add	 esp, 4
  0023b	8b c8		 mov	 ecx, eax
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00243	51		 push	 ecx
  00244	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02DEPNMBPN@$?4?$AA@
  00249	8b c8		 mov	 ecx, eax
  0024b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00250	83 c4 04	 add	 esp, 4
  00253	8b c8		 mov	 ecx, eax
  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 355  : 
; 356  : 	return wygrana; //Zwracam warto wygranej lub zwrotu

  0025b	8b c7		 mov	 eax, edi

; 357  : }

  0025d	5f		 pop	 edi
  0025e	5e		 pop	 esi
  0025f	5b		 pop	 ebx
  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c3		 ret	 0
$LN360@Sprawd_Z:
  00264	00 00 00 00	 DD	 $LN14@Sprawd_Z
  00268	00 00 00 00	 DD	 $LN6@Sprawd_Z
  0026c	00 00 00 00	 DD	 $LN48@Sprawd_Z
  00270	00 00 00 00	 DD	 $LN49@Sprawd_Z
$LN343@Sprawd_Z:
  00274	00		 DB	 0
  00275	03		 DB	 3
  00276	03		 DB	 3
  00277	03		 DB	 3
  00278	03		 DB	 3
  00279	03		 DB	 3
  0027a	03		 DB	 3
  0027b	03		 DB	 3
  0027c	03		 DB	 3
  0027d	03		 DB	 3
  0027e	03		 DB	 3
  0027f	03		 DB	 3
  00280	03		 DB	 3
  00281	03		 DB	 3
  00282	03		 DB	 3
  00283	03		 DB	 3
  00284	03		 DB	 3
  00285	03		 DB	 3
  00286	03		 DB	 3
  00287	03		 DB	 3
  00288	03		 DB	 3
  00289	03		 DB	 3
  0028a	03		 DB	 3
  0028b	03		 DB	 3
  0028c	03		 DB	 3
  0028d	03		 DB	 3
  0028e	03		 DB	 3
  0028f	03		 DB	 3
  00290	03		 DB	 3
  00291	03		 DB	 3
  00292	03		 DB	 3
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	03		 DB	 3
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	03		 DB	 3
  002a1	03		 DB	 3
  002a2	03		 DB	 3
  002a3	03		 DB	 3
  002a4	03		 DB	 3
  002a5	03		 DB	 3
  002a6	01		 DB	 1
  002a7	03		 DB	 3
  002a8	01		 DB	 1
  002a9	03		 DB	 3
  002aa	03		 DB	 3
  002ab	01		 DB	 1
  002ac	03		 DB	 3
  002ad	03		 DB	 3
  002ae	03		 DB	 3
  002af	02		 DB	 2
  002b0	03		 DB	 3
  002b1	03		 DB	 3
  002b2	01		 DB	 1
  002b3	03		 DB	 3
  002b4	01		 DB	 1
  002b5	03		 DB	 3
  002b6	01		 DB	 1
  002b7	03		 DB	 3
  002b8	03		 DB	 3
  002b9	03		 DB	 3
  002ba	03		 DB	 3
  002bb	02		 DB	 2
?Sprawd_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; Sprawd_Zak³ad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Czy_Kontynuowaæ@@YA_NABH@Z
_TEXT	SEGMENT
_tak_nie$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Czy_Kontynuowaæ@@YA_NABH@Z PROC			; Czy_Kontynuowaæ, COMDAT
; _iloæ_pieniêdzy$ = ecx

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Czy_Kontynuowaæ@@YA_NABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _tak_nie$[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00034	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _tak_nie$[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0003b	c6 45 d8 00	 mov	 BYTE PTR _tak_nie$[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 361  : 	string tak_nie; //Zadeklarowanie zmiennej typu string

  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 362  : 
; 363  : 	if (iloæ_pieniêdzy == 0) //Je¿eli posiadana iloæ gotówki jest róna 0

  00046	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00049	75 35		 jne	 SHORT $LL2@Czy_Kontyn

; 364  : 	{
; 365  : 		cout << "Nie mo¿esz kontynuowaæ, przegra³e wszystko" << endl; //Poinformowanie u¿ytkownika, ¿e jest bankrutem

  0004b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00051	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@
  00056	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0005b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00060	8b c8		 mov	 ecx, eax
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00068	8b 45 d8	 mov	 eax, DWORD PTR _tak_nie$[ebp]
  0006b	32 db		 xor	 bl, bl
  0006d	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  00072	e9 55 01 00 00	 jmp	 $LN12@Czy_Kontyn
  00077	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@Czy_Kontyn:
$_Invalid_parameter$624:

; 366  : 		return false; //Zwrot wartoci false, co oznacza, ¿e kolejna runda siê nie odbêdzie
; 367  : 	}
; 368  : 
; 369  : 	while (true) //Rozpoczêcie pêtli nieskoñczonej
; 370  : 	{
; 371  : 		cout << "Na koncie masz " << iloæ_pieniêdzy << "$, czy chcesz grac dalej ('t'-tak, 'n'-nie) ?" << endl; //Pointormowanie o stanie konta i zapytanie o to czy gra dalej

  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00086	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@
  0008b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00090	ff 33		 push	 DWORD PTR [ebx]
  00092	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00097	8b c8		 mov	 ecx, eax
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0009f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CO@DOCNGCMI@$?0?5czy?5chcesz?5grac?5dalej?5?$CI?8t?8?9ta@
  000a4	8b c8		 mov	 ecx, eax
  000a6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000ab	8b c8		 mov	 ecx, eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  000b9	8d 55 d8	 lea	 edx, DWORD PTR _tak_nie$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000c1	8b 55 ec	 mov	 edx, DWORD PTR _tak_nie$[ebp+20]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  000c4	8d 4d d8	 lea	 ecx, DWORD PTR _tak_nie$[ebp]

; 1594 : 		if (_Large_string_engaged())

  000c7	8b 45 d8	 mov	 eax, DWORD PTR _tak_nie$[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000ca	83 fa 10	 cmp	 edx, 16			; 00000010H

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000cd	8b 75 e8	 mov	 esi, DWORD PTR _tak_nie$[ebp+16]

; 1594 : 		if (_Large_string_engaged())

  000d0	0f 43 c8	 cmovae	 ecx, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000d3	83 fe 01	 cmp	 esi, 1
  000d6	75 09		 jne	 SHORT $LN137@Czy_Kontyn
  000d8	80 39 74	 cmp	 BYTE PTR [ecx], 116	; 00000074H
  000db	0f 84 c9 00 00
	00		 je	 $LN610@Czy_Kontyn
$LN137@Czy_Kontyn:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000e1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  000e4	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1594 : 		if (_Large_string_engaged())

  000e7	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000ea	83 fe 03	 cmp	 esi, 3
  000ed	75 11		 jne	 SHORT $LN613@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000ef	66 81 3f 74 61	 cmp	 WORD PTR [edi], 24948	; 00006174H
  000f4	75 0a		 jne	 SHORT $LN613@Czy_Kontyn
  000f6	80 7f 02 6b	 cmp	 BYTE PTR [edi+2], 107	; 0000006bH
  000fa	0f 84 aa 00 00
	00		 je	 $LN610@Czy_Kontyn
$LN613@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00100	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00103	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1594 : 		if (_Large_string_engaged())

  00106	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00109	83 fe 03	 cmp	 esi, 3
  0010c	75 11		 jne	 SHORT $LN614@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0010e	66 81 3f 54 61	 cmp	 WORD PTR [edi], 24916	; 00006154H
  00113	75 0a		 jne	 SHORT $LN614@Czy_Kontyn
  00115	80 7f 02 6b	 cmp	 BYTE PTR [edi+2], 107	; 0000006bH
  00119	0f 84 8b 00 00
	00		 je	 $LN610@Czy_Kontyn
$LN614@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0011f	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00122	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1594 : 		if (_Large_string_engaged())

  00125	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00128	83 fe 03	 cmp	 esi, 3
  0012b	75 0d		 jne	 SHORT $LN615@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0012d	66 81 3f 54 41	 cmp	 WORD PTR [edi], 16724	; 00004154H
  00132	75 06		 jne	 SHORT $LN615@Czy_Kontyn
  00134	80 7f 02 4b	 cmp	 BYTE PTR [edi+2], 75	; 0000004bH
  00138	74 70		 je	 SHORT $LN610@Czy_Kontyn
$LN615@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0013a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0013d	8d 4d d8	 lea	 ecx, DWORD PTR _tak_nie$[ebp]

; 1594 : 		if (_Large_string_engaged())

  00140	0f 43 c8	 cmovae	 ecx, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00143	83 fe 01	 cmp	 esi, 1
  00146	75 05		 jne	 SHORT $LN253@Czy_Kontyn
  00148	80 39 6e	 cmp	 BYTE PTR [ecx], 110	; 0000006eH
  0014b	74 5d		 je	 SHORT $LN610@Czy_Kontyn
$LN253@Czy_Kontyn:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0014d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00150	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1594 : 		if (_Large_string_engaged())

  00153	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00156	83 fe 03	 cmp	 esi, 3
  00159	75 0d		 jne	 SHORT $LN616@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0015b	66 81 3f 6e 69	 cmp	 WORD PTR [edi], 26990	; 0000696eH
  00160	75 06		 jne	 SHORT $LN616@Czy_Kontyn
  00162	80 7f 02 65	 cmp	 BYTE PTR [edi+2], 101	; 00000065H
  00166	74 42		 je	 SHORT $LN610@Czy_Kontyn
$LN616@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00168	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0016b	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1594 : 		if (_Large_string_engaged())

  0016e	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00171	83 fe 03	 cmp	 esi, 3
  00174	75 0d		 jne	 SHORT $LN617@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00176	66 81 3f 4e 69	 cmp	 WORD PTR [edi], 26958	; 0000694eH
  0017b	75 06		 jne	 SHORT $LN617@Czy_Kontyn
  0017d	80 7f 02 65	 cmp	 BYTE PTR [edi+2], 101	; 00000065H
  00181	74 27		 je	 SHORT $LN610@Czy_Kontyn
$LN617@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00183	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00186	8d 7d d8	 lea	 edi, DWORD PTR _tak_nie$[ebp]

; 1594 : 		if (_Large_string_engaged())

  00189	0f 43 f8	 cmovae	 edi, eax

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0018c	83 fe 03	 cmp	 esi, 3
  0018f	0f 85 eb fe ff
	ff		 jne	 $LL2@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00195	66 81 3f 4e 49	 cmp	 WORD PTR [edi], 18766	; 0000494eH
  0019a	0f 85 e0 fe ff
	ff		 jne	 $LL2@Czy_Kontyn
  001a0	80 7f 02 45	 cmp	 BYTE PTR [edi+2], 69	; 00000045H
  001a4	0f 85 d6 fe ff
	ff		 jne	 $LL2@Czy_Kontyn
$LN610@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001aa	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  001ad	8d 4d d8	 lea	 ecx, DWORD PTR _tak_nie$[ebp]

; 1583 : 		if (_Large_string_engaged())

  001b0	0f 43 c8	 cmovae	 ecx, eax
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 374  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoæ true

  001b3	80 39 74	 cmp	 BYTE PTR [ecx], 116	; 00000074H
  001b6	74 12		 je	 SHORT $LN9@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001b8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  001bb	8d 4d d8	 lea	 ecx, DWORD PTR _tak_nie$[ebp]

; 1583 : 		if (_Large_string_engaged())

  001be	0f 43 c8	 cmovae	 ecx, eax
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 374  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoæ true

  001c1	80 39 54	 cmp	 BYTE PTR [ecx], 84	; 00000054H
  001c4	74 04		 je	 SHORT $LN9@Czy_Kontyn
$_Invalid_parameter$625:

; 375  : 			else return false; //W przeciwym wypadku zwracam wartoæ false

  001c6	32 db		 xor	 bl, bl
  001c8	eb 02		 jmp	 SHORT $LN12@Czy_Kontyn
$LN9@Czy_Kontyn:

; 374  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoæ true

  001ca	b3 01		 mov	 bl, 1
$LN12@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001cc	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  001cf	72 3c		 jb	 SHORT $LN485@Czy_Kontyn

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001d1	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001d2	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001d4	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001da	72 27		 jb	 SHORT $LN488@Czy_Kontyn

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001dc	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  001df	3b f2		 cmp	 esi, edx
  001e1	76 1a		 jbe	 SHORT $_Invalid_parameter$626

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001e3	8b d6		 mov	 edx, esi
  001e5	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001e8	75 13		 jne	 SHORT $_Invalid_parameter$626

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001ea	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  001ed	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  001ef	73 0c		 jae	 SHORT $_Invalid_parameter$626

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001f1	2b c8		 sub	 ecx, eax
  001f3	83 f9 04	 cmp	 ecx, 4
  001f6	72 05		 jb	 SHORT $_Invalid_parameter$626

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  001f8	83 f9 23	 cmp	 ecx, 35			; 00000023H
  001fb	76 06		 jbe	 SHORT $LN488@Czy_Kontyn
$_Invalid_parameter$626:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN623@Czy_Kontyn:
$LN488@Czy_Kontyn:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00203	52		 push	 edx
  00204	50		 push	 eax
  00205	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0020a	83 c4 08	 add	 esp, 8
$LN485@Czy_Kontyn:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 375  : 			else return false; //W przeciwym wypadku zwracam wartoæ false

  0020d	8a c3		 mov	 al, bl

; 376  : 	}
; 377  : }

  0020f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00212	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00219	59		 pop	 ecx
  0021a	5f		 pop	 edi
  0021b	5e		 pop	 esi
  0021c	5b		 pop	 ebx
  0021d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00220	33 cd		 xor	 ecx, ebp
  00222	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00227	8b e5		 mov	 esp, ebp
  00229	5d		 pop	 ebp
  0022a	c3		 ret	 0
$LN622@Czy_Kontyn:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Czy_Kontynuowaæ@@YA_NABH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _tak_nie$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Czy_Kontynuowaæ@@YA_NABH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Czy_Kontynuowaæ@@YA_NABH@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Czy_Kontynuowaæ@@YA_NABH@Z ENDP			; Czy_Kontynuowaæ
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Change_Col@@YAXABH@Z
_TEXT	SEGMENT
?Change_Col@@YAXABH@Z PROC				; Change_Col, COMDAT
; _num_of_col$ = ecx

; 380  : {

  00000	56		 push	 esi

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00001	6a f5		 push	 -11			; fffffff5H
  00003	8b f1		 mov	 esi, ecx
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0000b	0f b7 0e	 movzx	 ecx, WORD PTR [esi]
  0000e	51		 push	 ecx
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleTextAttribute@8
  00016	5e		 pop	 esi

; 383  : }

  00017	c3		 ret	 0
?Change_Col@@YAXABH@Z ENDP				; Change_Col
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Hide_Cursor@@YAXXZ
_TEXT	SEGMENT
_hCCI$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
?Hide_Cursor@@YAXXZ PROC				; Hide_Cursor, COMDAT

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 387  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00011	6a f5		 push	 -11			; fffffff5H
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  00019	8b f0		 mov	 esi, eax

; 388  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 389  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0001b	8d 45 f4	 lea	 eax, DWORD PTR _hCCI$[ebp]
  0001e	50		 push	 eax
  0001f	56		 push	 esi
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 390  : 	hCCI.bVisible = FALSE; //Zmiena widocznoci kursora na niewidoczny
; 391  : 	SetConsoleCursorInfo(hConsoleOut, &hCCI); //Ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  00026	8d 45 f4	 lea	 eax, DWORD PTR _hCCI$[ebp]
  00029	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hCCI$[ebp+4], 0
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8

; 392  : }

  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	5e		 pop	 esi
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?Hide_Cursor@@YAXXZ ENDP				; Hide_Cursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Show_Cursor@@YAXXZ
_TEXT	SEGMENT
_hCCI$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
?Show_Cursor@@YAXXZ PROC				; Show_Cursor, COMDAT

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 396  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00011	6a f5		 push	 -11			; fffffff5H
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  00019	8b f0		 mov	 esi, eax

; 397  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 398  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0001b	8d 45 f4	 lea	 eax, DWORD PTR _hCCI$[ebp]
  0001e	50		 push	 eax
  0001f	56		 push	 esi
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleCursorInfo@8

; 399  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoæ widocznoci kursorsora tekstego w konsoli jest ró¿na od prawdy

  00026	83 7d f8 01	 cmp	 DWORD PTR _hCCI$[ebp+4], 1
  0002a	74 12		 je	 SHORT $LN2@Show_Curso

; 400  : 	{
; 401  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoci kursora na widoczny
; 402  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  0002c	8d 45 f4	 lea	 eax, DWORD PTR _hCCI$[ebp]
  0002f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _hCCI$[ebp+4], 1
  00036	50		 push	 eax
  00037	56		 push	 esi
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorInfo@8
$LN2@Show_Curso:

; 403  : 	}
; 404  : }

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00041	33 cd		 xor	 ecx, ebp
  00043	5e		 pop	 esi
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?Show_Cursor@@YAXXZ ENDP				; Show_Cursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wylosuj@@YAHABH0@Z
_TEXT	SEGMENT
__Index$1$ = -12					; size = 4
tv491 = -8						; size = 4
$T9 = -4						; size = 4
?Wylosuj@@YAHABH0@Z PROC				; Wylosuj, COMDAT
; _od_liczby$ = ecx
; _do_liczby$ = edx

; 407  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 408  : 	if (od_liczby > do_liczby) //Je¿eli od jest wiêksze ni¿ do to

  00007	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	89 5d fc	 mov	 DWORD PTR $T9[ebp], ebx
  0000f	57		 push	 edi
  00010	3b de		 cmp	 ebx, esi
  00012	7e 11		 jle	 SHORT $LN2@Wylosuj
$LL96@Wylosuj:

; 409  : 	{
; 410  : 		return Wylosuj(do_liczby, od_liczby); //Wywo³ujemy funkcje z przeciwn¹ kolejnoci¹ argumentów

  00014	8b c1		 mov	 eax, ecx
  00016	8b ca		 mov	 ecx, edx
  00018	8b d0		 mov	 edx, eax
  0001a	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0001c	8b 32		 mov	 esi, DWORD PTR [edx]
  0001e	89 5d fc	 mov	 DWORD PTR $T9[ebp], ebx
  00021	3b de		 cmp	 ebx, esi
  00023	7f ef		 jg	 SHORT $LL96@Wylosuj
$LN2@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2328 : 		if (_Umax - _Umin == _Uty(-1))

  00025	2b f3		 sub	 esi, ebx
  00027	83 fe ff	 cmp	 esi, -1
  0002a	75 0f		 jne	 SHORT $LN32@Wylosuj

; 6410 : 		return (_Random_device());

  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  00032	03 c3		 add	 eax, ebx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 426  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
$LN32@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2331 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  0003b	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0003e	89 45 f4	 mov	 DWORD PTR __Index$1$[ebp], eax
  00041	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
$LL72@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3944 : 			_Udiff _Ret = 0;	// random bits

  00044	33 ff		 xor	 edi, edi

; 3945 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00046	33 c0		 xor	 eax, eax

; 3946 : 
; 3947 : 			while (_Mask < _Udiff(_Index - 1))

  00048	85 f6		 test	 esi, esi
  0004a	74 0b		 je	 SHORT $LN76@Wylosuj
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3987 : 			_Udiff _Val = _Ref() - (_Urng::min)();

  00052	8b f8		 mov	 edi, eax

; 3954 : 				_Mask |= _Bmask;

  00054	83 c8 ff	 or	 eax, -1
$LN76@Wylosuj:

; 3955 : 				}
; 3956 : 
; 3957 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3958 : 			if (_Ret / _Index < _Mask / _Index
; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00057	33 d2		 xor	 edx, edx
  00059	f7 f3		 div	 ebx
  0005b	8b c8		 mov	 ecx, eax
  0005d	89 55 f8	 mov	 DWORD PTR tv491[ebp], edx
  00060	33 d2		 xor	 edx, edx
  00062	8b c7		 mov	 eax, edi
  00064	f7 f3		 div	 ebx
  00066	3b c1		 cmp	 eax, ecx
  00068	72 05		 jb	 SHORT $LN109@Wylosuj
  0006a	39 75 f8	 cmp	 DWORD PTR tv491[ebp], esi
  0006d	75 d5		 jne	 SHORT $LL72@Wylosuj
$LN109@Wylosuj:

; 3960 : 				return (_Ret % _Index);

  0006f	8b c7		 mov	 eax, edi
  00071	33 d2		 xor	 edx, edx
  00073	f7 75 f4	 div	 DWORD PTR __Index$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  00076	8b 45 fc	 mov	 eax, DWORD PTR $T9[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 426  : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  0007b	03 c2		 add	 eax, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 426  : }

  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?Wylosuj@@YAHABH0@Z ENDP				; Wylosuj
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T190 = -480						; size = 24
_this$ = -456						; size = 4
_this$ = -456						; size = 4
$T192 = -452						; size = 24
$T160 = -452						; size = 24
$T22 = -452						; size = 24
$T191 = -428						; size = 24
$T152 = -428						; size = 24
$T14 = -428						; size = 24
$T189 = -404						; size = 24
$T142 = -404						; size = 24
$T130 = -404						; size = 24
$T119 = -404						; size = 24
$T98 = -404						; size = 24
$T87 = -404						; size = 24
$T66 = -404						; size = 24
$T55 = -404						; size = 24
$T7 = -404						; size = 24
_wylosowana_liczba$GSCopy$1$ = -380			; size = 4
$T146 = -380						; size = 1
_numers$198 = -376					; size = 176
_numers$ = -200						; size = 176
tv5337 = -24						; size = 4
tv5336 = -24						; size = 4
tv5335 = -24						; size = 4
__Ch$ = -24						; size = 1
$T1 = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Odczytaj_liczbê, COMDAT
; _wylosowana_liczba$ = ecx
; _typ_zak³adu$ = edx

; 428  : void Odczytaj_liczbê(const int & wylosowana_liczba, const string & typ_zak³adu) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 ec d0 01 00
	00		 sub	 esp, 464		; 000001d0H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	56		 push	 esi
  00036	57		 push	 edi
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	8b f2		 mov	 esi, edx
  00043	8b f9		 mov	 edi, ecx
  00045	89 bd 84 fe ff
	ff		 mov	 DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp], edi
  0004b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 429  : 	if ((Ustawienia.g³os_odczytu_numeru == 0) || (!G³osyKompletne)) return; //Je¿eli ustawienia wy³¹czaj¹ g³os lub brak plików g³osu to wyjd z funkcji

  00052	66 83 3d 14 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, 0
  0005a	0f 84 32 0a 00
	00		 je	 $LN3@Odczytaj_l
  00060	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  00067	0f 84 25 0a 00
	00		 je	 $LN3@Odczytaj_l
  0006d	68 b0 00 00 00	 push	 176			; 000000b0H
  00072	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _numers$[ebp]
  00078	6a 00		 push	 0
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _memset
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 590  : 		{	// construct empty character buffer

  00083	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0008d	8d 4d a0	 lea	 ecx, DWORD PTR _numers$[ebp+104]
  00090	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  000a0	6a 00		 push	 0
  000a2	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _numers$[ebp+24]
  000a8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000af	50		 push	 eax
  000b0	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp]
  000b6	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  000c3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000ca	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  000d0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d3	c7 84 05 38 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  000de	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  000e4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e7	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  000ea	89 84 0d 34 ff
	ff ff		 mov	 DWORD PTR _numers$[ebp+ecx-4], eax
  000f1	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _numers$[ebp+24]

; 30   : 		{	// construct empty character buffer from mode

  000f7	8b c8		 mov	 ecx, eax

; 589  : 			_Stringbuffer(_Mode)

  000f9	89 85 38 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00105	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

  0010f	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _numers$[ebp+80], 0

; 312  : 		_Mystate = _State;

  00116	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _numers$[ebp+84], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 431  : 	stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  0011d	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 432  : 	numers << wylosowana_liczba; //Wpisanie to typu wylosowanej liczby

  00124	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+16]
  0012a	ff 37		 push	 DWORD PTR [edi]
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 644  : 		return (_Stringbuffer.str());

  00132	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00138	50		 push	 eax
  00139	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+24]
  0013f	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3805 : 	return (_STD move(_Right.insert(0, _Left)));

  00144	68 00 00 00 00	 push	 OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00149	51		 push	 ecx
  0014a	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 433  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  00150	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3805 : 	return (_STD move(_Right.insert(0, _Left)));

  00154	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1563 : 		_Mysize(0),

  00159	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+16], 0

; 1564 : 		_Myres(0)

  00163	c7 85 68 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0016d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00170	0f 11 85 54 fe
	ff ff		 movups	 XMMWORD PTR $T14[ebp], xmm0
  00177	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0017c	66 0f d6 85 64
	fe ff ff	 movq	 QWORD PTR $T14[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  00184	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0018b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00192	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 433  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  00195	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  0019a	8d 95 54 fe ff
	ff		 lea	 edx, DWORD PTR $T14[ebp]
  001a0	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  001a4	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  001aa	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  001af	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001b2	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  001b6	72 02		 jb	 SHORT $LN668@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001b8	8b 00		 mov	 eax, DWORD PTR [eax]
$LN668@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 433  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  001ba	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PlaySoundA@12
  001c0	6a 00		 push	 0
  001c2	6a 00		 push	 0
  001c4	50		 push	 eax
  001c5	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001c7	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+20]
  001cd	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  001d0	72 4c		 jb	 SHORT $LN712@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001d2	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001d8	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001d9	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001db	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001e1	72 31		 jb	 SHORT $LN715@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001e3	8d 7a 23	 lea	 edi, DWORD PTR [edx+35]
  001e6	89 7d e8	 mov	 DWORD PTR tv5337[ebp], edi
  001e9	3b fa		 cmp	 edi, edx
  001eb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PlaySoundA@12
  001f1	76 1b		 jbe	 SHORT $_Invalid_parameter$2395

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001f3	8b 55 e8	 mov	 edx, DWORD PTR tv5337[ebp]
  001f6	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001f9	75 13		 jne	 SHORT $_Invalid_parameter$2395

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001fb	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  001fe	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00200	73 0c		 jae	 SHORT $_Invalid_parameter$2395

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00202	2b c8		 sub	 ecx, eax
  00204	83 f9 04	 cmp	 ecx, 4
  00207	72 05		 jb	 SHORT $_Invalid_parameter$2395

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00209	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0020c	76 06		 jbe	 SHORT $LN715@Odczytaj_l
$_Invalid_parameter$2395:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2383@Odczytaj_l:
$LN715@Odczytaj_l:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00214	52		 push	 edx
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0021b	83 c4 08	 add	 esp, 8
$LN712@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 433  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  0021e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00222	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR $T14[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00228	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00232	c7 85 50 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T22[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0023c	c6 85 3c fe ff
	ff 00		 mov	 BYTE PTR $T22[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00243	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00246	72 4c		 jb	 SHORT $LN783@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00248	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR $T14[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0024e	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0024f	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00251	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00257	72 31		 jb	 SHORT $LN786@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00259	8d 7a 23	 lea	 edi, DWORD PTR [edx+35]
  0025c	89 7d e8	 mov	 DWORD PTR tv5336[ebp], edi
  0025f	3b fa		 cmp	 edi, edx
  00261	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PlaySoundA@12
  00267	76 1b		 jbe	 SHORT $_Invalid_parameter$2396

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00269	8b 55 e8	 mov	 edx, DWORD PTR tv5336[ebp]
  0026c	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0026f	75 13		 jne	 SHORT $_Invalid_parameter$2396

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00271	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00274	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00276	73 0c		 jae	 SHORT $_Invalid_parameter$2396

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00278	2b c8		 sub	 ecx, eax
  0027a	83 f9 04	 cmp	 ecx, 4
  0027d	72 05		 jb	 SHORT $_Invalid_parameter$2396

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0027f	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00282	76 06		 jbe	 SHORT $LN786@Odczytaj_l
$_Invalid_parameter$2396:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2384@Odczytaj_l:
$LN786@Odczytaj_l:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0028a	52		 push	 edx
  0028b	50		 push	 eax
  0028c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00291	83 c4 08	 add	 esp, 8
$LN783@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 433  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  00294	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00298	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T7[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  0029e	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  002a8	c7 85 68 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T14[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  002b2	c6 85 54 fe ff
	ff 00		 mov	 BYTE PTR $T14[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002b9	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  002bc	72 4c		 jb	 SHORT $LN854@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002be	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002c4	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002c5	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  002c7	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002cd	72 31		 jb	 SHORT $LN857@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  002cf	8d 7a 23	 lea	 edi, DWORD PTR [edx+35]
  002d2	89 7d e8	 mov	 DWORD PTR tv5335[ebp], edi
  002d5	3b fa		 cmp	 edi, edx
  002d7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PlaySoundA@12
  002dd	76 1b		 jbe	 SHORT $_Invalid_parameter$2397

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  002df	8b 55 e8	 mov	 edx, DWORD PTR tv5335[ebp]
  002e2	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  002e5	75 13		 jne	 SHORT $_Invalid_parameter$2397

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002e7	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  002ea	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  002ec	73 0c		 jae	 SHORT $_Invalid_parameter$2397

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  002ee	2b c8		 sub	 ecx, eax
  002f0	83 f9 04	 cmp	 ecx, 4
  002f3	72 05		 jb	 SHORT $_Invalid_parameter$2397

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  002f5	83 f9 23	 cmp	 ecx, 35			; 00000023H
  002f8	76 06		 jbe	 SHORT $LN857@Odczytaj_l
$_Invalid_parameter$2397:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2385@Odczytaj_l:
$LN857@Odczytaj_l:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00300	52		 push	 edx
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00307	83 c4 08	 add	 esp, 8
$LN854@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 434  : 	if (wylosowana_liczba != 0)

  0030a	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  00310	8b 00		 mov	 eax, DWORD PTR [eax]
  00312	85 c0		 test	 eax, eax
  00314	0f 84 31 07 00
	00		 je	 $LN1086@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0031a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0031d	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0031f	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00322	72 02		 jb	 SHORT $LN2361@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00324	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2361@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00326	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00329	83 fa 01	 cmp	 edx, 1
  0032c	75 14		 jne	 SHORT $LN910@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0032e	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00331	3c 70		 cmp	 al, 112			; 00000070H
  00333	75 04		 jne	 SHORT $LN2368@Odczytaj_l
  00335	33 c0		 xor	 eax, eax
  00337	eb 05		 jmp	 SHORT $LN2369@Odczytaj_l
$LN2368@Odczytaj_l:
  00339	1b c0		 sbb	 eax, eax
  0033b	83 c8 01	 or	 eax, 1
$LN2369@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0033e	85 c0		 test	 eax, eax
  00340	74 2a		 je	 SHORT $LN7@Odczytaj_l
$LN910@Odczytaj_l:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00342	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00344	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00347	72 02		 jb	 SHORT $LN2362@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00349	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2362@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0034b	83 fa 01	 cmp	 edx, 1
  0034e	0f 85 fd 00 00
	00		 jne	 $LN939@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00354	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00357	3c 6e		 cmp	 al, 110			; 0000006eH
  00359	75 04		 jne	 SHORT $LN2370@Odczytaj_l
  0035b	33 c0		 xor	 eax, eax
  0035d	eb 05		 jmp	 SHORT $LN2371@Odczytaj_l
$LN2370@Odczytaj_l:
  0035f	1b c0		 sbb	 eax, eax
  00361	83 c8 01	 or	 eax, 1
$LN2371@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00364	85 c0		 test	 eax, eax
  00366	0f 85 e5 00 00
	00		 jne	 $LN939@Odczytaj_l
$LN7@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 436  : 			if (wylosowana_liczba % 2 == 0) //Je¿eli wylosowana liczba modulo 2 jest 0 to

  0036c	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  00372	8b 01		 mov	 eax, DWORD PTR [ecx]

; 437  : 				PlaySound((G³os + "p.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana licza jest parzysta

  00374	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]
  0037a	a8 01		 test	 al, 1
  0037c	75 71		 jne	 SHORT $LN8@Odczytaj_l
  0037e	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  00383	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00388	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0038b	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0038f	72 02		 jb	 SHORT $LN955@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00391	8b 00		 mov	 eax, DWORD PTR [eax]
$LN955@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 437  : 				PlaySound((G³os + "p.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana licza jest parzysta

  00393	6a 00		 push	 0
  00395	6a 00		 push	 0
  00397	50		 push	 eax
  00398	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0039a	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T55[ebp+20]
  003a0	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  003a3	0f 82 a2 06 00
	00		 jb	 $LN1086@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  003a9	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T55[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  003af	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  003b0	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  003b2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  003b8	72 26		 jb	 SHORT $LN1002@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  003ba	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  003bd	3b f2		 cmp	 esi, edx
  003bf	76 19		 jbe	 SHORT $_Invalid_parameter$2398

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  003c1	8b d6		 mov	 edx, esi
  003c3	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  003c5	75 13		 jne	 SHORT $_Invalid_parameter$2398

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  003c7	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  003ca	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  003cc	73 0c		 jae	 SHORT $_Invalid_parameter$2398

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  003ce	2b c1		 sub	 eax, ecx
  003d0	83 f8 04	 cmp	 eax, 4
  003d3	72 05		 jb	 SHORT $_Invalid_parameter$2398

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  003d5	83 f8 23	 cmp	 eax, 35			; 00000023H
  003d8	76 06		 jbe	 SHORT $LN1002@Odczytaj_l
$_Invalid_parameter$2398:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  003da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2386@Odczytaj_l:
$LN1002@Odczytaj_l:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  003e0	52		 push	 edx
  003e1	51		 push	 ecx
  003e2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003e7	83 c4 08	 add	 esp, 8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 438  : 			else

  003ea	e9 5c 06 00 00	 jmp	 $LN1086@Odczytaj_l
$LN8@Odczytaj_l:

; 439  : 				PlaySound((G³os + "n.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana licza jest nieparzysta

  003ef	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  003f4	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  003f9	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003fc	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00400	72 02		 jb	 SHORT $LN1042@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00402	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1042@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 439  : 				PlaySound((G³os + "n.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana licza jest nieparzysta

  00404	6a 00		 push	 0
  00406	6a 00		 push	 0
  00408	50		 push	 eax
  00409	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0040b	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T66[ebp+20]
  00411	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00414	0f 82 31 06 00
	00		 jb	 $LN1086@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0041a	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T66[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00420	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00421	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00423	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00429	72 b5		 jb	 SHORT $LN1002@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0042b	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  0042e	3b f2		 cmp	 esi, edx
  00430	76 19		 jbe	 SHORT $_Invalid_parameter$2399

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00432	8b d6		 mov	 edx, esi
  00434	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00436	75 13		 jne	 SHORT $_Invalid_parameter$2399

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00438	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0043b	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0043d	73 0c		 jae	 SHORT $_Invalid_parameter$2399

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0043f	2b c1		 sub	 eax, ecx
  00441	83 f8 04	 cmp	 eax, 4
  00444	72 05		 jb	 SHORT $_Invalid_parameter$2399

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00446	83 f8 23	 cmp	 eax, 35			; 00000023H
  00449	76 95		 jbe	 SHORT $LN1002@Odczytaj_l
$_Invalid_parameter$2399:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0044b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2387@Odczytaj_l:
$LN939@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00451	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00453	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00456	72 02		 jb	 SHORT $LN2363@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00458	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2363@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0045a	83 fa 01	 cmp	 edx, 1
  0045d	75 14		 jne	 SHORT $LN1142@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0045f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00462	3c 72		 cmp	 al, 114			; 00000072H
  00464	75 04		 jne	 SHORT $LN2372@Odczytaj_l
  00466	33 c0		 xor	 eax, eax
  00468	eb 05		 jmp	 SHORT $LN2373@Odczytaj_l
$LN2372@Odczytaj_l:
  0046a	1b c0		 sbb	 eax, eax
  0046c	83 c8 01	 or	 eax, 1
$LN2373@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0046f	85 c0		 test	 eax, eax
  00471	74 2a		 je	 SHORT $LN12@Odczytaj_l
$LN1142@Odczytaj_l:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00473	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00475	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00478	72 02		 jb	 SHORT $LN2364@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0047a	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2364@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0047c	83 fa 01	 cmp	 edx, 1
  0047f	0f 85 03 01 00
	00		 jne	 $LN1171@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00485	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00488	3c 62		 cmp	 al, 98			; 00000062H
  0048a	75 04		 jne	 SHORT $LN2374@Odczytaj_l
  0048c	33 c0		 xor	 eax, eax
  0048e	eb 05		 jmp	 SHORT $LN2375@Odczytaj_l
$LN2374@Odczytaj_l:
  00490	1b c0		 sbb	 eax, eax
  00492	83 c8 01	 or	 eax, 1
$LN2375@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00495	85 c0		 test	 eax, eax
  00497	0f 85 eb 00 00
	00		 jne	 $LN1171@Odczytaj_l
$LN12@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 441  : 			if (Ruletka_plansza_kolor[wylosowana_liczba] == 'r') //Je¿eli kolor wylosowanej liczby to czerwony

  0049d	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  004a3	8b 01		 mov	 eax, DWORD PTR [ecx]

; 442  : 				PlaySound((G³os + "r.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest koloru czerwonego

  004a5	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T87[ebp]
  004ab	80 b8 00 00 00
	00 72		 cmp	 BYTE PTR ?Ruletka_plansza_kolor@@3QBDB[eax], 114 ; 00000072H
  004b2	75 6a		 jne	 SHORT $LN13@Odczytaj_l
  004b4	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  004b9	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  004be	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004c1	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  004c5	72 02		 jb	 SHORT $LN1187@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004c7	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1187@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 442  : 				PlaySound((G³os + "r.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest koloru czerwonego

  004c9	6a 00		 push	 0
  004cb	6a 00		 push	 0
  004cd	50		 push	 eax
  004ce	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004d0	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T87[ebp+20]
  004d6	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  004d9	0f 82 6c 05 00
	00		 jb	 $LN1086@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  004df	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T87[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  004e5	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  004e6	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  004e8	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  004ee	0f 82 ec fe ff
	ff		 jb	 $LN1002@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  004f4	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  004f7	3b f2		 cmp	 esi, edx
  004f9	76 1d		 jbe	 SHORT $_Invalid_parameter$2400

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  004fb	8b d6		 mov	 edx, esi
  004fd	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  004ff	75 17		 jne	 SHORT $_Invalid_parameter$2400

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00501	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00504	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00506	73 10		 jae	 SHORT $_Invalid_parameter$2400

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00508	2b c1		 sub	 eax, ecx
  0050a	83 f8 04	 cmp	 eax, 4
  0050d	72 09		 jb	 SHORT $_Invalid_parameter$2400

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0050f	83 f8 23	 cmp	 eax, 35			; 00000023H
  00512	0f 86 c8 fe ff
	ff		 jbe	 $LN1002@Odczytaj_l
$_Invalid_parameter$2400:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00518	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2388@Odczytaj_l:
$LN13@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 444  : 				PlaySound((G³os + "b.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e liczba jest koloru czarnego

  0051e	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  00523	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00528	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0052b	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0052f	72 02		 jb	 SHORT $LN1274@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00531	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1274@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 444  : 				PlaySound((G³os + "b.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e liczba jest koloru czarnego

  00533	6a 00		 push	 0
  00535	6a 00		 push	 0
  00537	50		 push	 eax
  00538	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0053a	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T98[ebp+20]
  00540	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00543	0f 82 02 05 00
	00		 jb	 $LN1086@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00549	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T98[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0054f	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00550	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00552	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00558	0f 82 82 fe ff
	ff		 jb	 $LN1002@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0055e	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00561	3b f2		 cmp	 esi, edx
  00563	76 1d		 jbe	 SHORT $_Invalid_parameter$2401

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00565	8b d6		 mov	 edx, esi
  00567	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00569	75 17		 jne	 SHORT $_Invalid_parameter$2401

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0056b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0056e	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00570	73 10		 jae	 SHORT $_Invalid_parameter$2401

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00572	2b c1		 sub	 eax, ecx
  00574	83 f8 04	 cmp	 eax, 4
  00577	72 09		 jb	 SHORT $_Invalid_parameter$2401

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00579	83 f8 23	 cmp	 eax, 35			; 00000023H
  0057c	0f 86 5e fe ff
	ff		 jbe	 $LN1002@Odczytaj_l
$_Invalid_parameter$2401:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00582	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2389@Odczytaj_l:
$LN1171@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00588	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0058a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0058d	72 02		 jb	 SHORT $LN2365@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0058f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2365@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00591	83 fa 01	 cmp	 edx, 1
  00594	75 14		 jne	 SHORT $LN1374@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00596	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00599	3c 67		 cmp	 al, 103			; 00000067H
  0059b	75 04		 jne	 SHORT $LN2376@Odczytaj_l
  0059d	33 c0		 xor	 eax, eax
  0059f	eb 05		 jmp	 SHORT $LN2377@Odczytaj_l
$LN2376@Odczytaj_l:
  005a1	1b c0		 sbb	 eax, eax
  005a3	83 c8 01	 or	 eax, 1
$LN2377@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005a6	85 c0		 test	 eax, eax
  005a8	74 2a		 je	 SHORT $LN17@Odczytaj_l
$LN1374@Odczytaj_l:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  005aa	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005ac	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  005af	72 02		 jb	 SHORT $LN2366@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005b1	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2366@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005b3	83 fa 01	 cmp	 edx, 1
  005b6	0f 85 fd 00 00
	00		 jne	 $LN1403@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005bc	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  005bf	3c 64		 cmp	 al, 100			; 00000064H
  005c1	75 04		 jne	 SHORT $LN2378@Odczytaj_l
  005c3	33 c0		 xor	 eax, eax
  005c5	eb 05		 jmp	 SHORT $LN2379@Odczytaj_l
$LN2378@Odczytaj_l:
  005c7	1b c0		 sbb	 eax, eax
  005c9	83 c8 01	 or	 eax, 1
$LN2379@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005cc	85 c0		 test	 eax, eax
  005ce	0f 85 e5 00 00
	00		 jne	 $LN1403@Odczytaj_l
$LN17@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 446  : 			if (wylosowana_liczba < 19) //Je¿eli wylosowa liczba jest mniejsza ni¿ 19

  005d4	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  005da	83 39 13	 cmp	 DWORD PTR [ecx], 19	; 00000013H

; 447  : 				PlaySound((G³os + "g.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest z górnej po³ówki

  005dd	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T119[ebp]
  005e3	7d 6a		 jge	 SHORT $LN18@Odczytaj_l
  005e5	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  005ea	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  005ef	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005f2	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  005f6	72 02		 jb	 SHORT $LN1419@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005f8	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1419@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 447  : 				PlaySound((G³os + "g.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest z górnej po³ówki

  005fa	6a 00		 push	 0
  005fc	6a 00		 push	 0
  005fe	50		 push	 eax
  005ff	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00601	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T119[ebp+20]
  00607	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  0060a	0f 82 3b 04 00
	00		 jb	 $LN1086@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00610	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T119[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00616	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00617	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00619	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0061f	0f 82 bb fd ff
	ff		 jb	 $LN1002@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00625	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00628	3b f2		 cmp	 esi, edx
  0062a	76 1d		 jbe	 SHORT $_Invalid_parameter$2402

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0062c	8b d6		 mov	 edx, esi
  0062e	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00630	75 17		 jne	 SHORT $_Invalid_parameter$2402

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00632	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00635	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00637	73 10		 jae	 SHORT $_Invalid_parameter$2402

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00639	2b c1		 sub	 eax, ecx
  0063b	83 f8 04	 cmp	 eax, 4
  0063e	72 09		 jb	 SHORT $_Invalid_parameter$2402

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00640	83 f8 23	 cmp	 eax, 35			; 00000023H
  00643	0f 86 97 fd ff
	ff		 jbe	 $LN1002@Odczytaj_l
$_Invalid_parameter$2402:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00649	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2390@Odczytaj_l:
$LN18@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 449  : 				PlaySound((G³os + "d.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana liczba jest z dolnej po³ówki

  0064f	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  00654	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00659	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0065c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00660	72 02		 jb	 SHORT $LN1506@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00662	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1506@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 449  : 				PlaySound((G³os + "d.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana liczba jest z dolnej po³ówki

  00664	6a 00		 push	 0
  00666	6a 00		 push	 0
  00668	50		 push	 eax
  00669	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0066b	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T130[ebp+20]
  00671	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00674	0f 82 d1 03 00
	00		 jb	 $LN1086@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0067a	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T130[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00680	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00681	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00683	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00689	0f 82 51 fd ff
	ff		 jb	 $LN1002@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0068f	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00692	3b f2		 cmp	 esi, edx
  00694	76 1d		 jbe	 SHORT $_Invalid_parameter$2403

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00696	8b d6		 mov	 edx, esi
  00698	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0069a	75 17		 jne	 SHORT $_Invalid_parameter$2403

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0069c	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0069f	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  006a1	73 10		 jae	 SHORT $_Invalid_parameter$2403

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  006a3	2b c1		 sub	 eax, ecx
  006a5	83 f8 04	 cmp	 eax, 4
  006a8	72 09		 jb	 SHORT $_Invalid_parameter$2403

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  006aa	83 f8 23	 cmp	 eax, 35			; 00000023H
  006ad	0f 86 2d fd ff
	ff		 jbe	 $LN1002@Odczytaj_l
$_Invalid_parameter$2403:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  006b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2391@Odczytaj_l:
$LN1403@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  006b9	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006bb	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  006be	72 02		 jb	 SHORT $LN2367@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  006c0	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2367@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 450  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  006c2	80 38 6b	 cmp	 BYTE PTR [eax], 107	; 0000006bH
  006c5	0f 85 ee 01 00
	00		 jne	 $LN20@Odczytaj_l

; 451  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  006cb	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  006d0	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T142[ebp]
  006d6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  006db	83 c4 04	 add	 esp, 4
  006de	8b f0		 mov	 esi, eax
  006e0	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  006e4	b9 03 00 00 00	 mov	 ecx, 3
  006e9	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  006ef	8b 00		 mov	 eax, DWORD PTR [eax]
  006f1	48		 dec	 eax
  006f2	99		 cdq
  006f3	f7 f9		 idiv	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  006f5	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 451  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  006f8	80 c2 31	 add	 dl, 49			; 00000031H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3870 : 	_Left.push_back(_Right);

  006fb	88 55 e8	 mov	 BYTE PTR __Ch$[ebp], dl

; 2977 : 		if (_Old_size < _My_data._Myres)

  006fe	3b 4e 14	 cmp	 ecx, DWORD PTR [esi+20]
  00701	73 1a		 jae	 SHORT $LN1603@Odczytaj_l

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00703	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2979 : 			_My_data._Mysize = _Old_size + 1;

  00707	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0070a	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0070d	8b c6		 mov	 eax, esi

; 1583 : 		if (_Large_string_engaged())

  0070f	72 02		 jb	 SHORT $LN1612@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00711	8b 06		 mov	 eax, DWORD PTR [esi]
$LN1612@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00713	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  00716	c6 44 08 01 00	 mov	 BYTE PTR [eax+ecx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  0071b	eb 18		 jmp	 SHORT $LN1602@Odczytaj_l
$LN1603@Odczytaj_l:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  0071d	ff 75 e8	 push	 DWORD PTR __Ch$[ebp]
  00720	c6 85 84 fe ff
	ff 00		 mov	 BYTE PTR $T146[ebp], 0
  00727	ff b5 84 fe ff
	ff		 push	 DWORD PTR $T146[ebp]
  0072d	51		 push	 ecx
  0072e	8b ce		 mov	 ecx, esi
  00730	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN1602@Odczytaj_l:

; 1563 : 		_Mysize(0),

  00735	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T152[ebp+16], 0

; 1564 : 		_Myres(0)

  0073f	c7 85 68 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T152[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00749	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  0074c	0f 11 85 54 fe
	ff ff		 movups	 XMMWORD PTR $T152[ebp], xmm0
  00753	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  00758	66 0f d6 85 64
	fe ff ff	 movq	 QWORD PTR $T152[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  00760	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00767	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0076e	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 451  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  00771	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  00776	8d 95 54 fe ff
	ff		 lea	 edx, DWORD PTR $T152[ebp]
  0077c	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00780	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T160[ebp]
  00786	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0078b	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0078e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00792	72 02		 jb	 SHORT $LN1695@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00794	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1695@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 451  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  00796	6a 00		 push	 0
  00798	6a 00		 push	 0
  0079a	50		 push	 eax
  0079b	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0079d	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR $T160[ebp+20]
  007a3	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  007a6	72 41		 jb	 SHORT $LN1739@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  007a8	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR $T160[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  007ae	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  007af	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  007b1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  007b7	72 26		 jb	 SHORT $LN1742@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  007b9	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  007bc	3b f2		 cmp	 esi, edx
  007be	76 19		 jbe	 SHORT $_Invalid_parameter$2404

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  007c0	8b d6		 mov	 edx, esi
  007c2	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  007c4	75 13		 jne	 SHORT $_Invalid_parameter$2404

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  007c6	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  007c9	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  007cb	73 0c		 jae	 SHORT $_Invalid_parameter$2404

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  007cd	2b c1		 sub	 eax, ecx
  007cf	83 f8 04	 cmp	 eax, 4
  007d2	72 05		 jb	 SHORT $_Invalid_parameter$2404

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  007d4	83 f8 23	 cmp	 eax, 35			; 00000023H
  007d7	76 06		 jbe	 SHORT $LN1742@Odczytaj_l
$_Invalid_parameter$2404:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  007d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2392@Odczytaj_l:
$LN1742@Odczytaj_l:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  007df	52		 push	 edx
  007e0	51		 push	 ecx
  007e1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  007e6	83 c4 08	 add	 esp, 8
$LN1739@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007e9	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR $T152[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  007ef	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T160[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  007f9	c7 85 50 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T160[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00803	c6 85 3c fe ff
	ff 00		 mov	 BYTE PTR $T160[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0080a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  0080d	72 41		 jb	 SHORT $LN1810@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0080f	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR $T152[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00815	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00816	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00818	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0081e	72 26		 jb	 SHORT $LN1813@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00820	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00823	3b f2		 cmp	 esi, edx
  00825	76 19		 jbe	 SHORT $_Invalid_parameter$2405

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00827	8b d6		 mov	 edx, esi
  00829	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0082b	75 13		 jne	 SHORT $_Invalid_parameter$2405

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0082d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00830	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00832	73 0c		 jae	 SHORT $_Invalid_parameter$2405

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00834	2b c1		 sub	 eax, ecx
  00836	83 f8 04	 cmp	 eax, 4
  00839	72 05		 jb	 SHORT $_Invalid_parameter$2405

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0083b	83 f8 23	 cmp	 eax, 35			; 00000023H
  0083e	76 06		 jbe	 SHORT $LN1813@Odczytaj_l
$_Invalid_parameter$2405:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00840	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2393@Odczytaj_l:
$LN1813@Odczytaj_l:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00846	52		 push	 edx
  00847	51		 push	 ecx
  00848	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0084d	83 c4 08	 add	 esp, 8
$LN1810@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00850	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T142[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00856	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T152[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00860	c7 85 68 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T152[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0086a	c6 85 54 fe ff
	ff 00		 mov	 BYTE PTR $T152[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00871	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00874	0f 82 d1 01 00
	00		 jb	 $LN1086@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0087a	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T142[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00880	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00881	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00883	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00889	0f 82 51 fb ff
	ff		 jb	 $LN1002@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0088f	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00892	3b f2		 cmp	 esi, edx
  00894	76 1d		 jbe	 SHORT $_Invalid_parameter$2406

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00896	8b d6		 mov	 edx, esi
  00898	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0089a	75 17		 jne	 SHORT $_Invalid_parameter$2406

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0089c	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0089f	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  008a1	73 10		 jae	 SHORT $_Invalid_parameter$2406

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  008a3	2b c1		 sub	 eax, ecx
  008a5	83 f8 04	 cmp	 eax, 4
  008a8	72 09		 jb	 SHORT $_Invalid_parameter$2406

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  008aa	83 f8 23	 cmp	 eax, 35			; 00000023H
  008ad	0f 86 2d fb ff
	ff		 jbe	 $LN1002@Odczytaj_l
$_Invalid_parameter$2406:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  008b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2394@Odczytaj_l:
$LN20@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008b9	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  008bc	72 02		 jb	 SHORT $LN1923@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  008be	8b 36		 mov	 esi, DWORD PTR [esi]
$LN1923@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 452  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  008c0	80 3e 77	 cmp	 BYTE PTR [esi], 119	; 00000077H
  008c3	0f 85 82 01 00
	00		 jne	 $LN1086@Odczytaj_l
  008c9	68 b0 00 00 00	 push	 176			; 000000b0H
  008ce	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _numers$198[ebp]
  008d4	6a 00		 push	 0
  008d6	50		 push	 eax
  008d7	e8 00 00 00 00	 call	 _memset
  008dc	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 590  : 		{	// construct empty character buffer

  008df	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$198[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  008e9	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp+104]
  008ef	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$198[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  008f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  008ff	6a 00		 push	 0
  00901	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _numers$198[ebp+24]
  00907	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0090b	50		 push	 eax
  0090c	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp]
  00912	c7 45 e8 2b 00
	00 00		 mov	 DWORD PTR $T1[ebp], 43	; 0000002bH
  00919	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  0091f	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9
  00926	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _numers$198[ebp]
  0092c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0092f	c7 84 05 88 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$198[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0093a	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _numers$198[ebp]
  00940	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00943	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00946	89 84 0d 84 fe
	ff ff		 mov	 DWORD PTR _numers$198[ebp+ecx-4], eax
  0094d	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _numers$198[ebp+24]

; 30   : 		{	// construct empty character buffer from mode

  00953	8b c8		 mov	 ecx, eax

; 589  : 			_Stringbuffer(_Mode)

  00955	89 85 38 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

  0095b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00961	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$198[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

  0096b	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$198[ebp+80], 0

; 312  : 		_Mystate = _State;

  00975	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$198[ebp+84], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 454  : 			stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  0097f	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH

; 455  : 			numers << ((wylosowana_liczba - 1) / 3 + 1); //Wpisanie do typu obliczonego wiersza wylosowanej liczby

  00983	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  00989	8b 08		 mov	 ecx, DWORD PTR [eax]
  0098b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00990	49		 dec	 ecx
  00991	f7 e9		 imul	 ecx
  00993	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp+16]
  00999	8b c2		 mov	 eax, edx
  0099b	42		 inc	 edx
  0099c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0099f	03 c2		 add	 eax, edx
  009a1	50		 push	 eax
  009a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 644  : 		return (_Stringbuffer.str());

  009a8	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR $T189[ebp]
  009ae	50		 push	 eax
  009af	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp+24]
  009b5	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 456  : 			PlaySound((G³os + "w" + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiego wiersza jest wylosowana liczba

  009ba	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  009bf	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T190[ebp]
  009c5	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  009c9	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  009ce	83 c4 04	 add	 esp, 4
  009d1	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T189[ebp]
  009d7	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  009db	51		 push	 ecx
  009dc	8b d0		 mov	 edx, eax
  009de	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T191[ebp]
  009e4	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  009e9	83 c4 04	 add	 esp, 4
  009ec	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  009f1	8b d0		 mov	 edx, eax
  009f3	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  009f7	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T192[ebp]
  009fd	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00a02	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a05	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00a09	72 02		 jb	 SHORT $LN2336@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a0b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2336@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 456  : 			PlaySound((G³os + "w" + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiego wiersza jest wylosowana liczba

  00a0d	6a 00		 push	 0
  00a0f	6a 00		 push	 0
  00a11	50		 push	 eax
  00a12	ff d7		 call	 edi
  00a14	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T192[ebp]
  00a1a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a1f	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T191[ebp]
  00a25	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a2a	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T190[ebp]
  00a30	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a35	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T189[ebp]
  00a3b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 457  : 		}

  00a40	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp]
  00a46	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1086@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 634  : 		{	// destroy the object

  00a4b	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  00a51	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00a54	c7 84 05 38 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00a5f	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _numers$[ebp]
  00a65	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a68	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00a6b	89 84 0d 34 ff
	ff ff		 mov	 DWORD PTR _numers$[ebp+ecx-4], eax

; 635  : 		}

  00a72	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+24]
  00a78	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00a7d	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+32]
  00a83	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00a89	8d 4d a0	 lea	 ecx, DWORD PTR _numers$[ebp+104]
  00a8c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN3@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 458  : }

  00a92	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00a95	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00a9c	59		 pop	 ecx
  00a9d	5f		 pop	 edi
  00a9e	5e		 pop	 esi
  00a9f	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00aa2	33 cd		 xor	 ecx, ebp
  00aa4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00aa9	8b e5		 mov	 esp, ebp
  00aab	5d		 pop	 ebp
  00aac	8b e3		 mov	 esp, ebx
  00aae	5b		 pop	 ebx
  00aaf	c3		 ret	 0
$LN2382@Odczytaj_l:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$19:
  00000	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0d 00 00
	00		 je	 $LN49@Odczytaj_l
  0000c	83 65 e8 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8d 4d a0	 lea	 ecx, DWORD PTR _numers$[ebp+104]
  00013	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN49@Odczytaj_l:
  00019	c3		 ret	 0
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$20:
  0001a	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp+32]
  00020	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$22:
  00026	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00032	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$[ebp]
  00038	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  0003d	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
  00048	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  0004e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$10:
  00053	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T142[ebp]
  00059	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$11:
  0005e	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T152[ebp]
  00064	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$406:
  00069	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  0006c	83 e0 20	 and	 eax, 32			; 00000020H
  0006f	0f 84 10 00 00
	00		 je	 $LN1936@Odczytaj_l
  00075	83 65 e8 df	 and	 DWORD PTR $T1[ebp], -33	; ffffffdfH
  00079	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp+104]
  0007f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN1936@Odczytaj_l:
  00085	c3		 ret	 0
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$407:
  00086	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp+32]
  0008c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$409:
  00092	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00098	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$13:
  0009e	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _numers$198[ebp]
  000a4	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$14:
  000a9	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T189[ebp]
  000af	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$15:
  000b4	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T190[ebp]
  000ba	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$16:
  000bf	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T191[ebp]
  000c5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  000ca	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000ce	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000d1	8b 8a 20 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-480]
  000d7	33 c8		 xor	 ecx, eax
  000d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000de	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  000e1	33 c8		 xor	 ecx, eax
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  000ed	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Odczytaj_liczbê
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 634  : 		{	// destroy the object

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8d 71 68	 lea	 esi, DWORD PTR [ecx+104]

; 635  : 		}

  00006	8d 4e b0	 lea	 ecx, DWORD PTR [esi-80]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00014	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  0001d	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00026	8d 4e b8	 lea	 ecx, DWORD PTR [esi-72]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0002f	8b ce		 mov	 ecx, esi
  00031	5e		 pop	 esi
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	68 b0 00 00 00	 push	 176			; 000000b0H
  00005	6a 00		 push	 0
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memset
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00010	c2 04 00	 ret	 4
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_typ_zak³adu$GSCopy$1$ = -180				; size = 4
_log$GSCopy$1$ = -176					; size = 4
tv3844 = -176						; size = 4
_wylosowana_liczba$GSCopy$1$ = -172			; size = 4
tv3853 = -172						; size = 4
_kwota_zak³adu$GSCopy$1$ = -168				; size = 4
_iloæ_pieniêdzy$GSCopy$1$ = -164			; size = 4
_buf2$214 = -160					; size = 24
_buf2$215 = -136					; size = 24
_buf2$216 = -112					; size = 24
_buf2$217 = -88						; size = 24
_bufor2$218 = -64					; size = 24
_buf$219 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_co_kontynuowaæ$ = 8					; size = 4
_iloæ_pieniêdzy$ = 12					; size = 4
_kwota_zak³adu$ = 16					; size = 4
_wylosowana_liczba$ = 20				; size = 4
_typ_zak³adu$ = 24					; size = 4
?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; Wczytaj_z_pliku, COMDAT
; _log_ogólny$ = ecx
; _log$ = edx

; 461  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b da		 mov	 ebx, edx
  00030	89 9d 50 ff ff
	ff		 mov	 DWORD PTR _log$GSCopy$1$[ebp], ebx
  00036	8b f1		 mov	 esi, ecx

; 462  : 	if (!Ustawienia.czy_kontynuowaæ_grê) //Je¿eli czy_kontynuowaæ_grê == 0

  00038	66 83 3d 12 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, 0
  00040	8b 45 0c	 mov	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00043	8b 7d 08	 mov	 edi, DWORD PTR _co_kontynuowaæ$[ebp]
  00046	89 85 5c ff ff
	ff		 mov	 DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp], eax
  0004c	8b 45 10	 mov	 eax, DWORD PTR _kwota_zak³adu$[ebp]
  0004f	89 85 58 ff ff
	ff		 mov	 DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp], eax
  00055	8b 45 14	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00058	89 85 54 ff ff
	ff		 mov	 DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp], eax
  0005e	8b 45 18	 mov	 eax, DWORD PTR _typ_zak³adu$[ebp]
  00061	89 85 4c ff ff
	ff		 mov	 DWORD PTR _typ_zak³adu$GSCopy$1$[ebp], eax
  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___access
  0006c	75 4c		 jne	 SHORT $LN31@Wczytaj_z_

; 463  : 		if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  0006e	6a 00		 push	 0
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00075	ff d0		 call	 eax
  00077	83 c4 08	 add	 esp, 8
  0007a	85 c0		 test	 eax, eax
  0007c	75 37		 jne	 SHORT $LN1724@Wczytaj_z_

; 464  : 		{
; 465  : 			co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 466  : 			remove("log_aktualny.txt"); //Usuniêcie pliku log aktualny poniewa¿ rozpoczyna siê now¹ grê

  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00083	c6 07 6e	 mov	 BYTE PTR [edi], 110	; 0000006eH
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__remove
  0008c	83 c4 04	 add	 esp, 4

; 467  : 			log_ogólny << '\n' << "Uruchomiono ponownie grê z wy³¹czon¹ opcj¹ kontynuowania" << '\n'; //Wpisanie do buforu logu ogólnego informacje o rozpoczêciu nowej gry spowodowane ustawieniem gry

  0008f	b2 0a		 mov	 dl, 10			; 0000000aH
  00091	8b ce		 mov	 ecx, esi
  00093	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
  00098	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@
  0009d	8b c8		 mov	 ecx, eax
  0009f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000a4	b2 0a		 mov	 dl, 10			; 0000000aH
  000a6	8b c8		 mov	 ecx, eax
  000a8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 468  : 			log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000ad	8b ce		 mov	 ecx, esi
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN1724@Wczytaj_z_:

; 463  : 		if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000b5	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___access
$LN31@Wczytaj_z_:

; 471  : 	if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000ba	6a 00		 push	 0
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000c1	ff d0		 call	 eax
  000c3	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000c6	51		 push	 ecx
  000c7	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 471  : 	if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000ca	85 c0		 test	 eax, eax
  000cc	0f 85 84 09 00
	00		 jne	 $LN32@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000d2	6a 01		 push	 1
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000d9	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  000de	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1370 : 			_Myios::setstate(ios_base::failbit);

  000e0	6a 00		 push	 0
  000e2	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000e5	03 cb		 add	 ecx, ebx
  000e7	85 c0		 test	 eax, eax
  000e9	75 0a		 jne	 SHORT $LN74@Wczytaj_z_
  000eb	6a 02		 push	 2
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1371 : 		else

  000f3	eb 08		 jmp	 SHORT $LN75@Wczytaj_z_
$LN74@Wczytaj_z_:

; 1372 : 			_Myios::clear();	// added with C++11

  000f5	6a 00		 push	 0
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN75@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  000fd	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _buf$219[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00104	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _buf$219[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0010b	c6 45 d8 00	 mov	 BYTE PTR _buf$219[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 474  : 		string buf, bufor2; //Uworzenie 2 buforów na tekst, pierwszy na ostatni¹ linie tekst, drugi na przedostani¹ nie pust¹ linie tekstu lub ostani¹ w przypadku gdy ostania jest pusta

  0010f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00116	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _bufor2$218[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0011d	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _bufor2$218[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00124	c6 45 c0 00	 mov	 BYTE PTR _bufor2$218[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 474  : 		string buf, bufor2; //Uworzenie 2 buforów na tekst, pierwszy na ostatni¹ linie tekst, drugi na przedostani¹ nie pust¹ linie tekstu lub ostani¹ w przypadku gdy ostania jest pusta

  00128	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  0012c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0012e	6a 0a		 push	 10			; 0000000aH
  00130	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00133	03 cb		 add	 ecx, ebx
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0013b	0f b6 c0	 movzx	 eax, al
  0013e	8d 55 d8	 lea	 edx, DWORD PTR _buf$219[ebp]
  00141	50		 push	 eax
  00142	8b cb		 mov	 ecx, ebx
  00144	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  00149	8b 03		 mov	 eax, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  0014b	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  0014e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  00151	f6 44 18 0c 01	 test	 BYTE PTR [eax+ebx+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 476  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  00156	75 54		 jne	 SHORT $LN3@Wczytaj_z_
  00158	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00160	8b 75 e8	 mov	 esi, DWORD PTR _buf$219[ebp+16]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00163	8b 4d ec	 mov	 ecx, DWORD PTR _buf$219[ebp+20]

; 1594 : 		if (_Large_string_engaged())

  00166	8b 55 d8	 mov	 edx, DWORD PTR _buf$219[ebp]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00169	85 f6		 test	 esi, esi
  0016b	74 13		 je	 SHORT $LN164@Wczytaj_z_

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0016d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00170	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00173	56		 push	 esi

; 1594 : 		if (_Large_string_engaged())

  00174	0f 43 c2	 cmovae	 eax, edx

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00177	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$218[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN164@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	6a 0a		 push	 10			; 0000000aH
  00184	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00187	03 cb		 add	 ecx, ebx
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0018f	0f b6 c0	 movzx	 eax, al
  00192	8d 55 d8	 lea	 edx, DWORD PTR _buf$219[ebp]
  00195	50		 push	 eax
  00196	8b cb		 mov	 ecx, ebx
  00198	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  0019d	8b 03		 mov	 eax, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  0019f	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  001a2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  001a5	f6 44 18 0c 01	 test	 BYTE PTR [eax+ebx+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 476  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  001aa	74 b4		 je	 SHORT $LL2@Wczytaj_z_
$LN3@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001ac	83 7d e8 00	 cmp	 DWORD PTR _buf$219[ebp+16], 0
  001b0	75 17		 jne	 SHORT $LN238@Wczytaj_z_

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001b2	83 7d d4 10	 cmp	 DWORD PTR _bufor2$218[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001b6	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$218[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  001b9	ff 75 d0	 push	 DWORD PTR _bufor2$218[ebp+16]

; 1594 : 		if (_Large_string_engaged())

  001bc	0f 43 45 c0	 cmovae	 eax, DWORD PTR _bufor2$218[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  001c0	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN238@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 482  : 		if (buf.find("Posiadasz") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o skoñczeniu rundy

  001c9	51		 push	 ecx
  001ca	68 00 00 00 00	 push	 OFFSET ??_C@_09LFKNBKJA@Posiadasz?$AA@
  001cf	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  001d2	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  001d7	83 f8 ff	 cmp	 eax, -1
  001da	0f 84 15 01 00
	00		 je	 $LN36@Wczytaj_z_

; 483  : 		{
; 484  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 485  : 			auto pocz¹tek = (unsigned short)buf.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst pozycji ostatniego znaku tekstu o kwocie pieniêdzy któr¹ posiada jeszcze gracz, typ zmiennej auto wsazuje, ¿e kompilator sam wybierze typ zmiennej

  001e0	0f b7 75 e8	 movzx	 esi, WORD PTR _buf$219[ebp+16]
  001e4	8b 55 ec	 mov	 edx, DWORD PTR _buf$219[ebp+20]
  001e7	c6 07 6e	 mov	 BYTE PTR [edi], 110	; 0000006eH
  001ea	8b 7d d8	 mov	 edi, DWORD PTR _buf$219[ebp]
  001ed	0f 1f 00	 npad	 3
$LL4@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001f0	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 486  : 			while (buf[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  001f3	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  001f6	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  001f9	0f 43 cf	 cmovae	 ecx, edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 486  : 			while (buf[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  001fc	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  00200	74 0d		 je	 SHORT $LN5@Wczytaj_z_
  00202	66 85 f6	 test	 si, si
  00205	74 08		 je	 SHORT $LN5@Wczytaj_z_
  00207	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  0020d	eb e1		 jmp	 SHORT $LL4@Wczytaj_z_
$LN5@Wczytaj_z_:

; 487  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu
; 488  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeniej odczytanego tekstu

  0020f	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]
  00212	46		 inc	 esi
  00213	50		 push	 eax
  00214	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$215[ebp]
  0021a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0021f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00223	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$215[ebp]

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00229	8b 45 88	 mov	 eax, DWORD PTR _buf2$215[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 489  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  0022c	0f b7 d6	 movzx	 edx, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0022f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00235	3b c2		 cmp	 eax, edx
  00237	0f 42 d0	 cmovb	 edx, eax

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0023a	83 7d 8c 10	 cmp	 DWORD PTR _buf2$215[ebp+20], 16 ; 00000010H

; 1583 : 		if (_Large_string_engaged())

  0023e	0f 43 8d 78 ff
	ff ff		 cmovae	 ecx, DWORD PTR _buf2$215[ebp]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00245	2b c2		 sub	 eax, edx

; 2607 : 		_My_data._Mysize = _New_size;

  00247	89 45 88	 mov	 DWORD PTR _buf2$215[ebp+16], eax

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0024a	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0024b	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0024c	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0024f	50		 push	 eax
  00250	51		 push	 ecx
  00251	ff d6		 call	 esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 490  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00253	8b 45 88	 mov	 eax, DWORD PTR _buf2$215[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00256	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 490  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00259	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  0025c	3b c2		 cmp	 eax, edx
  0025e	0f 82 6b 0a 00
	00		 jb	 $LN1727@Wczytaj_z_

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00264	83 7d 8c 10	 cmp	 DWORD PTR _buf2$215[ebp+20], 16 ; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00268	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$215[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0026e	6a 01		 push	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1583 : 		if (_Large_string_engaged())

  00270	0f 43 8d 78 ff
	ff ff		 cmovae	 ecx, DWORD PTR _buf2$215[ebp]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00277	03 ca		 add	 ecx, edx

; 2607 : 		_My_data._Mysize = _New_size;

  00279	89 55 88	 mov	 DWORD PTR _buf2$215[ebp+16], edx

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0027c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0027f	50		 push	 eax
  00280	51		 push	 ecx
  00281	ff d6		 call	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00283	83 7d 8c 10	 cmp	 DWORD PTR _buf2$215[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00287	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buf2$215[ebp]

; 1594 : 		if (_Large_string_engaged())

  0028d	0f 43 85 78 ff
	ff ff		 cmovae	 eax, DWORD PTR _buf2$215[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 491  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00294	50		 push	 eax
  00295	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0029b	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp]
  002a1	83 c4 10	 add	 esp, 16			; 00000010H

; 492  : 		}

  002a4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002a8	8b 55 8c	 mov	 edx, DWORD PTR _buf2$215[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 491  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  002ab	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002ad	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  002b0	0f 82 c3 06 00
	00		 jb	 $LN50@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002b6	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _buf2$215[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002bc	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002bd	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  002bf	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002c5	0f 82 91 06 00
	00		 jb	 $LN1429@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  002cb	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  002ce	3b f2		 cmp	 esi, edx
  002d0	76 1d		 jbe	 SHORT $_Invalid_parameter$1736

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  002d2	8b d6		 mov	 edx, esi
  002d4	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  002d6	75 17		 jne	 SHORT $_Invalid_parameter$1736

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002d8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002db	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  002dd	73 10		 jae	 SHORT $_Invalid_parameter$1736

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  002df	2b c1		 sub	 eax, ecx
  002e1	83 f8 04	 cmp	 eax, 4
  002e4	72 09		 jb	 SHORT $_Invalid_parameter$1736

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  002e6	83 f8 23	 cmp	 eax, 35			; 00000023H
  002e9	0f 86 6d 06 00
	00		 jbe	 $LN1429@Wczytaj_z_
$_Invalid_parameter$1736:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1729@Wczytaj_z_:
$LN36@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 493  : 		else if (buf.find("Wylosowano") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o wylosowaniu liczby

  002f5	51		 push	 ecx
  002f6	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DAFLKCID@Wylosowano?$AA@
  002fb	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  002fe	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00303	83 f8 ff	 cmp	 eax, -1
  00306	0f 84 85 02 00
	00		 je	 $LN38@Wczytaj_z_

; 494  : 		{
; 495  : 			co_kontynuowaæ = 'w'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od sprawdzenia wygranej
; 496  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o wylosowanej liczbie

  0030c	8b 55 e8	 mov	 edx, DWORD PTR _buf$219[ebp+16]
  0030f	33 f6		 xor	 esi, esi
  00311	c6 07 77	 mov	 BYTE PTR [edi], 119	; 00000077H
  00314	8b 7d ec	 mov	 edi, DWORD PTR _buf$219[ebp+20]
$LL6@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00317	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 497  : 			while (buf[pocz¹tek] != 'y' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukiwanie od pocz¹tku litery y która wystêpuje w wyrazie po którym jest wylosowana liczba

  0031a	0f b7 ce	 movzx	 ecx, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0031d	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00320	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 497  : 			while (buf[pocz¹tek] != 'y' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukiwanie od pocz¹tku litery y która wystêpuje w wyrazie po którym jest wylosowana liczba

  00324	80 3c 08 79	 cmp	 BYTE PTR [eax+ecx], 121	; 00000079H
  00328	74 07		 je	 SHORT $LN7@Wczytaj_z_
  0032a	3b ca		 cmp	 ecx, edx
  0032c	7d 03		 jge	 SHORT $LN7@Wczytaj_z_
  0032e	46		 inc	 esi
  0032f	eb e6		 jmp	 SHORT $LL6@Wczytaj_z_
$LN7@Wczytaj_z_:

; 498  : 			pocz¹tek += 10; //Przesuniêcie o +10 pozycji pocz¹tku tekstu o po której jest wylosowana liczba
; 499  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeniej odczytanego tekstu

  00331	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]
  00334	83 c6 0a	 add	 esi, 10			; 0000000aH
  00337	50		 push	 eax
  00338	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  0033b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 500  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00340	0f b7 c6	 movzx	 eax, si
  00343	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  00346	50		 push	 eax
  00347	6a 00		 push	 0
  00349	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0034d	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00352	83 7d bc 10	 cmp	 DWORD PTR _buf2$217[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00356	8d 45 a8	 lea	 eax, DWORD PTR _buf2$217[ebp]

; 1594 : 		if (_Large_string_engaged())

  00359	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$217[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 501  : 			wylosowana_liczba = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  0035d	50		 push	 eax
  0035e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00364	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _wylosowana_liczba$GSCopy$1$[ebp]
  0036a	83 c4 04	 add	 esp, 4

; 502  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o typie zak³adu

  0036d	8b 7d ec	 mov	 edi, DWORD PTR _buf$219[ebp+20]
  00370	33 f6		 xor	 esi, esi
  00372	8b 55 e8	 mov	 edx, DWORD PTR _buf$219[ebp+16]
  00375	89 01		 mov	 DWORD PTR [ecx], eax
$LL8@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00377	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 503  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (int)buf.size()) ++pocz¹tek;

  0037a	0f b7 ce	 movzx	 ecx, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0037d	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00380	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 503  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (int)buf.size()) ++pocz¹tek;

  00384	80 3c 08 64	 cmp	 BYTE PTR [eax+ecx], 100	; 00000064H
  00388	74 07		 je	 SHORT $LN9@Wczytaj_z_
  0038a	3b ca		 cmp	 ecx, edx
  0038c	7d 03		 jge	 SHORT $LN9@Wczytaj_z_
  0038e	46		 inc	 esi
  0038f	eb e6		 jmp	 SHORT $LL8@Wczytaj_z_
$LN9@Wczytaj_z_:

; 504  : 			pocz¹tek += 2;  //Przesuniêcie o +2 pozycji pocz¹tku tekstu o po której jest typ zak³adu

  00391	83 c6 02	 add	 esi, 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00394	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00397	83 ff 10	 cmp	 edi, 16			; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0039a	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  0039d	52		 push	 edx

; 1594 : 		if (_Large_string_engaged())

  0039e	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$219[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 506  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  003a8	0f b7 c6	 movzx	 eax, si
  003ab	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  003ae	50		 push	 eax
  003af	6a 00		 push	 0
  003b1	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 507  : 			buf2.erase(buf2.find(" Wylosowano"), string::npos); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê nazw¹ typu zak³adu

  003b6	6a ff		 push	 -1
  003b8	51		 push	 ecx
  003b9	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
  003be	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  003c1	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  003c6	50		 push	 eax
  003c7	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  003ca	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2238 : 		if (this != _STD addressof(_Right))

  003cf	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _typ_zak³adu$GSCopy$1$[ebp]
  003d5	8d 45 a8	 lea	 eax, DWORD PTR _buf2$217[ebp]
  003d8	3b c8		 cmp	 ecx, eax
  003da	74 11		 je	 SHORT $LN559@Wczytaj_z_

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003dc	83 7d bc 10	 cmp	 DWORD PTR _buf2$217[ebp+20], 16 ; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  003e0	ff 75 b8	 push	 DWORD PTR _buf2$217[ebp+16]

; 1594 : 		if (_Large_string_engaged())

  003e3	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$217[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  003e7	50		 push	 eax
  003e8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN559@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 509  : 			buf.erase(buf.find("Obstawiono zaklad"), string::npos); //Usuniêcie wszystkiego w prawo razem z wyszukanym tekstem

  003ed	6a ff		 push	 -1
  003ef	51		 push	 ecx
  003f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  003f5	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  003f8	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  003fd	50		 push	 eax
  003fe	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  00401	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00406	8b 7d ec	 mov	 edi, DWORD PTR _buf$219[ebp+20]

; 1582 : 		value_type * _Result = _Bx._Buf;

  00409	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  0040c	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 510  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie zak³adu

  0040f	33 d2		 xor	 edx, edx

; 512  : 			else //Je¿eli nie to

  00411	66 8b 5d e8	 mov	 bx, WORD PTR _buf$219[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00415	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00418	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 511  : 			if (buf[12] == 'a') { pocz¹tek = 14; } //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a wiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  0041b	80 78 0c 61	 cmp	 BYTE PTR [eax+12], 97	; 00000061H
  0041f	75 07		 jne	 SHORT $LN1714@Wczytaj_z_
  00421	ba 0e 00 00 00	 mov	 edx, 14			; 0000000eH

; 512  : 			else //Je¿eli nie to

  00426	eb 28		 jmp	 SHORT $LN41@Wczytaj_z_
$LN1714@Wczytaj_z_:
  00428	8b 75 d8	 mov	 esi, DWORD PTR _buf$219[ebp]
  0042b	0f 1f 44 00 00	 npad	 5
$LL10@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00430	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 514  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  00433	0f b7 c2	 movzx	 eax, dx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00436	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00439	0f 43 ce	 cmovae	 ecx, esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 514  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  0043c	80 3c 08 7a	 cmp	 BYTE PTR [eax+ecx], 122	; 0000007aH
  00440	74 08		 je	 SHORT $LN11@Wczytaj_z_
  00442	66 3b d3	 cmp	 dx, bx
  00445	73 03		 jae	 SHORT $LN11@Wczytaj_z_
  00447	42		 inc	 edx
  00448	eb e6		 jmp	 SHORT $LL10@Wczytaj_z_
$LN11@Wczytaj_z_:

; 515  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  0044a	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
  0044d	83 c2 03	 add	 edx, 3
$LN41@Wczytaj_z_:

; 516  : 			}
; 517  : 			int koniec = pocz¹tek + 1; //Przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  00450	0f b7 c2	 movzx	 eax, dx
  00453	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv3853[ebp], eax
  00459	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0045c	0f 1f 40 00	 npad	 4
$LL12@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00460	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00463	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00466	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 518  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Poszukujemy znaku dolara przed którym jest kwota zak³adu

  00469	80 3c 30 24	 cmp	 BYTE PTR [eax+esi], 36	; 00000024H
  0046d	74 0a		 je	 SHORT $LN13@Wczytaj_z_
  0046f	0f b7 c3	 movzx	 eax, bx
  00472	3b f0		 cmp	 esi, eax
  00474	7d 03		 jge	 SHORT $LN13@Wczytaj_z_
  00476	46		 inc	 esi
  00477	eb e7		 jmp	 SHORT $LL12@Wczytaj_z_
$LN13@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00479	ff 75 e8	 push	 DWORD PTR _buf$219[ebp+16]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0047c	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0047f	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1594 : 		if (_Large_string_engaged())

  00482	0f 43 c1	 cmovae	 eax, ecx

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00485	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  00488	50		 push	 eax
  00489	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 520  : 			buf2.erase(koniec, string::npos); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  0048e	6a ff		 push	 -1
  00490	56		 push	 esi
  00491	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  00494	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 521  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00499	ff b5 54 ff ff
	ff		 push	 DWORD PTR tv3853[ebp]
  0049f	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  004a2	6a 00		 push	 0
  004a4	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004a9	83 7d bc 10	 cmp	 DWORD PTR _buf2$217[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  004ad	8d 45 a8	 lea	 eax, DWORD PTR _buf2$217[ebp]

; 1594 : 		if (_Large_string_engaged())

  004b0	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$217[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 522  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  004b4	50		 push	 eax
  004b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  004bb	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]
  004c1	83 c4 04	 add	 esp, 4

; 523  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  004c4	0f b7 75 d0	 movzx	 esi, WORD PTR _bufor2$218[ebp+16]
  004c8	8b 55 d4	 mov	 edx, DWORD PTR _bufor2$218[ebp+20]
  004cb	8b 7d c0	 mov	 edi, DWORD PTR _bufor2$218[ebp]
  004ce	8b 9d 50 ff ff
	ff		 mov	 ebx, DWORD PTR _log$GSCopy$1$[ebp]
  004d4	89 01		 mov	 DWORD PTR [ecx], eax
$LL14@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004d6	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 524  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  004d9	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  004dc	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$218[ebp]

; 1583 : 		if (_Large_string_engaged())

  004df	0f 43 cf	 cmovae	 ecx, edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 524  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  004e2	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  004e6	74 0d		 je	 SHORT $LN15@Wczytaj_z_
  004e8	66 85 f6	 test	 si, si
  004eb	74 08		 je	 SHORT $LN15@Wczytaj_z_
  004ed	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  004f3	eb e1		 jmp	 SHORT $LL14@Wczytaj_z_
$LN15@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  004f5	ff 75 d0	 push	 DWORD PTR _bufor2$218[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 525  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  004f8	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  004f9	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$218[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004fc	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  004ff	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]

; 1594 : 		if (_Large_string_engaged())

  00502	0f 43 c7	 cmovae	 eax, edi

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00505	50		 push	 eax
  00506	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 527  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  0050b	0f b7 c6	 movzx	 eax, si
  0050e	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  00511	50		 push	 eax
  00512	6a 00		 push	 0
  00514	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 528  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00519	8b 45 b8	 mov	 eax, DWORD PTR _buf2$217[ebp+16]
  0051c	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  0051f	6a 01		 push	 1
  00521	48		 dec	 eax
  00522	50		 push	 eax
  00523	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00528	83 7d bc 10	 cmp	 DWORD PTR _buf2$217[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0052c	8d 45 a8	 lea	 eax, DWORD PTR _buf2$217[ebp]

; 1594 : 		if (_Large_string_engaged())

  0052f	0f 43 45 a8	 cmovae	 eax, DWORD PTR _buf2$217[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 529  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00533	50		 push	 eax
  00534	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0053a	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp]
  00540	83 c4 04	 add	 esp, 4

; 530  : 		}

  00543	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00547	8b 55 bc	 mov	 edx, DWORD PTR _buf2$217[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 529  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  0054a	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0054c	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  0054f	0f 82 24 04 00
	00		 jb	 $LN50@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00555	8b 4d a8	 mov	 ecx, DWORD PTR _buf2$217[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00558	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00559	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0055b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00561	0f 82 f5 03 00
	00		 jb	 $LN1429@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00567	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  0056a	3b f2		 cmp	 esi, edx
  0056c	76 1d		 jbe	 SHORT $_Invalid_parameter$1737

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0056e	8b d6		 mov	 edx, esi
  00570	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00572	75 17		 jne	 SHORT $_Invalid_parameter$1737

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00574	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00577	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00579	73 10		 jae	 SHORT $_Invalid_parameter$1737

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0057b	2b c1		 sub	 eax, ecx
  0057d	83 f8 04	 cmp	 eax, 4
  00580	72 09		 jb	 SHORT $_Invalid_parameter$1737

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00582	83 f8 23	 cmp	 eax, 35			; 00000023H
  00585	0f 86 d1 03 00
	00		 jbe	 $LN1429@Wczytaj_z_
$_Invalid_parameter$1737:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0058b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1730@Wczytaj_z_:
$LN38@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 531  : 		else if (buf.find("Obstawiono zaklad") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o typie obstawionego zak³adu

  00591	51		 push	 ecx
  00592	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  00597	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  0059a	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0059f	83 f8 ff	 cmp	 eax, -1
  005a2	0f 84 03 02 00
	00		 je	 $LN42@Wczytaj_z_

; 532  : 		{
; 533  : 			co_kontynuowaæ = 't'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od wylosowania liczby
; 534  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o typie zak³adu

  005a8	66 8b 55 e8	 mov	 dx, WORD PTR _buf$219[ebp+16]
  005ac	33 f6		 xor	 esi, esi
  005ae	c6 07 74	 mov	 BYTE PTR [edi], 116	; 00000074H
  005b1	8b 7d ec	 mov	 edi, DWORD PTR _buf$219[ebp+20]
$LL16@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005b4	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 535  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek;

  005b7	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  005ba	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  005bd	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 535  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek;

  005c1	80 3c 08 64	 cmp	 BYTE PTR [eax+ecx], 100	; 00000064H
  005c5	74 08		 je	 SHORT $LN17@Wczytaj_z_
  005c7	66 3b f2	 cmp	 si, dx
  005ca	73 03		 jae	 SHORT $LN17@Wczytaj_z_
  005cc	46		 inc	 esi
  005cd	eb e5		 jmp	 SHORT $LL16@Wczytaj_z_
$LN17@Wczytaj_z_:

; 536  : 			pocz¹tek += 2; //Przesuniêcie pozycji pocz¹tku tekstu o 2 po której jest typ zak³adu
; 537  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeniej odczytanego tekstu

  005cf	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]
  005d2	83 c6 02	 add	 esi, 2
  005d5	50		 push	 eax
  005d6	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  005d9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 538  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  005de	0f b7 c6	 movzx	 eax, si
  005e1	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  005e4	50		 push	 eax
  005e5	6a 00		 push	 0
  005e7	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  005eb	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2238 : 		if (this != _STD addressof(_Right))

  005f0	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _typ_zak³adu$GSCopy$1$[ebp]
  005f6	8d 45 90	 lea	 eax, DWORD PTR _buf2$216[ebp]
  005f9	3b c8		 cmp	 ecx, eax
  005fb	74 11		 je	 SHORT $LN902@Wczytaj_z_

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005fd	83 7d a4 10	 cmp	 DWORD PTR _buf2$216[ebp+20], 16 ; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00601	ff 75 a0	 push	 DWORD PTR _buf2$216[ebp+16]

; 1594 : 		if (_Large_string_engaged())

  00604	0f 43 45 90	 cmovae	 eax, DWORD PTR _buf2$216[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00608	50		 push	 eax
  00609	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN902@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 540  : 			buf.erase(buf.find("Obstawiono zaklad"), string::npos); //Usuniêcie wszystkiego w prawo razem z wyszukanym tekstem

  0060e	6a ff		 push	 -1
  00610	51		 push	 ecx
  00611	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  00616	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  00619	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0061e	50		 push	 eax
  0061f	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  00622	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00627	8b 55 ec	 mov	 edx, DWORD PTR _buf$219[ebp+20]

; 1582 : 		value_type * _Result = _Bx._Buf;

  0062a	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  0062d	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 541  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie zak³adu

  00630	33 ff		 xor	 edi, edi

; 542  : 			if (buf[12] == 'a') pocz¹tek = 14; //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a wiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  00632	8b 75 e8	 mov	 esi, DWORD PTR _buf$219[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00635	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00638	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 542  : 			if (buf[12] == 'a') pocz¹tek = 14; //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a wiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  0063b	80 78 0c 61	 cmp	 BYTE PTR [eax+12], 97	; 00000061H
  0063f	75 0f		 jne	 SHORT $LL18@Wczytaj_z_
  00641	bf 0e 00 00 00	 mov	 edi, 14			; 0000000eH

; 543  : 			else //Je¿eli nie to

  00646	eb 27		 jmp	 SHORT $LN45@Wczytaj_z_
  00648	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL18@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00650	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00653	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00656	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 545  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  00659	0f b7 cf	 movzx	 ecx, di
  0065c	80 3c 08 7a	 cmp	 BYTE PTR [eax+ecx], 122	; 0000007aH
  00660	74 0a		 je	 SHORT $LN19@Wczytaj_z_
  00662	3b ce		 cmp	 ecx, esi
  00664	7d 06		 jge	 SHORT $LN19@Wczytaj_z_
  00666	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
  00669	47		 inc	 edi
  0066a	eb e4		 jmp	 SHORT $LL18@Wczytaj_z_
$LN19@Wczytaj_z_:

; 546  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  0066c	83 c7 03	 add	 edi, 3
$LN45@Wczytaj_z_:

; 547  : 			}
; 548  : 			unsigned short koniec = pocz¹tek + 1; //Przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  0066f	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00672	0f b7 f0	 movzx	 esi, ax
$LL20@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00675	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 549  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Pêtla poszukuj¹ca znaku dolara, pêtla koñczy siê znalezieniem znaku dolara

  00678	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0067b	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  0067e	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 549  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Pêtla poszukuj¹ca znaku dolara, pêtla koñczy siê znalezieniem znaku dolara

  00682	80 3c 08 24	 cmp	 BYTE PTR [eax+ecx], 36	; 00000024H
  00686	74 09		 je	 SHORT $LN21@Wczytaj_z_
  00688	66 3b 75 e8	 cmp	 si, WORD PTR _buf$219[ebp+16]
  0068c	73 03		 jae	 SHORT $LN21@Wczytaj_z_
  0068e	46		 inc	 esi
  0068f	eb e4		 jmp	 SHORT $LL20@Wczytaj_z_
$LN21@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00691	ff 75 e8	 push	 DWORD PTR _buf$219[ebp+16]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00694	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00697	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0069a	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]

; 1594 : 		if (_Large_string_engaged())

  0069d	0f 43 45 d8	 cmovae	 eax, DWORD PTR _buf$219[ebp]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  006a1	50		 push	 eax
  006a2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 551  : 			buf2.erase(koniec, string::npos); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  006a7	6a ff		 push	 -1
  006a9	0f b7 c6	 movzx	 eax, si
  006ac	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  006af	50		 push	 eax
  006b0	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 552  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  006b5	0f b7 c7	 movzx	 eax, di
  006b8	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  006bb	50		 push	 eax
  006bc	6a 00		 push	 0
  006be	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006c3	83 7d a4 10	 cmp	 DWORD PTR _buf2$216[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  006c7	8d 45 90	 lea	 eax, DWORD PTR _buf2$216[ebp]

; 1594 : 		if (_Large_string_engaged())

  006ca	0f 43 45 90	 cmovae	 eax, DWORD PTR _buf2$216[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 553  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  006ce	50		 push	 eax
  006cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  006d5	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]
  006db	83 c4 04	 add	 esp, 4

; 554  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  006de	0f b7 75 d0	 movzx	 esi, WORD PTR _bufor2$218[ebp+16]
  006e2	8b 55 d4	 mov	 edx, DWORD PTR _bufor2$218[ebp+20]
  006e5	8b 7d c0	 mov	 edi, DWORD PTR _bufor2$218[ebp]
  006e8	89 01		 mov	 DWORD PTR [ecx], eax
  006ea	66 0f 1f 44 00
	00		 npad	 6
$LL22@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006f0	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 555  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  006f3	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  006f6	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$218[ebp]

; 1583 : 		if (_Large_string_engaged())

  006f9	0f 43 cf	 cmovae	 ecx, edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 555  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  006fc	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  00700	74 0d		 je	 SHORT $LN23@Wczytaj_z_
  00702	66 85 f6	 test	 si, si
  00705	74 08		 je	 SHORT $LN23@Wczytaj_z_
  00707	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  0070d	eb e1		 jmp	 SHORT $LL22@Wczytaj_z_
$LN23@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0070f	ff 75 d0	 push	 DWORD PTR _bufor2$218[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 556  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  00712	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00713	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$218[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00716	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00719	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]

; 1594 : 		if (_Large_string_engaged())

  0071c	0f 43 c7	 cmovae	 eax, edi

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0071f	50		 push	 eax
  00720	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 558  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00725	0f b7 c6	 movzx	 eax, si
  00728	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  0072b	50		 push	 eax
  0072c	6a 00		 push	 0
  0072e	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 559  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00733	8b 45 a0	 mov	 eax, DWORD PTR _buf2$216[ebp+16]
  00736	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  00739	6a 01		 push	 1
  0073b	48		 dec	 eax
  0073c	50		 push	 eax
  0073d	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00742	83 7d a4 10	 cmp	 DWORD PTR _buf2$216[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00746	8d 45 90	 lea	 eax, DWORD PTR _buf2$216[ebp]

; 1594 : 		if (_Large_string_engaged())

  00749	0f 43 45 90	 cmovae	 eax, DWORD PTR _buf2$216[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 560  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  0074d	50		 push	 eax
  0074e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00754	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp]
  0075a	83 c4 04	 add	 esp, 4

; 561  : 		}

  0075d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00761	8b 55 a4	 mov	 edx, DWORD PTR _buf2$216[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 560  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00764	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00766	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00769	0f 82 0a 02 00
	00		 jb	 $LN50@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0076f	8b 4d 90	 mov	 ecx, DWORD PTR _buf2$216[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00772	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00773	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00775	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0077b	0f 82 db 01 00
	00		 jb	 $LN1429@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00781	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00784	3b f2		 cmp	 esi, edx
  00786	76 1d		 jbe	 SHORT $_Invalid_parameter$1738

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00788	8b d6		 mov	 edx, esi
  0078a	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0078c	75 17		 jne	 SHORT $_Invalid_parameter$1738

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0078e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00791	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00793	73 10		 jae	 SHORT $_Invalid_parameter$1738

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00795	2b c1		 sub	 eax, ecx
  00797	83 f8 04	 cmp	 eax, 4
  0079a	72 09		 jb	 SHORT $_Invalid_parameter$1738

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0079c	83 f8 23	 cmp	 eax, 35			; 00000023H
  0079f	0f 86 b7 01 00
	00		 jbe	 $LN1429@Wczytaj_z_
$_Invalid_parameter$1738:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  007a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1731@Wczytaj_z_:
$LN42@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 562  : 		else if (buf.find("Obstawiono za") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o kwocie obstawionego zak³adu

  007ab	51		 push	 ecx
  007ac	68 00 00 00 00	 push	 OFFSET ??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@
  007b1	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  007b4	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  007b9	83 f8 ff	 cmp	 eax, -1
  007bc	0f 84 a6 01 00
	00		 je	 $LN46@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007c2	8b 55 ec	 mov	 edx, DWORD PTR _buf$219[ebp+20]

; 1582 : 		value_type * _Result = _Bx._Buf;

  007c5	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  007c8	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 565  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  007cb	33 f6		 xor	 esi, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007cd	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 564  : 			co_kontynuowaæ = 'k';  //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od zapytania o typ zak³adu

  007d0	c6 07 6b	 mov	 BYTE PTR [edi], 107	; 0000006bH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1583 : 		if (_Large_string_engaged())

  007d3	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 566  : 			if (buf[12] == 'a') { pocz¹tek = 14; } //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a wiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  007d6	80 78 0c 61	 cmp	 BYTE PTR [eax+12], 97	; 00000061H
  007da	75 07		 jne	 SHORT $LN1711@Wczytaj_z_
  007dc	be 0e 00 00 00	 mov	 esi, 14			; 0000000eH

; 567  : 			else //Je¿eli nie to

  007e1	eb 24		 jmp	 SHORT $LN49@Wczytaj_z_
$LN1711@Wczytaj_z_:
  007e3	8b 7d d8	 mov	 edi, DWORD PTR _buf$219[ebp]
$LL24@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007e6	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 569  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  007e9	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  007ec	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  007ef	0f 43 cf	 cmovae	 ecx, edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 569  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  007f2	80 3c 08 7a	 cmp	 BYTE PTR [eax+ecx], 122	; 0000007aH
  007f6	74 09		 je	 SHORT $LN25@Wczytaj_z_
  007f8	66 3b 75 e8	 cmp	 si, WORD PTR _buf$219[ebp+16]
  007fc	73 03		 jae	 SHORT $LN25@Wczytaj_z_
  007fe	46		 inc	 esi
  007ff	eb e5		 jmp	 SHORT $LL24@Wczytaj_z_
$LN25@Wczytaj_z_:

; 570  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  00801	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
  00804	83 c6 03	 add	 esi, 3
$LN49@Wczytaj_z_:

; 571  : 			}
; 572  : 			unsigned short koniec = pocz¹tek + 1; //Utworzenie i przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  00807	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0080a	0f b7 f8	 movzx	 edi, ax
  0080d	0f 1f 00	 npad	 3
$LL26@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00810	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00813	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]

; 1583 : 		if (_Large_string_engaged())

  00816	0f 43 c1	 cmovae	 eax, ecx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 573  : 			while (buf[koniec] != '$' && koniec < (int)buf.size()) ++koniec; //Pêtla szukaj¹ca znaku dolara

  00819	0f b7 cf	 movzx	 ecx, di
  0081c	80 3c 08 24	 cmp	 BYTE PTR [eax+ecx], 36	; 00000024H
  00820	74 0b		 je	 SHORT $LN27@Wczytaj_z_
  00822	3b 4d e8	 cmp	 ecx, DWORD PTR _buf$219[ebp+16]
  00825	7d 06		 jge	 SHORT $LN27@Wczytaj_z_
  00827	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
  0082a	47		 inc	 edi
  0082b	eb e3		 jmp	 SHORT $LL26@Wczytaj_z_
$LN27@Wczytaj_z_:

; 574  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeniej odczytanego tekstu

  0082d	8d 45 d8	 lea	 eax, DWORD PTR _buf$219[ebp]
  00830	50		 push	 eax
  00831	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  00837	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 575  : 			buf2.erase(koniec, string::npos); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  0083c	6a ff		 push	 -1
  0083e	0f b7 c7	 movzx	 eax, di
  00841	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  00847	50		 push	 eax
  00848	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0084c	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 576  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00851	0f b7 c6	 movzx	 eax, si
  00854	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  0085a	50		 push	 eax
  0085b	6a 00		 push	 0
  0085d	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00862	83 bd 74 ff ff
	ff 10		 cmp	 DWORD PTR _buf2$214[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00869	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _buf2$214[ebp]

; 1594 : 		if (_Large_string_engaged())

  0086f	0f 43 85 60 ff
	ff ff		 cmovae	 eax, DWORD PTR _buf2$214[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 577  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00876	50		 push	 eax
  00877	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0087d	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _kwota_zak³adu$GSCopy$1$[ebp]
  00883	83 c4 04	 add	 esp, 4

; 578  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  00886	0f b7 75 d0	 movzx	 esi, WORD PTR _bufor2$218[ebp+16]
  0088a	8b 55 d4	 mov	 edx, DWORD PTR _bufor2$218[ebp+20]
  0088d	8b 7d c0	 mov	 edi, DWORD PTR _bufor2$218[ebp]
  00890	89 01		 mov	 DWORD PTR [ecx], eax
$LL28@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00892	83 fa 10	 cmp	 edx, 16			; 00000010H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 579  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  00895	0f b7 c6	 movzx	 eax, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00898	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$218[ebp]

; 1583 : 		if (_Large_string_engaged())

  0089b	0f 43 cf	 cmovae	 ecx, edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 579  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  0089e	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  008a2	74 0d		 je	 SHORT $LN29@Wczytaj_z_
  008a4	66 85 f6	 test	 si, si
  008a7	74 08		 je	 SHORT $LN29@Wczytaj_z_
  008a9	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  008af	eb e1		 jmp	 SHORT $LL28@Wczytaj_z_
$LN29@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  008b1	ff 75 d0	 push	 DWORD PTR _bufor2$218[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 580  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  008b4	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008b5	8d 45 c0	 lea	 eax, DWORD PTR _bufor2$218[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008b8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  008bb	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]

; 1594 : 		if (_Large_string_engaged())

  008c1	0f 43 c7	 cmovae	 eax, edi

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  008c4	50		 push	 eax
  008c5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 582  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  008ca	0f b7 c6	 movzx	 eax, si
  008cd	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  008d3	50		 push	 eax
  008d4	6a 00		 push	 0
  008d6	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 583  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  008db	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _buf2$214[ebp+16]
  008e1	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  008e7	6a 01		 push	 1
  008e9	48		 dec	 eax
  008ea	50		 push	 eax
  008eb	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008f0	83 bd 74 ff ff
	ff 10		 cmp	 DWORD PTR _buf2$214[ebp+20], 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008f7	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _buf2$214[ebp]

; 1594 : 		if (_Large_string_engaged())

  008fd	0f 43 85 60 ff
	ff ff		 cmovae	 eax, DWORD PTR _buf2$214[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 584  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00904	50		 push	 eax
  00905	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0090b	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iloæ_pieniêdzy$GSCopy$1$[ebp]
  00911	83 c4 04	 add	 esp, 4

; 585  : 		}

  00914	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00918	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _buf2$214[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 584  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  0091e	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00920	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00923	72 54		 jb	 SHORT $LN50@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00925	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _buf2$214[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0092b	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0092c	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0092e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00934	72 26		 jb	 SHORT $LN1429@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00936	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00939	3b f2		 cmp	 esi, edx
  0093b	76 19		 jbe	 SHORT $_Invalid_parameter$1739

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0093d	8b d6		 mov	 edx, esi
  0093f	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00941	75 13		 jne	 SHORT $_Invalid_parameter$1739

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00943	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00946	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00948	73 0c		 jae	 SHORT $_Invalid_parameter$1739

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0094a	2b c1		 sub	 eax, ecx
  0094c	83 f8 04	 cmp	 eax, 4
  0094f	72 05		 jb	 SHORT $_Invalid_parameter$1739

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00951	83 f8 23	 cmp	 eax, 35			; 00000023H
  00954	76 06		 jbe	 SHORT $LN1429@Wczytaj_z_
$_Invalid_parameter$1739:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00956	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1732@Wczytaj_z_:
$LN1429@Wczytaj_z_:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0095c	52		 push	 edx
  0095d	51		 push	 ecx
  0095e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00963	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1641 : 			}

  00966	eb 11		 jmp	 SHORT $LN50@Wczytaj_z_
$LN46@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 586  : 		else if (buf.find("Gra rozpoczeta dnia") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o rozpoczêciu nowej gry

  00968	51		 push	 ecx
  00969	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@
  0096e	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  00971	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00976	c6 07 6e	 mov	 BYTE PTR [edi], 110	; 0000006eH
$LN50@Wczytaj_z_:

; 587  : 		{
; 588  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 589  : 		}
; 590  : 		else //Je¿eli co pójdzie nie tak, to warunek aby gra siê niewysypa³a
; 591  : 		{
; 592  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku
; 593  : 		}
; 594  : 		log.close(); //Zamkniêcie pliku logu ogólnego

  00979	8b cb		 mov	 ecx, ebx
  0097b	e8 00 00 00 00	 call	 ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::close
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00980	51		 push	 ecx
  00981	6a 0a		 push	 10			; 0000000aH
  00983	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00988	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  0098b	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00990	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1370 : 			_Myios::setstate(ios_base::failbit);

  00992	6a 00		 push	 0
  00994	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00997	03 cb		 add	 ecx, ebx
  00999	85 c0		 test	 eax, eax
  0099b	75 0a		 jne	 SHORT $LN1460@Wczytaj_z_
  0099d	6a 02		 push	 2
  0099f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1371 : 		else

  009a5	eb 08		 jmp	 SHORT $LN1461@Wczytaj_z_
$LN1460@Wczytaj_z_:

; 1372 : 			_Myios::clear();	// added with C++11

  009a7	6a 00		 push	 0
  009a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN1461@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009af	8b 55 d4	 mov	 edx, DWORD PTR _bufor2$218[ebp+20]
  009b2	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  009b5	72 3e		 jb	 SHORT $LN1501@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  009b7	8b 4d c0	 mov	 ecx, DWORD PTR _bufor2$218[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  009ba	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  009bb	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  009bd	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  009c3	72 26		 jb	 SHORT $LN1504@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  009c5	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  009c8	3b f2		 cmp	 esi, edx
  009ca	76 19		 jbe	 SHORT $_Invalid_parameter$1740

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  009cc	8b d6		 mov	 edx, esi
  009ce	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  009d0	75 13		 jne	 SHORT $_Invalid_parameter$1740

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  009d2	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  009d5	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  009d7	73 0c		 jae	 SHORT $_Invalid_parameter$1740

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  009d9	2b c1		 sub	 eax, ecx
  009db	83 f8 04	 cmp	 eax, 4
  009de	72 05		 jb	 SHORT $_Invalid_parameter$1740

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  009e0	83 f8 23	 cmp	 eax, 35			; 00000023H
  009e3	76 06		 jbe	 SHORT $LN1504@Wczytaj_z_
$_Invalid_parameter$1740:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  009e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1733@Wczytaj_z_:
$LN1504@Wczytaj_z_:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  009eb	52		 push	 edx
  009ec	51		 push	 ecx
  009ed	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009f2	83 c4 08	 add	 esp, 8
$LN1501@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009f5	8b 55 ec	 mov	 edx, DWORD PTR _buf$219[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  009f8	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _bufor2$218[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  009ff	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _bufor2$218[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00a06	c6 45 c0 00	 mov	 BYTE PTR _bufor2$218[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a0a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00a0d	0f 82 a0 02 00
	00		 jb	 $LN33@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00a13	8b 4d d8	 mov	 ecx, DWORD PTR _buf$219[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00a16	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00a17	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00a19	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00a1f	72 26		 jb	 SHORT $LN1575@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00a21	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00a24	3b f2		 cmp	 esi, edx
  00a26	76 19		 jbe	 SHORT $_Invalid_parameter$1741

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00a28	8b d6		 mov	 edx, esi
  00a2a	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00a2c	75 13		 jne	 SHORT $_Invalid_parameter$1741

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00a2e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00a31	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00a33	73 0c		 jae	 SHORT $_Invalid_parameter$1741

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00a35	2b c1		 sub	 eax, ecx
  00a37	83 f8 04	 cmp	 eax, 4
  00a3a	72 05		 jb	 SHORT $_Invalid_parameter$1741

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00a3c	83 f8 23	 cmp	 eax, 35			; 00000023H
  00a3f	76 06		 jbe	 SHORT $LN1575@Wczytaj_z_
$_Invalid_parameter$1741:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00a41	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1734@Wczytaj_z_:
$LN1575@Wczytaj_z_:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00a47	52		 push	 edx
  00a48	51		 push	 ecx
  00a49	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00a4e	83 c4 08	 add	 esp, 8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 597  : 	else

  00a51	e9 5d 02 00 00	 jmp	 $LN33@Wczytaj_z_
$LN32@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00a56	6a 02		 push	 2
  00a58	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 599  : 		co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  00a5d	c6 07 6e	 mov	 BYTE PTR [edi], 110	; 0000006eH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00a60	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00a65	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1370 : 			_Myios::setstate(ios_base::failbit);

  00a67	6a 00		 push	 0
  00a69	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00a6c	03 cb		 add	 ecx, ebx
  00a6e	85 c0		 test	 eax, eax
  00a70	75 0a		 jne	 SHORT $LN1606@Wczytaj_z_
  00a72	6a 02		 push	 2
  00a74	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1371 : 		else

  00a7a	eb 08		 jmp	 SHORT $LN1607@Wczytaj_z_
$LN1606@Wczytaj_z_:

; 1372 : 			_Myios::clear();	// added with C++11

  00a7c	6a 00		 push	 0
  00a7e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN1607@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 601  : 		GetSystemTime(&Czas); //Pobieranie aktualnej daty i czasu z zegara systemowego

  00a84	68 00 00 00 00	 push	 OFFSET ?Czas@@3U_SYSTEMTIME@@A ; Czas
  00a89	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemTime@4

; 602  : 		log << "Gra rozpoczeta dnia " << Czas.wDay << "." << Czas.wMonth << "." << Czas.wYear << " o godzinie "; //Wpisanie do bufora zapisu danych o dniu,miesi¹cu i roku do pliku log_aktualny.txt

  00a8f	33 c0		 xor	 eax, eax
  00a91	8d 7b 10	 lea	 edi, DWORD PTR [ebx+16]
  00a94	85 db		 test	 ebx, ebx
  00a96	89 bd 50 ff ff
	ff		 mov	 DWORD PTR tv3844[ebp], edi
  00a9c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@
  00aa1	0f 44 f8	 cmove	 edi, eax
  00aa4	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A
  00aab	50		 push	 eax
  00aac	0f b7 05 02 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+2
  00ab3	8b cf		 mov	 ecx, edi
  00ab5	50		 push	 eax
  00ab6	0f b7 05 06 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+6
  00abd	50		 push	 eax
  00abe	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00ac3	8b c8		 mov	 ecx, eax
  00ac5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00acb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00ad0	8b c8		 mov	 ecx, eax
  00ad2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00ad7	8b c8		 mov	 ecx, eax
  00ad9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00adf	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00ae4	8b c8		 mov	 ecx, eax
  00ae6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00aeb	8b c8		 mov	 ecx, eax
  00aed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00af3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
  00af8	8b c8		 mov	 ecx, eax
  00afa	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 603  : 		if (Czas.wHour < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania godzinny je¿eli godzina jest minejsza ni¿ 10 do pliku log_aktualny.txt

  00aff	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
  00b05	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00b09	73 12		 jae	 SHORT $LN52@Wczytaj_z_
  00b0b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00b10	8b cf		 mov	 ecx, edi
  00b12	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00b17	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
$LN52@Wczytaj_z_:

; 604  : 		log << Czas.wHour << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia godzin od minut do pliku log_aktualny.txt

  00b1d	8b 9d 50 ff ff
	ff		 mov	 ebx, DWORD PTR tv3844[ebp]
  00b23	8b cb		 mov	 ecx, ebx
  00b25	0f b7 c0	 movzx	 eax, ax
  00b28	50		 push	 eax
  00b29	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00b2f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00b34	8b c8		 mov	 ecx, eax
  00b36	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 605  : 		if (Czas.wMinute < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania minut je¿eli minuty jest minejsze ni¿ 10 do pliku log_aktualny.txt

  00b3b	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
  00b41	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00b45	73 12		 jae	 SHORT $LN53@Wczytaj_z_
  00b47	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00b4c	8b cf		 mov	 ecx, edi
  00b4e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00b53	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
$LN53@Wczytaj_z_:

; 606  : 		log << Czas.wMinute << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia minut od sekund do pliku log_aktualny.txt

  00b59	0f b7 c0	 movzx	 eax, ax
  00b5c	8b cb		 mov	 ecx, ebx
  00b5e	50		 push	 eax
  00b5f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00b65	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00b6a	8b c8		 mov	 ecx, eax
  00b6c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 607  : 		if (Czas.wSecond < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania sekund je¿eli sekundy jest minejsza ni¿ 10 do pliku log_aktualny.txt

  00b71	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
  00b77	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00b7b	73 12		 jae	 SHORT $LN54@Wczytaj_z_
  00b7d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00b82	8b cf		 mov	 ecx, edi
  00b84	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00b89	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
$LN54@Wczytaj_z_:

; 608  : 		log << Czas.wSecond << '\n'; // Wpisanie do bufora zapisu danych o sekundzie do pliku log_aktualny.txt

  00b8f	0f b7 c0	 movzx	 eax, ax
  00b92	8b cb		 mov	 ecx, ebx
  00b94	50		 push	 eax
  00b95	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00b9b	b2 0a		 mov	 dl, 10			; 0000000aH
  00b9d	8b c8		 mov	 ecx, eax
  00b9f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 609  : 		log_ogólny << "Nowa gra rozpoczeta dnia " << Czas.wDay << "." << Czas.wMonth << "." << Czas.wYear << " o godzinie "; //Wpisanie do bufora zapisu danych o dniu,miesi¹cu i roku do pliku log_ogólny.txt

  00ba4	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A
  00bab	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@
  00bb0	50		 push	 eax
  00bb1	0f b7 05 02 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+2
  00bb8	8b ce		 mov	 ecx, esi
  00bba	50		 push	 eax
  00bbb	0f b7 05 06 00
	00 00		 movzx	 eax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+6
  00bc2	50		 push	 eax
  00bc3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00bc8	8b c8		 mov	 ecx, eax
  00bca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00bd0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00bd5	8b c8		 mov	 ecx, eax
  00bd7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00bdc	8b c8		 mov	 ecx, eax
  00bde	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00be4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00be9	8b c8		 mov	 ecx, eax
  00beb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00bf0	8b c8		 mov	 ecx, eax
  00bf2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00bf8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
  00bfd	8b c8		 mov	 ecx, eax
  00bff	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 610  : 		if (Czas.wHour < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania godzinny je¿eli godzina jest minejsza ni¿ 10 do pliku log_ogólny.txt

  00c04	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
  00c0a	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00c0e	73 12		 jae	 SHORT $LN55@Wczytaj_z_
  00c10	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00c15	8b ce		 mov	 ecx, esi
  00c17	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00c1c	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
$LN55@Wczytaj_z_:

; 611  : 		log_ogólny << Czas.wHour << ":";//Wpisanie do bufora zapisu znaku : dla rozdzielenia godzin od minut do pliku log_aktualny.txt

  00c22	0f b7 c0	 movzx	 eax, ax
  00c25	8b ce		 mov	 ecx, esi
  00c27	50		 push	 eax
  00c28	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00c2e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00c33	8b c8		 mov	 ecx, eax
  00c35	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 612  : 		if (Czas.wMinute < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania minut je¿eli minuty jest minejsza ni¿ 10 do pliku log_ogólny.txt

  00c3a	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
  00c40	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00c44	73 12		 jae	 SHORT $LN56@Wczytaj_z_
  00c46	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00c4b	8b ce		 mov	 ecx, esi
  00c4d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00c52	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
$LN56@Wczytaj_z_:

; 613  : 		log_ogólny << Czas.wMinute << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia minut od sekund do pliku log_ogólny.txt

  00c58	0f b7 c0	 movzx	 eax, ax
  00c5b	8b ce		 mov	 ecx, esi
  00c5d	50		 push	 eax
  00c5e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00c64	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00c69	8b c8		 mov	 ecx, eax
  00c6b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 614  : 		if (Czas.wSecond < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania sekund je¿eli sekundy jest minejsza ni¿ 10 do pliku log_ogólny.txt

  00c70	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
  00c76	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00c7a	73 12		 jae	 SHORT $LN57@Wczytaj_z_
  00c7c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  00c81	8b ce		 mov	 ecx, esi
  00c83	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00c88	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
$LN57@Wczytaj_z_:

; 615  : 		log_ogólny << Czas.wSecond << '\n'; // Wpisanie do bufora zapisu danych o sekundzie do pliku log_ogólny.txt

  00c8e	0f b7 c0	 movzx	 eax, ax
  00c91	8b ce		 mov	 ecx, esi
  00c93	50		 push	 eax
  00c94	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  00c9a	b2 0a		 mov	 dl, 10			; 0000000aH
  00c9c	8b c8		 mov	 ecx, eax
  00c9e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 616  : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  00ca3	8b cb		 mov	 ecx, ebx
  00ca5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 617  : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00cab	8b ce		 mov	 ecx, esi
  00cad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN33@Wczytaj_z_:

; 619  : }

  00cb3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00cb6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00cbd	59		 pop	 ecx
  00cbe	5f		 pop	 edi
  00cbf	5e		 pop	 esi
  00cc0	5b		 pop	 ebx
  00cc1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cc4	33 cd		 xor	 ecx, ebp
  00cc6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ccb	8b e5		 mov	 esp, ebp
  00ccd	5d		 pop	 ebp
  00cce	c3		 ret	 0
$LN1727@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1611 : 			_Xran();

  00ccf	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN1735@Wczytaj_z_:
$LN1726@Wczytaj_z_:
  00cd4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _buf$219[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR _bufor2$218[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2:
  00010	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$215[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3:
  0001b	8d 4d a8	 lea	 ecx, DWORD PTR _buf2$217[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4:
  00023	8d 4d 90	 lea	 ecx, DWORD PTR _buf2$216[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5:
  0002b	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf2$214[ebp]
  00031	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
  00036	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003d	8b 8a 44 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-188]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0004d	33 c8		 xor	 ecx, eax
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  00059	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Wczytaj_z_pliku@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAH33AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; Wczytaj_z_pliku
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Sprawd_Pliki@@YAXXZ
_TEXT	SEGMENT
$T511 = -520						; size = 24
$T502 = -520						; size = 24
$T473 = -520						; size = 24
$T510 = -496						; size = 24
$T501 = -496						; size = 24
$T493 = -496						; size = 24
$T508 = -472						; size = 24
$T498 = -472						; size = 24
$T381 = -472						; size = 24
$T507 = -448						; size = 24
$T497 = -448						; size = 24
$T399 = -448						; size = 24
$T506 = -424						; size = 24
$T496 = -424						; size = 24
$T401 = -424						; size = 24
$T509 = -400						; size = 24
$T500 = -400						; size = 24
$T499 = -400						; size = 24
$T380 = -400						; size = 24
$T361 = -376						; size = 1
$T437 = -372						; size = 1
$T406 = -372						; size = 1
$T479 = -368						; size = 1
$T385 = -368						; size = 1
__Result$1$ = -364					; size = 4
$T513 = -364						; size = 4
$T1 = -364						; size = 4
$T504 = -360						; size = 24
$T485 = -360						; size = 24
$T431 = -360						; size = 24
$T412 = -360						; size = 24
$T329 = -360						; size = 24
$T311 = -360						; size = 24
$T293 = -360						; size = 24
$T234 = -360						; size = 24
$T174 = -360						; size = 24
$T111 = -360						; size = 24
$T495 = -336						; size = 24
$T430 = -336						; size = 24
$T391 = -336						; size = 24
$T367 = -336						; size = 24
$T327 = -336						; size = 24
$T309 = -336						; size = 24
$T291 = -336						; size = 24
$T233 = -336						; size = 24
$T173 = -336						; size = 24
$T114 = -336						; size = 24
$T505 = -312						; size = 24
$T472 = -312						; size = 24
$T429 = -312						; size = 24
$T420 = -312						; size = 24
$T338 = -312						; size = 24
$T330 = -312						; size = 24
$T320 = -312						; size = 24
$T312 = -312						; size = 24
$T302 = -312						; size = 24
$T294 = -312						; size = 24
$T278 = -312						; size = 24
$T230 = -312						; size = 24
$T218 = -312						; size = 24
$T170 = -312						; size = 24
$T158 = -312						; size = 24
$T110 = -312						; size = 24
$T98 = -312						; size = 24
$T87 = -312						; size = 24
$T75 = -312						; size = 24
$T494 = -288						; size = 24
$T443 = -288						; size = 24
$T402 = -288						; size = 24
$T348 = -288						; size = 24
$T326 = -288						; size = 24
$T308 = -288						; size = 24
$T290 = -288						; size = 24
$T231 = -288						; size = 24
$T171 = -288						; size = 24
$T113 = -288						; size = 24
_i$1$ = -264						; size = 4
__Result$1$ = -264					; size = 4
__Result$1$ = -264					; size = 4
$T55 = -264						; size = 1
_czy_pobrano$1$ = -258					; size = 1
_czy_pobierano$1$ = -257				; size = 1
_czy_pobierano$1$ = -257				; size = 1
_numers$514 = -256					; size = 176
_numers$515 = -256					; size = 176
_link$516 = -80						; size = 24
__Ch$ = -56						; size = 1
_this$ = -56						; size = 4
__Ch$ = -52						; size = 1
tv10521 = -52						; size = 4
_g³os2$517 = -48					; size = 24
$T518 = -24						; size = 4
__Ch$ = -24						; size = 1
_i$1$ = -20						; size = 4
_i$1$ = -20						; size = 4
$T519 = -20						; size = 4
_res$1$ = -20						; size = 4
$T520 = -20						; size = 4
_res$1$ = -20						; size = 4
$T521 = -20						; size = 4
_res$1$ = -20						; size = 4
$T522 = -20						; size = 4
$T523 = -20						; size = 4
$T342 = -20						; size = 1
$T60 = -20						; size = 1
__Ch$ = -20						; size = 1
$T52 = -20						; size = 1
$T47 = -20						; size = 1
$T27 = -20						; size = 1
$T17 = -20						; size = 1
$T12 = -20						; size = 1
tv10474 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Sprawd_Pliki@@YAXXZ PROC				; Sprawd_Pliki, COMDAT

; 622  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Sprawd_Pliki@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec fc 01 00
	00		 sub	 esp, 508		; 000001fcH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 623  : 	if (Ustawienia.efekty_dwiêkowe == 1) //Je¿eli w³¹czono efekty dwiêkowe

  00037	66 83 3d 18 00
	00 00 01	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, 1
  0003f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___access
  00045	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__URLDownloadToFileA@20
  0004b	0f 85 f5 01 00
	00		 jne	 $LN34@Sprawd_P

; 624  : 	{
; 625  : 		if ((_access("Efekty_dwiêkowe", 0))) //Sprawd czy nie ma folderu Efekty dwiêkowe

  00051	6a 00		 push	 0
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
  00058	ff d6		 call	 esi
  0005a	83 c4 08	 add	 esp, 8
  0005d	85 c0		 test	 eax, eax
  0005f	74 0d		 je	 SHORT $LN14@Sprawd_P

; 626  : 		{
; 627  : 			CreateDirectoryA("Efekty_dwiêkowe", nullptr); //Je¿eli nie ma to utwórz go

  00061	6a 00		 push	 0
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8
$LN14@Sprawd_P:

; 628  : 		}
; 629  : 
; 630  : 		bool czy_pobierano = false; //Utworzenie zmiennej informuj¹c¹ czy rozpoczêto pobieranie plików
; 631  : 		bool czy_pobrano = true; //Utworzenie zmiennej informuj¹c¹ czy ostatnie pobieranie zakoñczy³o siê sukesem
; 632  : 
; 633  : 		if ((_access("Efekty_dwiêkowe/bankrut.wav", 0))) //Sprawdzenie czy plik nie istnieje

  0006e	6a 00		 push	 0
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  00075	c6 85 ff fe ff
	ff 00		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0007c	c6 85 fe fe ff
	ff 01		 mov	 BYTE PTR _czy_pobrano$1$[ebp], 1
  00083	ff d6		 call	 esi
  00085	83 c4 08	 add	 esp, 8
  00088	85 c0		 test	 eax, eax
  0008a	74 63		 je	 SHORT $LN4247@Sprawd_P

; 634  : 		{
; 635  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o
; 636  : 			{
; 637  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00092	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00097	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0009c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000a1	8b c8		 mov	 ecx, eax
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 638  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie
; 639  : 			}
; 640  : 			auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/bankrut.wav", "Efekty_dwiêkowe/bankrut.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  000a9	6a 00		 push	 0
  000ab	6a 00		 push	 0
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@
  000b7	6a 00		 push	 0
  000b9	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  000c0	ff d7		 call	 edi

; 641  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  000c2	85 c0		 test	 eax, eax
  000c4	74 29		 je	 SHORT $LN4247@Sprawd_P

; 642  : 				if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 643  : 				{
; 644  : 					czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false
; 645  : 					cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  000c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000cc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  000d1	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000d6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000db	8b c8		 mov	 ecx, eax
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 646  : 					EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio

  000e3	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne

; 647  : 				}
; 648  : 		}
; 649  : 
; 650  : 		if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo

  000ea	e9 57 01 00 00	 jmp	 $LN34@Sprawd_P
$LN4247@Sprawd_P:

; 651  : 			if ((_access("Efekty_dwiêkowe/wygrana1.wav", 0))) //Sprawdzenie czy plik nie istnieje

  000ef	6a 00		 push	 0
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
  000f6	ff d6		 call	 esi
  000f8	83 c4 08	 add	 esp, 8
  000fb	85 c0		 test	 eax, eax
  000fd	74 47		 je	 SHORT $LN4251@Sprawd_P

; 652  : 			{
; 653  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  000ff	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00106	75 24		 jne	 SHORT $LN21@Sprawd_P

; 654  : 				{
; 655  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0010e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00113	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00118	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0011d	8b c8		 mov	 ecx, eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 656  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00125	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN21@Sprawd_P:

; 657  : 				}
; 658  : 				auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/wygrana1.wav", "Efekty_dwiêkowe/wygrana1.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  0012c	6a 00		 push	 0
  0012e	6a 00		 push	 0
  00130	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@
  0013a	6a 00		 push	 0
  0013c	ff d7		 call	 edi

; 659  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0013e	85 c0		 test	 eax, eax
  00140	0f 85 a6 00 00
	00		 jne	 $LN4262@Sprawd_P
$LN4251@Sprawd_P:

; 660  : 					if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 661  : 					{
; 662  : 						czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false
; 663  : 						cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 664  : 						EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 665  : 					}
; 666  : 			}
; 667  : 
; 668  : 		if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 669  : 			if ((_access("Efekty_dwiêkowe/wygrana2.wav", 0))) //Sprawdzenie czy plik nie istnieje

  00146	6a 00		 push	 0
  00148	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
  0014d	ff d6		 call	 esi
  0014f	83 c4 08	 add	 esp, 8
  00152	85 c0		 test	 eax, eax
  00154	74 43		 je	 SHORT $LN4253@Sprawd_P

; 670  : 			{
; 671  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  00156	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0015d	75 24		 jne	 SHORT $LN26@Sprawd_P

; 672  : 				{
; 673  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0015f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00165	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0016a	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0016f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00174	8b c8		 mov	 ecx, eax
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 674  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  0017c	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN26@Sprawd_P:

; 675  : 				}
; 676  : 				auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/wygrana2.wav", "Efekty_dwiêkowe/wygrana2.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  00183	6a 00		 push	 0
  00185	6a 00		 push	 0
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@
  00191	6a 00		 push	 0
  00193	ff d7		 call	 edi

; 677  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00195	85 c0		 test	 eax, eax
  00197	75 53		 jne	 SHORT $LN4262@Sprawd_P
$LN4253@Sprawd_P:

; 678  : 					if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 679  : 					{
; 680  : 						czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false
; 681  : 						cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 682  : 						EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 683  : 					}
; 684  : 			}
; 685  : 
; 686  : 		if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 687  : 			if ((_access("Efekty_dwiêkowe/zwielokrotnenie.wav", 0))) //Sprawdzenie czy plik nie istnieje

  00199	6a 00		 push	 0
  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  001a0	ff d6		 call	 esi
  001a2	83 c4 08	 add	 esp, 8
  001a5	85 c0		 test	 eax, eax
  001a7	74 6e		 je	 SHORT $LN33@Sprawd_P

; 688  : 			{
; 689  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  001a9	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  001b0	75 24		 jne	 SHORT $LN31@Sprawd_P

; 690  : 				{
; 691  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001b8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  001bd	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001c2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001c7	8b c8		 mov	 ecx, eax
  001c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 692  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  001cf	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN31@Sprawd_P:

; 693  : 				}
; 694  : 				auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/zwielokrotnenie.wav", "Efekty_dwiêkowe/zwielokrotnenie.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  001d6	6a 00		 push	 0
  001d8	6a 00		 push	 0
  001da	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  001df	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@
  001e4	6a 00		 push	 0
  001e6	ff d7		 call	 edi

; 695  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  001e8	85 c0		 test	 eax, eax
  001ea	74 2b		 je	 SHORT $LN33@Sprawd_P
$LN4262@Sprawd_P:

; 696  : 					if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 697  : 					{
; 698  : 						czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false
; 699  : 						cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  001ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001f2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  001f7	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001fc	c6 85 fe fe ff
	ff 00		 mov	 BYTE PTR _czy_pobrano$1$[ebp], 0
  00203	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00208	8b c8		 mov	 ecx, eax
  0020a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 700  : 						EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio

  00210	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
$LN33@Sprawd_P:

; 701  : 					}
; 702  : 			}
; 703  : 
; 704  : 		if (czy_pobierano && czy_pobrano) cout << "Pobrano brakuj¹ce pliki efektów" << endl; //Poinformowanie o ukoñczonu pobierania plików

  00217	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0021e	74 26		 je	 SHORT $LN34@Sprawd_P
  00220	80 bd fe fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobrano$1$[ebp], 0
  00227	74 1d		 je	 SHORT $LN34@Sprawd_P
  00229	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0022f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@
  00234	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00239	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0023e	8b c8		 mov	 ecx, eax
  00240	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN34@Sprawd_P:

; 705  : 	}
; 706  : 
; 707  : 	if (Ustawienia.g³os_odczytu_numeru > 0) //Je¿eli w³¹czono odczyt g³osowy

  00246	66 83 3d 14 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, 0
  0024e	0f 8e b4 1c 00
	00		 jle	 $LN35@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00254	6a 05		 push	 5
  00256	68 00 00 00 00	 push	 OFFSET ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  0025b	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00260	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 711  : 		switch (Ustawienia.g³os_odczytu_numeru) //U¿ycie warunku wielokrotnego wyboru do wpisania odpowiedniej nazwy g³osu do zmiennej g³os_nazwa

  00265	0f bf 05 14 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20
  0026c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__memmove
  00272	48		 dec	 eax
  00273	83 f8 08	 cmp	 eax, 8
  00276	0f 87 87 01 00
	00		 ja	 $LN423@Sprawd_P
  0027c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN4273@Sprawd_P[eax*4]
$LN36@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00283	6a 05		 push	 5
  00285	68 00 00 00 00	 push	 OFFSET ??_C@_05KFCKMKOB@Jacek?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0028a	e9 27 01 00 00	 jmp	 $LN4268@Sprawd_P
$LN37@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0028f	6a 03		 push	 3
  00291	68 00 00 00 00	 push	 OFFSET ??_C@_03FPCJKMNP@Ewa?$AA@
$LN4269@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00296	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  0029c	8b c2		 mov	 eax, edx
  0029e	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  002a4	2b c1		 sub	 eax, ecx
  002a6	83 f8 03	 cmp	 eax, 3
  002a9	72 28		 jb	 SHORT $LN207@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002ab	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  002ae	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]

; 1582 : 		value_type * _Result = _Bx._Buf;

  002b1	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  002b6	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  002bb	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  002c2	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  002c4	56		 push	 esi
  002c5	ff d7		 call	 edi
  002c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  002ca	c6 46 03 00	 mov	 BYTE PTR [esi+3], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  002ce	e9 30 01 00 00	 jmp	 $LN423@Sprawd_P
$LN207@Sprawd_P:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  002d3	c6 45 ec 00	 mov	 BYTE PTR $T12[ebp], 0
  002d7	ff 75 ec	 push	 DWORD PTR $T12[ebp]
  002da	6a 03		 push	 3
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 721  : 			break; //Wyjcie z instrukcji case

  002dc	e9 18 01 00 00	 jmp	 $LN4263@Sprawd_P
$LN38@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  002e1	6a 04		 push	 4
  002e3	68 00 00 00 00	 push	 OFFSET ??_C@_04CDICBAGM@Maja?$AA@
$LN4270@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  002e8	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  002ee	8b c2		 mov	 eax, edx
  002f0	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  002f6	2b c1		 sub	 eax, ecx
  002f8	83 f8 04	 cmp	 eax, 4
  002fb	72 28		 jb	 SHORT $LN238@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002fd	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00300	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1582 : 		value_type * _Result = _Bx._Buf;

  00303	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00308	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  0030d	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00314	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00316	56		 push	 esi
  00317	ff d7		 call	 edi
  00319	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  0031c	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  00320	e9 de 00 00 00	 jmp	 $LN423@Sprawd_P
$LN238@Sprawd_P:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  00325	c6 45 ec 00	 mov	 BYTE PTR $T17[ebp], 0
  00329	ff 75 ec	 push	 DWORD PTR $T17[ebp]
  0032c	6a 04		 push	 4
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 726  : 			break; //Wyjcie z instrukcji case

  0032e	e9 c6 00 00 00	 jmp	 $LN4263@Sprawd_P
$LN39@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00333	6a 03		 push	 3
  00335	68 00 00 00 00	 push	 OFFSET ??_C@_03JIHJHPIE@Jan?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0033a	e9 57 ff ff ff	 jmp	 $LN4269@Sprawd_P
$LN40@Sprawd_P:

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  0033f	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00345	8b c2		 mov	 eax, edx
  00347	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0034d	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0034f	6a 06		 push	 6
  00351	68 00 00 00 00	 push	 OFFSET ??_C@_06DKNIKMFF@Jacek2?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00356	83 f8 06	 cmp	 eax, 6
  00359	72 28		 jb	 SHORT $LN300@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0035b	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  0035e	8d 41 06	 lea	 eax, DWORD PTR [ecx+6]

; 1582 : 		value_type * _Result = _Bx._Buf;

  00361	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00366	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  0036b	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00372	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00374	56		 push	 esi
  00375	ff d7		 call	 edi
  00377	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  0037a	c6 46 06 00	 mov	 BYTE PTR [esi+6], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0037e	e9 80 00 00 00	 jmp	 $LN423@Sprawd_P
$LN300@Sprawd_P:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  00383	c6 45 ec 00	 mov	 BYTE PTR $T27[ebp], 0
  00387	ff 75 ec	 push	 DWORD PTR $T27[ebp]
  0038a	6a 06		 push	 6
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 736  : 			break; //Wyjcie z instrukcji case

  0038c	eb 6b		 jmp	 SHORT $LN4263@Sprawd_P
$LN41@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0038e	6a 04		 push	 4
  00390	68 00 00 00 00	 push	 OFFSET ??_C@_04PLEDLCJI@Ewa2?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  00395	e9 4e ff ff ff	 jmp	 $LN4270@Sprawd_P
$LN42@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0039a	6a 05		 push	 5
  0039c	68 00 00 00 00	 push	 OFFSET ??_C@_05KJFHPLBC@Maja2?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  003a1	eb 13		 jmp	 SHORT $LN4268@Sprawd_P
$LN43@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  003a3	6a 04		 push	 4
  003a5	68 00 00 00 00	 push	 OFFSET ??_C@_04HDNGKDH@Jan2?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  003aa	e9 39 ff ff ff	 jmp	 $LN4270@Sprawd_P
$LN44@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  003af	6a 05		 push	 5
  003b1	68 00 00 00 00	 push	 OFFSET ??_C@_05NKPCGME@Agata?$AA@
$LN4268@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  003b6	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  003bc	8b c2		 mov	 eax, edx
  003be	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  003c4	2b c1		 sub	 eax, ecx
  003c6	83 f8 05	 cmp	 eax, 5
  003c9	72 25		 jb	 SHORT $LN176@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003cb	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  003ce	8d 41 05	 lea	 eax, DWORD PTR [ecx+5]

; 1582 : 		value_type * _Result = _Bx._Buf;

  003d1	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  003d6	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  003db	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  003e2	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  003e4	56		 push	 esi
  003e5	ff d7		 call	 edi
  003e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  003ea	c6 46 05 00	 mov	 BYTE PTR [esi+5], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  003ee	eb 13		 jmp	 SHORT $LN423@Sprawd_P
$LN176@Sprawd_P:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  003f0	c6 45 ec 00	 mov	 BYTE PTR $T47[ebp], 0
  003f4	ff 75 ec	 push	 DWORD PTR $T47[ebp]
  003f7	6a 05		 push	 5
$LN4263@Sprawd_P:
  003f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  003fe	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN423@Sprawd_P:

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00403	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00409	8b c2		 mov	 eax, edx
  0040b	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00411	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00413	6a 01		 push	 1
  00415	68 00 00 00 00	 push	 OFFSET ??_C@_01IDAFKMJL@_?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  0041a	83 f8 01	 cmp	 eax, 1
  0041d	72 25		 jb	 SHORT $LN455@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0041f	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00422	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 1582 : 		value_type * _Result = _Bx._Buf;

  00425	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  0042a	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  0042f	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00436	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00438	56		 push	 esi
  00439	ff d7		 call	 edi
  0043b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  0043e	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  00442	eb 13		 jmp	 SHORT $LN454@Sprawd_P
$LN455@Sprawd_P:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  00444	c6 45 ec 00	 mov	 BYTE PTR $T52[ebp], 0
  00448	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0044d	ff 75 ec	 push	 DWORD PTR $T52[ebp]
  00450	6a 01		 push	 1
  00452	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN454@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 764  : 		G³os += '0' + Ustawienia.g³os_szybkoæ_odczytu_numeru; //Dodanie do zmiennej szybkoci mowy

  00457	8a 0d 16 00 00
	00		 mov	 cl, BYTE PTR ?Ustawienia@@3US_Ustawienia@@A+22
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  0045d	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 764  : 		G³os += '0' + Ustawienia.g³os_szybkoæ_odczytu_numeru; //Dodanie do zmiennej szybkoci mowy

  00463	80 c1 30	 add	 cl, 48			; 00000030H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2977 : 		if (_Old_size < _My_data._Myres)

  00466	8b 35 14 00 00
	00		 mov	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20

; 2299 : 		push_back(_Ch);

  0046c	88 4d ec	 mov	 BYTE PTR __Ch$[ebp], cl

; 2977 : 		if (_Old_size < _My_data._Myres)

  0046f	3b d6		 cmp	 edx, esi
  00471	73 21		 jae	 SHORT $LN479@Sprawd_P

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  00473	8d 42 01	 lea	 eax, DWORD PTR [edx+1]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00476	83 fe 10	 cmp	 esi, 16			; 00000010H

; 2979 : 			_My_data._Mysize = _Old_size + 1;

  00479	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0047e	b8 00 00 00 00	 mov	 eax, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1583 : 		if (_Large_string_engaged())

  00483	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0048a	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  0048d	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  00492	eb 1b		 jmp	 SHORT $LN478@Sprawd_P
$LN479@Sprawd_P:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  00494	ff 75 ec	 push	 DWORD PTR __Ch$[ebp]
  00497	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR $T55[ebp], 0
  0049e	ff b5 f8 fe ff
	ff		 push	 DWORD PTR $T55[ebp]
  004a4	51		 push	 ecx
  004a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  004aa	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN478@Sprawd_P:

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  004af	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  004b5	8b c2		 mov	 eax, edx
  004b7	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  004bd	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  004bf	6a 01		 push	 1
  004c1	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  004c6	83 f8 01	 cmp	 eax, 1
  004c9	72 25		 jb	 SHORT $LN510@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004cb	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  004ce	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 1582 : 		value_type * _Result = _Bx._Buf;

  004d1	be 00 00 00 00	 mov	 esi, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  004d6	a3 10 00 00 00	 mov	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 1583 : 		if (_Large_string_engaged())

  004db	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  004e2	03 f1		 add	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  004e4	56		 push	 esi
  004e5	ff d7		 call	 edi
  004e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  004ea	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  004ee	eb 13		 jmp	 SHORT $LN509@Sprawd_P
$LN510@Sprawd_P:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  004f0	c6 45 ec 00	 mov	 BYTE PTR $T60[ebp], 0
  004f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  004f9	ff 75 ec	 push	 DWORD PTR $T60[ebp]
  004fc	6a 01		 push	 1
  004fe	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN509@Sprawd_P:

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00503	6a 42		 push	 66			; 00000042H
  00505	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
  0050a	8d 4d b0	 lea	 ecx, DWORD PTR _link$516[ebp]

; 3683 : 		_My_data._Mysize = 0;

  0050d	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _link$516[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00514	c7 45 c4 0f 00
	00 00		 mov	 DWORD PTR _link$516[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0051b	c6 45 b0 00	 mov	 BYTE PTR _link$516[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0051f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 767  : 		const string link = "https://github.com/talez2709/Ruletka/raw/master/Ruletka/G%C5%82os/"; //Zmienna przechowywuj¹ca pocz¹tek strony do pobierania g³osu

  00524	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  0052b	a1 10 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 3683 : 		_My_data._Mysize = 0;

  00530	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _g³os2$517[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00537	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR _g³os2$517[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0053e	c6 45 d0 00	 mov	 BYTE PTR _g³os2$517[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00542	83 f8 05	 cmp	 eax, 5
  00545	0f 82 09 1a 00
	00		 jb	 $LN4271@Sprawd_P

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  0054b	83 c0 fb	 add	 eax, -5			; fffffffbH
  0054e	83 c9 ff	 or	 ecx, -1
  00551	83 f8 ff	 cmp	 eax, -1
  00554	0f 42 c8	 cmovb	 ecx, eax

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00557	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0055e	b8 00 00 00 00	 mov	 eax, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1594 : 		if (_Large_string_engaged())

  00563	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0056a	51		 push	 ecx
  0056b	83 c0 05	 add	 eax, 5
  0056e	8d 4d d0	 lea	 ecx, DWORD PTR _g³os2$517[ebp]
  00571	50		 push	 eax
  00572	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3468 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  00577	bf 01 00 00 00	 mov	 edi, 1
  0057c	89 7d e8	 mov	 DWORD PTR $T518[ebp], edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 771  : 		if ((_access("G³os", 0))) //Sprawd czy nie ma folderu G³os

  0057f	6a 00		 push	 0
  00581	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00585	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___access
  0058b	68 00 00 00 00	 push	 OFFSET ??_C@_04JLFAMLOH@G?$LDos?$AA@
  00590	ff d6		 call	 esi
  00592	83 c4 08	 add	 esp, 8
  00595	85 c0		 test	 eax, eax
  00597	74 0d		 je	 SHORT $LN46@Sprawd_P

; 772  : 		{
; 773  : 			CreateDirectoryA("G³os", nullptr); //Je¿eli nie ma to utwórz go

  00599	6a 00		 push	 0
  0059b	68 00 00 00 00	 push	 OFFSET ??_C@_04JLFAMLOH@G?$LDos?$AA@
  005a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8
$LN46@Sprawd_P:

; 775  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //Sprawd czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoci¹ g³osu

  005a6	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  005a9	50		 push	 eax
  005aa	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T75[ebp]
  005b0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  005b5	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005b8	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  005bc	72 02		 jb	 SHORT $LN636@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005be	8b 00		 mov	 eax, DWORD PTR [eax]
$LN636@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 775  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //Sprawd czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoci¹ g³osu

  005c0	6a 00		 push	 0
  005c2	50		 push	 eax
  005c3	ff d6		 call	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005c5	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR $T75[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 775  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //Sprawd czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoci¹ g³osu

  005cb	83 c4 08	 add	 esp, 8
  005ce	89 45 ec	 mov	 DWORD PTR $T523[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005d1	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  005d4	72 4d		 jb	 SHORT $LN680@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  005d6	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T75[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  005dc	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  005df	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  005e1	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  005e7	72 27		 jb	 SHORT $LN683@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  005e9	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  005ec	3b c6		 cmp	 eax, esi
  005ee	76 1a		 jbe	 SHORT $_Invalid_parameter$4293

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  005f0	8b f0		 mov	 esi, eax
  005f2	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  005f5	75 13		 jne	 SHORT $_Invalid_parameter$4293

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  005f7	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  005fa	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  005fc	73 0c		 jae	 SHORT $_Invalid_parameter$4293

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  005fe	2b ca		 sub	 ecx, edx
  00600	83 f9 04	 cmp	 ecx, 4
  00603	72 05		 jb	 SHORT $_Invalid_parameter$4293

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00605	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00608	76 06		 jbe	 SHORT $LN683@Sprawd_P
$_Invalid_parameter$4293:
$_Invalid_parameter$4294:
$_Invalid_parameter$4295:
$_Invalid_parameter$4296:
$_Invalid_parameter$4297:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0060a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4274@Sprawd_P:
$LN683@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00610	56		 push	 esi
  00611	52		 push	 edx
  00612	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00617	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___access
  0061d	83 c4 08	 add	 esp, 8
  00620	8b 45 ec	 mov	 eax, DWORD PTR $T523[ebp]
$LN680@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 775  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //Sprawd czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoci¹ g³osu

  00623	85 c0		 test	 eax, eax
  00625	74 77		 je	 SHORT $LN767@Sprawd_P

; 777  : 			CreateDirectoryA(("G³os/" + g³os2).c_str(), nullptr); //Je¿eli nie ma to utwórz go

  00627	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  0062a	50		 push	 eax
  0062b	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T87[ebp]
  00631	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00636	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00639	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0063d	72 02		 jb	 SHORT $LN723@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0063f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN723@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 777  : 			CreateDirectoryA(("G³os/" + g³os2).c_str(), nullptr); //Je¿eli nie ma to utwórz go

  00641	6a 00		 push	 0
  00643	50		 push	 eax
  00644	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0064a	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR $T87[ebp+20]
  00650	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00653	72 49		 jb	 SHORT $LN767@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00655	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T87[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0065b	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0065c	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0065e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00664	72 2e		 jb	 SHORT $LN770@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00666	8d 7a 23	 lea	 edi, DWORD PTR [edx+35]
  00669	89 7d ec	 mov	 DWORD PTR tv10474[ebp], edi
  0066c	3b fa		 cmp	 edi, edx
  0066e	8b 7d e8	 mov	 edi, DWORD PTR $T518[ebp]
  00671	76 1b		 jbe	 SHORT $_Invalid_parameter$4298

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00673	8b 55 ec	 mov	 edx, DWORD PTR tv10474[ebp]
  00676	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00679	75 13		 jne	 SHORT $_Invalid_parameter$4298

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0067b	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  0067e	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00680	73 0c		 jae	 SHORT $_Invalid_parameter$4298

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00682	2b c8		 sub	 ecx, eax
  00684	83 f9 04	 cmp	 ecx, 4
  00687	72 05		 jb	 SHORT $_Invalid_parameter$4298

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00689	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0068c	76 06		 jbe	 SHORT $LN770@Sprawd_P
$_Invalid_parameter$4298:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0068e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4275@Sprawd_P:
$LN770@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00694	52		 push	 edx
  00695	50		 push	 eax
  00696	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0069b	83 c4 08	 add	 esp, 8
$LN767@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 782  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0069e	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  006a3	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T98[ebp]
  006a9	c6 85 ff fe ff
	ff 00		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 0
  006b0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  006b5	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006b8	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  006bc	72 02		 jb	 SHORT $LN810@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  006be	8b 00		 mov	 eax, DWORD PTR [eax]
$LN810@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 782  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  006c0	6a 00		 push	 0
  006c2	50		 push	 eax
  006c3	ff d6		 call	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006c5	8b b5 dc fe ff
	ff		 mov	 esi, DWORD PTR $T98[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 782  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  006cb	83 c4 08	 add	 esp, 8
  006ce	89 45 ec	 mov	 DWORD PTR $T522[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006d1	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  006d4	72 45		 jb	 SHORT $LN854@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  006d6	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T98[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  006dc	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  006dd	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  006df	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  006e5	72 27		 jb	 SHORT $LN857@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  006e7	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  006ea	3b c6		 cmp	 eax, esi
  006ec	76 1a		 jbe	 SHORT $_Invalid_parameter$4299

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  006ee	8b f0		 mov	 esi, eax
  006f0	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  006f3	75 13		 jne	 SHORT $_Invalid_parameter$4299

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  006f5	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  006f8	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  006fa	73 0c		 jae	 SHORT $_Invalid_parameter$4299

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  006fc	2b ca		 sub	 ecx, edx
  006fe	83 f9 04	 cmp	 ecx, 4
  00701	72 05		 jb	 SHORT $_Invalid_parameter$4299

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00703	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00706	76 06		 jbe	 SHORT $LN857@Sprawd_P
$_Invalid_parameter$4299:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00708	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4276@Sprawd_P:
$LN857@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0070e	56		 push	 esi
  0070f	52		 push	 edx
  00710	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00715	8b 45 ec	 mov	 eax, DWORD PTR $T522[ebp]
  00718	83 c4 08	 add	 esp, 8
$LN854@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 782  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0071b	85 c0		 test	 eax, eax
  0071d	0f 84 36 02 00
	00		 je	 $LN50@Sprawd_P

; 783  : 		{
; 784  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o
; 785  : 			{
; 786  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00723	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00729	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0072e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00733	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00738	8b c8		 mov	 ecx, eax
  0073a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 789  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00740	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  00743	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
  0074a	50		 push	 eax
  0074b	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T110[ebp]
  00751	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00756	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  0075b	8b d0		 mov	 edx, eax
  0075d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00761	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T111[ebp]
  00767	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0076c	8b f0		 mov	 esi, eax
  0076e	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  00771	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00775	50		 push	 eax
  00776	8d 55 b0	 lea	 edx, DWORD PTR _link$516[ebp]
  00779	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T113[ebp]
  0077f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00784	68 00 00 00 00	 push	 OFFSET ??_C@_05PNHGCFLK@p?4wav?$AA@
  00789	8b d0		 mov	 edx, eax
  0078b	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0078f	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T114[ebp]
  00795	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0079a	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0079d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  007a1	72 02		 jb	 SHORT $LN897@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  007a3	8b 36		 mov	 esi, DWORD PTR [esi]
$LN897@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007a5	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  007a9	72 02		 jb	 SHORT $LN913@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  007ab	8b 00		 mov	 eax, DWORD PTR [eax]
$LN913@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 789  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  007ad	6a 00		 push	 0
  007af	6a 00		 push	 0
  007b1	56		 push	 esi
  007b2	50		 push	 eax
  007b3	6a 00		 push	 0
  007b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007bb	8b b5 c4 fe ff
	ff		 mov	 esi, DWORD PTR $T114[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 789  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  007c1	89 45 ec	 mov	 DWORD PTR _res$1$[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007c4	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  007c7	72 42		 jb	 SHORT $LN957@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  007c9	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR $T114[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  007cf	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  007d0	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  007d2	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  007d8	72 27		 jb	 SHORT $LN960@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  007da	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  007dd	3b c6		 cmp	 eax, esi
  007df	76 1a		 jbe	 SHORT $_Invalid_parameter$4300

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  007e1	8b f0		 mov	 esi, eax
  007e3	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  007e6	75 13		 jne	 SHORT $_Invalid_parameter$4300

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  007e8	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  007eb	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  007ed	73 0c		 jae	 SHORT $_Invalid_parameter$4300

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  007ef	2b ca		 sub	 ecx, edx
  007f1	83 f9 04	 cmp	 ecx, 4
  007f4	72 05		 jb	 SHORT $_Invalid_parameter$4300

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  007f6	83 f9 23	 cmp	 ecx, 35			; 00000023H
  007f9	76 06		 jbe	 SHORT $LN960@Sprawd_P
$_Invalid_parameter$4300:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  007fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4277@Sprawd_P:
$LN960@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00801	56		 push	 esi
  00802	52		 push	 edx
  00803	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00808	83 c4 08	 add	 esp, 8
$LN957@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 789  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0080b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0080f	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR $T113[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00815	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T114[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0081f	c7 85 c4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T114[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00829	c6 85 b0 fe ff
	ff 00		 mov	 BYTE PTR $T114[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00830	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00833	72 42		 jb	 SHORT $LN1028@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00835	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR $T113[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0083b	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0083c	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0083e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00844	72 27		 jb	 SHORT $LN1031@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00846	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00849	3b f2		 cmp	 esi, edx
  0084b	76 1a		 jbe	 SHORT $_Invalid_parameter$4301

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0084d	8b d6		 mov	 edx, esi
  0084f	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00852	75 13		 jne	 SHORT $_Invalid_parameter$4301

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00854	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00857	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00859	73 0c		 jae	 SHORT $_Invalid_parameter$4301

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0085b	2b c8		 sub	 ecx, eax
  0085d	83 f9 04	 cmp	 ecx, 4
  00860	72 05		 jb	 SHORT $_Invalid_parameter$4301

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00862	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00865	76 06		 jbe	 SHORT $LN1031@Sprawd_P
$_Invalid_parameter$4301:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00867	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4278@Sprawd_P:
$LN1031@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0086d	52		 push	 edx
  0086e	50		 push	 eax
  0086f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00874	83 c4 08	 add	 esp, 8
$LN1028@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 789  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00877	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0087b	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR $T111[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00881	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T113[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0088b	c7 85 f4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T113[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00895	c6 85 e0 fe ff
	ff 00		 mov	 BYTE PTR $T113[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0089c	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  0089f	72 42		 jb	 SHORT $LN1099@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  008a1	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR $T111[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  008a7	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  008a8	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  008aa	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  008b0	72 27		 jb	 SHORT $LN1102@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  008b2	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  008b5	3b f2		 cmp	 esi, edx
  008b7	76 1a		 jbe	 SHORT $_Invalid_parameter$4302

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  008b9	8b d6		 mov	 edx, esi
  008bb	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  008be	75 13		 jne	 SHORT $_Invalid_parameter$4302

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  008c0	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  008c3	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  008c5	73 0c		 jae	 SHORT $_Invalid_parameter$4302

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  008c7	2b c8		 sub	 ecx, eax
  008c9	83 f9 04	 cmp	 ecx, 4
  008cc	72 05		 jb	 SHORT $_Invalid_parameter$4302

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  008ce	83 f9 23	 cmp	 ecx, 35			; 00000023H
  008d1	76 06		 jbe	 SHORT $LN1102@Sprawd_P
$_Invalid_parameter$4302:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  008d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4279@Sprawd_P:
$LN1102@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  008d9	52		 push	 edx
  008da	50		 push	 eax
  008db	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008e0	83 c4 08	 add	 esp, 8
$LN1099@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 789  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  008e3	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008e7	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR $T110[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  008ed	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T111[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  008f7	c7 85 ac fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T111[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00901	c6 85 98 fe ff
	ff 00		 mov	 BYTE PTR $T111[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00908	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  0090b	72 42		 jb	 SHORT $LN1170@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0090d	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T110[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00913	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00914	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00916	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0091c	72 27		 jb	 SHORT $LN1173@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0091e	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00921	3b f2		 cmp	 esi, edx
  00923	76 1a		 jbe	 SHORT $_Invalid_parameter$4303

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00925	8b d6		 mov	 edx, esi
  00927	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0092a	75 13		 jne	 SHORT $_Invalid_parameter$4303

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0092c	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  0092f	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00931	73 0c		 jae	 SHORT $_Invalid_parameter$4303

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00933	2b c8		 sub	 ecx, eax
  00935	83 f9 04	 cmp	 ecx, 4
  00938	72 05		 jb	 SHORT $_Invalid_parameter$4303

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0093a	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0093d	76 06		 jbe	 SHORT $LN1173@Sprawd_P
$_Invalid_parameter$4303:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0093f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4280@Sprawd_P:
$LN1173@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00945	52		 push	 edx
  00946	50		 push	 eax
  00947	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0094c	83 c4 08	 add	 esp, 8
$LN1170@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 790  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0094f	83 7d ec 00	 cmp	 DWORD PTR _res$1$[ebp], 0
  00953	0f 85 71 0e 00
	00		 jne	 $LN4211@Sprawd_P
$LN50@Sprawd_P:
$_Invalid_parameter$4304:
$_Invalid_parameter$4305:

; 798  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00959	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  0095e	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T158[ebp]
  00964	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00969	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0096c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00970	72 02		 jb	 SHORT $LN1355@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00972	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1355@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 798  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00974	6a 00		 push	 0
  00976	50		 push	 eax
  00977	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0097d	8b b5 dc fe ff
	ff		 mov	 esi, DWORD PTR $T158[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 798  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00983	83 c4 08	 add	 esp, 8
  00986	89 45 ec	 mov	 DWORD PTR $T521[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00989	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  0098c	72 45		 jb	 SHORT $LN1399@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0098e	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T158[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00994	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00995	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00997	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  0099d	72 27		 jb	 SHORT $LN1402@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0099f	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  009a2	3b c6		 cmp	 eax, esi
  009a4	76 1a		 jbe	 SHORT $_Invalid_parameter$4306

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  009a6	8b f0		 mov	 esi, eax
  009a8	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  009ab	75 13		 jne	 SHORT $_Invalid_parameter$4306

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  009ad	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  009b0	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  009b2	73 0c		 jae	 SHORT $_Invalid_parameter$4306

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  009b4	2b ca		 sub	 ecx, edx
  009b6	83 f9 04	 cmp	 ecx, 4
  009b9	72 05		 jb	 SHORT $_Invalid_parameter$4306

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  009bb	83 f9 23	 cmp	 ecx, 35			; 00000023H
  009be	76 06		 jbe	 SHORT $LN1402@Sprawd_P
$_Invalid_parameter$4306:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  009c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4281@Sprawd_P:
$LN1402@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  009c6	56		 push	 esi
  009c7	52		 push	 edx
  009c8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009cd	8b 45 ec	 mov	 eax, DWORD PTR $T521[ebp]
  009d0	83 c4 08	 add	 esp, 8
$LN1399@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 798  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  009d3	85 c0		 test	 eax, eax
  009d5	0f 84 3f 02 00
	00		 je	 $LN53@Sprawd_P

; 799  : 		{
; 800  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  009db	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  009e2	75 24		 jne	 SHORT $LN52@Sprawd_P

; 801  : 			{
; 802  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  009e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  009ea	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  009ef	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  009f4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  009f9	8b c8		 mov	 ecx, eax
  009fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 803  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00a01	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN52@Sprawd_P:

; 805  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00a08	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  00a0b	50		 push	 eax
  00a0c	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T170[ebp]
  00a12	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00a17	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  00a1c	8b d0		 mov	 edx, eax
  00a1e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00a22	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T171[ebp]
  00a28	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00a2d	8b f0		 mov	 esi, eax
  00a2f	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  00a32	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00a36	50		 push	 eax
  00a37	8d 55 b0	 lea	 edx, DWORD PTR _link$516[ebp]
  00a3a	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T173[ebp]
  00a40	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00a45	68 00 00 00 00	 push	 OFFSET ??_C@_05MEKKEGFB@n?4wav?$AA@
  00a4a	8b d0		 mov	 edx, eax
  00a4c	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00a50	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T174[ebp]
  00a56	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00a5b	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a5e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00a62	72 02		 jb	 SHORT $LN1442@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a64	8b 36		 mov	 esi, DWORD PTR [esi]
$LN1442@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a66	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00a6a	72 02		 jb	 SHORT $LN1458@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a6c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1458@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 805  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00a6e	6a 00		 push	 0
  00a70	6a 00		 push	 0
  00a72	56		 push	 esi
  00a73	50		 push	 eax
  00a74	6a 00		 push	 0
  00a76	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a7c	8b b5 ac fe ff
	ff		 mov	 esi, DWORD PTR $T174[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 805  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00a82	89 45 ec	 mov	 DWORD PTR _res$1$[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a85	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00a88	72 42		 jb	 SHORT $LN1502@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00a8a	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR $T174[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00a90	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00a91	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00a93	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00a99	72 27		 jb	 SHORT $LN1505@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00a9b	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  00a9e	3b c6		 cmp	 eax, esi
  00aa0	76 1a		 jbe	 SHORT $_Invalid_parameter$4307

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00aa2	8b f0		 mov	 esi, eax
  00aa4	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00aa7	75 13		 jne	 SHORT $_Invalid_parameter$4307

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00aa9	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00aac	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00aae	73 0c		 jae	 SHORT $_Invalid_parameter$4307

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00ab0	2b ca		 sub	 ecx, edx
  00ab2	83 f9 04	 cmp	 ecx, 4
  00ab5	72 05		 jb	 SHORT $_Invalid_parameter$4307

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00ab7	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00aba	76 06		 jbe	 SHORT $LN1505@Sprawd_P
$_Invalid_parameter$4307:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00abc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4282@Sprawd_P:
$LN1505@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00ac2	56		 push	 esi
  00ac3	52		 push	 edx
  00ac4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00ac9	83 c4 08	 add	 esp, 8
$LN1502@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 805  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00acc	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ad0	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR $T173[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00ad6	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T174[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00ae0	c7 85 ac fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T174[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00aea	c6 85 98 fe ff
	ff 00		 mov	 BYTE PTR $T174[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00af1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00af4	72 42		 jb	 SHORT $LN1573@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00af6	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T173[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00afc	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00afd	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00aff	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00b05	72 27		 jb	 SHORT $LN1576@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00b07	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00b0a	3b f2		 cmp	 esi, edx
  00b0c	76 1a		 jbe	 SHORT $_Invalid_parameter$4308

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00b0e	8b d6		 mov	 edx, esi
  00b10	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00b13	75 13		 jne	 SHORT $_Invalid_parameter$4308

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00b15	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00b18	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00b1a	73 0c		 jae	 SHORT $_Invalid_parameter$4308

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00b1c	2b c8		 sub	 ecx, eax
  00b1e	83 f9 04	 cmp	 ecx, 4
  00b21	72 05		 jb	 SHORT $_Invalid_parameter$4308

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00b23	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00b26	76 06		 jbe	 SHORT $LN1576@Sprawd_P
$_Invalid_parameter$4308:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00b28	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4283@Sprawd_P:
$LN1576@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00b2e	52		 push	 edx
  00b2f	50		 push	 eax
  00b30	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b35	83 c4 08	 add	 esp, 8
$LN1573@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 805  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00b38	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b3c	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR $T171[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00b42	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T173[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00b4c	c7 85 c4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T173[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00b56	c6 85 b0 fe ff
	ff 00		 mov	 BYTE PTR $T173[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b5d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00b60	72 42		 jb	 SHORT $LN1644@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00b62	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR $T171[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00b68	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00b69	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00b6b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00b71	72 27		 jb	 SHORT $LN1647@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00b73	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00b76	3b f2		 cmp	 esi, edx
  00b78	76 1a		 jbe	 SHORT $_Invalid_parameter$4309

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00b7a	8b d6		 mov	 edx, esi
  00b7c	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00b7f	75 13		 jne	 SHORT $_Invalid_parameter$4309

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00b81	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00b84	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00b86	73 0c		 jae	 SHORT $_Invalid_parameter$4309

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00b88	2b c8		 sub	 ecx, eax
  00b8a	83 f9 04	 cmp	 ecx, 4
  00b8d	72 05		 jb	 SHORT $_Invalid_parameter$4309

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00b8f	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00b92	76 06		 jbe	 SHORT $LN1647@Sprawd_P
$_Invalid_parameter$4309:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00b94	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4284@Sprawd_P:
$LN1647@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00b9a	52		 push	 edx
  00b9b	50		 push	 eax
  00b9c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00ba1	83 c4 08	 add	 esp, 8
$LN1644@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 805  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00ba4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ba8	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR $T170[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00bae	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T171[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00bb8	c7 85 f4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T171[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00bc2	c6 85 e0 fe ff
	ff 00		 mov	 BYTE PTR $T171[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00bc9	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00bcc	72 42		 jb	 SHORT $LN1715@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00bce	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T170[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00bd4	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00bd5	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00bd7	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00bdd	72 27		 jb	 SHORT $LN1718@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00bdf	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00be2	3b f2		 cmp	 esi, edx
  00be4	76 1a		 jbe	 SHORT $_Invalid_parameter$4310

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00be6	8b d6		 mov	 edx, esi
  00be8	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00beb	75 13		 jne	 SHORT $_Invalid_parameter$4310

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00bed	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00bf0	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00bf2	73 0c		 jae	 SHORT $_Invalid_parameter$4310

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00bf4	2b c8		 sub	 ecx, eax
  00bf6	83 f9 04	 cmp	 ecx, 4
  00bf9	72 05		 jb	 SHORT $_Invalid_parameter$4310

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00bfb	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00bfe	76 06		 jbe	 SHORT $LN1718@Sprawd_P
$_Invalid_parameter$4310:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00c00	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4285@Sprawd_P:
$LN1718@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00c06	52		 push	 edx
  00c07	50		 push	 eax
  00c08	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00c0d	83 c4 08	 add	 esp, 8
$LN1715@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 806  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00c10	83 7d ec 00	 cmp	 DWORD PTR _res$1$[ebp], 0
  00c14	0f 85 b0 0b 00
	00		 jne	 $LN4211@Sprawd_P
$LN53@Sprawd_P:
$_Invalid_parameter$4311:
$_Invalid_parameter$4312:

; 814  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00c1a	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  00c1f	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T218[ebp]
  00c25	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00c2a	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c2d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00c31	72 02		 jb	 SHORT $LN1900@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00c33	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1900@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 814  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00c35	6a 00		 push	 0
  00c37	50		 push	 eax
  00c38	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c3e	8b b5 dc fe ff
	ff		 mov	 esi, DWORD PTR $T218[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 814  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00c44	83 c4 08	 add	 esp, 8
  00c47	89 45 ec	 mov	 DWORD PTR $T520[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c4a	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00c4d	72 45		 jb	 SHORT $LN1944@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00c4f	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T218[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00c55	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00c56	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00c58	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00c5e	72 27		 jb	 SHORT $LN1947@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00c60	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  00c63	3b c6		 cmp	 eax, esi
  00c65	76 1a		 jbe	 SHORT $_Invalid_parameter$4313

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00c67	8b f0		 mov	 esi, eax
  00c69	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00c6c	75 13		 jne	 SHORT $_Invalid_parameter$4313

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00c6e	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00c71	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00c73	73 0c		 jae	 SHORT $_Invalid_parameter$4313

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00c75	2b ca		 sub	 ecx, edx
  00c77	83 f9 04	 cmp	 ecx, 4
  00c7a	72 05		 jb	 SHORT $_Invalid_parameter$4313

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00c7c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00c7f	76 06		 jbe	 SHORT $LN1947@Sprawd_P
$_Invalid_parameter$4313:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00c81	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4286@Sprawd_P:
$LN1947@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00c87	56		 push	 esi
  00c88	52		 push	 edx
  00c89	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00c8e	8b 45 ec	 mov	 eax, DWORD PTR $T520[ebp]
  00c91	83 c4 08	 add	 esp, 8
$LN1944@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 814  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00c94	85 c0		 test	 eax, eax
  00c96	0f 84 3f 02 00
	00		 je	 $LN56@Sprawd_P

; 815  : 		{
; 816  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  00c9c	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00ca3	75 24		 jne	 SHORT $LN55@Sprawd_P

; 817  : 			{
; 818  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00ca5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00cab	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00cb0	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00cb5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00cba	8b c8		 mov	 ecx, eax
  00cbc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 819  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00cc2	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN55@Sprawd_P:

; 821  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00cc9	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  00ccc	50		 push	 eax
  00ccd	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T230[ebp]
  00cd3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00cd8	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  00cdd	8b d0		 mov	 edx, eax
  00cdf	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00ce3	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T231[ebp]
  00ce9	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00cee	8b f0		 mov	 esi, eax
  00cf0	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  00cf3	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00cf7	50		 push	 eax
  00cf8	8d 55 b0	 lea	 edx, DWORD PTR _link$516[ebp]
  00cfb	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T233[ebp]
  00d01	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00d06	68 00 00 00 00	 push	 OFFSET ??_C@_05LALOIELB@r?4wav?$AA@
  00d0b	8b d0		 mov	 edx, eax
  00d0d	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00d11	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T234[ebp]
  00d17	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00d1c	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d1f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00d23	72 02		 jb	 SHORT $LN1987@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00d25	8b 36		 mov	 esi, DWORD PTR [esi]
$LN1987@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d27	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00d2b	72 02		 jb	 SHORT $LN2003@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00d2d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2003@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 821  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00d2f	6a 00		 push	 0
  00d31	6a 00		 push	 0
  00d33	56		 push	 esi
  00d34	50		 push	 eax
  00d35	6a 00		 push	 0
  00d37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d3d	8b b5 ac fe ff
	ff		 mov	 esi, DWORD PTR $T234[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 821  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00d43	89 45 ec	 mov	 DWORD PTR _res$1$[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d46	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00d49	72 42		 jb	 SHORT $LN2047@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00d4b	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR $T234[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00d51	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00d52	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00d54	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00d5a	72 27		 jb	 SHORT $LN2050@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00d5c	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  00d5f	3b c6		 cmp	 eax, esi
  00d61	76 1a		 jbe	 SHORT $_Invalid_parameter$4314

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00d63	8b f0		 mov	 esi, eax
  00d65	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00d68	75 13		 jne	 SHORT $_Invalid_parameter$4314

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00d6a	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00d6d	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00d6f	73 0c		 jae	 SHORT $_Invalid_parameter$4314

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00d71	2b ca		 sub	 ecx, edx
  00d73	83 f9 04	 cmp	 ecx, 4
  00d76	72 05		 jb	 SHORT $_Invalid_parameter$4314

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00d78	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00d7b	76 06		 jbe	 SHORT $LN2050@Sprawd_P
$_Invalid_parameter$4314:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00d7d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4287@Sprawd_P:
$LN2050@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00d83	56		 push	 esi
  00d84	52		 push	 edx
  00d85	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00d8a	83 c4 08	 add	 esp, 8
$LN2047@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 821  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00d8d	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d91	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR $T233[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00d97	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T234[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00da1	c7 85 ac fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T234[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00dab	c6 85 98 fe ff
	ff 00		 mov	 BYTE PTR $T234[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00db2	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00db5	72 42		 jb	 SHORT $LN2118@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00db7	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T233[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00dbd	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00dbe	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00dc0	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00dc6	72 27		 jb	 SHORT $LN2121@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00dc8	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00dcb	3b f2		 cmp	 esi, edx
  00dcd	76 1a		 jbe	 SHORT $_Invalid_parameter$4315

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00dcf	8b d6		 mov	 edx, esi
  00dd1	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00dd4	75 13		 jne	 SHORT $_Invalid_parameter$4315

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00dd6	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00dd9	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00ddb	73 0c		 jae	 SHORT $_Invalid_parameter$4315

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00ddd	2b c8		 sub	 ecx, eax
  00ddf	83 f9 04	 cmp	 ecx, 4
  00de2	72 05		 jb	 SHORT $_Invalid_parameter$4315

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00de4	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00de7	76 06		 jbe	 SHORT $LN2121@Sprawd_P
$_Invalid_parameter$4315:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00de9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4288@Sprawd_P:
$LN2121@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00def	52		 push	 edx
  00df0	50		 push	 eax
  00df1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00df6	83 c4 08	 add	 esp, 8
$LN2118@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 821  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00df9	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00dfd	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR $T231[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00e03	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T233[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00e0d	c7 85 c4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T233[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00e17	c6 85 b0 fe ff
	ff 00		 mov	 BYTE PTR $T233[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00e1e	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00e21	72 42		 jb	 SHORT $LN2189@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00e23	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR $T231[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00e29	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00e2a	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00e2c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00e32	72 27		 jb	 SHORT $LN2192@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00e34	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00e37	3b f2		 cmp	 esi, edx
  00e39	76 1a		 jbe	 SHORT $_Invalid_parameter$4316

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00e3b	8b d6		 mov	 edx, esi
  00e3d	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00e40	75 13		 jne	 SHORT $_Invalid_parameter$4316

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00e42	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00e45	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00e47	73 0c		 jae	 SHORT $_Invalid_parameter$4316

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00e49	2b c8		 sub	 ecx, eax
  00e4b	83 f9 04	 cmp	 ecx, 4
  00e4e	72 05		 jb	 SHORT $_Invalid_parameter$4316

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00e50	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00e53	76 06		 jbe	 SHORT $LN2192@Sprawd_P
$_Invalid_parameter$4316:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00e55	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4289@Sprawd_P:
$LN2192@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00e5b	52		 push	 edx
  00e5c	50		 push	 eax
  00e5d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00e62	83 c4 08	 add	 esp, 8
$LN2189@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 821  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00e65	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00e69	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR $T230[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  00e6f	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T231[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00e79	c7 85 f4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T231[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00e83	c6 85 e0 fe ff
	ff 00		 mov	 BYTE PTR $T231[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00e8a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00e8d	72 42		 jb	 SHORT $LN2260@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00e8f	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T230[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00e95	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00e96	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00e98	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00e9e	72 27		 jb	 SHORT $LN2263@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00ea0	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00ea3	3b f2		 cmp	 esi, edx
  00ea5	76 1a		 jbe	 SHORT $_Invalid_parameter$4317

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00ea7	8b d6		 mov	 edx, esi
  00ea9	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00eac	75 13		 jne	 SHORT $_Invalid_parameter$4317

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00eae	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00eb1	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00eb3	73 0c		 jae	 SHORT $_Invalid_parameter$4317

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00eb5	2b c8		 sub	 ecx, eax
  00eb7	83 f9 04	 cmp	 ecx, 4
  00eba	72 05		 jb	 SHORT $_Invalid_parameter$4317

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00ebc	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00ebf	76 06		 jbe	 SHORT $LN2263@Sprawd_P
$_Invalid_parameter$4317:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00ec1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4290@Sprawd_P:
$LN2263@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00ec7	52		 push	 edx
  00ec8	50		 push	 eax
  00ec9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00ece	83 c4 08	 add	 esp, 8
$LN2260@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 822  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00ed1	83 7d ec 00	 cmp	 DWORD PTR _res$1$[ebp], 0
  00ed5	0f 85 ef 08 00
	00		 jne	 $LN4211@Sprawd_P
$LN56@Sprawd_P:
$_Invalid_parameter$4318:
$_Invalid_parameter$4319:

; 830  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00edb	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  00ee0	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T278[ebp]
  00ee6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00eeb	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00eee	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00ef2	72 02		 jb	 SHORT $LN2445@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00ef4	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2445@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 830  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00ef6	6a 00		 push	 0
  00ef8	50		 push	 eax
  00ef9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00eff	8b b5 dc fe ff
	ff		 mov	 esi, DWORD PTR $T278[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 830  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00f05	83 c4 08	 add	 esp, 8
  00f08	89 45 ec	 mov	 DWORD PTR $T519[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00f0b	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00f0e	72 45		 jb	 SHORT $LN2489@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00f10	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T278[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00f16	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00f17	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00f19	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00f1f	72 27		 jb	 SHORT $LN2492@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00f21	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  00f24	3b c6		 cmp	 eax, esi
  00f26	76 1a		 jbe	 SHORT $_Invalid_parameter$4320

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00f28	8b f0		 mov	 esi, eax
  00f2a	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00f2d	75 13		 jne	 SHORT $_Invalid_parameter$4320

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00f2f	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00f32	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00f34	73 0c		 jae	 SHORT $_Invalid_parameter$4320

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00f36	2b ca		 sub	 ecx, edx
  00f38	83 f9 04	 cmp	 ecx, 4
  00f3b	72 05		 jb	 SHORT $_Invalid_parameter$4320

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00f3d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00f40	76 06		 jbe	 SHORT $LN2492@Sprawd_P
$_Invalid_parameter$4320:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00f42	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4291@Sprawd_P:
$LN2492@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00f48	56		 push	 esi
  00f49	52		 push	 edx
  00f4a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00f4f	8b 45 ec	 mov	 eax, DWORD PTR $T519[ebp]
  00f52	83 c4 08	 add	 esp, 8
$LN2489@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 830  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00f55	85 c0		 test	 eax, eax
  00f57	0f 84 db 00 00
	00		 je	 $LN59@Sprawd_P

; 831  : 		{
; 832  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  00f5d	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  00f64	75 24		 jne	 SHORT $LN58@Sprawd_P

; 833  : 			{
; 834  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00f66	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00f6c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00f71	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00f76	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00f7b	8b c8		 mov	 ecx, eax
  00f7d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 835  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00f83	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN58@Sprawd_P:

; 837  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "b.wav").c_str(), ("G³os/" + g³os2 + "b.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00f8a	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  00f8d	50		 push	 eax
  00f8e	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T290[ebp]
  00f94	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00f99	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  00f9e	8b d0		 mov	 edx, eax
  00fa0	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00fa4	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T291[ebp]
  00faa	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00faf	8b f0		 mov	 esi, eax
  00fb1	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  00fb4	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00fb8	50		 push	 eax
  00fb9	8d 55 b0	 lea	 edx, DWORD PTR _link$516[ebp]
  00fbc	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T293[ebp]
  00fc2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00fc7	68 00 00 00 00	 push	 OFFSET ??_C@_05LDGIIGCK@b?4wav?$AA@
  00fcc	8b d0		 mov	 edx, eax
  00fce	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00fd2	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T294[ebp]
  00fd8	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00fdd	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00fe0	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00fe4	72 02		 jb	 SHORT $LN2532@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00fe6	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2532@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00fe8	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00fec	72 02		 jb	 SHORT $LN2548@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00fee	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2548@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 837  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "b.wav").c_str(), ("G³os/" + g³os2 + "b.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00ff0	6a 00		 push	 0
  00ff2	6a 00		 push	 0
  00ff4	56		 push	 esi
  00ff5	50		 push	 eax
  00ff6	6a 00		 push	 0
  00ff8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  00ffe	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T294[ebp]
  01004	8b f0		 mov	 esi, eax
  01006	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0100b	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T293[ebp]
  01011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01016	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T291[ebp]
  0101c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01021	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T290[ebp]
  01027	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0102b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 838  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01030	85 f6		 test	 esi, esi
  01032	0f 85 92 07 00
	00		 jne	 $LN4211@Sprawd_P
$LN59@Sprawd_P:

; 846  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01038	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  0103d	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T302[ebp]
  01043	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01048	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0104b	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0104f	72 02		 jb	 SHORT $LN2564@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01051	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2564@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 846  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01053	6a 00		 push	 0
  01055	50		 push	 eax
  01056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  0105c	83 c4 08	 add	 esp, 8
  0105f	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T302[ebp]
  01065	8b f0		 mov	 esi, eax
  01067	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0106c	85 f6		 test	 esi, esi
  0106e	0f 84 db 00 00
	00		 je	 $LN62@Sprawd_P

; 847  : 		{
; 848  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  01074	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  0107b	75 24		 jne	 SHORT $LN61@Sprawd_P

; 849  : 			{
; 850  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0107d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01083	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01088	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0108d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01092	8b c8		 mov	 ecx, eax
  01094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 851  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  0109a	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN61@Sprawd_P:

; 853  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "g.wav").c_str(), ("G³os/" + g³os2 + "g.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  010a1	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  010a4	50		 push	 eax
  010a5	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T308[ebp]
  010ab	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  010b0	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  010b5	8b d0		 mov	 edx, eax
  010b7	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  010bb	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T309[ebp]
  010c1	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  010c6	8b f0		 mov	 esi, eax
  010c8	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  010cb	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  010cf	50		 push	 eax
  010d0	8d 55 b0	 lea	 edx, DWORD PTR _link$516[ebp]
  010d3	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T311[ebp]
  010d9	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  010de	68 00 00 00 00	 push	 OFFSET ??_C@_05ODKFBHJJ@g?4wav?$AA@
  010e3	8b d0		 mov	 edx, eax
  010e5	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  010e9	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T312[ebp]
  010ef	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  010f4	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  010f7	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  010fb	72 02		 jb	 SHORT $LN2580@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  010fd	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2580@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  010ff	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01103	72 02		 jb	 SHORT $LN2596@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01105	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2596@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 853  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "g.wav").c_str(), ("G³os/" + g³os2 + "g.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01107	6a 00		 push	 0
  01109	6a 00		 push	 0
  0110b	56		 push	 esi
  0110c	50		 push	 eax
  0110d	6a 00		 push	 0
  0110f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  01115	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T312[ebp]
  0111b	8b f0		 mov	 esi, eax
  0111d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01122	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T311[ebp]
  01128	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0112d	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T309[ebp]
  01133	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01138	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T308[ebp]
  0113e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01142	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 854  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01147	85 f6		 test	 esi, esi
  01149	0f 85 7b 06 00
	00		 jne	 $LN4211@Sprawd_P
$LN62@Sprawd_P:

; 862  : 		if ((_access((G³os + "d.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0114f	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  01154	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T320[ebp]
  0115a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0115f	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01162	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01166	72 02		 jb	 SHORT $LN2612@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01168	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2612@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 862  : 		if ((_access((G³os + "d.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0116a	6a 00		 push	 0
  0116c	50		 push	 eax
  0116d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  01173	83 c4 08	 add	 esp, 8
  01176	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T320[ebp]
  0117c	8b f0		 mov	 esi, eax
  0117e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01183	85 f6		 test	 esi, esi
  01185	0f 84 db 00 00
	00		 je	 $LN65@Sprawd_P

; 863  : 		{
; 864  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  0118b	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  01192	75 24		 jne	 SHORT $LN64@Sprawd_P

; 865  : 			{
; 866  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01194	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0119a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0119f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  011a4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  011a9	8b c8		 mov	 ecx, eax
  011ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 867  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  011b1	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN64@Sprawd_P:

; 869  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "d.wav").c_str(), ("G³os/" + g³os2 + "d.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  011b8	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  011bb	50		 push	 eax
  011bc	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T326[ebp]
  011c2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  011c7	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  011cc	8b d0		 mov	 edx, eax
  011ce	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  011d2	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T327[ebp]
  011d8	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  011dd	8b f0		 mov	 esi, eax
  011df	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  011e2	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  011e6	50		 push	 eax
  011e7	8d 55 b0	 lea	 edx, DWORD PTR _link$516[ebp]
  011ea	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T329[ebp]
  011f0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  011f5	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDBGFDH@d?4wav?$AA@
  011fa	8b d0		 mov	 edx, eax
  011fc	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  01200	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T330[ebp]
  01206	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0120b	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0120e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01212	72 02		 jb	 SHORT $LN2628@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01214	8b 36		 mov	 esi, DWORD PTR [esi]
$LN2628@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01216	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0121a	72 02		 jb	 SHORT $LN2644@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0121c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2644@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 869  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "d.wav").c_str(), ("G³os/" + g³os2 + "d.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0121e	6a 00		 push	 0
  01220	6a 00		 push	 0
  01222	56		 push	 esi
  01223	50		 push	 eax
  01224	6a 00		 push	 0
  01226	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  0122c	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T330[ebp]
  01232	8b f0		 mov	 esi, eax
  01234	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01239	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T329[ebp]
  0123f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01244	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T327[ebp]
  0124a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0124f	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T326[ebp]
  01255	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01259	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 870  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0125e	85 f6		 test	 esi, esi
  01260	0f 85 64 05 00
	00		 jne	 $LN4211@Sprawd_P
$LN65@Sprawd_P:

; 871  : 			{
; 872  : 				cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 873  : 				G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 874  : 				return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 875  : 			}
; 876  : 		}
; 877  : 
; 878  : 		for (unsigned short i = 1; i <= 3; ++i) //Pêtla licz¹ca od 1 do 3

  01266	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _i$1$[ebp], 1
$LL6@Sprawd_P:

; 880  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01270	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  01275	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T338[ebp]
  0127b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01280	83 c4 04	 add	 esp, 4
  01283	8b f0		 mov	 esi, eax
  01285	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  01289	8a 8d f8 fe ff
	ff		 mov	 cl, BYTE PTR _i$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  0128f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 880  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01292	80 c1 30	 add	 cl, 48			; 00000030H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3870 : 	_Left.push_back(_Right);

  01295	88 4d e8	 mov	 BYTE PTR __Ch$[ebp], cl

; 2977 : 		if (_Old_size < _My_data._Myres)

  01298	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  0129b	73 1a		 jae	 SHORT $LN2655@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0129d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2979 : 			_My_data._Mysize = _Old_size + 1;

  012a1	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  012a4	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  012a7	8b c6		 mov	 eax, esi

; 1583 : 		if (_Large_string_engaged())

  012a9	72 02		 jb	 SHORT $LN2664@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  012ab	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2664@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  012ad	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  012b0	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  012b5	eb 12		 jmp	 SHORT $LN2654@Sprawd_P
$LN2655@Sprawd_P:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  012b7	ff 75 e8	 push	 DWORD PTR __Ch$[ebp]
  012ba	c6 45 ec 00	 mov	 BYTE PTR $T342[ebp], 0
  012be	ff 75 ec	 push	 DWORD PTR $T342[ebp]
  012c1	51		 push	 ecx
  012c2	8b ce		 mov	 ecx, esi
  012c4	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN2654@Sprawd_P:

; 1563 : 		_Mysize(0),

  012c9	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T348[ebp+16], 0

; 1564 : 		_Myres(0)

  012d3	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T348[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  012dd	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  012e0	0f 11 85 e0 fe
	ff ff		 movups	 XMMWORD PTR $T348[ebp], xmm0
  012e7	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  012ec	66 0f d6 85 f0
	fe ff ff	 movq	 QWORD PTR $T348[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  012f4	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  012fb	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01302	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 880  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01305	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2335 : 		const size_type _Old_size = _My_data._Mysize;

  01309	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR $T348[ebp+20]
  0130f	8b c2		 mov	 eax, edx
  01311	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T348[ebp+16]
  01317	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01319	6a 04		 push	 4
  0131b	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  01320	83 f8 04	 cmp	 eax, 4
  01323	72 31		 jb	 SHORT $LN2749@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01325	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  01328	8d b5 e0 fe ff
	ff		 lea	 esi, DWORD PTR $T348[ebp]

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  0132e	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1583 : 		if (_Large_string_engaged())

  01331	0f 43 b5 e0 fe
	ff ff		 cmovae	 esi, DWORD PTR $T348[ebp]

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  01338	03 f1		 add	 esi, ecx
  0133a	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T348[ebp+16], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01340	56		 push	 esi
  01341	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  01347	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  0134a	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0134e	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T348[ebp]
  01354	eb 1a		 jmp	 SHORT $LN2748@Sprawd_P
$LN2749@Sprawd_P:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  01356	c6 85 88 fe ff
	ff 00		 mov	 BYTE PTR $T361[ebp], 0
  0135d	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T348[ebp]
  01363	ff b5 88 fe ff
	ff		 push	 DWORD PTR $T361[ebp]
  01369	6a 04		 push	 4
  0136b	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN2748@Sprawd_P:

; 1563 : 		_Mysize(0),

  01370	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T367[ebp+16], 0

; 3860 : 	return (_STD move(_Left.append(_Right)));

  0137a	83 cf 06	 or	 edi, 6

; 1564 : 		_Myres(0)

  0137d	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T367[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01387	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 880  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0138a	6a 00		 push	 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0138c	0f 11 85 b0 fe
	ff ff		 movups	 XMMWORD PTR $T367[ebp], xmm0
  01393	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  01398	66 0f d6 85 c0
	fe ff ff	 movq	 QWORD PTR $T367[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  013a0	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  013a7	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  013ae	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  013b1	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR $T367[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  013b7	83 bd c4 fe ff
	ff 10		 cmp	 DWORD PTR $T367[ebp+20], 16 ; 00000010H

; 1594 : 		if (_Large_string_engaged())

  013be	0f 43 85 b0 fe
	ff ff		 cmovae	 eax, DWORD PTR $T367[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 880  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  013c5	50		 push	 eax
  013c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  013cc	83 c4 08	 add	 esp, 8
  013cf	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T367[ebp]
  013d5	8b f0		 mov	 esi, eax
  013d7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  013dc	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T348[ebp]
  013e2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  013e7	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T338[ebp]
  013ed	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  013f1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  013f6	85 f6		 test	 esi, esi
  013f8	0f 84 52 02 00
	00		 je	 $LN4@Sprawd_P

; 881  : 			{
; 882  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  013fe	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  01405	75 24		 jne	 SHORT $LN67@Sprawd_P

; 883  : 				{
; 884  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01407	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0140d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01412	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  01417	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0141c	8b c8		 mov	 ecx, eax
  0141e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 885  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01424	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN67@Sprawd_P:

; 887  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0142b	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  0142e	50		 push	 eax
  0142f	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T380[ebp]
  01435	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0143a	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  0143f	8b d0		 mov	 edx, eax
  01441	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  01445	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T381[ebp]
  0144b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01450	83 c4 08	 add	 esp, 8
  01453	8b f0		 mov	 esi, eax
  01455	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3870 : 	_Left.push_back(_Right);

  01459	8a 4d e8	 mov	 cl, BYTE PTR __Ch$[ebp]

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  0145c	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 3870 : 	_Left.push_back(_Right);

  0145f	88 4d c8	 mov	 BYTE PTR __Ch$[ebp], cl

; 2977 : 		if (_Old_size < _My_data._Myres)

  01462	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  01465	73 1a		 jae	 SHORT $LN2852@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01467	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2979 : 			_My_data._Mysize = _Old_size + 1;

  0146b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0146e	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  01471	8b c6		 mov	 eax, esi

; 1583 : 		if (_Large_string_engaged())

  01473	72 02		 jb	 SHORT $LN2861@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01475	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2861@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01477	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  0147a	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  0147f	eb 18		 jmp	 SHORT $LN2851@Sprawd_P
$LN2852@Sprawd_P:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  01481	ff 75 c8	 push	 DWORD PTR __Ch$[ebp]
  01484	c6 85 90 fe ff
	ff 00		 mov	 BYTE PTR $T385[ebp], 0
  0148b	ff b5 90 fe ff
	ff		 push	 DWORD PTR $T385[ebp]
  01491	51		 push	 ecx
  01492	8b ce		 mov	 ecx, esi
  01494	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN2851@Sprawd_P:

; 1563 : 		_Mysize(0),

  01499	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T391[ebp+16], 0

; 1564 : 		_Myres(0)

  014a3	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T391[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  014ad	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  014b0	0f 11 85 b0 fe
	ff ff		 movups	 XMMWORD PTR $T391[ebp], xmm0
  014b7	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  014bc	66 0f d6 85 c0
	fe ff ff	 movq	 QWORD PTR $T391[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  014c4	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  014cb	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  014d2	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 887  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  014d5	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  014da	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR $T391[ebp]
  014e0	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  014e4	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T399[ebp]
  014ea	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  014ef	89 85 94 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
  014f5	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  014f8	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H
  014fc	50		 push	 eax
  014fd	8d 55 b0	 lea	 edx, DWORD PTR _link$516[ebp]
  01500	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T401[ebp]
  01506	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0150b	68 00 00 00 00	 push	 OFFSET ??_C@_01DICPFPGM@k?$AA@
  01510	8b d0		 mov	 edx, eax
  01512	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  01516	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T402[ebp]
  0151c	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01521	83 c4 0c	 add	 esp, 12			; 0000000cH
  01524	8b f0		 mov	 esi, eax
  01526	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3870 : 	_Left.push_back(_Right);

  0152a	8a 4d e8	 mov	 cl, BYTE PTR __Ch$[ebp]

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  0152d	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 3870 : 	_Left.push_back(_Right);

  01530	88 4d cc	 mov	 BYTE PTR __Ch$[ebp], cl

; 2977 : 		if (_Old_size < _My_data._Myres)

  01533	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  01536	73 1a		 jae	 SHORT $LN2955@Sprawd_P

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01538	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2979 : 			_My_data._Mysize = _Old_size + 1;

  0153c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0153f	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  01542	8b c6		 mov	 eax, esi

; 1583 : 		if (_Large_string_engaged())

  01544	72 02		 jb	 SHORT $LN2964@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01546	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2964@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01548	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  0154b	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  01550	eb 18		 jmp	 SHORT $LN2954@Sprawd_P
$LN2955@Sprawd_P:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  01552	ff 75 cc	 push	 DWORD PTR __Ch$[ebp]
  01555	c6 85 8c fe ff
	ff 00		 mov	 BYTE PTR $T406[ebp], 0
  0155c	ff b5 8c fe ff
	ff		 push	 DWORD PTR $T406[ebp]
  01562	51		 push	 ecx
  01563	8b ce		 mov	 ecx, esi
  01565	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN2954@Sprawd_P:

; 1563 : 		_Mysize(0),

  0156a	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T412[ebp+16], 0

; 3871 : 	return (_STD move(_Left));

  01574	83 cf 18	 or	 edi, 24			; 00000018H

; 1564 : 		_Myres(0)

  01577	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T412[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01581	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  01584	0f 11 85 98 fe
	ff ff		 movups	 XMMWORD PTR $T412[ebp], xmm0
  0158b	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  01590	66 0f d6 85 a8
	fe ff ff	 movq	 QWORD PTR $T412[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  01598	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0159f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  015a6	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 887  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  015a9	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  015ae	8d 95 98 fe ff
	ff		 lea	 edx, DWORD PTR $T412[ebp]
  015b4	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  015b8	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T420[ebp]
  015be	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  015c3	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR __Result$1$[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 887  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  015c9	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  015cc	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  015d0	72 02		 jb	 SHORT $LN2944@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  015d2	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN2944@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  015d4	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  015d8	72 02		 jb	 SHORT $LN3047@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  015da	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3047@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 887  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  015dc	6a 00		 push	 0
  015de	6a 00		 push	 0
  015e0	51		 push	 ecx
  015e1	50		 push	 eax
  015e2	6a 00		 push	 0
  015e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  015ea	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T420[ebp]
  015f0	8b f0		 mov	 esi, eax
  015f2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  015f7	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T412[ebp]
  015fd	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01602	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T402[ebp]
  01608	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0160d	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T401[ebp]
  01613	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01618	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T399[ebp]
  0161e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01623	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T391[ebp]
  01629	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0162e	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T381[ebp]
  01634	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01639	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T380[ebp]
  0163f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01643	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 888  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01648	85 f6		 test	 esi, esi
  0164a	0f 85 7a 01 00
	00		 jne	 $LN4211@Sprawd_P
$LN4@Sprawd_P:

; 871  : 			{
; 872  : 				cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 873  : 				G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 874  : 				return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 875  : 			}
; 876  : 		}
; 877  : 
; 878  : 		for (unsigned short i = 1; i <= 3; ++i) //Pêtla licz¹ca od 1 do 3

  01650	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  01656	40		 inc	 eax
  01657	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  0165d	66 83 f8 03	 cmp	 ax, 3
  01661	0f 86 09 fc ff
	ff		 jbe	 $LL6@Sprawd_P

; 892  : 					return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 893  : 				}
; 894  : 			}
; 895  : 		}
; 896  : 
; 897  : 		for (unsigned short i = 1; i <= 12; ++i) //Pêtla licz¹ca od 1 do 12

  01667	be 01 00 00 00	 mov	 esi, 1
  0166c	89 75 ec	 mov	 DWORD PTR _i$1$[ebp], esi
  0166f	90		 npad	 1
$LL9@Sprawd_P:
  01670	68 b0 00 00 00	 push	 176			; 000000b0H
  01675	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _numers$515[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 590  : 		{	// construct empty character buffer

  0167b	89 7d cc	 mov	 DWORD PTR tv10521[ebp], edi
  0167e	6a 00		 push	 0
  01680	50		 push	 eax
  01681	e8 00 00 00 00	 call	 _memset
  01686	83 c4 0c	 add	 esp, 12			; 0000000cH
  01689	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$515[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  01693	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$515[ebp+104]
  01699	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$515[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  016a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  016a9	6a 00		 push	 0
  016ab	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _numers$515[ebp+24]
  016b1	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+8], 29 ; 0000001dH
  016b5	83 cf 20	 or	 edi, 32			; 00000020H
  016b8	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$515[ebp]
  016be	50		 push	 eax
  016bf	89 bd 94 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], edi
  016c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  016cb	c7 45 fc 1e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 30 ; 0000001eH
  016d2	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _numers$515[ebp]
  016d8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  016db	c7 84 05 00 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _numers$515[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  016e6	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _numers$515[ebp]
  016ec	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  016ef	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  016f2	89 84 0d fc fe
	ff ff		 mov	 DWORD PTR _numers$515[ebp+ecx-4], eax
  016f9	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _numers$515[ebp+24]

; 30   : 		{	// construct empty character buffer from mode

  016ff	8b c8		 mov	 ecx, eax

; 589  : 			_Stringbuffer(_Mode)

  01701	89 45 c8	 mov	 DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

  01704	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0170a	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$515[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

  01714	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$515[ebp+80], 0

; 312  : 		_Mystate = _State;

  0171e	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numers$515[ebp+84], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 900  : 			numers << i; //Wpisanie do typu wartoci z obrotu pêtli

  01728	56		 push	 esi
  01729	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$515[ebp+16]
  0172f	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
  01733	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 644  : 		return (_Stringbuffer.str());

  01739	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T429[ebp]
  0173f	50		 push	 eax
  01740	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$515[ebp+24]
  01746	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 901  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0174b	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  01750	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T430[ebp]
  01756	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
  0175a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0175f	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T429[ebp]
  01765	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
  01769	51		 push	 ecx
  0176a	8b d0		 mov	 edx, eax
  0176c	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T431[ebp]
  01772	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01777	83 c4 08	 add	 esp, 8
  0177a	8b f0		 mov	 esi, eax
  0177c	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+8], 35 ; 00000023H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  01780	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  01783	8b c1		 mov	 eax, ecx
  01785	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  01788	2b c7		 sub	 eax, edi
  0178a	83 f8 04	 cmp	 eax, 4
  0178d	72 64		 jb	 SHORT $LN3439@Sprawd_P

; 1582 : 		value_type * _Result = _Bx._Buf;

  0178f	89 b5 f8 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], esi

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  01795	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  01798	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0179b	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0179d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  017a0	72 08		 jb	 SHORT $LN3448@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  017a2	8b 06		 mov	 eax, DWORD PTR [esi]
  017a4	89 85 f8 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN3448@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  017aa	6a 04		 push	 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  017ac	03 c7		 add	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  017ae	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  017b3	50		 push	 eax
  017b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 442  : 		_Left = _Right;

  017ba	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  017c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  017c3	c6 44 38 04 00	 mov	 BYTE PTR [eax+edi+4], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  017c8	eb 48		 jmp	 SHORT $LN3438@Sprawd_P
$LN4211@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 890  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  017ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  017d0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  017d5	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  017da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  017df	8b c8		 mov	 ecx, eax
  017e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 891  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio

  017e7	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  017ee	e9 05 07 00 00	 jmp	 $LN75@Sprawd_P
$LN3439@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2345 : 		return (_Reallocate_grow_by(_Count,

  017f3	6a 04		 push	 4
  017f5	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  017fa	c6 85 8c fe ff
	ff 00		 mov	 BYTE PTR $T437[ebp], 0
  01801	8b ce		 mov	 ecx, esi
  01803	ff b5 8c fe ff
	ff		 push	 DWORD PTR $T437[ebp]
  01809	6a 04		 push	 4
  0180b	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  01810	8b f0		 mov	 esi, eax
$LN3438@Sprawd_P:

; 3860 : 	return (_STD move(_Left.append(_Right)));

  01812	8b 7d cc	 mov	 edi, DWORD PTR tv10521[ebp]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01815	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T443[ebp]

; 1563 : 		_Mysize(0),

  0181b	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T443[ebp+16], 0

; 3860 : 	return (_STD move(_Left.append(_Right)));

  01825	81 cf 60 01 00
	00		 or	 edi, 352		; 00000160H

; 1564 : 		_Myres(0)

  0182b	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T443[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01835	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 901  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01838	6a 00		 push	 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3860 : 	return (_STD move(_Left.append(_Right)));

  0183a	89 7d e8	 mov	 DWORD PTR $T518[ebp], edi

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0183d	0f 11 85 e0 fe
	ff ff		 movups	 XMMWORD PTR $T443[ebp], xmm0
  01844	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  01849	66 0f d6 85 f0
	fe ff ff	 movq	 QWORD PTR $T443[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  01851	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01858	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0185f	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01862	83 bd f4 fe ff
	ff 10		 cmp	 DWORD PTR $T443[ebp+20], 16 ; 00000010H

; 1594 : 		if (_Large_string_engaged())

  01869	0f 43 85 e0 fe
	ff ff		 cmovae	 eax, DWORD PTR $T443[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 901  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01870	50		 push	 eax
  01871	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01877	8b b5 f4 fe ff
	ff		 mov	 esi, DWORD PTR $T443[ebp+20]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 901  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0187d	83 c4 08	 add	 esp, 8
  01880	89 85 94 fe ff
	ff		 mov	 DWORD PTR $T513[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01886	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  01889	72 4a		 jb	 SHORT $LN3564@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0188b	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T443[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01891	46		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01892	8b ca		 mov	 ecx, edx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01894	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  0189a	72 2f		 jb	 SHORT $LN3567@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0189c	8d 46 23	 lea	 eax, DWORD PTR [esi+35]
  0189f	3b c6		 cmp	 eax, esi
  018a1	0f 86 63 ed ff
	ff		 jbe	 $_Invalid_parameter$4293

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  018a7	8b f0		 mov	 esi, eax
  018a9	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  018ac	0f 85 58 ed ff
	ff		 jne	 $_Invalid_parameter$4293

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  018b2	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  018b5	3b d1		 cmp	 edx, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  018b7	0f 83 4d ed ff
	ff		 jae	 $_Invalid_parameter$4293

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  018bd	2b ca		 sub	 ecx, edx
  018bf	83 e9 04	 sub	 ecx, 4
  018c2	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  018c5	0f 87 3f ed ff
	ff		 ja	 $_Invalid_parameter$4293
$LN3567@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  018cb	56		 push	 esi
  018cc	52		 push	 edx
  018cd	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  018d2	83 c4 08	 add	 esp, 8
$LN3564@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 901  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  018d5	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  018d9	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR $T431[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  018df	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T443[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  018e9	c7 85 f4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T443[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  018f3	c6 85 e0 fe ff
	ff 00		 mov	 BYTE PTR $T443[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  018fa	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  018fd	72 4a		 jb	 SHORT $LN3624@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  018ff	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR $T431[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01905	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01906	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01908	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0190e	72 2f		 jb	 SHORT $LN3627@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01910	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  01913	3b f2		 cmp	 esi, edx
  01915	0f 86 ef ec ff
	ff		 jbe	 $_Invalid_parameter$4293

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0191b	8b d6		 mov	 edx, esi
  0191d	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01920	0f 85 e4 ec ff
	ff		 jne	 $_Invalid_parameter$4293

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01926	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  01929	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0192b	0f 83 d9 ec ff
	ff		 jae	 $_Invalid_parameter$4293

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01931	2b c8		 sub	 ecx, eax
  01933	83 e9 04	 sub	 ecx, 4
  01936	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01939	0f 87 cb ec ff
	ff		 ja	 $_Invalid_parameter$4293
$LN3627@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0193f	52		 push	 edx
  01940	50		 push	 eax
  01941	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01946	83 c4 08	 add	 esp, 8
$LN3624@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 901  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01949	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0194d	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR $T430[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  01953	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T431[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0195d	c7 85 ac fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T431[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01967	c6 85 98 fe ff
	ff 00		 mov	 BYTE PTR $T431[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0196e	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  01971	72 4a		 jb	 SHORT $LN3684@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01973	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T430[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01979	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0197a	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0197c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01982	72 2f		 jb	 SHORT $LN3687@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01984	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  01987	3b f2		 cmp	 esi, edx
  01989	0f 86 7b ec ff
	ff		 jbe	 $_Invalid_parameter$4293

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0198f	8b d6		 mov	 edx, esi
  01991	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01994	0f 85 70 ec ff
	ff		 jne	 $_Invalid_parameter$4293

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0199a	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  0199d	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0199f	0f 83 65 ec ff
	ff		 jae	 $_Invalid_parameter$4293

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  019a5	2b c8		 sub	 ecx, eax
  019a7	83 e9 04	 sub	 ecx, 4
  019aa	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  019ad	0f 87 57 ec ff
	ff		 ja	 $_Invalid_parameter$4293
$LN3687@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  019b3	52		 push	 edx
  019b4	50		 push	 eax
  019b5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  019ba	83 c4 08	 add	 esp, 8
$LN3684@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 901  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  019bd	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  019c1	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR $T429[ebp+20]

; 3702 : 		_My_data._Mysize = 0;

  019c7	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T430[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  019d1	c7 85 c4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T430[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  019db	c6 85 b0 fe ff
	ff 00		 mov	 BYTE PTR $T430[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  019e2	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  019e5	72 4a		 jb	 SHORT $LN3744@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  019e7	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T429[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  019ed	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  019ee	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  019f0	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  019f6	72 2f		 jb	 SHORT $LN3747@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  019f8	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  019fb	3b f2		 cmp	 esi, edx
  019fd	0f 86 07 ec ff
	ff		 jbe	 $_Invalid_parameter$4293

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01a03	8b d6		 mov	 edx, esi
  01a05	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01a08	0f 85 fc eb ff
	ff		 jne	 $_Invalid_parameter$4293

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01a0e	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  01a11	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01a13	0f 83 f1 eb ff
	ff		 jae	 $_Invalid_parameter$4293

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01a19	2b c8		 sub	 ecx, eax
  01a1b	83 e9 04	 sub	 ecx, 4
  01a1e	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01a21	0f 87 e3 eb ff
	ff		 ja	 $_Invalid_parameter$4293
$LN3747@Sprawd_P:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01a27	52		 push	 edx
  01a28	50		 push	 eax
  01a29	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01a2e	83 c4 08	 add	 esp, 8
$LN3744@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 901  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01a31	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR $T513[ebp], 0
  01a38	0f 84 4a 02 00
	00		 je	 $LN71@Sprawd_P

; 902  : 			{
; 903  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  01a3e	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  01a45	75 24		 jne	 SHORT $LN70@Sprawd_P

; 904  : 				{
; 905  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01a47	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01a4d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01a52	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  01a57	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01a5c	8b c8		 mov	 ecx, eax
  01a5e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 906  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01a64	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN70@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 644  : 		return (_Stringbuffer.str());

  01a6b	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T472[ebp]
  01a71	50		 push	 eax
  01a72	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$515[ebp+24]
  01a78	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 908  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01a7d	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  01a80	c6 45 fc 24	 mov	 BYTE PTR __$EHRec$[ebp+8], 36 ; 00000024H
  01a84	50		 push	 eax
  01a85	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T473[ebp]
  01a8b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01a90	83 c4 04	 add	 esp, 4
  01a93	8b f0		 mov	 esi, eax
  01a95	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+8], 37 ; 00000025H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  01a99	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  01a9c	8b c1		 mov	 eax, ecx
  01a9e	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  01aa1	2b c7		 sub	 eax, edi
  01aa3	83 f8 01	 cmp	 eax, 1
  01aa6	72 3b		 jb	 SHORT $LN4126@Sprawd_P

; 1582 : 		value_type * _Result = _Bx._Buf;

  01aa8	89 b5 f8 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], esi

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  01aae	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  01ab1	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  01ab4	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01ab6	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  01ab9	72 08		 jb	 SHORT $LN4135@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  01abb	8b 06		 mov	 eax, DWORD PTR [esi]
  01abd	89 85 f8 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN4135@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01ac3	6a 01		 push	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  01ac5	03 c7		 add	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01ac7	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  01acc	50		 push	 eax
  01acd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 442  : 		_Left = _Right;

  01ad3	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01ad9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  01adc	c6 44 38 01 00	 mov	 BYTE PTR [eax+edi+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  01ae1	eb 1f		 jmp	 SHORT $LN4125@Sprawd_P
$LN4126@Sprawd_P:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  01ae3	6a 01		 push	 1
  01ae5	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  01aea	c6 85 90 fe ff
	ff 00		 mov	 BYTE PTR $T479[ebp], 0
  01af1	8b ce		 mov	 ecx, esi
  01af3	ff b5 90 fe ff
	ff		 push	 DWORD PTR $T479[ebp]
  01af9	6a 01		 push	 1
  01afb	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  01b00	8b f0		 mov	 esi, eax
$LN4125@Sprawd_P:

; 3860 : 	return (_STD move(_Left.append(_Right)));

  01b02	81 4d e8 00 0a
	00 00		 or	 DWORD PTR $T518[ebp], 2560 ; 00000a00H

; 1563 : 		_Mysize(0),

  01b09	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T485[ebp+16], 0

; 1564 : 		_Myres(0)

  01b13	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T485[ebp+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01b1d	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  01b20	0f 11 85 98 fe
	ff ff		 movups	 XMMWORD PTR $T485[ebp], xmm0
  01b27	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  01b2c	66 0f d6 85 a8
	fe ff ff	 movq	 QWORD PTR $T485[ebp+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  01b34	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01b3b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01b42	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 908  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01b45	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T472[ebp]
  01b4b	c6 45 fc 26	 mov	 BYTE PTR __$EHRec$[ebp+8], 38 ; 00000026H
  01b4f	50		 push	 eax
  01b50	8d 95 98 fe ff
	ff		 lea	 edx, DWORD PTR $T485[ebp]
  01b56	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T493[ebp]
  01b5c	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01b61	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01b66	8b d0		 mov	 edx, eax
  01b68	c6 45 fc 27	 mov	 BYTE PTR __$EHRec$[ebp+8], 39 ; 00000027H
  01b6c	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T494[ebp]
  01b72	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01b77	83 c4 08	 add	 esp, 8
  01b7a	8b f8		 mov	 edi, eax
  01b7c	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR $T495[ebp]
  01b82	c6 45 fc 28	 mov	 BYTE PTR __$EHRec$[ebp+8], 40 ; 00000028H
  01b86	50		 push	 eax
  01b87	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$515[ebp]
  01b8d	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01b92	8b f0		 mov	 esi, eax
  01b94	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  01b97	c6 45 fc 29	 mov	 BYTE PTR __$EHRec$[ebp+8], 41 ; 00000029H
  01b9b	50		 push	 eax
  01b9c	8d 55 b0	 lea	 edx, DWORD PTR _link$516[ebp]
  01b9f	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T496[ebp]
  01ba5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01baa	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  01baf	8b d0		 mov	 edx, eax
  01bb1	c6 45 fc 2a	 mov	 BYTE PTR __$EHRec$[ebp+8], 42 ; 0000002aH
  01bb5	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T497[ebp]
  01bbb	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01bc0	56		 push	 esi
  01bc1	8b d0		 mov	 edx, eax
  01bc3	c6 45 fc 2b	 mov	 BYTE PTR __$EHRec$[ebp+8], 43 ; 0000002bH
  01bc7	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T498[ebp]
  01bcd	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01bd2	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01bd7	8b d0		 mov	 edx, eax
  01bd9	c6 45 fc 2c	 mov	 BYTE PTR __$EHRec$[ebp+8], 44 ; 0000002cH
  01bdd	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T499[ebp]
  01be3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01be8	83 c4 10	 add	 esp, 16			; 00000010H
  01beb	8b cf		 mov	 ecx, edi
  01bed	8b d0		 mov	 edx, eax
  01bef	6a 00		 push	 0
  01bf1	6a 00		 push	 0
  01bf3	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01bf8	50		 push	 eax
  01bf9	8b ca		 mov	 ecx, edx
  01bfb	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01c00	50		 push	 eax
  01c01	6a 00		 push	 0
  01c03	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  01c09	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T499[ebp]
  01c0f	8b f0		 mov	 esi, eax
  01c11	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c16	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T498[ebp]
  01c1c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c21	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T497[ebp]
  01c27	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c2c	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T496[ebp]
  01c32	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c37	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T495[ebp]
  01c3d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c42	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T494[ebp]
  01c48	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c4d	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T493[ebp]
  01c53	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c58	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T485[ebp]
  01c5e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c63	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T473[ebp]
  01c69	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c6e	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T472[ebp]
  01c74	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
  01c78	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 909  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01c7d	85 f6		 test	 esi, esi
  01c7f	0f 85 9e 02 00
	00		 jne	 $LN4237@Sprawd_P
  01c85	8b 7d e8	 mov	 edi, DWORD PTR $T518[ebp]
$LN71@Sprawd_P:

; 910  : 				{
; 911  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 912  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 913  : 					return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 914  : 				}
; 915  : 			}
; 916  : 		}

  01c88	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$515[ebp]
  01c8e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01c92	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  01c97	8b 75 ec	 mov	 esi, DWORD PTR _i$1$[ebp]
  01c9a	46		 inc	 esi
  01c9b	89 75 ec	 mov	 DWORD PTR _i$1$[ebp], esi
  01c9e	66 83 fe 0c	 cmp	 si, 12			; 0000000cH
  01ca2	0f 86 c8 f9 ff
	ff		 jbe	 $LL9@Sprawd_P

; 917  : 
; 918  : 		for (unsigned short i = 0; i <= 36; ++i) //Pêtla licz¹ca od 0 do 36

  01ca8	33 f6		 xor	 esi, esi
  01caa	89 75 ec	 mov	 DWORD PTR _i$1$[ebp], esi
  01cad	0f 1f 00	 npad	 3
$LL12@Sprawd_P:

; 919  : 		{
; 920  : 			stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  01cb0	51		 push	 ecx
  01cb1	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$514[ebp]
  01cb7	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
  01cbc	83 ec 08	 sub	 esp, 8
  01cbf	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$514[ebp]
  01cc5	e8 00 00 00 00	 call	 ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >

; 921  : 			numers << i; //Wpisanie do typu wartoci z obrotu pêtli

  01cca	56		 push	 esi
  01ccb	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$514[ebp+16]
  01cd1	c6 45 fc 2d	 mov	 BYTE PTR __$EHRec$[ebp+8], 45 ; 0000002dH
  01cd5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z

; 922  : 			if ((_access((G³os + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01cdb	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T500[ebp]
  01ce1	50		 push	 eax
  01ce2	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$514[ebp]
  01ce8	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01ced	50		 push	 eax
  01cee	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T501[ebp]
  01cf4	c6 45 fc 2e	 mov	 BYTE PTR __$EHRec$[ebp+8], 46 ; 0000002eH
  01cf8	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01cfd	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01d02	8b d0		 mov	 edx, eax
  01d04	c6 45 fc 2f	 mov	 BYTE PTR __$EHRec$[ebp+8], 47 ; 0000002fH
  01d08	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T502[ebp]
  01d0e	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d13	83 c4 08	 add	 esp, 8
  01d16	8b c8		 mov	 ecx, eax
  01d18	6a 00		 push	 0
  01d1a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01d1f	50		 push	 eax
  01d20	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  01d26	83 c4 08	 add	 esp, 8
  01d29	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T502[ebp]
  01d2f	8b f0		 mov	 esi, eax
  01d31	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01d36	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T501[ebp]
  01d3c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01d41	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T500[ebp]
  01d47	c6 45 fc 2d	 mov	 BYTE PTR __$EHRec$[ebp+8], 45 ; 0000002dH
  01d4b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01d50	85 f6		 test	 esi, esi
  01d52	0f 84 5a 01 00
	00		 je	 $LN74@Sprawd_P

; 923  : 			{
; 924  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  01d58	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  01d5f	75 24		 jne	 SHORT $LN73@Sprawd_P

; 925  : 				{
; 926  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01d61	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01d67	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01d6c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  01d71	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01d76	8b c8		 mov	 ecx, eax
  01d78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 927  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01d7e	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR _czy_pobierano$1$[ebp], 1
$LN73@Sprawd_P:

; 928  : 				}
; 929  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01d85	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR $T504[ebp]
  01d8b	50		 push	 eax
  01d8c	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$514[ebp]
  01d92	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01d97	8b f0		 mov	 esi, eax
  01d99	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  01d9c	c6 45 fc 30	 mov	 BYTE PTR __$EHRec$[ebp+8], 48 ; 00000030H
  01da0	50		 push	 eax
  01da1	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T505[ebp]
  01da7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01dac	56		 push	 esi
  01dad	8b d0		 mov	 edx, eax
  01daf	c6 45 fc 31	 mov	 BYTE PTR __$EHRec$[ebp+8], 49 ; 00000031H
  01db3	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T506[ebp]
  01db9	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01dbe	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01dc3	8b d0		 mov	 edx, eax
  01dc5	c6 45 fc 32	 mov	 BYTE PTR __$EHRec$[ebp+8], 50 ; 00000032H
  01dc9	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T507[ebp]
  01dcf	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01dd4	83 c4 0c	 add	 esp, 12			; 0000000cH
  01dd7	8b f8		 mov	 edi, eax
  01dd9	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T508[ebp]
  01ddf	c6 45 fc 33	 mov	 BYTE PTR __$EHRec$[ebp+8], 51 ; 00000033H
  01de3	50		 push	 eax
  01de4	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$514[ebp]
  01dea	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01def	8b f0		 mov	 esi, eax
  01df1	8d 45 d0	 lea	 eax, DWORD PTR _g³os2$517[ebp]
  01df4	c6 45 fc 34	 mov	 BYTE PTR __$EHRec$[ebp+8], 52 ; 00000034H
  01df8	50		 push	 eax
  01df9	8d 55 b0	 lea	 edx, DWORD PTR _link$516[ebp]
  01dfc	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T509[ebp]
  01e02	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01e07	56		 push	 esi
  01e08	8b d0		 mov	 edx, eax
  01e0a	c6 45 fc 35	 mov	 BYTE PTR __$EHRec$[ebp+8], 53 ; 00000035H
  01e0e	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T510[ebp]
  01e14	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01e19	68 00 00 00 00	 push	 OFFSET ??_C@_04IBLEHOMF@?4wav?$AA@
  01e1e	8b d0		 mov	 edx, eax
  01e20	c6 45 fc 36	 mov	 BYTE PTR __$EHRec$[ebp+8], 54 ; 00000036H
  01e24	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T511[ebp]
  01e2a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01e2f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01e32	8b cf		 mov	 ecx, edi
  01e34	8b d0		 mov	 edx, eax
  01e36	6a 00		 push	 0
  01e38	6a 00		 push	 0
  01e3a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01e3f	50		 push	 eax
  01e40	8b ca		 mov	 ecx, edx
  01e42	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01e47	50		 push	 eax
  01e48	6a 00		 push	 0
  01e4a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__URLDownloadToFileA@20
  01e50	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T511[ebp]
  01e56	8b f0		 mov	 esi, eax
  01e58	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e5d	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T510[ebp]
  01e63	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e68	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T509[ebp]
  01e6e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e73	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T508[ebp]
  01e79	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e7e	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T507[ebp]
  01e84	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e89	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T506[ebp]
  01e8f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e94	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T505[ebp]
  01e9a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e9f	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T504[ebp]
  01ea5	c6 45 fc 2d	 mov	 BYTE PTR __$EHRec$[ebp+8], 45 ; 0000002dH
  01ea9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 930  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01eae	85 f6		 test	 esi, esi
  01eb0	75 71		 jne	 SHORT $LN4237@Sprawd_P
$LN74@Sprawd_P:

; 935  : 				}
; 936  : 			}
; 937  : 		}

  01eb2	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$514[ebp]
  01eb8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01ebc	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  01ec1	8b 75 ec	 mov	 esi, DWORD PTR _i$1$[ebp]
  01ec4	46		 inc	 esi
  01ec5	89 75 ec	 mov	 DWORD PTR _i$1$[ebp], esi
  01ec8	66 83 fe 24	 cmp	 si, 36			; 00000024H
  01ecc	0f 86 de fd ff
	ff		 jbe	 $LL12@Sprawd_P

; 938  : 
; 939  : 		if (czy_pobierano) cout << "Pobrano brakuj¹ce pliki g³osów" << endl; //Poinformowanie o ukoñczonu pobierania plików

  01ed2	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR _czy_pobierano$1$[ebp], 0
  01ed9	74 1d		 je	 SHORT $LN75@Sprawd_P
  01edb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01ee1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@
  01ee6	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  01eeb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01ef0	8b c8		 mov	 ecx, eax
  01ef2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN75@Sprawd_P:

; 940  : 	}

  01ef8	8d 4d d0	 lea	 ecx, DWORD PTR _g³os2$517[ebp]
  01efb	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f00	8d 4d b0	 lea	 ecx, DWORD PTR _link$516[ebp]
  01f03	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN35@Sprawd_P:

; 941  : }

  01f08	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01f0b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01f12	59		 pop	 ecx
  01f13	5f		 pop	 edi
  01f14	5e		 pop	 esi
  01f15	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01f18	33 cd		 xor	 ecx, ebp
  01f1a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01f1f	8b e5		 mov	 esp, ebp
  01f21	5d		 pop	 ebp
  01f22	c3		 ret	 0
$LN4237@Sprawd_P:

; 931  : 				{
; 932  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  01f23	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01f29	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  01f2e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  01f33	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  01f38	8b c8		 mov	 ecx, eax
  01f3a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 933  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 934  : 					return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej

  01f40	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$514[ebp]
  01f46	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  01f4d	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  01f52	eb a4		 jmp	 SHORT $LN75@Sprawd_P
$LN4271@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1611 : 			_Xran();

  01f54	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN4292@Sprawd_P:
$LN4261@Sprawd_P:
  01f59	0f 1f 00	 npad	 3
$LN4273@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 941  : }

  01f5c	00 00 00 00	 DD	 $LN36@Sprawd_P
  01f60	00 00 00 00	 DD	 $LN37@Sprawd_P
  01f64	00 00 00 00	 DD	 $LN38@Sprawd_P
  01f68	00 00 00 00	 DD	 $LN39@Sprawd_P
  01f6c	00 00 00 00	 DD	 $LN40@Sprawd_P
  01f70	00 00 00 00	 DD	 $LN41@Sprawd_P
  01f74	00 00 00 00	 DD	 $LN42@Sprawd_P
  01f78	00 00 00 00	 DD	 $LN43@Sprawd_P
  01f7c	00 00 00 00	 DD	 $LN44@Sprawd_P
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR _link$516[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$1:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR _g³os2$517[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$5:
  00010	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T110[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$6:
  0001b	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T111[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$7:
  00026	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T113[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$10:
  00031	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T170[ebp]
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$11:
  0003c	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T171[ebp]
  00042	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$12:
  00047	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T173[ebp]
  0004d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$15:
  00052	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T230[ebp]
  00058	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$16:
  0005d	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T231[ebp]
  00063	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$17:
  00068	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T233[ebp]
  0006e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$20:
  00073	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T290[ebp]
  00079	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$21:
  0007e	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T291[ebp]
  00084	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$22:
  00089	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T293[ebp]
  0008f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$25:
  00094	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T308[ebp]
  0009a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$26:
  0009f	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T309[ebp]
  000a5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$27:
  000aa	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T311[ebp]
  000b0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$30:
  000b5	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T326[ebp]
  000bb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$31:
  000c0	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T327[ebp]
  000c6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$32:
  000cb	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T329[ebp]
  000d1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$34:
  000d6	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T338[ebp]
  000dc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$35:
  000e1	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T348[ebp]
  000e7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$37:
  000ec	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T380[ebp]
  000f2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$38:
  000f7	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T381[ebp]
  000fd	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$39:
  00102	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T391[ebp]
  00108	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$40:
  0010d	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T399[ebp]
  00113	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$41:
  00118	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T401[ebp]
  0011e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$42:
  00123	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T402[ebp]
  00129	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$43:
  0012e	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T412[ebp]
  00134	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$645:
  00139	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  0013f	83 e0 20	 and	 eax, 32			; 00000020H
  00142	0f 84 13 00 00
	00		 je	 $LN3060@Sprawd_P
  00148	83 a5 94 fe ff
	ff df		 and	 DWORD PTR $T1[ebp], -33	; ffffffdfH
  0014f	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$515[ebp+104]
  00155	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN3060@Sprawd_P:
  0015b	c3		 ret	 0
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$646:
  0015c	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$515[ebp+32]
  00162	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$648:
  00168	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$45:
  00171	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$515[ebp]
  00177	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$46:
  0017c	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T429[ebp]
  00182	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$47:
  00187	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T430[ebp]
  0018d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$48:
  00192	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T431[ebp]
  00198	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$50:
  0019d	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T472[ebp]
  001a3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$51:
  001a8	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T473[ebp]
  001ae	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$52:
  001b3	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T485[ebp]
  001b9	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$53:
  001be	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T493[ebp]
  001c4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$54:
  001c9	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T494[ebp]
  001cf	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$55:
  001d4	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T495[ebp]
  001da	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$56:
  001df	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T496[ebp]
  001e5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$57:
  001ea	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T497[ebp]
  001f0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$58:
  001f5	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T498[ebp]
  001fb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$60:
  00200	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _numers$514[ebp]
  00206	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$61:
  0020b	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T500[ebp]
  00211	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$62:
  00216	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T501[ebp]
  0021c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$64:
  00221	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T504[ebp]
  00227	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$65:
  0022c	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T505[ebp]
  00232	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$66:
  00237	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T506[ebp]
  0023d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$67:
  00242	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T507[ebp]
  00248	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$68:
  0024d	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T508[ebp]
  00253	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$69:
  00258	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T509[ebp]
  0025e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_Pliki@@YAXXZ$70:
  00263	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T510[ebp]
  00269	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Sprawd_Pliki@@YAXXZ:
  0026e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00272	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00275	8b 8a f8 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-520]
  0027b	33 c8		 xor	 ecx, eax
  0027d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00282	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00285	33 c8		 xor	 ecx, eax
  00287	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Sprawd_Pliki@@YAXXZ
  00291	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Sprawd_Pliki@@YAXXZ ENDP				; Sprawd_Pliki
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Sprawd_ustawienia@@YAXXZ
_TEXT	SEGMENT
_this$ = -408						; size = 4
$T1 = -404						; size = 4
_ustawienia$13 = -400					; size = 184
_ustawienia$14 = -216					; size = 176
_buf$15 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Sprawd_ustawienia@@YAXXZ PROC				; Sprawd_ustawienia, COMDAT

; 944  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Sprawd_ustawienia@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 945  : 	if (!_access("setting.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  0002d	6a 00		 push	 0
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COFBHHKL@setting?4txt?$AA@
  00034	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  00044	83 c4 08	 add	 esp, 8
  00047	85 c0		 test	 eax, eax
  00049	0f 85 43 02 00
	00		 jne	 $LN4@Sprawd_u
  0004f	68 b8 00 00 00	 push	 184			; 000000b8H
  00054	50		 push	 eax
  00055	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _ustawienia$13[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _memset
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 771  : 		{	// construct unopened

  00064	c7 85 70 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$13[ebp], OFFSET ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  0006e	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+112]
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  0007a	6a 00		 push	 0
  0007c	6a 00		 push	 0
  0007e	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR _ustawienia$13[ebp+16]
  00084	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008b	50		 push	 eax
  0008c	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp]
  00092	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T1[ebp], 1
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  000a2	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000a9	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$13[ebp]
  000af	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b2	c7 84 05 70 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ustawienia$13[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  000bd	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$13[ebp]
  000c3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c6	8d 41 90	 lea	 eax, DWORD PTR [ecx-112]
  000c9	89 84 0d 6c fe
	ff ff		 mov	 DWORD PTR _ustawienia$13[ebp+ecx-4], eax
  000d0	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR _ustawienia$13[ebp+16]

; 155  : 		: _Mysb()

  000d6	8b c8		 mov	 ecx, eax

; 771  : 		{	// construct unopened

  000d8	89 85 68 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax

; 155  : 		: _Mysb()

  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  000e4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  000e8	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+16]

; 156  : 		{	// construct from pointer to C stream

  000ee	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$13[ebp+16], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 636  : 		_Closef = _Which == _Openfl;

  000f8	c6 85 c8 fe ff
	ff 00		 mov	 BYTE PTR _ustawienia$13[ebp+88], 0

; 637  : 		_Wrotesome = false;

  000ff	c6 85 bd fe ff
	ff 00		 mov	 BYTE PTR _ustawienia$13[ebp+77], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;
; 663  : 		_State = _Stinit;

  0010c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  00111	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _ustawienia$13[ebp+80], eax
  00117	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  0011c	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$13[ebp+92], 0
  00126	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _ustawienia$13[ebp+84], eax

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  0012c	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ustawienia$13[ebp+72], 0

; 934  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00136	51		 push	 ecx
  00137	6a 01		 push	 1
  00139	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COFBHHKL@setting?4txt?$AA@
  0013e	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+16]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 947  : 		ifstream ustawienia; //Utworzenie typu do celu odczytu z pliku

  00144	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 934  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  0014b	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00150	85 c0		 test	 eax, eax

; 935  : 			_Myios::setstate(ios_base::failbit);

  00152	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp]
  00158	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$13[ebp]
  0015e	6a 00		 push	 0
  00160	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00163	75 0c		 jne	 SHORT $LN47@Sprawd_u
  00165	6a 02		 push	 2
  00167	03 c8		 add	 ecx, eax
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 936  : 		else

  0016f	eb 0a		 jmp	 SHORT $LN48@Sprawd_u
$LN47@Sprawd_u:

; 937  : 			_Myios::clear();	// added with C++11

  00171	6a 00		 push	 0
  00173	03 c8		 add	 ecx, eax
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN48@Sprawd_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0017b	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  00180	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _buf$15[ebp+16], 0
  00187	89 55 ec	 mov	 DWORD PTR _buf$15[ebp+20], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0018a	c6 45 d8 00	 mov	 BYTE PTR _buf$15[ebp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 949  : 		string buf; //Utworzenie buforu do odczytu z pliku

  0018e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  00192	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _ustawienia$13[ebp]
  00198	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  0019b	f6 84 05 7c fe
	ff ff 01	 test	 BYTE PTR _ustawienia$13[ebp+eax+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 950  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  001a3	75 43		 jne	 SHORT $LN3@Sprawd_u
$LL2@Sprawd_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  001a5	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp]
  001ab	6a 0a		 push	 10			; 0000000aH
  001ad	03 c8		 add	 ecx, eax
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  001b5	0f b6 c0	 movzx	 eax, al
  001b8	8d 55 d8	 lea	 edx, DWORD PTR _buf$15[ebp]
  001bb	50		 push	 eax
  001bc	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp]
  001c2	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  001c7	83 c4 04	 add	 esp, 4
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 953  : 			Ustaw_ustawienia(buf); //Zamiana wczytanej lini na ustawienie programu

  001ca	8d 4d d8	 lea	 ecx, DWORD PTR _buf$15[ebp]
  001cd	e8 00 00 00 00	 call	 ?Ustaw_ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ustaw_ustawienia
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  001d2	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _ustawienia$13[ebp]
  001d8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 343  : 		return ((int)rdstate() & (int)eofbit);

  001db	f6 84 05 7c fe
	ff ff 01	 test	 BYTE PTR _ustawienia$13[ebp+eax+12], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 950  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  001e3	74 c0		 je	 SHORT $LL2@Sprawd_u
  001e5	8b 55 ec	 mov	 edx, DWORD PTR _buf$15[ebp+20]
$LN3@Sprawd_u:

; 955  : 	}

  001e8	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001ec	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  001ef	72 45		 jb	 SHORT $LN120@Sprawd_u
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001f1	8b 45 d8	 mov	 eax, DWORD PTR _buf$15[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001f4	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001f5	8b c8		 mov	 ecx, eax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001f7	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001fd	72 27		 jb	 SHORT $LN123@Sprawd_u

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001ff	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00202	3b f2		 cmp	 esi, edx
  00204	76 1a		 jbe	 SHORT $_Invalid_parameter$183

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00206	8b d6		 mov	 edx, esi
  00208	f6 c1 1f	 test	 cl, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0020b	75 13		 jne	 SHORT $_Invalid_parameter$183

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0020d	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00210	3b c1		 cmp	 eax, ecx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00212	73 0c		 jae	 SHORT $_Invalid_parameter$183

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00214	2b c8		 sub	 ecx, eax
  00216	83 f9 04	 cmp	 ecx, 4
  00219	72 05		 jb	 SHORT $_Invalid_parameter$183

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0021b	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0021e	76 06		 jbe	 SHORT $LN123@Sprawd_u
$_Invalid_parameter$183:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00220	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN182@Sprawd_u:
$LN123@Sprawd_u:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00226	52		 push	 edx
  00227	50		 push	 eax
  00228	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0022d	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _ustawienia$13[ebp]
  00233	83 c4 08	 add	 esp, 8
$LN120@Sprawd_u:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 955  : 	}

  00236	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  0023d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _buf$15[ebp+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00244	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _buf$15[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0024b	c6 45 d8 00	 mov	 BYTE PTR _buf$15[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 917  : 		{	// destroy the object

  0024f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00252	c7 84 05 70 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ustawienia$13[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  0025d	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _ustawienia$13[ebp]
  00263	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00266	8d 41 90	 lea	 eax, DWORD PTR [ecx-112]
  00269	89 84 0d 6c fe
	ff ff		 mov	 DWORD PTR _ustawienia$13[ebp+ecx-4], eax

; 918  : 		}

  00270	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+16]
  00276	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0027b	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+24]
  00281	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00287	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+112]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 956  : 	else

  0028d	e9 e6 01 00 00	 jmp	 $LN180@Sprawd_u
$LN4@Sprawd_u:
  00292	68 b0 00 00 00	 push	 176			; 000000b0H
  00297	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _ustawienia$14[ebp]
  0029d	6a 00		 push	 0
  0029f	50		 push	 eax
  002a0	e8 00 00 00 00	 call	 _memset

; 958  : 		ofstream ustawienia; //Utworzenie typu do celu zapisu do pliku

  002a5	83 c4 08	 add	 esp, 8
  002a8	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  002ae	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  002b3	51		 push	 ecx
  002b4	6a 02		 push	 2
  002b6	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COFBHHKL@setting?4txt?$AA@
  002bb	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp+4]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 958  : 		ofstream ustawienia; //Utworzenie typu do celu zapisu do pliku

  002c1	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  002c8	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  002cd	85 c0		 test	 eax, eax

; 1150 : 			_Myios::setstate(ios_base::failbit);

  002cf	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  002d5	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _ustawienia$14[ebp]
  002db	6a 00		 push	 0
  002dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002e0	75 0c		 jne	 SHORT $LN164@Sprawd_u
  002e2	6a 02		 push	 2
  002e4	03 c8		 add	 ecx, eax
  002e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 1151 : 		else

  002ec	eb 0a		 jmp	 SHORT $LN165@Sprawd_u
$LN164@Sprawd_u:

; 1152 : 			_Myios::clear();	// added with C++11

  002ee	6a 00		 push	 0
  002f0	03 c8		 add	 ecx, eax
  002f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN165@Sprawd_u:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 960  : 		ustawienia << "iloæ_minimalna_obrotów_ruletki 2" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych iloæ_minimalna_obrotów_ruletki

  002f8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@
  002fd	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00303	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00308	b2 0a		 mov	 dl, 10			; 0000000aH
  0030a	8b c8		 mov	 ecx, eax
  0030c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 961  : 		ustawienia << "iloæ_max_dodatkowych_obrotów_ruletki 3" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych iloæ_max_dodatkowych_obrotów_ruletki

  00311	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
  00316	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  0031c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00321	b2 0a		 mov	 dl, 10			; 0000000aH
  00323	8b c8		 mov	 ecx, eax
  00325	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 962  : 		ustawienia << "czas_przeskoku_kulki_szybki 50" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czas_przeskoku_kulki_szybki

  0032a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@
  0032f	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00335	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0033a	b2 0a		 mov	 dl, 10			; 0000000aH
  0033c	8b c8		 mov	 ecx, eax
  0033e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 963  : 		ustawienia << "czas_przeskoku_kulki_wolny 75" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czas_przeskoku_kulki_wolny

  00343	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@
  00348	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  0034e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00353	b2 0a		 mov	 dl, 10			; 0000000aH
  00355	8b c8		 mov	 ecx, eax
  00357	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 964  : 		ustawienia << "czas_przerwy_dzwiêku 500" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czas_przerwy_dzwiêku

  0035c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@
  00361	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00367	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0036c	b2 0a		 mov	 dl, 10			; 0000000aH
  0036e	8b c8		 mov	 ecx, eax
  00370	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 965  : 		ustawienia << "styl_liczenia_wygranej 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych styl_liczenia_wygranej

  00375	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@
  0037a	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00380	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00385	b2 0a		 mov	 dl, 10			; 0000000aH
  00387	8b c8		 mov	 ecx, eax
  00389	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 966  : 		ustawienia << "kwota_pocz¹tkowa 1000" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych kwota_pocz¹tkowa

  0038e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@
  00393	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00399	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0039e	b2 0a		 mov	 dl, 10			; 0000000aH
  003a0	8b c8		 mov	 ecx, eax
  003a2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 967  : 		ustawienia << "stan_dwiêków 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych stan_dwiêków

  003a7	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@
  003ac	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  003b2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003b7	b2 0a		 mov	 dl, 10			; 0000000aH
  003b9	8b c8		 mov	 ecx, eax
  003bb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 968  : 		ustawienia << "czy_kontynuowaæ_grê 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czy_kontynuowaæ_grê

  003c0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@
  003c5	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  003cb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003d0	b2 0a		 mov	 dl, 10			; 0000000aH
  003d2	8b c8		 mov	 ecx, eax
  003d4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 969  : 		ustawienia << "g³os_odczytu_numeru 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych g³os_odczytu_numeru

  003d9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@
  003de	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  003e4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003e9	b2 0a		 mov	 dl, 10			; 0000000aH
  003eb	8b c8		 mov	 ecx, eax
  003ed	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 970  : 		ustawienia << "g³os_szybkoæ_odczytu_numeru 4" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych g³os_szybkoæ_odczytu_numeru

  003f2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@
  003f7	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  003fd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00402	b2 0a		 mov	 dl, 10			; 0000000aH
  00404	8b c8		 mov	 ecx, eax
  00406	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 971  : 		ustawienia << "efekty_dwiêkowe 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych efekty_dwiêkowe

  0040b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@
  00410	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00416	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0041b	b2 0a		 mov	 dl, 10			; 0000000aH
  0041d	8b c8		 mov	 ecx, eax
  0041f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 972  : 		ustawienia.flush(); //Zapisanie do pliku setting.txt danych wpisanych do bufora danych

  00424	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  0042a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 973  : 	}

  00430	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1132 : 		{	// destroy the object

  00437	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _ustawienia$14[ebp]
  0043d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00440	c7 84 05 28 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ustawienia$14[ebp+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  0044b	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _ustawienia$14[ebp]
  00451	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00454	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00457	89 84 0d 24 ff
	ff ff		 mov	 DWORD PTR _ustawienia$14[ebp+ecx-4], eax

; 1133 : 		}

  0045e	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp+4]
  00464	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00469	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp+8]
  0046f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00475	8d 4d 90	 lea	 ecx, DWORD PTR _ustawienia$14[ebp+104]
$LN180@Sprawd_u:
  00478	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 975  : 	if (Ustawienia.czas_przeskoku_kulki_wolny < Ustawienia.czas_przeskoku_kulki_szybki) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0047e	66 a1 06 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+6
  00484	66 3b 05 04 00
	00 00		 cmp	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4
  0048b	7d 49		 jge	 SHORT $LN6@Sprawd_u

; 976  : 	{
; 977  : 		cout << "Wartoæ wolnego czasu przeskoku kulki musi byæ ni¿sza ni¿ wartoæ szybkiego czasu przeskoku kulki" << endl; //(Wartoci tych zmiennych to czas opónienia wiêc im jest wy¿szy tym d³u¿sza przerwa)

  0048d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00493	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@
  00498	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0049d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004a2	8b c8		 mov	 ecx, eax
  004a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 978  : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  004aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004b0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  004b5	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  004ba	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004bf	8b c8		 mov	 ecx, eax
  004c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 979  : 		Ustawienia.czas_przeskoku_kulki_szybki = 50; //Ustawienie wartoci domylnej

  004c7	c7 05 04 00 00
	00 32 00 4b 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+4, 4915250 ; 004b0032H

; 980  : 		Ustawienia.czas_przeskoku_kulki_wolny = 75; //Ustawienie wartoci domylnej

  004d1	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
$LN6@Sprawd_u:

; 981  : 	}
; 982  : 	if (Ustawienia.iloæ_minimalna_obrotów_ruletki < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  004d6	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A
  004dc	be 02 00 00 00	 mov	 esi, 2
  004e1	66 85 c0	 test	 ax, ax
  004e4	79 42		 jns	 SHORT $LN7@Sprawd_u

; 983  : 	{
; 984  : 		cout << "Iloæ minimalna obrotów ruletki nie mo¿e byæ mniejsza od 0" << endl;

  004e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004ec	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@
  004f1	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  004f6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004fb	8b c8		 mov	 ecx, eax
  004fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 985  : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00503	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00509	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0050e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00513	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00518	8b c8		 mov	 ecx, eax
  0051a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 986  : 		Ustawienia.iloæ_minimalna_obrotów_ruletki = 2; //Ustawienie wartoci domylnej

  00520	8b c6		 mov	 eax, esi
  00522	66 a3 00 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A, ax
$LN7@Sprawd_u:

; 987  : 	}
; 988  : 	if (Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00528	66 8b 0d 02 00
	00 00		 mov	 cx, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2
  0052f	bf 03 00 00 00	 mov	 edi, 3
  00534	66 85 c9	 test	 cx, cx
  00537	79 49		 jns	 SHORT $LN8@Sprawd_u

; 989  : 	{
; 990  : 		cout << "Iloæ max obrotów ruletki nie mo¿e byæ mniejsza od 0" << endl;

  00539	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0053f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@
  00544	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00549	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0054e	8b c8		 mov	 ecx, eax
  00550	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 991  : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00556	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0055c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00561	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00566	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0056b	8b c8		 mov	 ecx, eax
  0056d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 992  : 		Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = 3; //Ustawienie wartoci domylnej

  00573	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A
  00579	8b cf		 mov	 ecx, edi
  0057b	66 89 0d 02 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2, cx
$LN8@Sprawd_u:

; 993  : 	}
; 994  : 	if ((Ustawienia.iloæ_minimalna_obrotów_ruletki == 0) && (Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki == 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00582	66 85 c0	 test	 ax, ax
  00585	75 49		 jne	 SHORT $LN9@Sprawd_u
  00587	66 85 c9	 test	 cx, cx
  0058a	75 44		 jne	 SHORT $LN9@Sprawd_u

; 995  : 	{
; 996  : 		cout << "Jedna z deklaracji w sprawie obrotów ruletki musi byæ wiêksza od zera" << endl;

  0058c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00592	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@
  00597	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0059c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005a1	8b c8		 mov	 ecx, eax
  005a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 997  : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  005a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005af	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  005b4	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  005b9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005be	8b c8		 mov	 ecx, eax
  005c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 998  : 		Ustawienia.iloæ_minimalna_obrotów_ruletki = 2; //Ustawienie wartoci domylnej

  005c6	c7 05 00 00 00
	00 02 00 03 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A, 196610 ; 00030002H
$LN9@Sprawd_u:

; 999  : 		Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = 3; //Ustawienie wartoci domylnej
; 1000 : 	}
; 1001 : 	if (((Ustawienia.styl_liczenia_wygranej > 1) || (Ustawienia.styl_liczenia_wygranej < 0))) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  005d0	66 a1 0a 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10
  005d6	be 01 00 00 00	 mov	 esi, 1
  005db	66 3b c6	 cmp	 ax, si
  005de	7f 05		 jg	 SHORT $LN11@Sprawd_u
  005e0	66 85 c0	 test	 ax, ax
  005e3	79 41		 jns	 SHORT $LN10@Sprawd_u
$LN11@Sprawd_u:

; 1002 : 	{
; 1003 : 		cout << "Styl liczeia wygranej przyjmuje wartoci tylko 0 lub 1" << endl;

  005e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005eb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@
  005f0	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  005f5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005fa	8b c8		 mov	 ecx, eax
  005fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1004 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00602	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00608	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0060d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00612	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00617	8b c8		 mov	 ecx, eax
  00619	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1005 : 		Ustawienia.styl_liczenia_wygranej = 1; //Ustawienie wartoci domylnej

  0061f	66 89 35 0a 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, si
$LN10@Sprawd_u:

; 1006 : 	}
; 1007 : 	if (Ustawienia.czas_przerwy_dzwiêku < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00626	66 83 3d 08 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8, 0
  0062e	7d 45		 jge	 SHORT $LN12@Sprawd_u

; 1008 : 	{
; 1009 : 		cout << "Czas przerwy dwiêku nie mo¿e byæ mniejszy od zera" << endl;

  00630	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00636	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@
  0063b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00640	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00645	8b c8		 mov	 ecx, eax
  00647	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1010 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  0064d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00653	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00658	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0065d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00662	8b c8		 mov	 ecx, eax
  00664	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1011 : 		Ustawienia.czas_przerwy_dzwiêku = 500; //Ustawienie wartoci domylnej

  0066a	b8 f4 01 00 00	 mov	 eax, 500		; 000001f4H
  0066f	66 a3 08 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8, ax
$LN12@Sprawd_u:

; 1012 : 	}
; 1013 : 	if (Ustawienia.kwota_pocz¹tkowa < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00675	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, 0
  0067c	7d 44		 jge	 SHORT $LN13@Sprawd_u

; 1014 : 	{
; 1015 : 		cout << "Kwota pocz¹tkowa nie mo¿e byæ mniejsza od zera" << endl;

  0067e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00684	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@
  00689	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0068e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00693	8b c8		 mov	 ecx, eax
  00695	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1016 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  0069b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006a1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  006a6	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  006ab	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  006b0	8b c8		 mov	 ecx, eax
  006b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1017 : 		Ustawienia.kwota_pocz¹tkowa = 1000; //Ustawienie wartoci domylnej

  006b8	c7 05 0c 00 00
	00 e8 03 00 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, 1000 ; 000003e8H
$LN13@Sprawd_u:

; 1018 : 	}
; 1019 : 	if ((Ustawienia.stan_dwiêków > 1) || (Ustawienia.stan_dwiêków < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  006c2	66 a1 10 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16
  006c8	66 83 f8 01	 cmp	 ax, 1
  006cc	7f 05		 jg	 SHORT $LN15@Sprawd_u
  006ce	66 85 c0	 test	 ax, ax
  006d1	79 41		 jns	 SHORT $LN14@Sprawd_u
$LN15@Sprawd_u:

; 1020 : 	{
; 1021 : 		cout << "Stan dwiêków przyjmuje wartoci tylko 0 lub 1" << endl;

  006d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006d9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@
  006de	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  006e3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  006e8	8b c8		 mov	 ecx, eax
  006ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1022 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  006f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006f6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  006fb	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00700	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00705	8b c8		 mov	 ecx, eax
  00707	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1023 : 		Ustawienia.stan_dwiêków = 1; //Ustawienie wartoci domylnej

  0070d	66 89 35 10 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, si
$LN14@Sprawd_u:

; 1024 : 	}
; 1025 : 	if ((Ustawienia.czy_kontynuowaæ_grê > 1) || (Ustawienia.czy_kontynuowaæ_grê < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00714	66 a1 12 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18
  0071a	66 83 f8 01	 cmp	 ax, 1
  0071e	7f 05		 jg	 SHORT $LN17@Sprawd_u
  00720	66 85 c0	 test	 ax, ax
  00723	79 41		 jns	 SHORT $LN16@Sprawd_u
$LN17@Sprawd_u:

; 1026 : 	{
; 1027 : 		cout << "Opcja kontynuowania gry przyjmuje wartoci tylko 0 lub 1" << endl;

  00725	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0072b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@
  00730	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00735	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0073a	8b c8		 mov	 ecx, eax
  0073c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1028 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00742	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00748	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0074d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00752	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00757	8b c8		 mov	 ecx, eax
  00759	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1029 : 		Ustawienia.czy_kontynuowaæ_grê = 1; //Ustawienie wartoci domylnej

  0075f	66 89 35 12 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, si
$LN16@Sprawd_u:

; 1030 : 	}
; 1031 : 	if ((Ustawienia.g³os_odczytu_numeru > 10) || (Ustawienia.g³os_odczytu_numeru < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00766	66 a1 14 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20
  0076c	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00770	7f 05		 jg	 SHORT $LN19@Sprawd_u
  00772	66 85 c0	 test	 ax, ax
  00775	79 41		 jns	 SHORT $LN18@Sprawd_u
$LN19@Sprawd_u:

; 1032 : 	{
; 1033 : 		cout << "Opcja g³os odczytu numeru przyjmuje wartoci w przedziale [0;10]" << endl;

  00777	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0077d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@
  00782	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00787	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0078c	8b c8		 mov	 ecx, eax
  0078e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1034 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00794	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0079a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0079f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  007a4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  007a9	8b c8		 mov	 ecx, eax
  007ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1035 : 		Ustawienia.g³os_odczytu_numeru = 1; //Ustawienie wartoci domylnej

  007b1	66 89 35 14 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, si
$LN18@Sprawd_u:

; 1036 : 	}
; 1037 : 	if ((Ustawienia.g³os_szybkoæ_odczytu_numeru > 5) || (Ustawienia.g³os_szybkoæ_odczytu_numeru < 1)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  007b8	66 a1 16 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22
  007be	66 83 f8 05	 cmp	 ax, 5
  007c2	7f 06		 jg	 SHORT $LN21@Sprawd_u
  007c4	66 83 f8 01	 cmp	 ax, 1
  007c8	7d 45		 jge	 SHORT $LN20@Sprawd_u
$LN21@Sprawd_u:

; 1038 : 	{
; 1039 : 		cout << "Opcja szybkoæ g³osu odczytu przyjmuje wartoci w przedziale [1;5]" << endl;

  007ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007d0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@
  007d5	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  007da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  007df	8b c8		 mov	 ecx, eax
  007e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1040 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  007e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007ed	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  007f2	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  007f7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  007fc	8b c8		 mov	 ecx, eax
  007fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1041 : 		Ustawienia.g³os_szybkoæ_odczytu_numeru = 4; //Ustawienie wartoci domylnej

  00804	b8 04 00 00 00	 mov	 eax, 4
  00809	66 a3 16 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax
$LN20@Sprawd_u:

; 1042 : 	}
; 1043 : 	if ((Ustawienia.efekty_dwiêkowe > 1) || (Ustawienia.efekty_dwiêkowe < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0080f	66 a1 18 00 00
	00		 mov	 ax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24
  00815	66 83 f8 01	 cmp	 ax, 1
  00819	7f 11		 jg	 SHORT $LN23@Sprawd_u
  0081b	66 85 c0	 test	 ax, ax
  0081e	78 0c		 js	 SHORT $LN23@Sprawd_u

; 1048 : 	}
; 1049 : 	if (Ustawienia.efekty_dwiêkowe == 1 && Ustawienia.stan_dwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00820	66 83 f8 01	 cmp	 ax, 1
  00824	0f 85 8e 00 00
	00		 jne	 $LN24@Sprawd_u
  0082a	eb 41		 jmp	 SHORT $LN177@Sprawd_u
$LN23@Sprawd_u:

; 1044 : 	{
; 1045 : 		cout << "Opcja efekty dwiêkowe przyjmuje wartoci 0 lub 1" << endl;

  0082c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00832	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@
  00837	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0083c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00841	8b c8		 mov	 ecx, eax
  00843	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1046 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00849	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0084f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00854	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00859	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0085e	8b c8		 mov	 ecx, eax
  00860	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1047 : 		Ustawienia.efekty_dwiêkowe = 1; //Ustawienie wartoci domylnej

  00866	66 89 35 18 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, si
$LN177@Sprawd_u:

; 1048 : 	}
; 1049 : 	if (Ustawienia.efekty_dwiêkowe == 1 && Ustawienia.stan_dwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0086d	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  00875	75 41		 jne	 SHORT $LN24@Sprawd_u

; 1050 : 	{
; 1051 : 		cout << "Nie mo¿esz mieæ wy³¹czonych dwiêków i w³¹czonych efektów dwiêkowych" << endl;

  00877	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0087d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
  00882	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00887	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0088c	8b c8		 mov	 ecx, eax
  0088e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1052 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00894	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0089a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0089f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  008a4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  008a9	8b c8		 mov	 ecx, eax
  008ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1053 : 		Ustawienia.stan_dwiêków = 1; //Ustawienie wartoci domylnej

  008b1	66 89 35 10 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, si
$LN24@Sprawd_u:

; 1054 : 	}
; 1055 : 	if (Ustawienia.g³os_odczytu_numeru > 0 && Ustawienia.stan_dwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  008b8	66 83 3d 14 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, 0
  008c0	7e 4b		 jle	 SHORT $LN25@Sprawd_u
  008c2	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  008ca	75 41		 jne	 SHORT $LN25@Sprawd_u

; 1056 : 	{
; 1057 : 		cout << "Nie mo¿esz mieæ wy³¹czonych dwiêków i w³¹czon¹ mowê" << endl;

  008cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008d2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
  008d7	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  008dc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  008e1	8b c8		 mov	 ecx, eax
  008e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1058 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  008e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008ef	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  008f4	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  008f9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  008fe	8b c8		 mov	 ecx, eax
  00900	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1059 : 		Ustawienia.stan_dwiêków = 1; //Ustawienie wartoci domylnej

  00906	66 89 35 10 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, si
$LN25@Sprawd_u:

; 1060 : 	}
; 1061 : }

  0090d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00910	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00917	59		 pop	 ecx
  00918	5f		 pop	 edi
  00919	5e		 pop	 esi
  0091a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0091d	33 cd		 xor	 ecx, ebp
  0091f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00924	8b e5		 mov	 esp, ebp
  00926	5d		 pop	 ebp
  00927	c3		 ret	 0
$LN181@Sprawd_u:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$4:
  00000	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00006	83 e0 01	 and	 eax, 1
  00009	0f 84 13 00 00
	00		 je	 $LN37@Sprawd_u
  0000f	83 a5 6c fe ff
	ff fe		 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00016	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+112]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN37@Sprawd_u:
  00022	c3		 ret	 0
__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$5:
  00023	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp+24]
  00029	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$7:
  0002f	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00035	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$0:
  0003b	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$13[ebp]
  00041	e9 00 00 00 00	 jmp	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$1:
  00046	8d 4d d8	 lea	 ecx, DWORD PTR _buf$15[ebp]
  00049	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Sprawd_ustawienia@@YAXXZ$2:
  0004e	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ustawienia$14[ebp]
  00054	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__ehhandler$?Sprawd_ustawienia@@YAXXZ:
  00059	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00060	8b 8a 68 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-408]
  00066	33 c8		 xor	 ecx, eax
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00070	33 c8		 xor	 ecx, eax
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Sprawd_ustawienia@@YAXXZ
  0007c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Sprawd_ustawienia@@YAXXZ ENDP				; Sprawd_ustawienia
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 917  : 		{	// destroy the object

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8d 71 70	 lea	 esi, DWORD PTR [ecx+112]

; 918  : 		}

  00006	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 90 00
	00 00 00	 mov	 DWORD PTR [eax+esi-112], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 90	 mov	 eax, DWORD PTR [esi-112]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 90	 lea	 eax, DWORD PTR [edx-112]
  0001d	89 44 32 8c	 mov	 DWORD PTR [edx+esi-116], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0002f	8b ce		 mov	 ecx, esi
  00031	5e		 pop	 esi
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	68 b8 00 00 00	 push	 184			; 000000b8H
  00005	6a 00		 push	 0
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memset
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00010	c2 04 00	 ret	 4
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Og³o_wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 24
_kwota_zak³adu$1$ = -12					; size = 4
_wygrana$1$ = -8					; size = 4
_iloæ_pieniêdzy$ = 8					; size = 4
_log_ogólny$ = 12					; size = 4
_log$ = 16						; size = 4
?Og³o_wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z PROC ; Og³o_wynik, COMDAT
; _wygrana$ = ecx
; _kwota_zak³adu$ = edx

; 1064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1065 : 	if (wygrana >= kwota_zak³adu) //Je¿eli wygrana jest wiêksza lub równa kwocie zak³adu to znaczy, ¿e siê wygra³o zak³ad

  00008	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000a	57		 push	 edi
  0000b	8b 3a		 mov	 edi, DWORD PTR [edx]
  0000d	89 55 f4	 mov	 DWORD PTR _kwota_zak³adu$1$[ebp], edx
  00010	89 4d f8	 mov	 DWORD PTR _wygrana$1$[ebp], ecx
  00013	3b f7		 cmp	 esi, edi
  00015	0f 8c b9 01 00
	00		 jl	 $LN2@Og?

; 1066 : 	{
; 1067 : 		iloæ_pieniêdzy += wygrana; //Dopisanie do salda kwoty wygranej z zak³adu

  0001b	8b 5d 08	 mov	 ebx, DWORD PTR _iloæ_pieniêdzy$[ebp]
  0001e	03 33		 add	 esi, DWORD PTR [ebx]
  00020	89 33		 mov	 DWORD PTR [ebx], esi

; 1068 : 		if (Ustawienia.styl_liczenia_wygranej) iloæ_pieniêdzy += kwota_zak³adu; //Dopisanie do salda kwoty zak³adu

  00022	66 83 3d 0a 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, 0
  0002a	74 06		 je	 SHORT $LN4@Og?
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	03 c6		 add	 eax, esi
  00030	89 03		 mov	 DWORD PTR [ebx], eax
$LN4@Og?:

; 1069 : 		log << " Wygrywasz " << wygrana << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie wygranej zak³adu

  00032	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  00035	33 d2		 xor	 edx, edx
  00037	ff 31		 push	 DWORD PTR [ecx]
  00039	85 c0		 test	 eax, eax
  0003b	51		 push	 ecx
  0003c	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0003f	8b f7		 mov	 esi, edi
  00041	0f 44 f2	 cmove	 esi, edx
  00044	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00050	83 c4 04	 add	 esp, 4
  00053	8b c8		 mov	 ecx, eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0005b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00060	8b c8		 mov	 ecx, eax
  00062	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1070 : 		log << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  00067	ff 33		 push	 DWORD PTR [ebx]
  00069	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  0006e	51		 push	 ecx
  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00076	83 c4 04	 add	 esp, 4
  00079	8b c8		 mov	 ecx, eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00081	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00086	8b c8		 mov	 ecx, eax
  00088	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0008d	b2 0a		 mov	 dl, 10			; 0000000aH
  0008f	8b c8		 mov	 ecx, eax
  00091	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1071 : 		log_ogólny << " Wygrywasz " << wygrana << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie wygranej zak³adu

  00096	8b 45 f8	 mov	 eax, DWORD PTR _wygrana$1$[ebp]
  00099	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
  0009e	8b 75 0c	 mov	 esi, DWORD PTR _log_ogólny$[ebp]
  000a1	ff 30		 push	 DWORD PTR [eax]
  000a3	51		 push	 ecx
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000ab	83 c4 04	 add	 esp, 4
  000ae	8b c8		 mov	 ecx, eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000b6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000bb	8b c8		 mov	 ecx, eax
  000bd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1072 : 		log_ogólny << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  000c2	ff 33		 push	 DWORD PTR [ebx]
  000c4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  000c9	51		 push	 ecx
  000ca	8b ce		 mov	 ecx, esi
  000cc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000d1	83 c4 04	 add	 esp, 4
  000d4	8b c8		 mov	 ecx, eax
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000dc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000e1	8b c8		 mov	 ecx, eax
  000e3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000e8	b2 0a		 mov	 dl, 10			; 0000000aH
  000ea	8b c8		 mov	 ecx, eax
  000ec	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1073 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  000f1	8b cf		 mov	 ecx, edi
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1074 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000f9	8b ce		 mov	 ecx, esi
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1075 : 		if (Ustawienia.stan_dwiêków) //Je¿eli stan_dwiêków == 1

  00101	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  00109	0f 84 eb 02 00
	00		 je	 $LN14@Og?

; 1076 : 		{
; 1077 : 			if (G³osyKompletne) //Je¿eli s¹ wszystkie pliki g³osów to

  0010f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  00116	74 74		 je	 SHORT $LN6@Og?

; 1079 : 				PlaySound((G³os + "win.wav").c_str(), nullptr, SND_SYNC); //Odtworzenie efektu wygrania zak³adu

  00118	68 00 00 00 00	 push	 OFFSET ??_C@_07KIPBKJCE@win?4wav?$AA@
  0011d	8d 4d dc	 lea	 ecx, DWORD PTR $T1[ebp]
  00120	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00125	83 c4 04	 add	 esp, 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00128	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0012c	72 02		 jb	 SHORT $LN39@Og?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0012e	8b 00		 mov	 eax, DWORD PTR [eax]
$LN39@Og?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1079 : 				PlaySound((G³os + "win.wav").c_str(), nullptr, SND_SYNC); //Odtworzenie efektu wygrania zak³adu

  00130	6a 00		 push	 0
  00132	6a 00		 push	 0
  00134	50		 push	 eax
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PlaySoundA@12
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0013b	8b 55 f0	 mov	 edx, DWORD PTR $T1[ebp+20]
  0013e	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00141	0f 82 b3 02 00
	00		 jb	 $LN14@Og?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00147	8b 4d dc	 mov	 ecx, DWORD PTR $T1[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0014a	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0014b	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0014d	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00153	72 26		 jb	 SHORT $LN86@Og?

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00155	8d 72 23	 lea	 esi, DWORD PTR [edx+35]
  00158	3b f2		 cmp	 esi, edx
  0015a	76 19		 jbe	 SHORT $_Invalid_parameter$121

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0015c	8b d6		 mov	 edx, esi
  0015e	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00160	75 13		 jne	 SHORT $_Invalid_parameter$121

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00162	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00165	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00167	73 0c		 jae	 SHORT $_Invalid_parameter$121

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00169	2b c1		 sub	 eax, ecx
  0016b	83 f8 04	 cmp	 eax, 4
  0016e	72 05		 jb	 SHORT $_Invalid_parameter$121

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00170	83 f8 23	 cmp	 eax, 35			; 00000023H
  00173	76 06		 jbe	 SHORT $LN86@Og?
$_Invalid_parameter$121:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN120@Og?:
$LN86@Og?:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0017b	52		 push	 edx
  0017c	51		 push	 ecx
  0017d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00182	83 c4 08	 add	 esp, 8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1119 : }

  00185	5f		 pop	 edi
  00186	5e		 pop	 esi
  00187	5b		 pop	 ebx
  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
$LN6@Og?:

; 1080 : 			}
; 1081 : 			else
; 1082 : 			{
; 1083 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku

  0018c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00192	b2 07		 mov	 dl, 7
  00194	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1084 : 				Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  00199	0f bf 05 08 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8
  001a0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__Sleep@4
  001a6	50		 push	 eax
  001a7	ff d6		 call	 esi

; 1085 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001af	b2 07		 mov	 dl, 7
  001b1	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1086 : 				Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  001b6	0f bf 05 08 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8
  001bd	50		 push	 eax
  001be	ff d6		 call	 esi

; 1117 : 			if (!G³osyKompletne) cout << '\a';  //Je¿eli nie ma wszystkich plików g³osów to wywo³anie pikniêcia w g³oniku

  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001c6	b2 07		 mov	 dl, 7
  001c8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1119 : }

  001cd	5f		 pop	 edi
  001ce	5e		 pop	 esi
  001cf	5b		 pop	 ebx
  001d0	8b e5		 mov	 esp, ebp
  001d2	5d		 pop	 ebp
  001d3	c3		 ret	 0
$LN2@Og?:

; 1087 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku
; 1088 : 			}
; 1089 : 		}
; 1090 : 	}
; 1091 : 	else if (wygrana == (kwota_zak³adu / 2)) //Je¿eli wygrana jest równa po³owie kwocie zak³adu to znaczy, ¿e dostaje siê zwrot po³owy kwoty zak³adu

  001d4	8b c7		 mov	 eax, edi
  001d6	99		 cdq
  001d7	2b c2		 sub	 eax, edx
  001d9	d1 f8		 sar	 eax, 1
  001db	3b f0		 cmp	 esi, eax
  001dd	0f 85 1e 01 00
	00		 jne	 $LN8@Og?

; 1092 : 	{
; 1093 : 		iloæ_pieniêdzy += wygrana; //Dopisanie do salda kwoty zwrotu z zak³adu
; 1094 : 		log << " Dostajesz polowe zak³adu " << wygrana << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie zwrotu zak³adu

  001e3	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  001e6	33 d2		 xor	 edx, edx
  001e8	8b 7d 08	 mov	 edi, DWORD PTR _iloæ_pieniêdzy$[ebp]
  001eb	8d 58 10	 lea	 ebx, DWORD PTR [eax+16]
  001ee	01 37		 add	 DWORD PTR [edi], esi
  001f0	85 c0		 test	 eax, eax
  001f2	ff 31		 push	 DWORD PTR [ecx]
  001f4	8b f3		 mov	 esi, ebx
  001f6	0f 44 f2	 cmove	 esi, edx
  001f9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
  001fe	51		 push	 ecx
  001ff	8b ce		 mov	 ecx, esi
  00201	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00206	83 c4 04	 add	 esp, 4
  00209	8b c8		 mov	 ecx, eax
  0020b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00211	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00216	8b c8		 mov	 ecx, eax
  00218	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1095 : 		log << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  0021d	ff 37		 push	 DWORD PTR [edi]
  0021f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00224	51		 push	 ecx
  00225	8b ce		 mov	 ecx, esi
  00227	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0022c	83 c4 04	 add	 esp, 4
  0022f	8b c8		 mov	 ecx, eax
  00231	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00237	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0023c	8b c8		 mov	 ecx, eax
  0023e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00243	b2 0a		 mov	 dl, 10			; 0000000aH
  00245	8b c8		 mov	 ecx, eax
  00247	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1096 : 		log_ogólny << " Dostajesz polowe zak³adu " << wygrana << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie zwrotu zak³adu

  0024c	8b 45 f8	 mov	 eax, DWORD PTR _wygrana$1$[ebp]
  0024f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
  00254	8b 75 0c	 mov	 esi, DWORD PTR _log_ogólny$[ebp]
  00257	ff 30		 push	 DWORD PTR [eax]
  00259	51		 push	 ecx
  0025a	8b ce		 mov	 ecx, esi
  0025c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00261	83 c4 04	 add	 esp, 4
  00264	8b c8		 mov	 ecx, eax
  00266	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0026c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00271	8b c8		 mov	 ecx, eax
  00273	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1097 : 		log_ogólny << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  00278	ff 37		 push	 DWORD PTR [edi]
  0027a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  0027f	51		 push	 ecx
  00280	8b ce		 mov	 ecx, esi
  00282	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00287	83 c4 04	 add	 esp, 4
  0028a	8b c8		 mov	 ecx, eax
  0028c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00292	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00297	8b c8		 mov	 ecx, eax
  00299	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0029e	b2 0a		 mov	 dl, 10			; 0000000aH
  002a0	8b c8		 mov	 ecx, eax
  002a2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1098 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  002a7	8b cb		 mov	 ecx, ebx
  002a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1099 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  002af	8b ce		 mov	 ecx, esi
  002b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1100 : 		if (Ustawienia.stan_dwiêków) //Je¿eli stan_dwiêków == 1

  002b7	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  002bf	0f 84 35 01 00
	00		 je	 $LN14@Og?

; 1101 : 			if (!G³osyKompletne) //Je¿eli nie ma wszystkich plików g³osów to

  002c5	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  002cc	0f 85 28 01 00
	00		 jne	 $LN14@Og?

; 1102 : 			{
; 1103 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku

  002d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002d8	b2 07		 mov	 dl, 7
  002da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1104 : 				Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  002df	0f bf 05 08 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8
  002e6	50		 push	 eax
  002e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 1117 : 			if (!G³osyKompletne) cout << '\a';  //Je¿eli nie ma wszystkich plików g³osów to wywo³anie pikniêcia w g³oniku

  002ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002f3	b2 07		 mov	 dl, 7
  002f5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1119 : }

  002fa	5f		 pop	 edi
  002fb	5e		 pop	 esi
  002fc	5b		 pop	 ebx
  002fd	8b e5		 mov	 esp, ebp
  002ff	5d		 pop	 ebp
  00300	c3		 ret	 0
$LN8@Og?:

; 1105 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku
; 1106 : 			}
; 1107 : 	}
; 1108 : 	else if (wygrana == 0) //Je¿eli wygrana jest równa 0 to znaczy, ¿e siê zak³ad przegra³o

  00301	85 f6		 test	 esi, esi
  00303	0f 85 f1 00 00
	00		 jne	 $LN14@Og?

; 1109 : 	{
; 1110 : 		log << " Przegrales " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o przegranej kwocie

  00309	8b 45 10	 mov	 eax, DWORD PTR _log$[ebp]
  0030c	33 c9		 xor	 ecx, ecx
  0030e	85 c0		 test	 eax, eax
  00310	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
  00315	57		 push	 edi
  00316	51		 push	 ecx
  00317	8d 58 10	 lea	 ebx, DWORD PTR [eax+16]
  0031a	8b f3		 mov	 esi, ebx
  0031c	0f 44 f1	 cmove	 esi, ecx
  0031f	8b ce		 mov	 ecx, esi
  00321	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00326	83 c4 04	 add	 esp, 4
  00329	8b c8		 mov	 ecx, eax
  0032b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00331	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00336	8b c8		 mov	 ecx, eax
  00338	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1111 : 		log << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  0033d	8b 7d 08	 mov	 edi, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00340	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00345	ff 37		 push	 DWORD PTR [edi]
  00347	51		 push	 ecx
  00348	8b ce		 mov	 ecx, esi
  0034a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0034f	83 c4 04	 add	 esp, 4
  00352	8b c8		 mov	 ecx, eax
  00354	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0035a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0035f	8b c8		 mov	 ecx, eax
  00361	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00366	b2 0a		 mov	 dl, 10			; 0000000aH
  00368	8b c8		 mov	 ecx, eax
  0036a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1112 : 		log_ogólny << " Przegrales " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o przegranej kwocie

  0036f	8b 45 f4	 mov	 eax, DWORD PTR _kwota_zak³adu$1$[ebp]
  00372	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
  00377	8b 75 0c	 mov	 esi, DWORD PTR _log_ogólny$[ebp]
  0037a	ff 30		 push	 DWORD PTR [eax]
  0037c	51		 push	 ecx
  0037d	8b ce		 mov	 ecx, esi
  0037f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00384	83 c4 04	 add	 esp, 4
  00387	8b c8		 mov	 ecx, eax
  00389	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0038f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00394	8b c8		 mov	 ecx, eax
  00396	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1113 : 		log_ogólny << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  0039b	ff 37		 push	 DWORD PTR [edi]
  0039d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  003a2	51		 push	 ecx
  003a3	8b ce		 mov	 ecx, esi
  003a5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003aa	83 c4 04	 add	 esp, 4
  003ad	8b c8		 mov	 ecx, eax
  003af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  003b5	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  003ba	8b c8		 mov	 ecx, eax
  003bc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003c1	b2 0a		 mov	 dl, 10			; 0000000aH
  003c3	8b c8		 mov	 ecx, eax
  003c5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1114 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  003ca	8b cb		 mov	 ecx, ebx
  003cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1115 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  003d2	8b ce		 mov	 ecx, esi
  003d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1116 : 		if (Ustawienia.stan_dwiêków)

  003da	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  003e2	74 16		 je	 SHORT $LN14@Og?

; 1117 : 			if (!G³osyKompletne) cout << '\a';  //Je¿eli nie ma wszystkich plików g³osów to wywo³anie pikniêcia w g³oniku

  003e4	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  003eb	75 0d		 jne	 SHORT $LN14@Og?
  003ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  003f3	b2 07		 mov	 dl, 7
  003f5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
$LN14@Og?:

; 1119 : }

  003fa	5f		 pop	 edi
  003fb	5e		 pop	 esi
  003fc	5b		 pop	 ebx
  003fd	8b e5		 mov	 esp, ebp
  003ff	5d		 pop	 ebp
  00400	c3		 ret	 0
$LN119@Og?:
?Og³o_wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ENDP ; Og³o_wynik
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Koniec_gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z
_TEXT	SEGMENT
_iloæ_pieniêdzy$ = 8					; size = 4
?Koniec_gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z PROC ; Koniec_gry, COMDAT
; _log_ogólny$ = ecx
; _log$ = edx

; 1122 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx

; 1123 : 	cout << endl << "Koñczysz grê z wynikiem " << iloæ_pieniêdzy << "$" << endl; //Poinformowanie u¿ytkownika o saldzie konta

  00007	8b 45 08	 mov	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00012	ff 30		 push	 DWORD PTR [eax]
  00014	8b f9		 mov	 edi, ecx
  00016	8b da		 mov	 ebx, edx
  00018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0001e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00029	51		 push	 ecx
  0002a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  0002f	8b c8		 mov	 ecx, eax
  00031	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00036	83 c4 04	 add	 esp, 4
  00039	8b c8		 mov	 ecx, eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00041	51		 push	 ecx
  00042	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00047	8b c8		 mov	 ecx, eax
  00049	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0004e	83 c4 04	 add	 esp, 4
  00051	8b c8		 mov	 ecx, eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1124 : 	log << '\n' << "Koñczysz grê z wynikiem " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  00059	8b 45 08	 mov	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  0005c	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  0005f	b2 0a		 mov	 dl, 10			; 0000000aH
  00061	ff 30		 push	 DWORD PTR [eax]
  00063	33 c0		 xor	 eax, eax
  00065	85 db		 test	 ebx, ebx
  00067	0f 44 c8	 cmove	 ecx, eax
  0006a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
  0006f	51		 push	 ecx
  00070	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  00075	8b c8		 mov	 ecx, eax
  00077	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0007c	83 c4 04	 add	 esp, 4
  0007f	8b c8		 mov	 ecx, eax
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00087	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  0008c	8b c8		 mov	 ecx, eax
  0008e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00093	b2 0a		 mov	 dl, 10			; 0000000aH
  00095	8b c8		 mov	 ecx, eax
  00097	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1125 : 	log_ogólny << "Koñczysz grê z wynikiem " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  0009c	8b 45 08	 mov	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  0009f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  000a4	ff 30		 push	 DWORD PTR [eax]
  000a6	51		 push	 ecx
  000a7	8b cf		 mov	 ecx, edi
  000a9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000ae	83 c4 04	 add	 esp, 4
  000b1	8b c8		 mov	 ecx, eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000b9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000be	8b c8		 mov	 ecx, eax
  000c0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000c5	b2 0a		 mov	 dl, 10			; 0000000aH
  000c7	8b c8		 mov	 ecx, eax
  000c9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1126 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  000ce	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1127 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000d7	8b cf		 mov	 ecx, edi
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1128 : 	log.close(); //Zamkniêcie pliku log aktualny

  000df	8b cb		 mov	 ecx, ebx
  000e1	e8 00 00 00 00	 call	 ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::close

; 1129 : 	remove("log_aktualny.txt"); //Usuniêcie pliku log aktualny poniewa¿ skoñczy³o siê grê

  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__remove

; 1130 : 
; 1131 : 	if (Ustawienia.stan_dwiêków == 1) //Je¿eli stan_dwiêków == 1

  000f1	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__PlaySoundA@12
  000f7	83 c4 04	 add	 esp, 4
  000fa	66 83 3d 10 00
	00 00 01	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 1

; 1132 : 		if (iloæ_pieniêdzy == 0) //Je¿eli bud¿et jest równy 0 to

  00102	8b 75 08	 mov	 esi, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00105	75 48		 jne	 SHORT $LN3@Koniec_gry
  00107	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0010a	75 43		 jne	 SHORT $LN3@Koniec_gry

; 1133 : 			if (EfektyKompletne) PlaySound("Efekty_dwiêkowe/bankrut.wav", nullptr, SND_SYNC); //Je¿eli pliki efektów s¹ dostêpne, odtworzenie efektu bankruta

  0010c	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  00113	74 0d		 je	 SHORT $LN7@Koniec_gry
  00115	6a 00		 push	 0
  00117	6a 00		 push	 0
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  0011e	ff d3		 call	 ebx

; 1134 : 			else //W przeciwym wypadku

  00120	eb 2d		 jmp	 SHORT $LN3@Koniec_gry
$LN7@Koniec_gry:

; 1135 : 				for (unsigned short i = 0; i < 5; ++i) //Rozpoczêcie pêtli która wykona 5 obrotów

  00122	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Sleep@4
  00128	be 05 00 00 00	 mov	 esi, 5
  0012d	0f 1f 00	 npad	 3
$LL4@Koniec_gry:

; 1136 : 				{
; 1137 : 					cout << '\a'; //Wywo³anie pikniêcia w g³oniku

  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00136	b2 07		 mov	 dl, 7
  00138	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1138 : 					Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem //Przerwa przed kolejnym pikniêciem

  0013d	0f bf 05 08 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8
  00144	50		 push	 eax
  00145	ff d7		 call	 edi
  00147	83 ee 01	 sub	 esi, 1
  0014a	75 e4		 jne	 SHORT $LL4@Koniec_gry

; 1130 : 
; 1131 : 	if (Ustawienia.stan_dwiêków == 1) //Je¿eli stan_dwiêków == 1

  0014c	8b 75 08	 mov	 esi, DWORD PTR _iloæ_pieniêdzy$[ebp]
$LN3@Koniec_gry:

; 1139 : 				}
; 1140 : 
; 1141 : 	if (iloæ_pieniêdzy > Ustawienia.kwota_pocz¹tkowa && iloæ_pieniêdzy < Ustawienia.kwota_pocz¹tkowa * 2) //Sprawdzenie czy zwiêkszy³o siê bud¿et

  0014f	8b 16		 mov	 edx, DWORD PTR [esi]
  00151	8b 35 0c 00 00
	00		 mov	 esi, DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12
  00157	3b d6		 cmp	 edx, esi
  00159	7e 49		 jle	 SHORT $LN9@Koniec_gry
  0015b	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  0015e	3b d0		 cmp	 edx, eax
  00160	7d 42		 jge	 SHORT $LN9@Koniec_gry

; 1142 : 	{
; 1143 : 		cout << "Gratuluje zwiêkszy³e swój zasób finansowy" << endl; //Wywietlenie gratulacji z powodu zwiêkszenia bud¿etu

  00162	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00167	51		 push	 ecx
  00168	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@
  00173	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00178	83 c4 04	 add	 esp, 4
  0017b	8b c8		 mov	 ecx, eax
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1144 : 		if (EfektyKompletne) //Je¿eli pliki efektów s¹ dostêpne

  00183	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  0018a	74 72		 je	 SHORT $LN15@Koniec_gry

; 1145 : 			if (rand() % 1) PlaySound("Efekty_dwiêkowe/wygrana1.wav", nullptr, SND_SYNC); //Wylosowanie numeru otworzonego efektu, odtworzenie je¿eli wylosowano efekt 0

  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand

; 1146 : 			else PlaySound("Efekty_dwiêkowe/wygrana2.wav", nullptr, SND_SYNC); //Odtworzenie je¿eli wylosowano efekt 1

  00192	6a 00		 push	 0
  00194	6a 00		 push	 0
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@

; 1151 : 		if (EfektyKompletne) PlaySound("Efekty_dwiêkowe/zwielokrotnenie.wav", nullptr, SND_SYNC); //Odtworzenie efektu dwiêkowego wzamian za zwielokrotnienie bud¿etu, je¿eli pliki efektów s¹ dostêpne

  0019b	ff d3		 call	 ebx

; 1152 : 	}
; 1153 : }

  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	5b		 pop	 ebx
  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c3		 ret	 0
$LN9@Koniec_gry:

; 1147 : 	}
; 1148 : 	else if (iloæ_pieniêdzy >= Ustawienia.kwota_pocz¹tkowa * 2) //Sprawdzenie czy zwielokrotniono przynajmniej 2 razy bud¿et

  001a4	8d 0c 36	 lea	 ecx, DWORD PTR [esi+esi]
  001a7	3b d1		 cmp	 edx, ecx
  001a9	7c 53		 jl	 SHORT $LN15@Koniec_gry

; 1149 : 	{
; 1150 : 		cout << "Gratuluje zwiêkszy³e " << iloæ_pieniêdzy / Ustawienia.kwota_pocz¹tkowa << " krotnie swój zasób finansowy" << endl; //Wywietlenie gratulacji z powodu zwielokrotnienia przynajmniej 2 razy bud¿etu

  001ab	8b c2		 mov	 eax, edx
  001ad	99		 cdq
  001ae	f7 fe		 idiv	 esi
  001b0	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001b5	50		 push	 eax
  001b6	51		 push	 ecx
  001b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001bd	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@
  001c2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001c7	83 c4 04	 add	 esp, 4
  001ca	8b c8		 mov	 ecx, eax
  001cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  001d2	51		 push	 ecx
  001d3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@
  001d8	8b c8		 mov	 ecx, eax
  001da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001df	83 c4 04	 add	 esp, 4
  001e2	8b c8		 mov	 ecx, eax
  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1151 : 		if (EfektyKompletne) PlaySound("Efekty_dwiêkowe/zwielokrotnenie.wav", nullptr, SND_SYNC); //Odtworzenie efektu dwiêkowego wzamian za zwielokrotnienie bud¿etu, je¿eli pliki efektów s¹ dostêpne

  001ea	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  001f1	74 0b		 je	 SHORT $LN15@Koniec_gry
  001f3	6a 00		 push	 0
  001f5	6a 00		 push	 0
  001f7	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  001fc	ff d3		 call	 ebx
$LN15@Koniec_gry:

; 1152 : 	}
; 1153 : }

  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
  00200	5b		 pop	 ebx
  00201	8b e5		 mov	 esp, ebp
  00203	5d		 pop	 ebp
  00204	c3		 ret	 0
?Koniec_gry@@YAXAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@ABH@Z ENDP ; Koniec_gry
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Pêtla_g³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
$T43 = -36						; size = 4
_kwota_zak³adu$1$ = -32					; size = 4
_wygrana$1$ = -28					; size = 4
$T1 = -24						; size = 24
_iloæ_pieniêdzy$ = 8					; size = 4
_log_ogólny$ = 12					; size = 4
_log$ = 16						; size = 4
_co_kontynuowaæ$ = 20					; size = 4
_typ_zak³adu$ = 24					; size = 4
_wylosowana_liczba$ = 28				; size = 4
?Pêtla_g³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; Pêtla_g³ówna, COMDAT
; _wygrana$ = ecx
; _kwota_zak³adu$ = edx

; 1156 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 24	 sub	 esp, 36			; 00000024H

; 1157 : 	if (co_kontynuowaæ == 'n') Wczytaj_Kwotê_Zak³adu(kwota_zak³adu, iloæ_pieniêdzy); //Przypisanie do zmiennej pobranej od u¿ytkownika kwoty zak³adu

  00009	8b 45 08	 mov	 eax, DWORD PTR _iloæ_pieniêdzy$[ebp]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b 75 14	 mov	 esi, DWORD PTR _co_kontynuowaæ$[ebp]
  00011	8b da		 mov	 ebx, edx
  00013	57		 push	 edi
  00014	89 5c 24 10	 mov	 DWORD PTR _kwota_zak³adu$1$[esp+48], ebx
  00018	89 4c 24 14	 mov	 DWORD PTR _wygrana$1$[esp+48], ecx
  0001c	80 3e 6e	 cmp	 BYTE PTR [esi], 110	; 0000006eH
  0001f	75 0b		 jne	 SHORT $LN2@P?
  00021	8b d0		 mov	 edx, eax
  00023	8b cb		 mov	 ecx, ebx
  00025	e8 00 00 00 00	 call	 ?Wczytaj_Kwotê_Zak³adu@@YAXAAHABH@Z ; Wczytaj_Kwotê_Zak³adu

; 1158 : 	else

  0002a	eb 76		 jmp	 SHORT $LN3@P?
$LN2@P?:

; 1159 : 	{
; 1160 : 		cout << "Masz " << iloæ_pieniêdzy << "$" << endl; //Wypisanie wczytanej informacji o posiadanej iloci pieniêdzy

  0002c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00031	ff 30		 push	 DWORD PTR [eax]
  00033	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05OMMBNPEF@Masz?5?$AA@
  00038	51		 push	 ecx
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0003f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00044	83 c4 04	 add	 esp, 4
  00047	8b c8		 mov	 ecx, eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0004f	51		 push	 ecx
  00050	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00055	8b c8		 mov	 ecx, eax
  00057	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0005c	83 c4 04	 add	 esp, 4
  0005f	8b c8		 mov	 ecx, eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 1161 : 		cout << "Obstawiono za " << kwota_zak³adu << "$" << endl; //Wypisanie wczytanej kwoty zak³adu

  00067	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0006c	ff 33		 push	 DWORD PTR [ebx]
  0006e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  00073	51		 push	 ecx
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0007a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0007f	83 c4 04	 add	 esp, 4
  00082	8b c8		 mov	 ecx, eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0008a	51		 push	 ecx
  0008b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00090	8b c8		 mov	 ecx, eax
  00092	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00097	83 c4 04	 add	 esp, 4
  0009a	8b c8		 mov	 ecx, eax
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN3@P?:

; 1162 : 	}
; 1163 : 	if (co_kontynuowaæ == 'n') log << "Obstawiono za " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie obstawionego zak³adu

  000a2	8b 55 10	 mov	 edx, DWORD PTR _log$[ebp]
  000a5	8a 06		 mov	 al, BYTE PTR [esi]
  000a7	8d 7a 10	 lea	 edi, DWORD PTR [edx+16]
  000aa	89 7c 24 0c	 mov	 DWORD PTR $T43[esp+48], edi
  000ae	3c 6e		 cmp	 al, 110			; 0000006eH
  000b0	75 31		 jne	 SHORT $LN266@P?
  000b2	ff 33		 push	 DWORD PTR [ebx]
  000b4	33 c0		 xor	 eax, eax
  000b6	8b cf		 mov	 ecx, edi
  000b8	85 d2		 test	 edx, edx
  000ba	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  000bf	0f 44 c8	 cmove	 ecx, eax
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000c8	83 c4 04	 add	 esp, 4
  000cb	8b c8		 mov	 ecx, eax
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  000d3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  000d8	8b c8		 mov	 ecx, eax
  000da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000df	8a 06		 mov	 al, BYTE PTR [esi]
  000e1	eb 04		 jmp	 SHORT $LN4@P?
$LN266@P?:
  000e3	89 7c 24 0c	 mov	 DWORD PTR $T43[esp+48], edi
$LN4@P?:

; 1164 : 	if (co_kontynuowaæ == 'n') log_ogólny << "Obstawiono za " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie obstawionego zak³adu

  000e7	8b 5d 0c	 mov	 ebx, DWORD PTR _log_ogólny$[ebp]
  000ea	3c 6e		 cmp	 al, 110			; 0000006eH
  000ec	75 2e		 jne	 SHORT $LN5@P?
  000ee	8b 44 24 10	 mov	 eax, DWORD PTR _kwota_zak³adu$1$[esp+48]
  000f2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  000f7	ff 30		 push	 DWORD PTR [eax]
  000f9	51		 push	 ecx
  000fa	8b cb		 mov	 ecx, ebx
  000fc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00101	83 c4 04	 add	 esp, 4
  00104	8b c8		 mov	 ecx, eax
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0010c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EPMOAMKG@$?$AA@
  00111	8b c8		 mov	 ecx, eax
  00113	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00118	89 7c 24 0c	 mov	 DWORD PTR $T43[esp+48], edi
$LN5@P?:

; 1165 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0011c	8b cf		 mov	 ecx, edi
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1166 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00124	8b cb		 mov	 ecx, ebx
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1167 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  0012c	8a 06		 mov	 al, BYTE PTR [esi]
  0012e	3c 6e		 cmp	 al, 110			; 0000006eH
  00130	74 41		 je	 SHORT $LN8@P?
  00132	3c 6b		 cmp	 al, 107			; 0000006bH
  00134	74 3d		 je	 SHORT $LN8@P?

; 1168 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  00136	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0013c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@
  00141	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3047 : 		return (this->_Get_data()._Mysize);

  00146	8b 5d 18	 mov	 ebx, DWORD PTR _typ_zak³adu$[ebp]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00149	8b d3		 mov	 edx, ebx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0014b	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0014f	72 02		 jb	 SHORT $LN267@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00151	8b 13		 mov	 edx, DWORD PTR [ebx]
$LN267@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1168 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  00153	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  00158	51		 push	 ecx
  00159	ff 73 10	 push	 DWORD PTR [ebx+16]
  0015c	8b c8		 mov	 ecx, eax
  0015e	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  00163	83 c4 08	 add	 esp, 8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1168 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  00166	8b c8		 mov	 ecx, eax
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0016e	e9 86 00 00 00	 jmp	 $LN145@P?
$LN8@P?:

; 1167 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  00173	8d 4c 24 18	 lea	 ecx, DWORD PTR $T1[esp+48]
  00177	e8 00 00 00 00	 call	 ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2071 : 		if (this != _STD addressof(_Right))

  0017c	8b 5d 18	 mov	 ebx, DWORD PTR _typ_zak³adu$[ebp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1167 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  0017f	8b f8		 mov	 edi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2071 : 		if (this != _STD addressof(_Right))

  00181	3b df		 cmp	 ebx, edi
  00183	74 28		 je	 SHORT $LN105@P?

; 2072 : 			{	// different, assign it
; 2073 : 			_Tidy_deallocate();

  00185	8b cb		 mov	 ecx, ebx
  00187	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0018c	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  0018f	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  00192	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  00197	66 0f d6 43 10	 movq	 QWORD PTR [ebx+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  0019c	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001a3	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  001aa	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN105@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001ad	8b 54 24 2c	 mov	 edx, DWORD PTR $T1[esp+68]
  001b1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  001b4	72 3f		 jb	 SHORT $LN269@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001b6	8b 4c 24 18	 mov	 ecx, DWORD PTR $T1[esp+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001ba	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001bb	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001bd	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001c3	72 26		 jb	 SHORT $LN148@P?

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001c5	8d 7a 23	 lea	 edi, DWORD PTR [edx+35]
  001c8	3b fa		 cmp	 edi, edx
  001ca	76 19		 jbe	 SHORT $_Invalid_parameter$275

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001cc	8b d7		 mov	 edx, edi
  001ce	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001d0	75 13		 jne	 SHORT $_Invalid_parameter$275

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001d2	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001d5	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  001d7	73 0c		 jae	 SHORT $_Invalid_parameter$275

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001d9	2b c1		 sub	 eax, ecx
  001db	83 f8 04	 cmp	 eax, 4
  001de	72 05		 jb	 SHORT $_Invalid_parameter$275

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  001e0	83 f8 23	 cmp	 eax, 35			; 00000023H
  001e3	76 06		 jbe	 SHORT $LN148@P?
$_Invalid_parameter$275:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN274@P?:
$LN148@P?:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  001eb	52		 push	 edx
  001ec	51		 push	 ecx
  001ed	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001f2	83 c4 08	 add	 esp, 8
$LN269@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3694 : 		if (_My_data._Large_string_engaged())

  001f5	8b 7c 24 0c	 mov	 edi, DWORD PTR $T43[esp+48]
$LN145@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1169 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') log << " Obstawiono zaklad " << typ_zak³adu; //Zapisanie do bufora pliku logu aktualnego informacji o typie obstawionego zak³adu

  001f9	8a 06		 mov	 al, BYTE PTR [esi]
  001fb	3c 6e		 cmp	 al, 110			; 0000006eH
  001fd	74 04		 je	 SHORT $LN10@P?
  001ff	3c 6b		 cmp	 al, 107			; 0000006bH
  00201	75 2d		 jne	 SHORT $LN9@P?
$LN10@P?:
  00203	33 c0		 xor	 eax, eax
  00205	8b cf		 mov	 ecx, edi
  00207	39 45 10	 cmp	 DWORD PTR _log$[ebp], eax
  0020a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
  0020f	0f 44 c8	 cmove	 ecx, eax
  00212	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00217	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0021b	8b d3		 mov	 edx, ebx

; 1594 : 		if (_Large_string_engaged())

  0021d	72 02		 jb	 SHORT $LN268@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0021f	8b 13		 mov	 edx, DWORD PTR [ebx]
$LN268@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  00221	ff 73 10	 push	 DWORD PTR [ebx+16]
  00224	8b c8		 mov	 ecx, eax
  00226	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  0022b	8a 06		 mov	 al, BYTE PTR [esi]
  0022d	83 c4 04	 add	 esp, 4
$LN9@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1170 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') log_ogólny << " Obstawiono zaklad " << typ_zak³adu; //Zapisanie do bufora pliku logu ogólnego informacji o typie obstawionego zak³adu

  00230	3c 6e		 cmp	 al, 110			; 0000006eH
  00232	74 04		 je	 SHORT $LN12@P?
  00234	3c 6b		 cmp	 al, 107			; 0000006bH
  00236	75 24		 jne	 SHORT $LN11@P?
$LN12@P?:
  00238	8b 4d 0c	 mov	 ecx, DWORD PTR _log_ogólny$[ebp]
  0023b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
  00240	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00245	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00249	8b d3		 mov	 edx, ebx

; 1594 : 		if (_Large_string_engaged())

  0024b	72 02		 jb	 SHORT $LN254@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0024d	8b 13		 mov	 edx, DWORD PTR [ebx]
$LN254@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  0024f	ff 73 10	 push	 DWORD PTR [ebx+16]
  00252	8b c8		 mov	 ecx, eax
  00254	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  00259	83 c4 04	 add	 esp, 4
$LN11@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1171 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0025c	8b cf		 mov	 ecx, edi
  0025e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1172 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00264	8b 4d 0c	 mov	 ecx, DWORD PTR _log_ogólny$[ebp]
  00267	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1173 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') iloæ_pieniêdzy -= kwota_zak³adu; //Odjêcie od iloci pieniêdzy kwoty zak³adu

  0026d	8a 06		 mov	 al, BYTE PTR [esi]
  0026f	3c 6e		 cmp	 al, 110			; 0000006eH
  00271	74 0c		 je	 SHORT $LN14@P?
  00273	3c 6b		 cmp	 al, 107			; 0000006bH
  00275	74 08		 je	 SHORT $LN14@P?
  00277	3c 74		 cmp	 al, 116			; 00000074H
  00279	74 04		 je	 SHORT $LN14@P?
  0027b	3c 77		 cmp	 al, 119			; 00000077H
  0027d	75 0d		 jne	 SHORT $LN13@P?
$LN14@P?:
  0027f	8b 44 24 10	 mov	 eax, DWORD PTR _kwota_zak³adu$1$[esp+48]
  00283	8b 4d 08	 mov	 ecx, DWORD PTR _iloæ_pieniêdzy$[ebp]
  00286	8b 00		 mov	 eax, DWORD PTR [eax]
  00288	29 01		 sub	 DWORD PTR [ecx], eax
  0028a	8a 06		 mov	 al, BYTE PTR [esi]
$LN13@P?:

; 1174 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') cout << "Kulka w grze, zaczekaj na wylosowanie numeru..." << endl; //Poinformowanie u¿ytkownika o rozpoczêciu losowania

  0028c	3c 6e		 cmp	 al, 110			; 0000006eH
  0028e	74 08		 je	 SHORT $LN16@P?
  00290	3c 6b		 cmp	 al, 107			; 0000006bH
  00292	74 04		 je	 SHORT $LN16@P?
  00294	3c 74		 cmp	 al, 116			; 00000074H
  00296	75 23		 jne	 SHORT $LN15@P?
$LN16@P?:
  00298	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0029d	51		 push	 ecx
  0029e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002a4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@
  002a9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002ae	83 c4 04	 add	 esp, 4
  002b1	8b c8		 mov	 ecx, eax
  002b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  002b9	8a 06		 mov	 al, BYTE PTR [esi]
$LN15@P?:

; 1175 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') wylosowana_liczba = Zakrêæ_Ruletk¹(); //Wylosowanie i przypisanie do zmiennej liczby bêdêcej na  wylosowanej pozycji na kole ruletki

  002bb	3c 6e		 cmp	 al, 110			; 0000006eH
  002bd	74 6f		 je	 SHORT $LN19@P?
  002bf	3c 6b		 cmp	 al, 107			; 0000006bH
  002c1	74 6b		 je	 SHORT $LN19@P?
  002c3	3c 74		 cmp	 al, 116			; 00000074H
  002c5	74 67		 je	 SHORT $LN19@P?

; 1176 : 	else {
; 1177 : 		cout << "Wylosowano numer "; //Poinformowaniu o wylosowaniu liczby

  002c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002cd	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
  002d2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 1178 : 		Change_Col(Ruletka_plansza_kolor_col[wylosowana_liczba]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  002d7	8b 45 1c	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  002da	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetStdHandle@4
  002e0	6a f5		 push	 -11			; fffffff5H

; 1178 : 		Change_Col(Ruletka_plansza_kolor_col[wylosowana_liczba]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  002e2	8b 00		 mov	 eax, DWORD PTR [eax]
  002e4	0f b7 34 45 00
	00 00 00	 movzx	 esi, WORD PTR ?Ruletka_plansza_kolor_col@@3QBGB[eax*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  002ec	ff d7		 call	 edi

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  002ee	56		 push	 esi
  002ef	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetConsoleTextAttribute@8
  002f5	50		 push	 eax
  002f6	ff d6		 call	 esi

; 1179 : 		cout << wylosowana_liczba; //Wypisanie wylosowanej liczby

  002f8	8b 45 1c	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  002fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00301	ff 30		 push	 DWORD PTR [eax]
  00303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00309	6a f5		 push	 -11			; fffffff5H
  0030b	ff d7		 call	 edi

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0030d	6a 07		 push	 7
  0030f	50		 push	 eax
  00310	ff d6		 call	 esi

; 1180 : 		Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 1181 : 		cout << ". "; //Wypisanie kropki koñcz¹cej zdanie

  00312	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00318	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02KHOJGJKF@?4?5?$AA@
  0031d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00322	8b 75 14	 mov	 esi, DWORD PTR _co_kontynuowaæ$[ebp]
  00325	8b 7c 24 0c	 mov	 edi, DWORD PTR $T43[esp+48]
  00329	8b 4d 1c	 mov	 ecx, DWORD PTR _wylosowana_liczba$[ebp]
  0032c	eb 0a		 jmp	 SHORT $LN18@P?
$LN19@P?:

; 1175 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') wylosowana_liczba = Zakrêæ_Ruletk¹(); //Wylosowanie i przypisanie do zmiennej liczby bêdêcej na  wylosowanej pozycji na kole ruletki

  0032e	e8 00 00 00 00	 call	 ?Zakrêæ_Ruletk¹@@YAHXZ	; Zakrêæ_Ruletk¹
  00333	8b 4d 1c	 mov	 ecx, DWORD PTR _wylosowana_liczba$[ebp]
  00336	89 01		 mov	 DWORD PTR [ecx], eax
$LN18@P?:

; 1182 : 	}
; 1183 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') log << " Wylosowano " << wylosowana_liczba; //Zapisanie do bufora pliku logu aktualnego informacji o wylosowanej liczbie

  00338	8a 06		 mov	 al, BYTE PTR [esi]
  0033a	3c 6e		 cmp	 al, 110			; 0000006eH
  0033c	74 08		 je	 SHORT $LN21@P?
  0033e	3c 6b		 cmp	 al, 107			; 0000006bH
  00340	74 04		 je	 SHORT $LN21@P?
  00342	3c 74		 cmp	 al, 116			; 00000074H
  00344	75 24		 jne	 SHORT $LN20@P?
$LN21@P?:
  00346	ff 31		 push	 DWORD PTR [ecx]
  00348	33 c0		 xor	 eax, eax
  0034a	8b cf		 mov	 ecx, edi
  0034c	39 45 10	 cmp	 DWORD PTR _log$[ebp], eax
  0034f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
  00354	0f 44 c8	 cmove	 ecx, eax
  00357	51		 push	 ecx
  00358	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0035d	83 c4 04	 add	 esp, 4
  00360	8b c8		 mov	 ecx, eax
  00362	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00368	8a 06		 mov	 al, BYTE PTR [esi]
$LN20@P?:

; 1184 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') log_ogólny << " Wylosowano " << wylosowana_liczba; //Zapisanie do bufora pliku logu ogólnego informacji o wylosowanej liczbie

  0036a	3c 6e		 cmp	 al, 110			; 0000006eH
  0036c	74 08		 je	 SHORT $LN23@P?
  0036e	3c 6b		 cmp	 al, 107			; 0000006bH
  00370	74 04		 je	 SHORT $LN23@P?
  00372	3c 74		 cmp	 al, 116			; 00000074H
  00374	75 1e		 jne	 SHORT $LN22@P?
$LN23@P?:
  00376	8b 45 1c	 mov	 eax, DWORD PTR _wylosowana_liczba$[ebp]
  00379	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
  0037e	ff 30		 push	 DWORD PTR [eax]
  00380	51		 push	 ecx
  00381	8b 4d 0c	 mov	 ecx, DWORD PTR _log_ogólny$[ebp]
  00384	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00389	83 c4 04	 add	 esp, 4
  0038c	8b c8		 mov	 ecx, eax
  0038e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
$LN22@P?:

; 1185 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  00394	8b cf		 mov	 ecx, edi
  00396	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1186 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  0039c	8b 4d 0c	 mov	 ecx, DWORD PTR _log_ogólny$[ebp]
  0039f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1187 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') Odczytaj_liczbê(wylosowana_liczba, typ_zak³adu);

  003a5	8a 06		 mov	 al, BYTE PTR [esi]
  003a7	3c 6e		 cmp	 al, 110			; 0000006eH
  003a9	74 08		 je	 SHORT $LN25@P?
  003ab	3c 6b		 cmp	 al, 107			; 0000006bH
  003ad	74 04		 je	 SHORT $LN25@P?
  003af	3c 74		 cmp	 al, 116			; 00000074H
  003b1	75 10		 jne	 SHORT $LN270@P?
$LN25@P?:
  003b3	8b 7d 1c	 mov	 edi, DWORD PTR _wylosowana_liczba$[ebp]
  003b6	8b d3		 mov	 edx, ebx
  003b8	8b cf		 mov	 ecx, edi
  003ba	e8 00 00 00 00	 call	 ?Odczytaj_liczbê@@YAXABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Odczytaj_liczbê
  003bf	8a 06		 mov	 al, BYTE PTR [esi]
  003c1	eb 03		 jmp	 SHORT $LN24@P?
$LN270@P?:
  003c3	8b 7d 1c	 mov	 edi, DWORD PTR _wylosowana_liczba$[ebp]
$LN24@P?:

; 1188 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') wygrana = Sprawd_Zak³ad(kwota_zak³adu, typ_zak³adu, wylosowana_liczba); //Przypisanie do wygranej kwoty zgodnej z wygran¹, je¿eli siê cowygra³o

  003c6	3c 6e		 cmp	 al, 110			; 0000006eH
  003c8	74 0c		 je	 SHORT $LN27@P?
  003ca	3c 6b		 cmp	 al, 107			; 0000006bH
  003cc	74 08		 je	 SHORT $LN27@P?
  003ce	3c 74		 cmp	 al, 116			; 00000074H
  003d0	74 04		 je	 SHORT $LN27@P?
  003d2	3c 77		 cmp	 al, 119			; 00000077H
  003d4	75 1b		 jne	 SHORT $LN271@P?
$LN27@P?:
  003d6	8b d3		 mov	 edx, ebx
  003d8	8b 5c 24 10	 mov	 ebx, DWORD PTR _kwota_zak³adu$1$[esp+48]
  003dc	57		 push	 edi
  003dd	8b cb		 mov	 ecx, ebx
  003df	e8 00 00 00 00	 call	 ?Sprawd_Zak³ad@@YAHABHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Sprawd_Zak³ad
  003e4	8b 4c 24 18	 mov	 ecx, DWORD PTR _wygrana$1$[esp+52]
  003e8	83 c4 04	 add	 esp, 4
  003eb	89 01		 mov	 DWORD PTR [ecx], eax
  003ed	8a 06		 mov	 al, BYTE PTR [esi]
  003ef	eb 08		 jmp	 SHORT $LN26@P?
$LN271@P?:
  003f1	8b 5c 24 10	 mov	 ebx, DWORD PTR _kwota_zak³adu$1$[esp+48]
  003f5	8b 4c 24 14	 mov	 ecx, DWORD PTR _wygrana$1$[esp+48]
$LN26@P?:

; 1189 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') Og³o_wynik(wygrana, kwota_zak³adu, iloæ_pieniêdzy, log_ogólny, log); //Funkcja informuj¹ca u¿ytkownika czy wygra³ zak³ad

  003f9	3c 6e		 cmp	 al, 110			; 0000006eH
  003fb	74 0c		 je	 SHORT $LN29@P?
  003fd	3c 6b		 cmp	 al, 107			; 0000006bH
  003ff	74 08		 je	 SHORT $LN29@P?
  00401	3c 74		 cmp	 al, 116			; 00000074H
  00403	74 04		 je	 SHORT $LN29@P?
  00405	3c 77		 cmp	 al, 119			; 00000077H
  00407	75 13		 jne	 SHORT $LN28@P?
$LN29@P?:
  00409	ff 75 10	 push	 DWORD PTR _log$[ebp]
  0040c	8b d3		 mov	 edx, ebx
  0040e	ff 75 0c	 push	 DWORD PTR _log_ogólny$[ebp]
  00411	ff 75 08	 push	 DWORD PTR _iloæ_pieniêdzy$[ebp]
  00414	e8 00 00 00 00	 call	 ?Og³o_wynik@@YAXABH0AAHAAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ; Og³o_wynik
  00419	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@P?:

; 1190 : }

  0041c	5f		 pop	 edi
  0041d	5e		 pop	 esi
  0041e	5b		 pop	 ebx
  0041f	8b e5		 mov	 esp, ebp
  00421	5d		 pop	 ebp
  00422	c3		 ret	 0
$LN273@P?:
?Pêtla_g³ówna@@YAXAAH00AAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AAV?$basic_fstream@DU?$char_traits@D@std@@@2@AADAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; Pêtla_g³ówna
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Ustaw_ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
?Ustaw_ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Ustaw_ustawienia, COMDAT
; _tekst$ = ecx

; 1192 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 1193 : 	if (tekst.find("iloæ_minimalna_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00003	51		 push	 ecx
  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00010	83 f8 ff	 cmp	 eax, -1
  00013	0f 84 93 00 00
	00		 je	 $LN35@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00019	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0001c	8d 5e 10	 lea	 ebx, DWORD PTR [esi+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0001f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00024	8b d6		 mov	 edx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00026	3b c1		 cmp	 eax, ecx
  00028	0f 42 c8	 cmovb	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0002b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1583 : 		if (_Large_string_engaged())

  0002f	72 02		 jb	 SHORT $LN963@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00031	8b 16		 mov	 edx, DWORD PTR [esi]
$LN963@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00033	2b c1		 sub	 eax, ecx

; 2607 : 		_My_data._Mysize = _New_size;

  00035	89 03		 mov	 DWORD PTR [ebx], eax

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00037	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00038	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00039	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0003c	50		 push	 eax
  0003d	52		 push	 edx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00047	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00049	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0004d	72 02		 jb	 SHORT $LN964@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN964@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1196 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_minimalna_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00051	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00057	50		 push	 eax
  00058	ff d7		 call	 edi
  0005a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0005d	83 c4 04	 add	 esp, 4
  00060	85 c0		 test	 eax, eax
  00062	74 17		 je	 SHORT $LN37@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00064	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00067	72 02		 jb	 SHORT $LN148@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00069	8b 36		 mov	 esi, DWORD PTR [esi]
$LN148@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1196 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_minimalna_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0006b	56		 push	 esi
  0006c	ff d7		 call	 edi
  0006e	83 c4 04	 add	 esp, 4
  00071	66 a3 00 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A, ax
  00077	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	c3		 ret	 0
$LN37@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0007b	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0007d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00080	72 04		 jb	 SHORT $LN180@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00082	8b 06		 mov	 eax, DWORD PTR [esi]
  00084	8b f0		 mov	 esi, eax
$LN180@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00086	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00088	03 ce		 add	 ecx, esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1199 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  0008a	3b c1		 cmp	 eax, ecx
  0008c	0f 84 f2 04 00
	00		 je	 $LN30@Ustaw_usta
$LL4@Ustaw_usta:

; 1200 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00092	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00095	0f 85 77 05 00
	00		 jne	 $LN87@Ustaw_usta

; 1199 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  0009b	40		 inc	 eax
  0009c	3b c1		 cmp	 eax, ecx
  0009e	75 f2		 jne	 SHORT $LL4@Ustaw_usta

; 1201 : 			Ustawienia.g³os_szybkoæ_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  000a0	5f		 pop	 edi
  000a1	33 c0		 xor	 eax, eax

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  000a3	5e		 pop	 esi
  000a4	66 a3 16 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax
  000aa	5b		 pop	 ebx
  000ab	c3		 ret	 0
$LN35@Ustaw_usta:

; 1202 : 		}
; 1203 : 	}
; 1204 : 	else if (tekst.find("iloæ_max_dodatkowych_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  000ac	51		 push	 ecx
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
  000b2	8b ce		 mov	 ecx, esi
  000b4	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  000b9	83 f8 ff	 cmp	 eax, -1
  000bc	0f 84 8f 00 00
	00		 je	 $LN40@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  000c2	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000c5	8d 5e 10	 lea	 ebx, DWORD PTR [esi+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  000c8	b9 26 00 00 00	 mov	 ecx, 38			; 00000026H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  000cd	8b d6		 mov	 edx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  000cf	3b c1		 cmp	 eax, ecx
  000d1	0f 42 c8	 cmovb	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000d4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1583 : 		if (_Large_string_engaged())

  000d8	72 02		 jb	 SHORT $LN966@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000da	8b 16		 mov	 edx, DWORD PTR [esi]
$LN966@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  000dc	2b c1		 sub	 eax, ecx

; 2607 : 		_My_data._Mysize = _New_size;

  000de	89 03		 mov	 DWORD PTR [ebx], eax

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  000e0	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000e1	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  000e2	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000e5	50		 push	 eax
  000e6	52		 push	 edx
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  000f0	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000f2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  000f6	72 02		 jb	 SHORT $LN967@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000f8	8b 06		 mov	 eax, DWORD PTR [esi]
$LN967@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1207 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  000fa	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00100	50		 push	 eax
  00101	ff d7		 call	 edi
  00103	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00106	83 c4 04	 add	 esp, 4
  00109	85 c0		 test	 eax, eax
  0010b	74 17		 je	 SHORT $LN42@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0010d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00110	72 02		 jb	 SHORT $LN243@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00112	8b 36		 mov	 esi, DWORD PTR [esi]
$LN243@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1207 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00114	56		 push	 esi
  00115	ff d7		 call	 edi
  00117	83 c4 04	 add	 esp, 4
  0011a	66 a3 02 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2, ax
  00120	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	c3		 ret	 0
$LN42@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00124	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00126	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00129	72 04		 jb	 SHORT $LN275@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0012b	8b 06		 mov	 eax, DWORD PTR [esi]
  0012d	8b f0		 mov	 esi, eax
$LN275@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0012f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00131	03 ce		 add	 ecx, esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1210 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00133	3b c1		 cmp	 eax, ecx
  00135	74 0e		 je	 SHORT $LN6@Ustaw_usta
$LL7@Ustaw_usta:

; 1211 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00137	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  0013a	0f 85 d2 04 00
	00		 jne	 $LN87@Ustaw_usta

; 1210 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00140	40		 inc	 eax
  00141	3b c1		 cmp	 eax, ecx
  00143	75 f2		 jne	 SHORT $LL7@Ustaw_usta
$LN6@Ustaw_usta:
  00145	5f		 pop	 edi

; 1212 : 			Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00146	33 c0		 xor	 eax, eax

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00148	5e		 pop	 esi
  00149	66 a3 02 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2, ax
  0014f	5b		 pop	 ebx
  00150	c3		 ret	 0
$LN40@Ustaw_usta:

; 1213 : 		}
; 1214 : 	}
; 1215 : 	else if (tekst.find("czas_przeskoku_kulki_szybki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00151	51		 push	 ecx
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@
  00157	8b ce		 mov	 ecx, esi
  00159	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0015e	83 f8 ff	 cmp	 eax, -1
  00161	74 77		 je	 SHORT $LN45@Ustaw_usta

; 1216 : 	{
; 1217 : 		tekst.erase(0, size("czas_przeskoku_kulki_szybki")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  00163	6a 1c		 push	 28			; 0000001cH
  00165	6a 00		 push	 0
  00167	8b ce		 mov	 ecx, esi
  00169	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0016e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00172	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  00174	72 02		 jb	 SHORT $LN969@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00176	8b 06		 mov	 eax, DWORD PTR [esi]
$LN969@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1218 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_szybki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00178	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  0017e	50		 push	 eax
  0017f	ff d7		 call	 edi
  00181	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00184	83 c4 04	 add	 esp, 4
  00187	85 c0		 test	 eax, eax
  00189	74 17		 je	 SHORT $LN47@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0018b	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0018e	72 02		 jb	 SHORT $LN310@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00190	8b 36		 mov	 esi, DWORD PTR [esi]
$LN310@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1218 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_szybki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00192	56		 push	 esi
  00193	ff d7		 call	 edi
  00195	83 c4 04	 add	 esp, 4
  00198	66 a3 04 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4, ax
  0019e	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  0019f	5e		 pop	 esi
  001a0	5b		 pop	 ebx
  001a1	c3		 ret	 0
$LN47@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  001a2	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001a4	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  001a7	72 02		 jb	 SHORT $LN970@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001a9	8b 06		 mov	 eax, DWORD PTR [esi]
$LN970@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  001ab	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001ad	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  001b0	72 02		 jb	 SHORT $LN342@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001b2	8b 16		 mov	 edx, DWORD PTR [esi]
$LN342@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  001b4	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001b7	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1221 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  001b9	3b c1		 cmp	 eax, ecx
  001bb	74 11		 je	 SHORT $LN9@Ustaw_usta
  001bd	0f 1f 00	 npad	 3
$LL10@Ustaw_usta:

; 1222 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  001c0	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  001c3	0f 85 49 04 00
	00		 jne	 $LN87@Ustaw_usta

; 1221 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  001c9	40		 inc	 eax
  001ca	3b c1		 cmp	 eax, ecx
  001cc	75 f2		 jne	 SHORT $LL10@Ustaw_usta
$LN9@Ustaw_usta:
  001ce	5f		 pop	 edi

; 1223 : 			Ustawienia.czas_przeskoku_kulki_szybki = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  001cf	33 c0		 xor	 eax, eax

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  001d1	5e		 pop	 esi
  001d2	66 a3 04 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4, ax
  001d8	5b		 pop	 ebx
  001d9	c3		 ret	 0
$LN45@Ustaw_usta:

; 1224 : 		}
; 1225 : 	}
; 1226 : 	else if (tekst.find("czas_przeskoku_kulki_wolny") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  001da	51		 push	 ecx
  001db	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@
  001e0	8b ce		 mov	 ecx, esi
  001e2	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  001e7	83 f8 ff	 cmp	 eax, -1
  001ea	74 74		 je	 SHORT $LN50@Ustaw_usta

; 1227 : 	{
; 1228 : 		tekst.erase(0, size("czas_przeskoku_kulki_wolny")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  001ec	6a 1b		 push	 27			; 0000001bH
  001ee	6a 00		 push	 0
  001f0	8b ce		 mov	 ecx, esi
  001f2	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001f7	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001fb	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  001fd	72 02		 jb	 SHORT $LN971@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001ff	8b 06		 mov	 eax, DWORD PTR [esi]
$LN971@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1229 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_wolny = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00201	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00207	50		 push	 eax
  00208	ff d7		 call	 edi
  0020a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0020d	83 c4 04	 add	 esp, 4
  00210	85 c0		 test	 eax, eax
  00212	74 17		 je	 SHORT $LN52@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00214	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00217	72 02		 jb	 SHORT $LN377@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00219	8b 36		 mov	 esi, DWORD PTR [esi]
$LN377@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1229 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_wolny = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0021b	56		 push	 esi
  0021c	ff d7		 call	 edi
  0021e	83 c4 04	 add	 esp, 4
  00221	66 a3 06 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+6, ax
  00227	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00228	5e		 pop	 esi
  00229	5b		 pop	 ebx
  0022a	c3		 ret	 0
$LN52@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0022b	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0022d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00230	72 02		 jb	 SHORT $LN972@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00232	8b 06		 mov	 eax, DWORD PTR [esi]
$LN972@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00234	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00236	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00239	72 02		 jb	 SHORT $LN409@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0023b	8b 16		 mov	 edx, DWORD PTR [esi]
$LN409@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0023d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00240	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1232 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00242	3b c1		 cmp	 eax, ecx
  00244	74 0e		 je	 SHORT $LN12@Ustaw_usta
$LL13@Ustaw_usta:

; 1233 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00246	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00249	0f 85 c3 03 00
	00		 jne	 $LN87@Ustaw_usta

; 1232 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  0024f	40		 inc	 eax
  00250	3b c1		 cmp	 eax, ecx
  00252	75 f2		 jne	 SHORT $LL13@Ustaw_usta
$LN12@Ustaw_usta:
  00254	5f		 pop	 edi

; 1234 : 			Ustawienia.czas_przeskoku_kulki_wolny = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00255	33 c0		 xor	 eax, eax

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00257	5e		 pop	 esi
  00258	66 a3 06 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+6, ax
  0025e	5b		 pop	 ebx
  0025f	c3		 ret	 0
$LN50@Ustaw_usta:

; 1235 : 		}
; 1236 : 	}
; 1237 : 	else if (tekst.find("styl_liczenia_wygranej") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00260	51		 push	 ecx
  00261	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@
  00266	8b ce		 mov	 ecx, esi
  00268	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0026d	83 f8 ff	 cmp	 eax, -1
  00270	74 78		 je	 SHORT $LN55@Ustaw_usta

; 1238 : 	{
; 1239 : 		tekst.erase(0, size("styl_liczenia_wygranej")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  00272	6a 17		 push	 23			; 00000017H
  00274	6a 00		 push	 0
  00276	8b ce		 mov	 ecx, esi
  00278	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0027d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00281	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  00283	72 02		 jb	 SHORT $LN973@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00285	8b 06		 mov	 eax, DWORD PTR [esi]
$LN973@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1240 : 		if (atoi(tekst.c_str())) Ustawienia.styl_liczenia_wygranej = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00287	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  0028d	50		 push	 eax
  0028e	ff d7		 call	 edi
  00290	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00293	83 c4 04	 add	 esp, 4
  00296	85 c0		 test	 eax, eax
  00298	74 17		 je	 SHORT $LN57@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0029a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0029d	72 02		 jb	 SHORT $LN444@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0029f	8b 36		 mov	 esi, DWORD PTR [esi]
$LN444@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1240 : 		if (atoi(tekst.c_str())) Ustawienia.styl_liczenia_wygranej = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  002a1	56		 push	 esi
  002a2	ff d7		 call	 edi
  002a4	83 c4 04	 add	 esp, 4
  002a7	66 a3 0a 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, ax
  002ad	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  002ae	5e		 pop	 esi
  002af	5b		 pop	 ebx
  002b0	c3		 ret	 0
$LN57@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  002b1	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002b3	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  002b6	72 02		 jb	 SHORT $LN974@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  002b8	8b 06		 mov	 eax, DWORD PTR [esi]
$LN974@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  002ba	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002bc	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  002bf	72 02		 jb	 SHORT $LN476@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  002c1	8b 16		 mov	 edx, DWORD PTR [esi]
$LN476@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  002c3	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  002c6	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1243 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  002c8	3b c1		 cmp	 eax, ecx
  002ca	74 12		 je	 SHORT $LN15@Ustaw_usta
  002cc	0f 1f 40 00	 npad	 4
$LL16@Ustaw_usta:

; 1244 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  002d0	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  002d3	0f 85 39 03 00
	00		 jne	 $LN87@Ustaw_usta

; 1243 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  002d9	40		 inc	 eax
  002da	3b c1		 cmp	 eax, ecx
  002dc	75 f2		 jne	 SHORT $LL16@Ustaw_usta
$LN15@Ustaw_usta:
  002de	5f		 pop	 edi

; 1245 : 			Ustawienia.styl_liczenia_wygranej = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  002df	33 c0		 xor	 eax, eax

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  002e1	5e		 pop	 esi
  002e2	66 a3 0a 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, ax
  002e8	5b		 pop	 ebx
  002e9	c3		 ret	 0
$LN55@Ustaw_usta:

; 1246 : 		}
; 1247 : 	}
; 1248 : 	else if (tekst.find("kwota_pocz¹tkowa") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  002ea	51		 push	 ecx
  002eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@
  002f0	8b ce		 mov	 ecx, esi
  002f2	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  002f7	83 f8 ff	 cmp	 eax, -1
  002fa	74 75		 je	 SHORT $LN60@Ustaw_usta

; 1249 : 	{
; 1250 : 		tekst.erase(0, size("kwota_pocz¹tkowa")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  002fc	6a 11		 push	 17			; 00000011H
  002fe	6a 00		 push	 0
  00300	8b ce		 mov	 ecx, esi
  00302	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00307	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0030b	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  0030d	72 02		 jb	 SHORT $LN975@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0030f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN975@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1251 : 		if (atoi(tekst.c_str())) Ustawienia.kwota_pocz¹tkowa = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00311	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00317	50		 push	 eax
  00318	ff d7		 call	 edi
  0031a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0031d	83 c4 04	 add	 esp, 4
  00320	85 c0		 test	 eax, eax
  00322	74 16		 je	 SHORT $LN62@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00324	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00327	72 02		 jb	 SHORT $LN511@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00329	8b 36		 mov	 esi, DWORD PTR [esi]
$LN511@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1251 : 		if (atoi(tekst.c_str())) Ustawienia.kwota_pocz¹tkowa = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0032b	56		 push	 esi
  0032c	ff d7		 call	 edi
  0032e	83 c4 04	 add	 esp, 4
  00331	a3 0c 00 00 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, eax
  00336	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00337	5e		 pop	 esi
  00338	5b		 pop	 ebx
  00339	c3		 ret	 0
$LN62@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0033a	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0033c	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  0033f	72 02		 jb	 SHORT $LN976@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00341	8b 06		 mov	 eax, DWORD PTR [esi]
$LN976@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00343	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00345	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00348	72 02		 jb	 SHORT $LN543@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0034a	8b 16		 mov	 edx, DWORD PTR [esi]
$LN543@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0034c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0034f	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1254 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00351	3b c1		 cmp	 eax, ecx
  00353	74 0e		 je	 SHORT $LN18@Ustaw_usta
$LL19@Ustaw_usta:

; 1255 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00355	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00358	0f 85 b4 02 00
	00		 jne	 $LN87@Ustaw_usta

; 1254 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  0035e	40		 inc	 eax
  0035f	3b c1		 cmp	 eax, ecx
  00361	75 f2		 jne	 SHORT $LL19@Ustaw_usta
$LN18@Ustaw_usta:
  00363	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00364	5e		 pop	 esi
  00365	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, 0
  0036f	5b		 pop	 ebx
  00370	c3		 ret	 0
$LN60@Ustaw_usta:

; 1256 : 			Ustawienia.kwota_pocz¹tkowa = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0
; 1257 : 		}
; 1258 : 	}
; 1259 : 	else if (tekst.find("stan_dwiêków") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00371	51		 push	 ecx
  00372	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@
  00377	8b ce		 mov	 ecx, esi
  00379	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0037e	83 f8 ff	 cmp	 eax, -1
  00381	74 77		 je	 SHORT $LN65@Ustaw_usta

; 1260 : 	{
; 1261 : 		tekst.erase(0, size("stan_dwiêków")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  00383	6a 0e		 push	 14			; 0000000eH
  00385	6a 00		 push	 0
  00387	8b ce		 mov	 ecx, esi
  00389	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0038e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00392	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  00394	72 02		 jb	 SHORT $LN977@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00396	8b 06		 mov	 eax, DWORD PTR [esi]
$LN977@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1262 : 		if (atoi(tekst.c_str())) Ustawienia.stan_dwiêków = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00398	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  0039e	50		 push	 eax
  0039f	ff d7		 call	 edi
  003a1	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  003a4	83 c4 04	 add	 esp, 4
  003a7	85 c0		 test	 eax, eax
  003a9	74 17		 je	 SHORT $LN67@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003ab	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  003ae	72 02		 jb	 SHORT $LN578@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  003b0	8b 36		 mov	 esi, DWORD PTR [esi]
$LN578@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1262 : 		if (atoi(tekst.c_str())) Ustawienia.stan_dwiêków = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  003b2	56		 push	 esi
  003b3	ff d7		 call	 edi
  003b5	83 c4 04	 add	 esp, 4
  003b8	66 a3 10 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, ax
  003be	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  003bf	5e		 pop	 esi
  003c0	5b		 pop	 ebx
  003c1	c3		 ret	 0
$LN67@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  003c2	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003c4	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  003c7	72 02		 jb	 SHORT $LN978@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  003c9	8b 06		 mov	 eax, DWORD PTR [esi]
$LN978@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  003cb	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003cd	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  003d0	72 02		 jb	 SHORT $LN610@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  003d2	8b 16		 mov	 edx, DWORD PTR [esi]
$LN610@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  003d4	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  003d7	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1265 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  003d9	3b c1		 cmp	 eax, ecx
  003db	74 11		 je	 SHORT $LN21@Ustaw_usta
  003dd	0f 1f 00	 npad	 3
$LL22@Ustaw_usta:

; 1266 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  003e0	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  003e3	0f 85 29 02 00
	00		 jne	 $LN87@Ustaw_usta

; 1265 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  003e9	40		 inc	 eax
  003ea	3b c1		 cmp	 eax, ecx
  003ec	75 f2		 jne	 SHORT $LL22@Ustaw_usta
$LN21@Ustaw_usta:
  003ee	5f		 pop	 edi

; 1267 : 			Ustawienia.stan_dwiêków = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  003ef	33 c0		 xor	 eax, eax

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  003f1	5e		 pop	 esi
  003f2	66 a3 10 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, ax
  003f8	5b		 pop	 ebx
  003f9	c3		 ret	 0
$LN65@Ustaw_usta:

; 1268 : 		}
; 1269 : 	}
; 1270 : 	else if (tekst.find("czy_kontynuowaæ_grê") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  003fa	51		 push	 ecx
  003fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@
  00400	8b ce		 mov	 ecx, esi
  00402	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00407	83 f8 ff	 cmp	 eax, -1
  0040a	74 74		 je	 SHORT $LN70@Ustaw_usta

; 1271 : 	{
; 1272 : 		tekst.erase(0, size("czy_kontynuowaæ_grê")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  0040c	6a 14		 push	 20			; 00000014H
  0040e	6a 00		 push	 0
  00410	8b ce		 mov	 ecx, esi
  00412	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00417	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0041b	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  0041d	72 02		 jb	 SHORT $LN979@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0041f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN979@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1273 : 		if (atoi(tekst.c_str())) Ustawienia.czy_kontynuowaæ_grê = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00421	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00427	50		 push	 eax
  00428	ff d7		 call	 edi
  0042a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0042d	83 c4 04	 add	 esp, 4
  00430	85 c0		 test	 eax, eax
  00432	74 17		 je	 SHORT $LN72@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00434	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00437	72 02		 jb	 SHORT $LN645@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00439	8b 36		 mov	 esi, DWORD PTR [esi]
$LN645@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1273 : 		if (atoi(tekst.c_str())) Ustawienia.czy_kontynuowaæ_grê = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0043b	56		 push	 esi
  0043c	ff d7		 call	 edi
  0043e	83 c4 04	 add	 esp, 4
  00441	66 a3 12 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, ax
  00447	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00448	5e		 pop	 esi
  00449	5b		 pop	 ebx
  0044a	c3		 ret	 0
$LN72@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0044b	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0044d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00450	72 02		 jb	 SHORT $LN980@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00452	8b 06		 mov	 eax, DWORD PTR [esi]
$LN980@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00454	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00456	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00459	72 02		 jb	 SHORT $LN677@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0045b	8b 16		 mov	 edx, DWORD PTR [esi]
$LN677@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0045d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00460	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1276 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00462	3b c1		 cmp	 eax, ecx
  00464	74 0e		 je	 SHORT $LN24@Ustaw_usta
$LL25@Ustaw_usta:

; 1277 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00466	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00469	0f 85 a3 01 00
	00		 jne	 $LN87@Ustaw_usta

; 1276 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  0046f	40		 inc	 eax
  00470	3b c1		 cmp	 eax, ecx
  00472	75 f2		 jne	 SHORT $LL25@Ustaw_usta
$LN24@Ustaw_usta:
  00474	5f		 pop	 edi

; 1278 : 			Ustawienia.czy_kontynuowaæ_grê = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00475	33 c0		 xor	 eax, eax

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00477	5e		 pop	 esi
  00478	66 a3 12 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, ax
  0047e	5b		 pop	 ebx
  0047f	c3		 ret	 0
$LN70@Ustaw_usta:

; 1279 : 		}
; 1280 : 	}
; 1281 : 	else if (tekst.find("g³os_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00480	51		 push	 ecx
  00481	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@
  00486	8b ce		 mov	 ecx, esi
  00488	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0048d	83 f8 ff	 cmp	 eax, -1
  00490	74 78		 je	 SHORT $LN75@Ustaw_usta

; 1282 : 	{
; 1283 : 		tekst.erase(0, size("g³os_odczytu_numeru")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  00492	6a 14		 push	 20			; 00000014H
  00494	6a 00		 push	 0
  00496	8b ce		 mov	 ecx, esi
  00498	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0049d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  004a1	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  004a3	72 02		 jb	 SHORT $LN981@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004a5	8b 06		 mov	 eax, DWORD PTR [esi]
$LN981@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1284 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  004a7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  004ad	50		 push	 eax
  004ae	ff d7		 call	 edi
  004b0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  004b3	83 c4 04	 add	 esp, 4
  004b6	85 c0		 test	 eax, eax
  004b8	74 17		 je	 SHORT $LN77@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004ba	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  004bd	72 02		 jb	 SHORT $LN712@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004bf	8b 36		 mov	 esi, DWORD PTR [esi]
$LN712@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1284 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  004c1	56		 push	 esi
  004c2	ff d7		 call	 edi
  004c4	83 c4 04	 add	 esp, 4
  004c7	66 a3 14 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, ax
  004cd	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  004ce	5e		 pop	 esi
  004cf	5b		 pop	 ebx
  004d0	c3		 ret	 0
$LN77@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  004d1	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004d3	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  004d6	72 02		 jb	 SHORT $LN982@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004d8	8b 06		 mov	 eax, DWORD PTR [esi]
$LN982@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  004da	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004dc	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  004df	72 02		 jb	 SHORT $LN744@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004e1	8b 16		 mov	 edx, DWORD PTR [esi]
$LN744@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  004e3	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  004e6	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1287 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  004e8	3b c1		 cmp	 eax, ecx
  004ea	74 12		 je	 SHORT $LN27@Ustaw_usta
  004ec	0f 1f 40 00	 npad	 4
$LL28@Ustaw_usta:

; 1288 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  004f0	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  004f3	0f 85 19 01 00
	00		 jne	 $LN87@Ustaw_usta

; 1287 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  004f9	40		 inc	 eax
  004fa	3b c1		 cmp	 eax, ecx
  004fc	75 f2		 jne	 SHORT $LL28@Ustaw_usta
$LN27@Ustaw_usta:
  004fe	5f		 pop	 edi

; 1289 : 			Ustawienia.g³os_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  004ff	33 c0		 xor	 eax, eax

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00501	5e		 pop	 esi
  00502	66 a3 14 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, ax
  00508	5b		 pop	 ebx
  00509	c3		 ret	 0
$LN75@Ustaw_usta:

; 1290 : 		}
; 1291 : 	}
; 1292 : 	else if (tekst.find("g³os_szybkoæ_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0050a	51		 push	 ecx
  0050b	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@
  00510	8b ce		 mov	 ecx, esi
  00512	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00517	83 f8 ff	 cmp	 eax, -1
  0051a	74 74		 je	 SHORT $LN80@Ustaw_usta

; 1293 : 	{
; 1294 : 		tekst.erase(0, size("g³os_szybkoæ_odczytu_numeru")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  0051c	6a 1d		 push	 29			; 0000001dH
  0051e	6a 00		 push	 0
  00520	8b ce		 mov	 ecx, esi
  00522	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00527	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0052b	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  0052d	72 02		 jb	 SHORT $LN983@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0052f	8b 06		 mov	 eax, DWORD PTR [esi]
$LN983@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1295 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_szybkoæ_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00531	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00537	50		 push	 eax
  00538	ff d7		 call	 edi
  0053a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0053d	83 c4 04	 add	 esp, 4
  00540	85 c0		 test	 eax, eax
  00542	74 17		 je	 SHORT $LN82@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00544	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00547	72 02		 jb	 SHORT $LN779@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00549	8b 36		 mov	 esi, DWORD PTR [esi]
$LN779@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1295 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_szybkoæ_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0054b	56		 push	 esi
  0054c	ff d7		 call	 edi
  0054e	83 c4 04	 add	 esp, 4
  00551	66 a3 16 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax
  00557	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00558	5e		 pop	 esi
  00559	5b		 pop	 ebx
  0055a	c3		 ret	 0
$LN82@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0055b	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0055d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00560	72 02		 jb	 SHORT $LN984@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00562	8b 06		 mov	 eax, DWORD PTR [esi]
$LN984@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00564	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00566	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00569	72 02		 jb	 SHORT $LN811@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0056b	8b 16		 mov	 edx, DWORD PTR [esi]
$LN811@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0056d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00570	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1298 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00572	3b c1		 cmp	 eax, ecx
  00574	74 0e		 je	 SHORT $LN30@Ustaw_usta
$LL31@Ustaw_usta:

; 1299 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00576	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00579	0f 85 93 00 00
	00		 jne	 $LN87@Ustaw_usta

; 1298 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  0057f	40		 inc	 eax
  00580	3b c1		 cmp	 eax, ecx
  00582	75 f2		 jne	 SHORT $LL31@Ustaw_usta
$LN30@Ustaw_usta:
  00584	5f		 pop	 edi

; 1300 : 			Ustawienia.g³os_szybkoæ_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00585	33 c0		 xor	 eax, eax

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00587	5e		 pop	 esi
  00588	66 a3 16 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax
  0058e	5b		 pop	 ebx
  0058f	c3		 ret	 0
$LN80@Ustaw_usta:

; 1301 : 		}
; 1302 : 	}
; 1303 : 	else if (tekst.find("efekty_dwiêkowe") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00590	51		 push	 ecx
  00591	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@
  00596	8b ce		 mov	 ecx, esi
  00598	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0059d	83 f8 ff	 cmp	 eax, -1
  005a0	74 70		 je	 SHORT $LN87@Ustaw_usta

; 1304 : 	{
; 1305 : 		tekst.erase(0, size("efekty_dwiêkowe")); //Usuniêcie s³owa z tekst aby zosta³a tylko liczba która jest wartoci¹ ustawienia

  005a2	6a 11		 push	 17			; 00000011H
  005a4	6a 00		 push	 0
  005a6	8b ce		 mov	 ecx, esi
  005a8	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005ad	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  005b1	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  005b3	72 02		 jb	 SHORT $LN985@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005b5	8b 06		 mov	 eax, DWORD PTR [esi]
$LN985@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1306 : 		if (atoi(tekst.c_str())) Ustawienia.efekty_dwiêkowe = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  005b7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  005bd	50		 push	 eax
  005be	ff d7		 call	 edi
  005c0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  005c3	83 c4 04	 add	 esp, 4
  005c6	85 c0		 test	 eax, eax
  005c8	74 17		 je	 SHORT $LN86@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005ca	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1594 : 		if (_Large_string_engaged())

  005cd	72 02		 jb	 SHORT $LN846@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005cf	8b 36		 mov	 esi, DWORD PTR [esi]
$LN846@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1306 : 		if (atoi(tekst.c_str())) Ustawienia.efekty_dwiêkowe = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  005d1	56		 push	 esi
  005d2	ff d7		 call	 edi
  005d4	83 c4 04	 add	 esp, 4

; 1311 : 			Ustawienia.efekty_dwiêkowe = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  005d7	66 a3 18 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, ax
  005dd	5f		 pop	 edi

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  005de	5e		 pop	 esi
  005df	5b		 pop	 ebx
  005e0	c3		 ret	 0
$LN86@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  005e1	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005e3	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  005e6	72 02		 jb	 SHORT $LN986@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005e8	8b 06		 mov	 eax, DWORD PTR [esi]
$LN986@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  005ea	8b d6		 mov	 edx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005ec	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  005ef	72 02		 jb	 SHORT $LN878@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005f1	8b 16		 mov	 edx, DWORD PTR [esi]
$LN878@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  005f3	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  005f6	03 ca		 add	 ecx, edx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1309 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  005f8	3b c1		 cmp	 eax, ecx
  005fa	74 0e		 je	 SHORT $LN33@Ustaw_usta
  005fc	0f 1f 40 00	 npad	 4
$LL34@Ustaw_usta:

; 1310 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00600	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  00603	75 0d		 jne	 SHORT $LN87@Ustaw_usta

; 1309 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00605	40		 inc	 eax
  00606	3b c1		 cmp	 eax, ecx
  00608	75 f6		 jne	 SHORT $LL34@Ustaw_usta
$LN33@Ustaw_usta:

; 1311 : 			Ustawienia.efekty_dwiêkowe = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  0060a	33 c0		 xor	 eax, eax
  0060c	66 a3 18 00 00
	00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, ax
$LN87@Ustaw_usta:

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00612	5f		 pop	 edi
  00613	5e		 pop	 esi
  00614	5b		 pop	 ebx
  00615	c3		 ret	 0
?Ustaw_ustawienia@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Ustaw_ustawienia
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0?$uniform_int_distribution@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0?$uniform_int_distribution@H@std@@QAE@HH@Z PROC	; std::uniform_int_distribution<int>::uniform_int_distribution<int>, COMDAT
; _this$ = ecx

; 2412 : 		{	// construct from parameters

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2224 : 			_Min = _Min0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Min0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 2225 : 			_Max = _Max0;

  00008	8b 45 0c	 mov	 eax, DWORD PTR __Max0$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2413 : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0?$uniform_int_distribution@H@std@@QAE@HH@Z ENDP	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator(), COMDAT
; _this$ = ecx

; 1346 : 		{	// return next value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	89 7d fc	 mov	 DWORD PTR _this$1$[ebp], edi

; 1347 : 		if (this->_Idx == _Nx)

  0000b	8b 07		 mov	 eax, DWORD PTR [edi]
  0000d	3d 70 02 00 00	 cmp	 eax, 624		; 00000270H
  00012	75 4a		 jne	 SHORT $LN2@operator

; 1398 : 		for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix)

  00014	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  00017	8b f0		 mov	 esi, eax
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@operator:

; 1399 : 			{	// fill in values
; 1400 : 			_Ty _Tmp = (this->_Ax[_Ix - _Nx] & _HMSK)
; 1401 : 				| (this->_Ax[_Ix - _Nx + 1] & _LMSK);

  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  00026	33 4a fc	 xor	 ecx, DWORD PTR [edx-4]
  00029	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0002f	33 4a f8	 xor	 ecx, DWORD PTR [edx-8]

; 1402 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00032	8b c1		 mov	 eax, ecx
  00034	24 01		 and	 al, 1
  00036	0f b6 c0	 movzx	 eax, al
  00039	f7 d8		 neg	 eax
  0003b	1b c0		 sbb	 eax, eax
  0003d	d1 e9		 shr	 ecx, 1
  0003f	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00044	33 82 2c 06 00
	00		 xor	 eax, DWORD PTR [edx+1580]
  0004a	33 c1		 xor	 eax, ecx
  0004c	89 82 b8 09 00
	00		 mov	 DWORD PTR [edx+2488], eax
  00052	83 ee 01	 sub	 esi, 1
  00055	75 c9		 jne	 SHORT $LL9@operator

; 1403 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1404 : 			}
; 1405 : 		}

  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	e9 eb 00 00 00	 jmp	 $LN4@operator
$LN2@operator:

; 1348 : 			_Refill_upper();
; 1349 : 		else if (2 * _Nx <= this->_Idx)

  0005e	3d e0 04 00 00	 cmp	 eax, 1248		; 000004e0H
  00063	0f 82 e0 00 00
	00		 jb	 $LN4@operator

; 1373 : 		for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix)

  00069	8b 87 c4 09 00
	00		 mov	 eax, DWORD PTR [edi+2500]
  0006f	53		 push	 ebx
  00070	8d 9f c4 09 00
	00		 lea	 ebx, DWORD PTR [edi+2500]
  00076	bf e3 00 00 00	 mov	 edi, 227		; 000000e3H
  0007b	0f 1f 44 00 00	 npad	 5
$LL14@operator:

; 1374 : 			{	// fill in lower region
; 1375 : 			_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK)
; 1376 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00080	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00083	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
  00086	33 c8		 xor	 ecx, eax
  00088	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0008e	33 c8		 xor	 ecx, eax

; 1377 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00090	8b c1		 mov	 eax, ecx
  00092	24 01		 and	 al, 1
  00094	0f b6 c0	 movzx	 eax, al
  00097	f7 d8		 neg	 eax
  00099	1b c0		 sbb	 eax, eax
  0009b	d1 e9		 shr	 ecx, 1
  0009d	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  000a2	33 83 34 06 00
	00		 xor	 eax, DWORD PTR [ebx+1588]
  000a8	33 c1		 xor	 eax, ecx
  000aa	89 83 40 f6 ff
	ff		 mov	 DWORD PTR [ebx-2496], eax
  000b0	8d 1a		 lea	 ebx, DWORD PTR [edx]
  000b2	8b 02		 mov	 eax, DWORD PTR [edx]
  000b4	83 ef 01	 sub	 edi, 1
  000b7	75 c7		 jne	 SHORT $LL14@operator

; 1378 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];
; 1379 : 			}
; 1380 : 
; 1381 : 		for (; _Ix < _Nx - 1; ++_Ix)

  000b9	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  000bc	bf 8c 01 00 00	 mov	 edi, 396		; 0000018cH
  000c1	81 c3 50 0d 00
	00		 add	 ebx, 3408		; 00000d50H
  000c7	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL17@operator:

; 1382 : 			{	// fill in upper region (avoids modulus operation)
; 1383 : 			_Ty _Tmp = (this->_Ax[_Ix +_Nx] & _HMSK)
; 1384 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  000d0	8b c8		 mov	 ecx, eax
  000d2	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
  000d5	33 0a		 xor	 ecx, DWORD PTR [edx]
  000d7	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  000dd	33 c8		 xor	 ecx, eax

; 1385 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  000df	8b c1		 mov	 eax, ecx
  000e1	24 01		 and	 al, 1
  000e3	0f b6 c0	 movzx	 eax, al
  000e6	f7 d8		 neg	 eax
  000e8	1b c0		 sbb	 eax, eax
  000ea	d1 e9		 shr	 ecx, 1
  000ec	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  000f1	33 83 b4 f2 ff
	ff		 xor	 eax, DWORD PTR [ebx-3404]
  000f7	33 c1		 xor	 eax, ecx
  000f9	89 83 40 f6 ff
	ff		 mov	 DWORD PTR [ebx-2496], eax
  000ff	8d 1a		 lea	 ebx, DWORD PTR [edx]
  00101	8b 02		 mov	 eax, DWORD PTR [edx]
  00103	83 ef 01	 sub	 edi, 1
  00106	75 c8		 jne	 SHORT $LL17@operator

; 1386 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1387 : 			}
; 1388 : 
; 1389 : 		_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

  00108	8b 7d fc	 mov	 edi, DWORD PTR _this$1$[ebp]

; 1390 : 		this->_Ax[_Ix] = (_Tmp >> 1)
; 1391 : 			^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];
; 1392 : 		this->_Idx = 0;

  0010b	5b		 pop	 ebx
  0010c	8b 8f 80 13 00
	00		 mov	 ecx, DWORD PTR [edi+4992]
  00112	33 4f 04	 xor	 ecx, DWORD PTR [edi+4]
  00115	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0011b	33 8f 80 13 00
	00		 xor	 ecx, DWORD PTR [edi+4992]
  00121	8b c1		 mov	 eax, ecx
  00123	24 01		 and	 al, 1
  00125	0f b6 c0	 movzx	 eax, al
  00128	f7 d8		 neg	 eax
  0012a	1b c0		 sbb	 eax, eax
  0012c	d1 e9		 shr	 ecx, 1
  0012e	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00133	33 87 34 06 00
	00		 xor	 eax, DWORD PTR [edi+1588]
  00139	33 c1		 xor	 eax, ecx
  0013b	89 87 c0 09 00
	00		 mov	 DWORD PTR [edi+2496], eax
  00141	33 c0		 xor	 eax, eax
  00143	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN4@operator:

; 1350 : 			_Refill_lower();
; 1351 : 
; 1352 : 		_Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

  00149	8b 54 87 04	 mov	 edx, DWORD PTR [edi+eax*4+4]
  0014d	40		 inc	 eax
  0014e	89 07		 mov	 DWORD PTR [edi], eax

; 1353 : 		_Res ^= (_Res >> _Ux) & _Dxval;

  00150	8b ca		 mov	 ecx, edx
  00152	8b 87 84 13 00
	00		 mov	 eax, DWORD PTR [edi+4996]
  00158	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  0015b	23 c1		 and	 eax, ecx
  0015d	33 d0		 xor	 edx, eax

; 1354 : 		_Res ^= (_Res << _Sx) & _Bx;

  0015f	8b c2		 mov	 eax, edx
  00161	25 ad 58 3a ff	 and	 eax, -12953427		; ff3a58adH
  00166	c1 e0 07	 shl	 eax, 7
  00169	33 d0		 xor	 edx, eax

; 1355 : 		_Res ^= (_Res << _Tx) & _Cx;

  0016b	8b c2		 mov	 eax, edx
  0016d	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  00172	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  00175	33 d0		 xor	 edx, eax

; 1356 : 		_Res ^= (_Res & _WMSK) >> _Lx;

  00177	8b c2		 mov	 eax, edx
  00179	c1 e8 12	 shr	 eax, 18			; 00000012H

; 1357 : 		return (_Res);

  0017c	5f		 pop	 edi
  0017d	33 c2		 xor	 eax, edx
  0017f	5e		 pop	 esi

; 1358 : 		}

  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>, COMDAT
; _this$ = ecx

; 1517 : 		{	// construct with default seed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1309 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00003	8b 55 08	 mov	 edx, DWORD PTR __X0$[ebp]

; 1517 : 		{	// construct with default seed

  00006	56		 push	 esi
  00007	57		 push	 edi

; 1293 : 		: _Dxval(_Dxarg)

  00008	c7 81 84 13 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+4996], -1
  00012	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]

; 1309 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00015	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1293 : 		: _Dxval(_Dxarg)

  00018	be 01 00 00 00	 mov	 esi, 1
  0001d	0f 1f 00	 npad	 3
$LL8@mersenne_t:

; 1311 : 			_Prev = this->_Ax[_Ix] =

  00020	8b c2		 mov	 eax, edx
  00022	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00025	c1 e8 1e	 shr	 eax, 30			; 0000001eH
  00028	33 c2		 xor	 eax, edx
  0002a	69 d0 65 89 07
	6c		 imul	 edx, eax, 1812433253
  00030	03 d6		 add	 edx, esi
  00032	46		 inc	 esi
  00033	89 57 fc	 mov	 DWORD PTR [edi-4], edx
  00036	81 fe 70 02 00
	00		 cmp	 esi, 624		; 00000270H
  0003c	7c e2		 jl	 SHORT $LL8@mersenne_t

; 1518 : 		}

  0003e	5f		 pop	 edi

; 1313 : 		this->_Idx = _Nx;

  0003f	c7 01 70 02 00
	00		 mov	 DWORD PTR [ecx], 624	; 00000270H

; 1518 : 		}

  00045	8b c1		 mov	 eax, ecx
  00047	5e		 pop	 esi
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$dead$ = 12					; size = 4
__Count$dead$ = 16					; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$dead$ = ecx

; 3467 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 3683 : 		_My_data._Mysize = 0;

  00007	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0000e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00015	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00018	a1 10 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0001d	83 f8 05	 cmp	 eax, 5
  00020	72 32		 jb	 SHORT $LN67@substr

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00022	83 c0 fb	 add	 eax, -5			; fffffffbH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00025	83 ca ff	 or	 edx, -1
  00028	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0002b	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00030	0f 42 d0	 cmovb	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00033	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0003a	52		 push	 edx

; 1594 : 		if (_Large_string_engaged())

  0003b	0f 43 0d 00 00
	00 00		 cmovae	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00042	83 c1 05	 add	 ecx, 5
  00045	51		 push	 ecx
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3468 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi

; 3469 : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN67@substr:

; 1611 : 			_Xran();

  00054	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN69@substr:
$LN66@substr:
  00059	cc		 int	 3
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z
_TEXT	SEGMENT
__Possible_matches_end$1$ = -8				; size = 4
__Result$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Off$dead$ = 12					; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 3256 : 		{	// look for [_Ptr, <null>) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00008	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  0000b	8b de		 mov	 ebx, esi
  0000d	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
$LL42@find:
  00010	8a 03		 mov	 al, BYTE PTR [ebx]
  00012	43		 inc	 ebx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL42@find
  00017	2b da		 sub	 ebx, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00019	89 4d fc	 mov	 DWORD PTR __Result$1$[ebp], ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0001c	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00020	8b d1		 mov	 edx, ecx

; 1594 : 		if (_Large_string_engaged())

  00022	72 05		 jb	 SHORT $LN13@find
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	89 55 fc	 mov	 DWORD PTR __Result$1$[ebp], edx
$LN13@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  00029	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0002c	3b d8		 cmp	 ebx, eax
  0002e	0f 87 c4 00 00
	00		 ja	 $LN24@find

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)

  00034	85 db		 test	 ebx, ebx
  00036	75 0a		 jne	 SHORT $LN25@find

; 3258 : 		return (static_cast<size_type>(

  00038	5e		 pop	 esi
  00039	33 c0		 xor	 eax, eax

; 3259 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3260 : 		}

  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN25@find:

; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00042	2b c3		 sub	 eax, ebx
  00044	40		 inc	 eax
  00045	03 c2		 add	 eax, edx
  00047	89 45 f8	 mov	 DWORD PTR __Possible_matches_end$1$[ebp], eax

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0004a	2b c2		 sub	 eax, edx
  0004c	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  0004d	50		 push	 eax
  0004e	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00051	50		 push	 eax
  00052	52		 push	 edx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  00059	8b f8		 mov	 edi, eax
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  0005e	85 ff		 test	 edi, edi
  00060	0f 84 78 00 00
	00		 je	 $LN37@find
$LL22@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00066	8b c3		 mov	 eax, ebx
  00068	8b d7		 mov	 edx, edi
  0006a	83 e8 04	 sub	 eax, 4
  0006d	72 12		 jb	 SHORT $LN45@find
  0006f	90		 npad	 1
$LL46@find:
  00070	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00072	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  00074	75 10		 jne	 SHORT $LN44@find
  00076	83 c2 04	 add	 edx, 4
  00079	83 c6 04	 add	 esi, 4
  0007c	83 e8 04	 sub	 eax, 4
  0007f	73 ef		 jae	 SHORT $LL46@find
$LN45@find:
  00081	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  00084	74 34		 je	 SHORT $LN43@find
$LN44@find:
  00086	8a 0a		 mov	 cl, BYTE PTR [edx]
  00088	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0008a	75 27		 jne	 SHORT $LN47@find
  0008c	83 f8 fd	 cmp	 eax, -3			; fffffffdH
  0008f	74 29		 je	 SHORT $LN43@find
  00091	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  00094	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00097	75 1a		 jne	 SHORT $LN47@find
  00099	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  0009c	74 1c		 je	 SHORT $LN43@find
  0009e	8a 4a 02	 mov	 cl, BYTE PTR [edx+2]
  000a1	3a 4e 02	 cmp	 cl, BYTE PTR [esi+2]
  000a4	75 0d		 jne	 SHORT $LN47@find
  000a6	83 f8 ff	 cmp	 eax, -1
  000a9	74 0f		 je	 SHORT $LN43@find
  000ab	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  000ae	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  000b1	74 07		 je	 SHORT $LN43@find
$LN47@find:
  000b3	1b c0		 sbb	 eax, eax
  000b5	83 c8 01	 or	 eax, 1
  000b8	eb 02		 jmp	 SHORT $LN48@find
$LN43@find:
  000ba	33 c0		 xor	 eax, eax
$LN48@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  000bc	85 c0		 test	 eax, eax
  000be	74 2a		 je	 SHORT $LN38@find

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  000c0	8b 45 f8	 mov	 eax, DWORD PTR __Possible_matches_end$1$[ebp]
  000c3	47		 inc	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  000c4	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  000c7	2b c7		 sub	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  000c9	50		 push	 eax
  000ca	0f be 06	 movsx	 eax, BYTE PTR [esi]
  000cd	50		 push	 eax
  000ce	57		 push	 edi
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  000d5	8b f8		 mov	 edi, eax
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  000da	85 ff		 test	 edi, edi
  000dc	75 88		 jne	 SHORT $LL22@find
$LN37@find:
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi

; 3258 : 		return (static_cast<size_type>(

  000e0	83 c8 ff	 or	 eax, -1

; 3259 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3260 : 		}

  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 08 00	 ret	 8
$LN38@find:

; 85   : 			return (_Match_try - _Haystack);

  000ea	2b 7d fc	 sub	 edi, DWORD PTR __Result$1$[ebp]

; 3258 : 		return (static_cast<size_type>(

  000ed	8b c7		 mov	 eax, edi
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi

; 3259 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3260 : 		}

  000f1	5b		 pop	 ebx
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 08 00	 ret	 8
$LN24@find:
  000f8	5e		 pop	 esi

; 3258 : 		return (static_cast<size_type>(

  000f9	83 c8 ff	 or	 eax, -1

; 3259 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3260 : 		}

  000fc	5b		 pop	 ebx
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3047 : 		return (this->_Get_data()._Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 3048 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00004	72 03		 jb	 SHORT $LN16@c_str

; 3025 : 		return (this->_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3026 : 		}

  00008	c3		 ret	 0
$LN16@c_str:

; 3025 : 		return (this->_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 3026 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2959 : 		{	// subscript immutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2962 : 		return (_My_data._Myptr()[_Off]);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]

; 1594 : 		if (_Large_string_engaged())

  0000a	72 02		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN16@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2962 : 		return (_My_data._Myptr()[_Off]);

  0000e	03 c1		 add	 eax, ecx

; 2963 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2952 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2955 : 		return (_My_data._Myptr()[_Off]);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]

; 1583 : 		if (_Large_string_engaged())

  0000a	72 02		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN16@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2955 : 		return (_My_data._Myptr()[_Off]);

  0000e	03 c1		 add	 eax, ecx

; 2956 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00004	8b d1		 mov	 edx, ecx

; 1583 : 		if (_Large_string_engaged())

  00006	72 02		 jb	 SHORT $LN10@Unchecked_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
$LN10@Unchecked_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0000a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000d	03 c2		 add	 eax, edx

; 2862 : 		}

  0000f	c3		 ret	 0
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00004	72 03		 jb	 SHORT $LN16@Unchecked_

; 2850 : 		return (this->_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2851 : 		}

  00008	c3		 ret	 0
$LN16@Unchecked_:

; 2850 : 		return (this->_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 2851 : 		}

  0000b	c3		 ret	 0
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2599 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]

; 1609 : 		if (_Mysize < _Off)

  0000e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00011	3b cb		 cmp	 ecx, ebx
  00013	72 36		 jb	 SHORT $LN30@erase

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00015	8b c1		 mov	 eax, ecx
  00017	2b c3		 sub	 eax, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00019	3b c7		 cmp	 eax, edi
  0001b	0f 42 f8	 cmovb	 edi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0001e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00022	8b c6		 mov	 eax, esi

; 1583 : 		if (_Large_string_engaged())

  00024	72 02		 jb	 SHORT $LN20@erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00026	8b 06		 mov	 eax, DWORD PTR [esi]
$LN20@erase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00028	2b cf		 sub	 ecx, edi
  0002a	8d 14 03	 lea	 edx, DWORD PTR [ebx+eax]

; 2607 : 		_My_data._Mysize = _New_size;

  0002d	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00030	2b cb		 sub	 ecx, ebx
  00032	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00033	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00034	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2609 : 		return (*this);

  00042	8b c6		 mov	 eax, esi
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx

; 2610 : 		}

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
$LN30@erase:

; 1611 : 			_Xran();

  0004b	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN32@erase:
$LN29@erase:
  00050	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2355 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2355 : 		{	// append [_Ptr, <null>)

  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00009	8b fa		 mov	 edi, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2355 : 		{	// append [_Ptr, <null>)

  0000b	8b d9		 mov	 ebx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0000d	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL30@append:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL30@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00017	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0001a	2b f9		 sub	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2335 : 		const size_type _Old_size = _My_data._Mysize;

  0001c	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  0001f	8b c6		 mov	 eax, esi
  00021	2b c1		 sub	 eax, ecx
  00023	3b f8		 cmp	 edi, eax
  00025	77 2b		 ja	 SHORT $LN9@append

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0002d	8b c3		 mov	 eax, ebx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0002f	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00032	72 02		 jb	 SHORT $LN18@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00034	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN18@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00036	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0003a	52		 push	 edx
  0003b	56		 push	 esi
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  00045	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00049	8b c3		 mov	 eax, ebx
  0004b	5f		 pop	 edi

; 2357 : 		}

  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN9@append:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  00052	57		 push	 edi
  00053	52		 push	 edx
  00054	c6 45 08 00	 mov	 BYTE PTR $T5[ebp], 0
  00058	8b cb		 mov	 ecx, ebx
  0005a	ff 75 08	 push	 DWORD PTR $T5[ebp]
  0005d	57		 push	 edi
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  00063	5f		 pop	 edi

; 2357 : 		}

  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2304 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 2304 : 		{	// append _Right

  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00009	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2304 : 		{	// append _Right

  0000d	8b f9		 mov	 edi, ecx

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0000f	8b c8		 mov	 ecx, eax

; 1594 : 		if (_Large_string_engaged())

  00011	72 02		 jb	 SHORT $LN10@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN10@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00015	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00018	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  0001b	8b c6		 mov	 eax, esi
  0001d	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00020	2b c2		 sub	 eax, edx
  00022	3b d8		 cmp	 ebx, eax
  00024	77 2b		 ja	 SHORT $LN17@append

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00026	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  00029	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0002c	8b c7		 mov	 eax, edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0002e	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00031	72 02		 jb	 SHORT $LN26@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00033	8b 07		 mov	 eax, DWORD PTR [edi]
$LN26@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00035	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00036	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00039	51		 push	 ecx
  0003a	56		 push	 esi
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  00044	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00048	8b c7		 mov	 eax, edi
  0004a	5f		 pop	 edi

; 2307 : 		}

  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN17@append:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  00051	53		 push	 ebx
  00052	51		 push	 ecx
  00053	c6 45 08 00	 mov	 BYTE PTR $T5[ebp], 0
  00057	8b cf		 mov	 ecx, edi
  00059	ff 75 08	 push	 DWORD PTR $T5[ebp]
  0005c	53		 push	 ebx
  0005d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  00062	5f		 pop	 edi

; 2307 : 		}

  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
$T3 = -4						; size = 1
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2298 : 		{	// append 1 * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  00007	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 2977 : 		if (_Old_size < _My_data._Myres)

  0000a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000d	3b d1		 cmp	 edx, ecx
  0000f	73 23		 jae	 SHORT $LN4@operator

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  00011	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00014	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00017	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00019	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  0001c	72 02		 jb	 SHORT $LN13@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
$LN13@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00020	8a 4d 08	 mov	 cl, BYTE PTR __Ch$[ebp]
  00023	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00026	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2300 : 		return (*this);

  0002b	8b c6		 mov	 eax, esi
  0002d	5e		 pop	 esi

; 2301 : 		}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@operator:

; 2986 : 		_Reallocate_grow_by(1,

  00034	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00037	c6 45 fc 00	 mov	 BYTE PTR $T3[ebp], 0
  0003b	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0003e	51		 push	 ecx
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>

; 2300 : 		return (*this);

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 2301 : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2293 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2293 : 		{	// append [_Ptr, <null>)

  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00009	8b fa		 mov	 edi, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2293 : 		{	// append [_Ptr, <null>)

  0000b	8b d9		 mov	 ebx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0000d	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL32@operator:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL32@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00017	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0001a	2b f9		 sub	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2335 : 		const size_type _Old_size = _My_data._Mysize;

  0001c	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  0001f	8b c6		 mov	 eax, esi
  00021	2b c1		 sub	 eax, ecx
  00023	3b f8		 cmp	 edi, eax
  00025	77 2b		 ja	 SHORT $LN11@operator

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0002d	8b c3		 mov	 eax, ebx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0002f	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00032	72 02		 jb	 SHORT $LN20@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00034	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN20@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00036	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0003a	52		 push	 edx
  0003b	56		 push	 esi
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  00045	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2294 : 		return (append(_Ptr));

  00049	8b c3		 mov	 eax, ebx
  0004b	5f		 pop	 edi

; 2295 : 		}

  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN11@operator:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  00052	57		 push	 edi
  00053	52		 push	 edx
  00054	c6 45 08 00	 mov	 BYTE PTR $T5[ebp], 0
  00058	8b cb		 mov	 ecx, ebx
  0005a	ff 75 08	 push	 DWORD PTR $T5[ebp]
  0005d	57		 push	 edi
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  00063	5f		 pop	 edi

; 2295 : 		}

  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$dead$ = ecx

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00000	6a 05		 push	 5
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0000c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2267 : 		return (assign(_Ptr));
; 2268 : 		}

  00011	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2237 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2238 : 		if (this != _STD addressof(_Right))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 15		 je	 SHORT $LN41@operator

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0000d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00011	8b c8		 mov	 ecx, eax

; 1594 : 		if (_Large_string_engaged())

  00013	72 02		 jb	 SHORT $LN35@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN35@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00017	ff 70 10	 push	 DWORD PTR [eax+16]
  0001a	51		 push	 ecx
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN41@operator:

; 2253 : 			}
; 2254 : 
; 2255 : 		return (*this);

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi

; 2256 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2230 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00009	72 37		 jb	 SHORT $LN38@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0000d	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 22		 jb	 SHORT $LN41@basic_stri

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00016	8d 51 23	 lea	 edx, DWORD PTR [ecx+35]
  00019	3b d1		 cmp	 edx, ecx
  0001b	76 38		 jbe	 SHORT $_Invalid_parameter$74

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0001d	8b ca		 mov	 ecx, edx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0001f	a8 1f		 test	 al, 31			; 0000001fH
  00021	75 32		 jne	 SHORT $_Invalid_parameter$74

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00023	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00026	3b d0		 cmp	 edx, eax
  00028	73 2b		 jae	 SHORT $_Invalid_parameter$74

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0002a	2b c2		 sub	 eax, edx
  0002c	83 f8 04	 cmp	 eax, 4
  0002f	72 24		 jb	 SHORT $_Invalid_parameter$74

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00031	83 f8 23	 cmp	 eax, 35			; 00000023H
  00034	77 1f		 ja	 SHORT $_Invalid_parameter$74

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00036	8b c2		 mov	 eax, edx
$LN41@basic_stri:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00038	51		 push	 ecx
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003f	83 c4 08	 add	 esp, 8
$LN38@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00042	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00049	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00050	c6 06 00	 mov	 BYTE PTR [esi], 0
  00053	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2232 : 		}

  00054	c3		 ret	 0
$_Invalid_parameter$74:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN73@basic_stri:
$LN72@basic_stri:
  0005b	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2070 : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 2071 : 		if (this != _STD addressof(_Right))

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 26		 je	 SHORT $LN69@operator

; 2072 : 			{	// different, assign it
; 2073 : 			_Tidy_deallocate();

  0000e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00013	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00016	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00019	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  0001e	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  00023	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0002a	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00031	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN69@operator:
  00034	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2082 : 		return (*this);

  00035	8b c6		 mov	 eax, esi

; 2083 : 		}

  00037	5e		 pop	 esi
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2039 : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 1563 : 		_Mysize(0),

  00006	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1564 : 		_Myres(0)

  0000d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00014	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00017	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0001a	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001f	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  00024	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0002b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00032	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2041 : 		}

  00035	8b c1		 mov	 eax, ecx
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
__Ch$dead$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1976 : 		{	// construct from _Count * _Ch

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1978 : 		assign(_Count, _Ch);

  00003	83 ec 08	 sub	 esp, 8

; 3683 : 		_My_data._Mysize = 0;

  00006	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00014	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1978 : 		assign(_Count, _Ch);

  00017	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1979 : 		}

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1962 : 		{	// construct from [_Ptr, <null>)

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00003	6a 42		 push	 66			; 00000042H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@

; 3683 : 		_My_data._Mysize = 0;

  0000a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00011	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00018	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1963 : 		_Tidy_init();
; 1964 : 		assign(_Ptr);
; 1965 : 		}

  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1947 : 		{	// construct from [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1949 : 		assign(_Ptr, _Count);

  00004	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3683 : 		_My_data._Mysize = 0;

  0000c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00013	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0001a	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1949 : 		assign(_Ptr, _Count);

  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1950 : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3683 : 		_My_data._Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1923 : 		}

  00007	8b c1		 mov	 eax, ecx

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00009	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1923 : 		}

  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right_size$1$ = -4					; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1909 : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi
  00009	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]

; 1563 : 		_Mysize(0),

  0000c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1564 : 		_Myres(0)

  00013	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0001a	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 2171 : 		const size_type _Right_size = _Right_data._Mysize;

  0001e	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00021	89 45 fc	 mov	 DWORD PTR __Right_size$1$[ebp], eax

; 1594 : 		if (_Large_string_engaged())

  00024	72 02		 jb	 SHORT $LN39@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00026	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN39@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2173 : 		if (_Right_size < this->_BUF_SIZE)

  00028	83 f8 10	 cmp	 eax, 16			; 00000010H
  0002b	73 1c		 jae	 SHORT $LN24@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0002d	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2177 : 			_My_data._Myres = this->_BUF_SIZE - 1;

  00030	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH

; 1911 : 		}

  00035	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00036	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1911 : 		}

  00039	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0003c	8b c6		 mov	 eax, esi
  0003e	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN24@basic_stri:

; 2182 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  00049	8b d8		 mov	 ebx, eax
  0004b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00050	83 cb 0f	 or	 ebx, 15			; 0000000fH
  00053	3b d8		 cmp	 ebx, eax
  00055	0f 47 d8	 cmova	 ebx, eax

; 2183 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  00058	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0005b	85 c0		 test	 eax, eax
  0005d	75 04		 jne	 SHORT $LN82@basic_stri

; 79   : 		{
; 80   : 		return (nullptr);

  0005f	33 c9		 xor	 ecx, ecx
  00061	eb 2d		 jmp	 SHORT $LN80@basic_stri
$LN82@basic_stri:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00063	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00068	72 1b		 jb	 SHORT $LN83@basic_stri

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  0006a	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 117  : 			if (_Block_size <= _User_size)

  0006d	3b c8		 cmp	 ecx, eax
  0006f	76 44		 jbe	 SHORT $LN110@basic_stri

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00077	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  0007a	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  0007d	83 e1 e0	 and	 ecx, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00080	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00083	eb 0b		 jmp	 SHORT $LN80@basic_stri
$LN83@basic_stri:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0008b	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  0008e	8b c8		 mov	 ecx, eax
$LN80@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2185 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  00090	8b 45 fc	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  00093	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 944  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00094	89 0e		 mov	 DWORD PTR [esi], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00096	50		 push	 eax
  00097	57		 push	 edi
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 _memcpy
  0009e	8b 45 fc	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1911 : 		}

  000a4	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000a7	8b c6		 mov	 eax, esi
  000a9	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
$LN110@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  000b5	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN112@basic_stri:
$LN109@basic_stri:
  000ba	cc		 int	 3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 1390 : 		{	// close the C stream

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 361  : 		if (_Myfile == 0)

  00005	83 7f 64 00	 cmp	 DWORD PTR [edi+100], 0
  00009	75 04		 jne	 SHORT $LN5@close

; 362  : 			_Ans = 0;

  0000b	33 db		 xor	 ebx, ebx

; 363  : 		else

  0000d	eb 25		 jmp	 SHORT $LN8@close
$LN5@close:

; 364  : 			{	// put any homing sequence and close file
; 365  : 			if (!_Endwrite())

  0000f	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00012	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 366  : 				_Ans = 0;
; 367  : 			if (fclose(_Myfile) != 0)

  00017	ff 77 64	 push	 DWORD PTR [edi+100]
  0001a	33 c9		 xor	 ecx, ecx
  0001c	8d 5f 18	 lea	 ebx, DWORD PTR [edi+24]
  0001f	84 c0		 test	 al, al
  00021	0f 44 d9	 cmove	 ebx, ecx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0002a	33 c9		 xor	 ecx, ecx
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	0f 45 d9	 cmovne	 ebx, ecx
$LN8@close:

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00034	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00037	c6 47 60 00	 mov	 BYTE PTR [edi+96], 0
  0003b	c6 47 55 00	 mov	 BYTE PTR [edi+85], 0
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;
; 663  : 		_State = _Stinit;

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  0004a	89 47 58	 mov	 DWORD PTR [edi+88], eax
  0004d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  00052	c7 47 64 00 00
	00 00		 mov	 DWORD PTR [edi+100], 0
  00059	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  0005c	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0

; 1391 : 		if (_Filebuffer.close() == 0)

  00063	85 db		 test	 ebx, ebx
  00065	75 10		 jne	 SHORT $LN2@close

; 1392 : 			_Myios::setstate(ios_base::failbit);

  00067	8b 07		 mov	 eax, DWORD PTR [edi]
  00069	53		 push	 ebx
  0006a	6a 02		 push	 2
  0006c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006f	03 cf		 add	 ecx, edi
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN2@close:

; 1393 : 	}

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	c3		 ret	 0
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
_TEXT	SEGMENT
__Filename$dead$ = 8					; size = 4
__Mode$ = 12						; size = 4
__Prot$dead$ = 16					; size = 4
?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 1368 : 		{	// open a C stream with specified mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00004	51		 push	 ecx
  00005	ff 75 0c	 push	 DWORD PTR __Mode$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  0000f	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00012	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00017	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 1370 : 			_Myios::setstate(ios_base::failbit);

  00019	6a 00		 push	 0
  0001b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001e	03 ce		 add	 ecx, esi
  00020	85 c0		 test	 eax, eax
  00022	75 0d		 jne	 SHORT $LN2@open
  00024	6a 02		 push	 2
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0002c	5e		 pop	 esi

; 1373 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@open:

; 1371 : 		else
; 1372 : 			_Myios::clear();	// added with C++11

  00031	6a 00		 push	 0
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00039	5e		 pop	 esi

; 1373 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1352 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 88	 mov	 eax, DWORD PTR [esi-120]

; 1353 : 		}

  00006	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 88 00
	00 00 00	 mov	 DWORD PTR [eax+esi-120], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 88	 mov	 eax, DWORD PTR [esi-120]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 88	 lea	 eax, DWORD PTR [edx-120]
  0001d	89 44 32 84	 mov	 DWORD PTR [edx+esi-124], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  00029	5e		 pop	 esi
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$GSCopy$ = -20					; size = 4
$T1 = -16						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_$initVBases$dead$ = 8					; size = 4
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1206 : 		{	// construct unopened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00033	8d 4f 78	 lea	 ecx, DWORD PTR [edi+120]
  00036	89 7d ec	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00039	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0003f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  0004c	6a 00		 push	 0
  0004e	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00058	56		 push	 esi
  00059	8b cf		 mov	 ecx, edi
  0005b	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00068	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0006f	8b 07		 mov	 eax, DWORD PTR [edi]
  00071	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00074	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  0007b	8b 07		 mov	 eax, DWORD PTR [edi]
  0007d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00080	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  00083	8d 41 88	 lea	 eax, DWORD PTR [ecx-120]
  00086	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax

; 155  : 		: _Mysb()

  0008a	8b ce		 mov	 ecx, esi
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00092	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00096	8b ce		 mov	 ecx, esi

; 156  : 		{	// construct from pointer to C stream

  00098	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 636  : 		_Closef = _Which == _Openfl;

  0009e	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0

; 637  : 		_Wrotesome = false;

  000a2	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;
; 663  : 		_State = _Stinit;

  000ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 1207 : 		}

  000b2	8b c7		 mov	 eax, edi

; 663  : 		_State = _Stinit;

  000b4	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  000b7	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000bd	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  000c4	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c7	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 1207 : 		}

  000ce	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d8	59		 pop	 ecx
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 10 00 00
	00		 je	 $LN5@basic_fstr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00013	83 c1 78	 add	 ecx, 120		; 00000078H
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_fstr:
  0001c	c3		 ret	 0
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1:
  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00020	83 c1 20	 add	 ecx, 32			; 00000020H
  00023	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3:
  00029	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00032	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00036	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00039	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
_TEXT	SEGMENT
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$dead$ = 16					; size = 4
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 1148 : 		{	// open a C stream with specified mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Mode$[ebp]
  00006	56		 push	 esi
  00007	51		 push	 ecx
  00008	8b f1		 mov	 esi, ecx
  0000a	83 c8 02	 or	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Filename$[ebp]
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00019	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 1150 : 			_Myios::setstate(ios_base::failbit);

  0001b	6a 00		 push	 0
  0001d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00020	03 ce		 add	 ecx, esi
  00022	85 c0		 test	 eax, eax
  00024	75 0d		 jne	 SHORT $LN2@open
  00026	6a 02		 push	 2
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0002e	5e		 pop	 esi

; 1153 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
$LN2@open:

; 1151 : 		else
; 1152 : 			_Myios::clear();	// added with C++11

  00033	6a 00		 push	 0
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0003b	5e		 pop	 esi

; 1153 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 0c 00	 ret	 12			; 0000000cH
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1132 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 98	 mov	 eax, DWORD PTR [esi-104]

; 1133 : 		}

  00006	8d 4e 9c	 lea	 ecx, DWORD PTR [esi-100]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  0001d	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00029	5e		 pop	 esi
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$GSCopy$ = -20					; size = 4
$T1 = -16						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_$initVBases$dead$ = 8					; size = 4
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 986  : 		{	// construct unopened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00033	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]
  00036	89 7d ec	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00039	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00053	56		 push	 esi
  00054	8b cf		 mov	 ecx, edi
  00056	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00063	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0006a	8b 07		 mov	 eax, DWORD PTR [edi]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00076	8b 07		 mov	 eax, DWORD PTR [edi]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  0007e	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00081	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax

; 155  : 		: _Mysb()

  00085	8b ce		 mov	 ecx, esi
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0008d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00091	8b ce		 mov	 ecx, esi

; 156  : 		{	// construct from pointer to C stream

  00093	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 636  : 		_Closef = _Which == _Openfl;

  00099	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0

; 637  : 		_Wrotesome = false;

  0009d	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;
; 663  : 		_State = _Stinit;

  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 987  : 		}

  000ad	8b c7		 mov	 eax, edi

; 663  : 		_State = _Stinit;

  000af	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  000b2	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000b8	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  000bf	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c2	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 987  : 		}

  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 10 00 00
	00		 je	 $LN5@basic_ofst
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_ofst:
  0001c	c3		 ret	 0
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1:
  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00020	83 c1 08	 add	 ecx, 8
  00023	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3:
  00029	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00032	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00036	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00039	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
_TEXT	SEGMENT
__Filename$dead$ = 8					; size = 4
__Mode$dead$ = 12					; size = 4
__Prot$dead$ = 16					; size = 4
?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 933  : 		{	// open a C stream with specified mode

  00000	56		 push	 esi

; 934  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00001	51		 push	 ecx
  00002	8b f1		 mov	 esi, ecx
  00004	6a 01		 push	 1
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COFBHHKL@setting?4txt?$AA@
  0000b	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  0000e	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00013	8b 16		 mov	 edx, DWORD PTR [esi]

; 935  : 			_Myios::setstate(ios_base::failbit);

  00015	6a 00		 push	 0
  00017	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0001a	03 ce		 add	 ecx, esi
  0001c	85 c0		 test	 eax, eax
  0001e	75 0c		 jne	 SHORT $LN2@open
  00020	6a 02		 push	 2
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00028	5e		 pop	 esi

; 938  : 		}

  00029	c2 0c 00	 ret	 12			; 0000000cH
$LN2@open:

; 936  : 		else
; 937  : 			_Myios::clear();	// added with C++11

  0002c	6a 00		 push	 0
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00034	5e		 pop	 esi

; 938  : 		}

  00035	c2 0c 00	 ret	 12			; 0000000cH
?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 917  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 90	 mov	 eax, DWORD PTR [esi-112]

; 918  : 		}

  00006	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 90 00
	00 00 00	 mov	 DWORD PTR [eax+esi-112], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 90	 mov	 eax, DWORD PTR [esi-112]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 90	 lea	 eax, DWORD PTR [edx-112]
  0001d	89 44 32 8c	 mov	 DWORD PTR [edx+esi-116], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00026	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  00029	5e		 pop	 esi
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$GSCopy$ = -20					; size = 4
$T1 = -16						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_$initVBases$dead$ = 8					; size = 4
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 771  : 		{	// construct unopened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00033	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  00036	89 7d ec	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00039	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00053	56		 push	 esi
  00054	8b cf		 mov	 ecx, edi
  00056	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00063	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0006a	8b 07		 mov	 eax, DWORD PTR [edi]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00076	8b 07		 mov	 eax, DWORD PTR [edi]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  0007e	8d 41 90	 lea	 eax, DWORD PTR [ecx-112]
  00081	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax

; 155  : 		: _Mysb()

  00085	8b ce		 mov	 ecx, esi
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0008d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00091	8b ce		 mov	 ecx, esi

; 156  : 		{	// construct from pointer to C stream

  00093	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 636  : 		_Closef = _Which == _Openfl;

  00099	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0

; 637  : 		_Wrotesome = false;

  0009d	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;
; 663  : 		_State = _Stinit;

  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 772  : 		}

  000ad	8b c7		 mov	 eax, edi

; 663  : 		_State = _Stinit;

  000af	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  000b2	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000b8	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  000bf	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c2	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 772  : 		}

  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 10 00 00
	00		 je	 $LN5@basic_ifst
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00013	83 c1 70	 add	 ecx, 112		; 00000070H
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_ifst:
  0001c	c3		 ret	 0
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1:
  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00020	83 c1 18	 add	 ecx, 24			; 00000018H
  00023	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3:
  00029	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00032	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00036	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00039	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 628  : 		{	// set locale to argument (capture nontrivial codecvt facet)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 629  : 		_Initcvt(&_USE(_Loc, _Cvt));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00009	57		 push	 edi
  0000a	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  0000f	8b f8		 mov	 edi, eax

; 712  : 		if (_Newpcvt->always_noconv())

  00011	8b cf		 mov	 ecx, edi
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
  00019	84 c0		 test	 al, al
  0001b	74 0d		 je	 SHORT $LN4@imbue
  0001d	5f		 pop	 edi

; 713  : 			_Pcvt = 0;	// nothing to do

  0001e	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 630  : 		}

  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN4@imbue:

; 717  : 			_Mysb::_Init();	// reset any buffering

  0002a	8b ce		 mov	 ecx, esi
  0002c	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
  00035	5f		 pop	 edi

; 630  : 		}

  00036	5e		 pop	 esi
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 621  : 		{	// synchronize C stream with external file

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 622  : 		return (_Myfile == 0

  00003	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00007	74 21		 je	 SHORT $LN3@sync
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	6a ff		 push	 -1
  0000d	ff 50 0c	 call	 DWORD PTR [eax+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  00010	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 622  : 		return (_Myfile == 0

  00013	74 15		 je	 SHORT $LN3@sync
  00015	ff 76 4c	 push	 DWORD PTR [esi+76]
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	79 05		 jns	 SHORT $LN3@sync
  00025	83 c8 ff	 or	 eax, -1
  00028	5e		 pop	 esi

; 623  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 624  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 625  : 		}

  00029	c3		 ret	 0
$LN3@sync:

; 622  : 		return (_Myfile == 0

  0002a	33 c0		 xor	 eax, eax
  0002c	5e		 pop	 esi

; 623  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 624  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 625  : 		}

  0002d	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
_TEXT	SEGMENT
__Nr$1 = -16						; size = 4
__Pn$2 = -12						; size = 4
__Pb$3 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 8
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 608  : 		{	// offer _Buffer to C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx
  00016	57		 push	 edi

; 609  : 		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,

  00017	8b 7e 4c	 mov	 edi, DWORD PTR [esi+76]
  0001a	85 ff		 test	 edi, edi
  0001c	0f 84 b8 00 00
	00		 je	 $LN4@setbuf
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	85 d2		 test	 edx, edx
  00027	75 0e		 jne	 SHORT $LN6@setbuf
  00029	8b c1		 mov	 eax, ecx
  0002b	0b 45 10	 or	 eax, DWORD PTR __Count$[ebp+4]
  0002e	75 07		 jne	 SHORT $LN6@setbuf
  00030	b8 04 00 00 00	 mov	 eax, 4
  00035	eb 02		 jmp	 SHORT $LN7@setbuf
$LN6@setbuf:
  00037	33 c0		 xor	 eax, eax
$LN7@setbuf:
  00039	51		 push	 ecx
  0003a	50		 push	 eax
  0003b	52		 push	 edx
  0003c	57		 push	 edi
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setvbuf
  00043	83 c4 10	 add	 esp, 16			; 00000010H
  00046	85 c0		 test	 eax, eax
  00048	0f 85 8c 00 00
	00		 jne	 $LN4@setbuf

; 610  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 611  : 			(size_t)_Count * sizeof (_Elem)) != 0)
; 612  : 			return (0);	// failed
; 613  : 		else
; 614  : 			{	// new buffer, reinitialize pointers
; 615  : 			_Init(_Myfile, _Openfl);

  0004e	8b 7e 4c	 mov	 edi, DWORD PTR [esi+76]

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00051	8b ce		 mov	 ecx, esi
  00053	c6 46 48 01	 mov	 BYTE PTR [esi+72], 1
  00057	88 46 3d	 mov	 BYTE PTR [esi+61], al
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)

  00060	85 ff		 test	 edi, edi
  00062	74 46		 je	 SHORT $LN9@setbuf

; 652  : 			::_get_stream_buffer_pointers(

  00064	8d 45 f0	 lea	 eax, DWORD PTR __Nr$1[ebp]
  00067	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Pb$3[ebp], 0
  0006e	50		 push	 eax
  0006f	8d 45 f4	 lea	 eax, DWORD PTR __Pn$2[ebp]
  00072	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Pn$2[ebp], 0
  00079	50		 push	 eax
  0007a	8d 45 f8	 lea	 eax, DWORD PTR __Pb$3[ebp]
  0007d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Nr$1[ebp], 0
  00084	50		 push	 eax
  00085	57		 push	 edi
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___get_stream_buffer_pointers
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 331  : 		_IGfirst = _Gf;

  0008c	8b 45 f8	 mov	 eax, DWORD PTR __Pb$3[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 652  : 			::_get_stream_buffer_pointers(

  0008f	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 335  : 		_IGcount = _Gc;

  00092	8b 4d f0	 mov	 ecx, DWORD PTR __Nr$1[ebp]
  00095	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00098	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0009b	8b 45 f4	 mov	 eax, DWORD PTR __Pn$2[ebp]
  0009e	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  000a1	89 46 20	 mov	 DWORD PTR [esi+32], eax
  000a4	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx

; 336  : 		_IPcount = _Pc;

  000a7	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
$LN9@setbuf:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 663  : 		_State = _Stinit;

  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 616  : 			return (this);

  000b0	8b c6		 mov	 eax, esi

; 662  : 		_Myfile = _File;

  000b2	89 7e 4c	 mov	 DWORD PTR [esi+76], edi

; 663  : 		_State = _Stinit;

  000b5	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  000b8	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000be	5f		 pop	 edi
  000bf	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c2	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 617  : 			}
; 618  : 		}

  000c9	5e		 pop	 esi
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cd	33 cd		 xor	 ecx, ebp
  000cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 0c 00	 ret	 12			; 0000000cH
$LN4@setbuf:
  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	33 c0		 xor	 eax, eax
  000df	5f		 pop	 edi
  000e0	33 cd		 xor	 ecx, ebp
  000e2	5e		 pop	 esi
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__Off$2$ = -20						; size = 4
__Fileposition$ = -16					; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 590  : 		{	// change position to _Pos

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 10	 mov	 DWORD PTR __$ArrayPad$[esp+20], eax

; 591  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);

  00014	8b 45 14	 mov	 eax, DWORD PTR __Pos$[ebp+8]
  00017	53		 push	 ebx

; 592  : 		off_type _Off = static_cast<off_type>(_Pos) - static_cast<off_type>(_Fileposition);

  00018	8b 5d 0c	 mov	 ebx, DWORD PTR __Pos$[ebp]
  0001b	56		 push	 esi
  0001c	8b f1		 mov	 esi, ecx
  0001e	89 44 24 0c	 mov	 DWORD PTR __Fileposition$[esp+28], eax
  00022	8b 45 18	 mov	 eax, DWORD PTR __Pos$[ebp+12]
  00025	89 44 24 10	 mov	 DWORD PTR __Fileposition$[esp+32], eax
  00029	8b 45 10	 mov	 eax, DWORD PTR __Pos$[ebp+4]

; 593  : 
; 594  : 		if (_Myfile == 0 || !_Endwrite()
; 595  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 596  : 			|| (_Off != 0 && _fseeki64(_Myfile, _Off, SEEK_CUR) != 0)
; 597  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  0002c	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00030	57		 push	 edi
  00031	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00034	89 44 24 0c	 mov	 DWORD PTR __Off$2$[esp+32], eax
  00038	0f 84 91 00 00
	00		 je	 $LN3@seekpos
  0003e	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00043	84 c0		 test	 al, al
  00045	0f 84 84 00 00
	00		 je	 $LN3@seekpos
  0004b	8d 44 24 10	 lea	 eax, DWORD PTR __Fileposition$[esp+32]
  0004f	50		 push	 eax
  00050	ff 76 4c	 push	 DWORD PTR [esi+76]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fsetpos
  00059	83 c4 08	 add	 esp, 8
  0005c	85 c0		 test	 eax, eax
  0005e	75 6f		 jne	 SHORT $LN3@seekpos
  00060	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$2$[esp+32]
  00064	8b c3		 mov	 eax, ebx
  00066	0b c1		 or	 eax, ecx
  00068	74 14		 je	 SHORT $LN4@seekpos
  0006a	6a 01		 push	 1
  0006c	51		 push	 ecx
  0006d	53		 push	 ebx
  0006e	ff 76 4c	 push	 DWORD PTR [esi+76]
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___fseeki64
  00077	83 c4 10	 add	 esp, 16			; 00000010H
  0007a	85 c0		 test	 eax, eax
  0007c	75 51		 jne	 SHORT $LN3@seekpos
$LN4@seekpos:
  0007e	8d 44 24 10	 lea	 eax, DWORD PTR __Fileposition$[esp+32]
  00082	50		 push	 eax
  00083	ff 76 4c	 push	 DWORD PTR [esi+76]
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetpos
  0008c	83 c4 08	 add	 esp, 8
  0008f	85 c0		 test	 eax, eax
  00091	75 3c		 jne	 SHORT $LN3@seekpos

; 598  : 			return (pos_type(_BADOFF));	// report failure
; 599  : 
; 600  : 		_State = _POS_TYPE_TO_STATE(_Pos);

  00093	8b 45 1c	 mov	 eax, DWORD PTR __Pos$[ebp+16]

; 601  : 
; 602  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

  00096	8b ce		 mov	 ecx, esi
  00098	89 46 40	 mov	 DWORD PTR [esi+64], eax
  0009b	8b 45 20	 mov	 eax, DWORD PTR __Pos$[ebp+20]
  0009e	89 46 44	 mov	 DWORD PTR [esi+68], eax
  000a1	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 603  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000a6	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  000a9	8b 76 44	 mov	 esi, DWORD PTR [esi+68]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 42   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  000ac	8b 4c 24 10	 mov	 ecx, DWORD PTR __Fileposition$[esp+32]
  000b0	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  000b3	8b 4c 24 14	 mov	 ecx, DWORD PTR __Fileposition$[esp+36]
  000b7	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  000bd	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  000c4	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  000c7	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000ca	89 77 14	 mov	 DWORD PTR [edi+20], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 603  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000cd	eb 26		 jmp	 SHORT $LN16@seekpos
$LN3@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  000cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?_BADOFF@std@@3_JB
  000d5	0f 57 c0	 xorps	 xmm0, xmm0
  000d8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000da	89 07		 mov	 DWORD PTR [edi], eax
  000dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000df	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000e2	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  000e9	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  000f0	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
$LN16@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 605  : 		}

  000f5	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  000f9	8b c7		 mov	 eax, edi
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	33 cc		 xor	 ecx, esp
  00100	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
__Off$2$ = -20						; size = 4
__Fileposition$ = -16					; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 568  : 		{	// change position by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 10	 mov	 DWORD PTR __$ArrayPad$[esp+20], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  0001c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 573  : 			&& _Pcvt == 0)	// not converting

  0001f	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  00022	39 08		 cmp	 DWORD PTR [eax], ecx
  00024	75 1a		 jne	 SHORT $LN21@seekoff
  00026	83 7d 14 01	 cmp	 DWORD PTR __Way$[ebp], 1
  0002a	75 14		 jne	 SHORT $LN21@seekoff
  0002c	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00030	75 0e		 jne	 SHORT $LN21@seekoff

; 574  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

  00032	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
  00035	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp+4]
  00038	83 c3 ff	 add	 ebx, -1
  0003b	83 d0 ff	 adc	 eax, -1
  0003e	eb 06		 jmp	 SHORT $LN23@seekoff
$LN21@seekoff:

; 573  : 			&& _Pcvt == 0)	// not converting

  00040	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp+4]
  00043	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
$LN23@seekoff:

; 575  : 
; 576  : 		if (_Myfile == 0 || !_Endwrite()
; 577  : 			|| ((_Off != 0 || _Way != ios_base::cur)
; 578  : 				&& _fseeki64(_Myfile, _Off, _Way) != 0)
; 579  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  00046	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0004a	89 44 24 0c	 mov	 DWORD PTR __Off$2$[esp+32], eax
  0004e	0f 84 90 00 00
	00		 je	 $LN4@seekoff
  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0005b	84 c0		 test	 al, al
  0005d	0f 84 81 00 00
	00		 je	 $LN4@seekoff
  00063	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$2$[esp+32]
  00067	8b c3		 mov	 eax, ebx
  00069	0b c1		 or	 eax, ecx
  0006b	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  0006e	75 05		 jne	 SHORT $LN6@seekoff
  00070	83 f8 01	 cmp	 eax, 1
  00073	74 13		 je	 SHORT $LN5@seekoff
$LN6@seekoff:
  00075	50		 push	 eax
  00076	51		 push	 ecx
  00077	53		 push	 ebx
  00078	ff 76 4c	 push	 DWORD PTR [esi+76]
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___fseeki64
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	85 c0		 test	 eax, eax
  00086	75 5c		 jne	 SHORT $LN4@seekoff
$LN5@seekoff:
  00088	8d 44 24 10	 lea	 eax, DWORD PTR __Fileposition$[esp+32]
  0008c	50		 push	 eax
  0008d	ff 76 4c	 push	 DWORD PTR [esi+76]
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetpos
  00096	83 c4 08	 add	 esp, 8
  00099	85 c0		 test	 eax, eax
  0009b	75 47		 jne	 SHORT $LN4@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0009d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  000a0	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  000a3	39 08		 cmp	 DWORD PTR [eax], ecx
  000a5	75 14		 jne	 SHORT $LN13@seekoff

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  000a7	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  000aa	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  000ad	2b d1		 sub	 edx, ecx
  000af	89 08		 mov	 DWORD PTR [eax], ecx
  000b1	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000b4	89 08		 mov	 DWORD PTR [eax], ecx
  000b6	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000b9	89 10		 mov	 DWORD PTR [eax], edx
$LN13@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 583  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000bb	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  000be	8b 76 44	 mov	 esi, DWORD PTR [esi+68]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 42   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  000c1	8b 4c 24 10	 mov	 ecx, DWORD PTR __Fileposition$[esp+32]
  000c5	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  000c8	8b 4c 24 14	 mov	 ecx, DWORD PTR __Fileposition$[esp+36]
  000cc	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  000d2	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  000d9	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  000dc	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000df	89 77 14	 mov	 DWORD PTR [edi+20], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 583  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000e2	eb 26		 jmp	 SHORT $LN24@seekoff
$LN4@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?_BADOFF@std@@3_JB
  000ea	0f 57 c0	 xorps	 xmm0, xmm0
  000ed	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ef	89 07		 mov	 DWORD PTR [edi], eax
  000f1	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000f4	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000f7	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  000fe	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00105	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
$LN24@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 585  : 		}

  0010a	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  0010e	8b c7		 mov	 eax, edi
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	33 cc		 xor	 ecx, esp
  00115	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
$T22 = -56						; size = 1
__Dest$84 = -52						; size = 4
__Src$85 = -48						; size = 4
__Str$86 = -44						; size = 24
__Ch$87 = -17						; size = 1
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 498  : 		{	// get an element from stream, point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  0002d	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 500  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00032	85 c9		 test	 ecx, ecx
  00034	74 23		 je	 SHORT $LN680@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00036	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00039	8b 32		 mov	 esi, DWORD PTR [edx]
  0003b	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 500  : 			&& _Mysb::gptr() < _Mysb::egptr())

  0003e	3b c8		 cmp	 ecx, eax
  00040	73 17		 jae	 SHORT $LN680@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 270  : 		--*_IGcount;

  00042	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00045	89 02		 mov	 DWORD PTR [edx], eax

; 271  : 		return ((*_IGnext)++);

  00047	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0004f	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  00051	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 501  : 			return (_Traits::to_int_type(

  00054	e9 14 02 00 00	 jmp	 $LN652@uflow
$LN680@uflow:

; 502  : 				*_Mysb::_Gninc()));	// return buffered
; 503  : 		else if (_Myfile == 0)

  00059	83 7f 4c 00	 cmp	 DWORD PTR [edi+76], 0
  0005d	75 08		 jne	 SHORT $LN11@uflow
$LN22@uflow:

; 504  : 			return (_Traits::eof());	// no open C stream, fail

  0005f	83 c8 ff	 or	 eax, -1
  00062	e9 06 02 00 00	 jmp	 $LN652@uflow
$LN11@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00067	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  0006a	8d 47 3c	 lea	 eax, DWORD PTR [edi+60]
  0006d	39 06		 cmp	 DWORD PTR [esi], eax
  0006f	75 14		 jne	 SHORT $LN43@uflow

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00071	8b 57 54	 mov	 edx, DWORD PTR [edi+84]
  00074	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00077	2b d1		 sub	 edx, ecx
  00079	89 0e		 mov	 DWORD PTR [esi], ecx
  0007b	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0007e	89 08		 mov	 DWORD PTR [eax], ecx
  00080	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00083	89 10		 mov	 DWORD PTR [eax], edx
$LN43@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 506  : 		if (_Pcvt == 0)

  00085	83 7f 38 00	 cmp	 DWORD PTR [edi+56], 0
  00089	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  0008c	75 17		 jne	 SHORT $LN12@uflow

; 49   : 	if ((_Meta = fgetc(_File)) == EOF)

  0008e	50		 push	 eax
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00095	83 c4 04	 add	 esp, 4
  00098	83 f8 ff	 cmp	 eax, -1
  0009b	74 c2		 je	 SHORT $LN22@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  0009d	0f b6 c0	 movzx	 eax, al

; 463  : 		}

  000a0	e9 c8 01 00 00	 jmp	 $LN652@uflow
$LN12@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  000a5	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Str$86[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000ac	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR __Str$86[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000b3	c6 45 d4 00	 mov	 BYTE PTR __Str$86[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 514  : 			string _Str;

  000b7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 515  : 
; 516  : 			for (;;)
; 517  : 				{	// get using codecvt facet
; 518  : 				_Elem _Ch, *_Dest;
; 519  : 				const char *_Src;
; 520  : 				int _Nleft;
; 521  : 				int _Meta = fgetc(_Myfile);

  000be	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__fgetc
  000c4	50		 push	 eax
  000c5	ff d3		 call	 ebx
  000c7	8b c8		 mov	 ecx, eax
  000c9	83 c4 04	 add	 esp, 4

; 522  : 
; 523  : 				if (_Meta == EOF)

  000cc	83 f9 ff	 cmp	 ecx, -1
  000cf	0f 84 ff 00 00
	00		 je	 $LN669@uflow
$LL2@uflow:
$_Invalid_parameter$691:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2362 : 		const size_type _Old_size = _My_data._Mysize;

  000d5	8b 75 e8	 mov	 esi, DWORD PTR __Str$86[ebp+20]
  000d8	8b c6		 mov	 eax, esi
  000da	8b 55 e4	 mov	 edx, DWORD PTR __Str$86[ebp+16]
  000dd	2b c2		 sub	 eax, edx

; 2363 : 		if (_Count <= _My_data._Myres - _Old_size)

  000df	83 f8 01	 cmp	 eax, 1
  000e2	72 27		 jb	 SHORT $LN158@uflow

; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  000e4	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  000e7	0f be c9	 movsx	 ecx, cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  000ea	89 45 e4	 mov	 DWORD PTR __Str$86[ebp+16], eax

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000ed	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  000f0	8d 45 d4	 lea	 eax, DWORD PTR __Str$86[ebp]

; 1583 : 		if (_Large_string_engaged())

  000f3	0f 43 45 d4	 cmovae	 eax, DWORD PTR __Str$86[ebp]

; 2367 : 			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  000f7	03 d0		 add	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  000f9	0f b6 c1	 movzx	 eax, cl
  000fc	66 c1 e1 08	 shl	 cx, 8
  00100	66 0b c8	 or	 cx, ax
  00103	88 0a		 mov	 BYTE PTR [edx], cl

; 442  : 		_Left = _Right;

  00105	c6 42 01 00	 mov	 BYTE PTR [edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2369 : 			return (*this);

  00109	eb 14		 jmp	 SHORT $LN157@uflow
$LN158@uflow:

; 2370 : 			}
; 2371 : 
; 2372 : 		return (_Reallocate_grow_by(_Count,

  0010b	51		 push	 ecx
  0010c	6a 01		 push	 1
  0010e	c6 45 c8 00	 mov	 BYTE PTR $T22[ebp], 0
  00112	8d 4d d4	 lea	 ecx, DWORD PTR __Str$86[ebp]
  00115	ff 75 c8	 push	 DWORD PTR $T22[ebp]
  00118	6a 01		 push	 1
  0011a	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN157@uflow:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0011f	83 7d e8 10	 cmp	 DWORD PTR __Str$86[ebp+20], 16 ; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 527  : 				switch (_Pcvt->in(_State,

  00123	8d 45 cc	 lea	 eax, DWORD PTR __Dest$84[ebp]
  00126	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00129	8d 75 d4	 lea	 esi, DWORD PTR __Str$86[ebp]

; 1583 : 		if (_Large_string_engaged())

  0012c	0f 43 75 d4	 cmovae	 esi, DWORD PTR __Str$86[ebp]

; 1582 : 		value_type * _Result = _Bx._Buf;

  00130	8d 55 d4	 lea	 edx, DWORD PTR __Str$86[ebp]

; 1583 : 		if (_Large_string_engaged())

  00133	0f 43 55 d4	 cmovae	 edx, DWORD PTR __Str$86[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 527  : 				switch (_Pcvt->in(_State,

  00137	50		 push	 eax
  00138	8d 45 f0	 lea	 eax, DWORD PTR __Ch$87[ebp+1]
  0013b	50		 push	 eax
  0013c	8d 45 ef	 lea	 eax, DWORD PTR __Ch$87[ebp]
  0013f	50		 push	 eax
  00140	8d 45 d0	 lea	 eax, DWORD PTR __Src$85[ebp]
  00143	50		 push	 eax
  00144	8b 45 e4	 mov	 eax, DWORD PTR __Str$86[ebp+16]
  00147	03 c6		 add	 eax, esi
  00149	50		 push	 eax
  0014a	52		 push	 edx
  0014b	8d 47 40	 lea	 eax, DWORD PTR [edi+64]
  0014e	50		 push	 eax
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
  00155	85 c0		 test	 eax, eax
  00157	78 7b		 js	 SHORT $LN669@uflow
  00159	83 f8 01	 cmp	 eax, 1
  0015c	7e 40		 jle	 SHORT $LN15@uflow
  0015e	83 f8 03	 cmp	 eax, 3
  00161	75 71		 jne	 SHORT $LN669@uflow

; 545  : 							(size_t)(_Src - &*_Str.begin()));
; 546  : 					break;
; 547  : 
; 548  : 				case codecvt_base::noconv:
; 549  : 					if (_Str.size() < sizeof (_Elem))

  00163	83 7d e4 01	 cmp	 DWORD PTR __Str$86[ebp+16], 1
  00167	72 58		 jb	 SHORT $LN17@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00169	83 7d e8 10	 cmp	 DWORD PTR __Str$86[ebp+20], 16 ; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  0016d	8d 45 d4	 lea	 eax, DWORD PTR __Str$86[ebp]

; 1583 : 		if (_Large_string_engaged())

  00170	0f 82 a1 00 00
	00		 jb	 $LN679@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00176	8b 45 d4	 mov	 eax, DWORD PTR __Str$86[ebp]
  00179	85 c0		 test	 eax, eax
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  0017b	0f 85 96 00 00
	00		 jne	 $LN679@uflow

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  00181	88 45 ef	 mov	 BYTE PTR __Ch$87[ebp], al

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0018a	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  00196	8a 45 ef	 mov	 al, BYTE PTR __Ch$87[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  00199	0f b6 f0	 movzx	 esi, al
  0019c	eb 39		 jmp	 SHORT $LN523@uflow
$LN15@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 533  : 					if (_Dest != &_Ch)

  0019e	8d 45 ef	 lea	 eax, DWORD PTR __Ch$87[ebp]
  001a1	39 45 cc	 cmp	 DWORD PTR __Dest$84[ebp], eax
  001a4	75 7b		 jne	 SHORT $LN671@uflow
$_Invalid_parameter$692:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001a6	83 7d e8 10	 cmp	 DWORD PTR __Str$86[ebp+20], 16 ; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  001aa	8d 4d d4	 lea	 ecx, DWORD PTR __Str$86[ebp]

; 1202 : 		: _Ptr(_Parg)

  001ad	8b 45 d0	 mov	 eax, DWORD PTR __Src$85[ebp]

; 1583 : 		if (_Large_string_engaged())

  001b0	0f 43 4d d4	 cmovae	 ecx, DWORD PTR __Str$86[ebp]

; 1202 : 		: _Ptr(_Parg)

  001b4	2b c1		 sub	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 544  : 						_Str.erase((size_t)0,	// partial, discard used input

  001b6	8d 4d d4	 lea	 ecx, DWORD PTR __Str$86[ebp]
  001b9	50		 push	 eax
  001ba	6a 00		 push	 0
  001bc	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
$LN17@uflow:

; 515  : 
; 516  : 			for (;;)
; 517  : 				{	// get using codecvt facet
; 518  : 				_Elem _Ch, *_Dest;
; 519  : 				const char *_Src;
; 520  : 				int _Nleft;
; 521  : 				int _Meta = fgetc(_Myfile);

  001c1	ff 77 4c	 push	 DWORD PTR [edi+76]
  001c4	ff d3		 call	 ebx
  001c6	8b c8		 mov	 ecx, eax
  001c8	83 c4 04	 add	 esp, 4

; 522  : 
; 523  : 				if (_Meta == EOF)

  001cb	83 f9 ff	 cmp	 ecx, -1
  001ce	0f 85 01 ff ff
	ff		 jne	 $LL2@uflow
$LN669@uflow:
$_Invalid_parameter$693:
  001d4	83 ce ff	 or	 esi, -1
$LN523@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001d7	8b 55 e8	 mov	 edx, DWORD PTR __Str$86[ebp+20]
  001da	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  001dd	0f 82 88 00 00
	00		 jb	 $LN563@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001e3	8b 4d d4	 mov	 ecx, DWORD PTR __Str$86[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001e6	42		 inc	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001e7	8b c1		 mov	 eax, ecx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001e9	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001ef	72 70		 jb	 SHORT $LN566@uflow

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001f1	8d 7a 23	 lea	 edi, DWORD PTR [edx+35]
  001f4	3b fa		 cmp	 edi, edx
  001f6	76 19		 jbe	 SHORT $_Invalid_parameter$694

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001f8	8b d7		 mov	 edx, edi
  001fa	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001fc	75 13		 jne	 SHORT $_Invalid_parameter$694

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001fe	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00201	3b c8		 cmp	 ecx, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00203	73 0c		 jae	 SHORT $_Invalid_parameter$694

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00205	2b c1		 sub	 eax, ecx
  00207	83 f8 04	 cmp	 eax, 4
  0020a	72 05		 jb	 SHORT $_Invalid_parameter$694

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0020c	83 f8 23	 cmp	 eax, 35			; 00000023H
  0020f	76 50		 jbe	 SHORT $LN566@uflow
$_Invalid_parameter$694:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00211	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN690@uflow:
$LN679@uflow:
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h

; 59   :         memcpy(_Destination, _Source, _SourceSize);

  00217	8a 00		 mov	 al, BYTE PTR [eax]
  00219	88 45 ef	 mov	 BYTE PTR __Ch$87[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  0021c	0f b6 f0	 movzx	 esi, al
  0021f	eb b6		 jmp	 SHORT $LN523@uflow
$LN671@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00221	83 7d e8 10	 cmp	 DWORD PTR __Str$86[ebp+20], 16 ; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00225	8d 45 d4	 lea	 eax, DWORD PTR __Str$86[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 535  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  00228	8b 75 e4	 mov	 esi, DWORD PTR __Str$86[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1583 : 		if (_Large_string_engaged())

  0022b	0f 43 45 d4	 cmovae	 eax, DWORD PTR __Str$86[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 535  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  0022f	8b 4d d0	 mov	 ecx, DWORD PTR __Src$85[ebp]
  00232	2b f1		 sub	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1223 : 		return (*_Ptr);

  00234	03 f0		 add	 esi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 536  : 						while (0 < _Nleft)

  00236	85 f6		 test	 esi, esi
  00238	7e 1e		 jle	 SHORT $LN684@uflow
  0023a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__ungetc
$LL7@uflow:

; 537  : 							{
; 538  : 							ungetc(_Src[--_Nleft], _Myfile);

  00240	ff 77 4c	 push	 DWORD PTR [edi+76]
  00243	0f be 44 0e ff	 movsx	 eax, BYTE PTR [esi+ecx-1]
  00248	4e		 dec	 esi
  00249	50		 push	 eax
  0024a	ff d3		 call	 ebx
  0024c	83 c4 08	 add	 esp, 8
  0024f	85 f6		 test	 esi, esi
  00251	7e 05		 jle	 SHORT $LN684@uflow

; 536  : 						while (0 < _Nleft)

  00253	8b 4d d0	 mov	 ecx, DWORD PTR __Src$85[ebp]
  00256	eb e8		 jmp	 SHORT $LL7@uflow
$LN684@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  00258	0f b6 75 ef	 movzx	 esi, BYTE PTR __Ch$87[ebp]
  0025c	e9 76 ff ff ff	 jmp	 $LN523@uflow
$LN566@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00261	52		 push	 edx
  00262	51		 push	 ecx
  00263	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00268	83 c4 08	 add	 esp, 8
$LN563@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 558  : 					return (_Traits::eof());	// conversion failed

  0026b	8b c6		 mov	 eax, esi
$LN652@uflow:

; 559  : 					}
; 560  : 				}
; 561  : 			}
; 562  : 		}

  0026d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00270	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00277	59		 pop	 ecx
  00278	5f		 pop	 edi
  00279	5e		 pop	 esi
  0027a	5b		 pop	 ebx
  0027b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027e	33 cd		 xor	 ecx, ebp
  00280	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00285	8b e5		 mov	 esp, ebp
  00287	5d		 pop	 ebp
  00288	c3		 ret	 0
$LN689@uflow:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Str$86[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 483  : 		{	// get an element from stream, but don't point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00003	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 486  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	85 c9		 test	 ecx, ecx
  0000a	74 10		 je	 SHORT $LN2@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0000c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	03 c1		 add	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 486  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00013	3b c8		 cmp	 ecx, eax
  00015	73 05		 jae	 SHORT $LN2@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  00017	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0001a	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 495  : 		}

  0001b	c3		 ret	 0
$LN2@underflow:

; 488  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8b ce		 mov	 ecx, esi
  00020	57		 push	 edi
  00021	ff 50 1c	 call	 DWORD PTR [eax+28]
  00024	8b f8		 mov	 edi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  00026	83 ff ff	 cmp	 edi, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 488  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  00029	75 05		 jne	 SHORT $LN4@underflow

; 489  : 			return (_Meta);	// uflow failed, return EOF

  0002b	5f		 pop	 edi
  0002c	0b c0		 or	 eax, eax
  0002e	5e		 pop	 esi

; 495  : 		}

  0002f	c3		 ret	 0
$LN4@underflow:

; 490  : 		else
; 491  : 			{	// get a char, don't point past it
; 492  : 			pbackfail(_Meta);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b ce		 mov	 ecx, esi
  00034	57		 push	 edi
  00035	ff 50 10	 call	 DWORD PTR [eax+16]

; 493  : 			return (_Meta);

  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi

; 495  : 		}

  0003c	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 458  : 		{	// put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 461  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  0000a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 461  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 2e		 je	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00013	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 461  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00016	39 08		 cmp	 DWORD PTR [eax], ecx
  00018	73 27		 jae	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  0001a	83 fb ff	 cmp	 ebx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 461  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001d	74 08		 je	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  0001f	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]

; 467  : 		return (_Left == _Right);

  00023	3b c3		 cmp	 eax, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 461  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00025	75 1a		 jne	 SHORT $LN2@pbackfail
$LN4@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 264  : 		++*_IGcount;

  00027	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0002a	ff 00		 inc	 DWORD PTR [eax]

; 265  : 		return (--*_IGnext);

  0002c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0002f	ff 08		 dec	 DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 466  : 			return (_Traits::not_eof(_Meta));

  00031	33 c0		 xor	 eax, eax
  00033	83 fb ff	 cmp	 ebx, -1
  00036	0f 44 d8	 cmove	 ebx, eax
$LN83@pbackfail:
  00039	5e		 pop	 esi
  0003a	8b c3		 mov	 eax, ebx

; 477  : 			}
; 478  : 		else
; 479  : 			return (_Traits::eof());	// nowhere to put back
; 480  : 	}

  0003c	5b		 pop	 ebx
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN2@pbackfail:

; 468  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  00041	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00044	85 c0		 test	 eax, eax
  00046	74 5d		 je	 SHORT $LN7@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  00048	83 fb ff	 cmp	 ebx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 468  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  0004b	74 58		 je	 SHORT $LN7@pbackfail

; 470  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  0004d	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00051	75 13		 jne	 SHORT $LN81@pbackfail

; 117  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  00053	50		 push	 eax
  00054	0f b6 cb	 movzx	 ecx, bl
  00057	51		 push	 ecx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ungetc
  0005e	83 c4 08	 add	 esp, 8
  00061	83 f8 ff	 cmp	 eax, -1

; 470  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  00064	75 d3		 jne	 SHORT $LN83@pbackfail
$LN81@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00066	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 472  : 		else if (_Mysb::gptr() != &_Mychar)

  00069	8d 56 3c	 lea	 edx, DWORD PTR [esi+60]
  0006c	39 11		 cmp	 DWORD PTR [ecx], edx
  0006e	74 35		 je	 SHORT $LN7@pbackfail

; 474  : 			_Mychar = _Traits::to_char_type(_Meta);

  00070	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00071	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 474  : 			_Mychar = _Traits::to_char_type(_Meta);

  00074	88 1a		 mov	 BYTE PTR [edx], bl

; 737  : 		if (_Mysb::eback() != &_Mychar)

  00076	8b 07		 mov	 eax, DWORD PTR [edi]
  00078	3b c2		 cmp	 eax, edx
  0007a	74 0d		 je	 SHORT $LN82@pbackfail

; 738  : 			{	// save current get buffer
; 739  : 			_Set_eback = _Mysb::eback();

  0007c	89 46 50	 mov	 DWORD PTR [esi+80], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0007f	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00082	8b 00		 mov	 eax, DWORD PTR [eax]
  00084	03 01		 add	 eax, DWORD PTR [ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 740  : 			_Set_egptr = _Mysb::egptr();

  00086	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN82@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00089	89 17		 mov	 DWORD PTR [edi], edx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008b	8b ce		 mov	 ecx, esi
  0008d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00090	2b ca		 sub	 ecx, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 476  : 			return (_Meta);

  00092	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00093	83 c1 3d	 add	 ecx, 61			; 0000003dH
  00096	89 10		 mov	 DWORD PTR [eax], edx
  00098	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0009b	5e		 pop	 esi
  0009c	89 08		 mov	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 476  : 			return (_Meta);

  0009e	8b c3		 mov	 eax, ebx

; 477  : 			}
; 478  : 		else
; 479  : 			return (_Traits::eof());	// nowhere to put back
; 480  : 	}

  000a0	5b		 pop	 ebx
  000a1	5d		 pop	 ebp
  000a2	c2 04 00	 ret	 4
$LN7@pbackfail:
  000a5	5e		 pop	 esi

; 469  : 			return (_Traits::eof());	// no open C stream or EOF, fail

  000a6	83 c8 ff	 or	 eax, -1

; 477  : 			}
; 478  : 		else
; 479  : 			return (_Traits::eof());	// nowhere to put back
; 480  : 	}

  000a9	5b		 pop	 ebx
  000aa	5d		 pop	 ebp
  000ab	c2 04 00	 ret	 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
$T58 = -60						; size = 1
__Count$1$ = -56					; size = 4
__Src$87 = -52						; size = 4
__Dest$88 = -48						; size = 4
__Str$89 = -44						; size = 24
__Ch$90 = -17						; size = 1
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Meta$ = 8						; size = 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 389  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx

; 390  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Meta$[ebp]
  00030	83 f9 ff	 cmp	 ecx, -1
  00033	75 07		 jne	 SHORT $LN7@overflow

; 391  : 			{
; 392  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  00035	33 c0		 xor	 eax, eax
  00037	e9 14 02 00 00	 jmp	 $LN698@overflow
$LN7@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  0003c	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0003f	8b 10		 mov	 edx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 394  : 		else if (_Mysb::pptr() != 0 && _Mysb::pptr() < _Mysb::epptr())

  00041	85 d2		 test	 edx, edx
  00043	74 25		 je	 SHORT $LN9@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00045	8b 73 30	 mov	 esi, DWORD PTR [ebx+48]
  00048	8b 3e		 mov	 edi, DWORD PTR [esi]
  0004a	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 394  : 		else if (_Mysb::pptr() != 0 && _Mysb::pptr() < _Mysb::epptr())

  0004d	3b d0		 cmp	 edx, eax
  0004f	73 19		 jae	 SHORT $LN9@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 307  : 		--*_IPcount;

  00051	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00054	89 06		 mov	 DWORD PTR [esi], eax

; 308  : 		return ((*_IPnext)++);

  00056	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 396  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00060	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00063	88 02		 mov	 BYTE PTR [edx], al

; 397  : 			return (_Meta);

  00065	e9 e6 01 00 00	 jmp	 $LN698@overflow
$LN9@overflow:

; 398  : 			}
; 399  : 		else if (_Myfile == 0)

  0006a	83 7b 4c 00	 cmp	 DWORD PTR [ebx+76], 0
  0006e	75 08		 jne	 SHORT $LN11@overflow

; 400  : 			{
; 401  : 			return (_Traits::eof());	// no open C stream, fail

  00070	83 c8 ff	 or	 eax, -1
  00073	e9 d8 01 00 00	 jmp	 $LN698@overflow
$LN11@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00078	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  0007b	8d 43 3c	 lea	 eax, DWORD PTR [ebx+60]
  0007e	39 06		 cmp	 DWORD PTR [esi], eax
  00080	75 17		 jne	 SHORT $LN65@overflow

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00082	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  00085	8b 53 54	 mov	 edx, DWORD PTR [ebx+84]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00088	89 0e		 mov	 DWORD PTR [esi], ecx

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008a	2b d1		 sub	 edx, ecx
  0008c	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0008f	89 08		 mov	 DWORD PTR [eax], ecx
  00091	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Meta$[ebp]
  00097	89 10		 mov	 DWORD PTR [eax], edx
$LN65@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 405  : 		if (_Pcvt == 0)

  00099	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  0009d	75 20		 jne	 SHORT $LN12@overflow

; 93   : 	return (fputc(_Byte, _File) != EOF);

  0009f	ff 73 4c	 push	 DWORD PTR [ebx+76]
  000a2	0f be c1	 movsx	 eax, cl
  000a5	50		 push	 eax
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputc

; 406  : 			{
; 407  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)

  000ac	83 c9 ff	 or	 ecx, -1

; 93   : 	return (fputc(_Byte, _File) != EOF);

  000af	83 c4 08	 add	 esp, 8
  000b2	3b c1		 cmp	 eax, ecx

; 406  : 			{
; 407  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)

  000b4	0f 45 4d 08	 cmovne	 ecx, DWORD PTR __Meta$[ebp]
  000b8	8b c1		 mov	 eax, ecx
  000ba	e9 91 01 00 00	 jmp	 $LN698@overflow
$LN12@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1978 : 		assign(_Count, _Ch);

  000bf	83 ec 08	 sub	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 457  : 		return (static_cast<char>(_Meta));

  000c2	88 4d ef	 mov	 BYTE PTR __Ch$90[ebp], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1978 : 		assign(_Count, _Ch);

  000c5	8d 4d d4	 lea	 ecx, DWORD PTR __Str$89[ebp]

; 3683 : 		_My_data._Mysize = 0;

  000c8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Str$89[ebp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000cf	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR __Str$89[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000d6	c6 45 d4 00	 mov	 BYTE PTR __Str$89[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1978 : 		assign(_Count, _Ch);

  000da	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 417  : 			string _Str(_STRING_INC, '\0');

  000df	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
$LN721@overflow:
$_Invalid_parameter$725:
  000e6	8b 7d e8	 mov	 edi, DWORD PTR __Str$89[ebp+20]
  000e9	8b 75 d4	 mov	 esi, DWORD PTR __Str$89[ebp]
  000ec	0f 1f 40 00	 npad	 4
$LL2@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000f0	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 420  : 				switch (_Pcvt->out(_State,

  000f3	8d 45 d0	 lea	 eax, DWORD PTR __Dest$88[ebp]
  000f6	50		 push	 eax
  000f7	8b 45 e4	 mov	 eax, DWORD PTR __Str$89[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  000fa	8d 55 d4	 lea	 edx, DWORD PTR __Str$89[ebp]

; 1583 : 		if (_Large_string_engaged())

  000fd	0f 43 d6	 cmovae	 edx, esi

; 1582 : 		value_type * _Result = _Bx._Buf;

  00100	8d 4d d4	 lea	 ecx, DWORD PTR __Str$89[ebp]

; 1583 : 		if (_Large_string_engaged())

  00103	0f 43 ce	 cmovae	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 420  : 				switch (_Pcvt->out(_State,

  00106	03 c2		 add	 eax, edx
  00108	50		 push	 eax
  00109	51		 push	 ecx
  0010a	8b 4b 38	 mov	 ecx, DWORD PTR [ebx+56]
  0010d	8d 45 cc	 lea	 eax, DWORD PTR __Src$87[ebp]
  00110	50		 push	 eax
  00111	8d 45 f0	 lea	 eax, DWORD PTR __Ch$90[ebp+1]
  00114	50		 push	 eax
  00115	8d 45 ef	 lea	 eax, DWORD PTR __Ch$90[ebp]
  00118	50		 push	 eax
  00119	8d 43 40	 lea	 eax, DWORD PTR [ebx+64]
  0011c	50		 push	 eax
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
  00123	85 c0		 test	 eax, eax
  00125	0f 88 da 00 00
	00		 js	 $LN22@overflow
  0012b	83 f8 01	 cmp	 eax, 1
  0012e	0f 8f a8 00 00
	00		 jg	 $LN714@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00134	8b 7d e8	 mov	 edi, DWORD PTR __Str$89[ebp+20]

; 1582 : 		value_type * _Result = _Bx._Buf;

  00137	8d 45 d4	 lea	 eax, DWORD PTR __Str$89[ebp]

; 1583 : 		if (_Large_string_engaged())

  0013a	8b 75 d4	 mov	 esi, DWORD PTR __Str$89[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0013d	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1202 : 		: _Ptr(_Parg)

  00140	8b 4d d0	 mov	 ecx, DWORD PTR __Dest$88[ebp]

; 1583 : 		if (_Large_string_engaged())

  00143	0f 43 c6	 cmovae	 eax, esi

; 1202 : 		: _Ptr(_Parg)

  00146	2b c8		 sub	 ecx, eax
  00148	89 4d c8	 mov	 DWORD PTR __Count$1$[ebp], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 428  : 						if (0 < _Count && _Count !=

  0014b	74 2a		 je	 SHORT $LN15@overflow
  0014d	ff 73 4c	 push	 DWORD PTR [ebx+76]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00150	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  00153	8d 45 d4	 lea	 eax, DWORD PTR __Str$89[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 428  : 						if (0 < _Count && _Count !=

  00156	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1583 : 		if (_Large_string_engaged())

  00157	0f 43 c6	 cmovae	 eax, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 428  : 						if (0 < _Count && _Count !=

  0015a	6a 01		 push	 1
  0015c	50		 push	 eax
  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00163	8b 4d c8	 mov	 ecx, DWORD PTR __Count$1$[ebp]
  00166	83 c4 10	 add	 esp, 16			; 00000010H
  00169	8b 7d e8	 mov	 edi, DWORD PTR __Str$89[ebp+20]
  0016c	8b 75 d4	 mov	 esi, DWORD PTR __Str$89[ebp]
  0016f	3b c8		 cmp	 ecx, eax
  00171	0f 85 94 00 00
	00		 jne	 $LN715@overflow
$LN15@overflow:
$_Invalid_parameter$726:

; 429  : 							fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 430  : 							return (_Traits::eof());	// write failed
; 431  : 
; 432  : 						_Wrotesome = true;	// write succeeded
; 433  : 						if (_Src != &_Ch)

  00177	8d 45 ef	 lea	 eax, DWORD PTR __Ch$90[ebp]
  0017a	c6 43 3d 01	 mov	 BYTE PTR [ebx+61], 1
  0017e	39 45 cc	 cmp	 DWORD PTR __Src$87[ebp], eax
  00181	75 54		 jne	 SHORT $LN716@overflow
$_Invalid_parameter$727:

; 434  : 							return (_Meta);	// converted whole element
; 435  : 
; 436  : 						if (0 < _Count)

  00183	85 c9		 test	 ecx, ecx
  00185	0f 85 65 ff ff
	ff		 jne	 $LL2@overflow

; 437  : 							;
; 438  : 						else if (_Str.size() < 4 * _STRING_INC)

  0018b	8b 4d e4	 mov	 ecx, DWORD PTR __Str$89[ebp+16]
  0018e	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00191	73 78		 jae	 SHORT $LN715@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2362 : 		const size_type _Old_size = _My_data._Mysize;

  00193	8b c7		 mov	 eax, edi
  00195	2b c1		 sub	 eax, ecx

; 2363 : 		if (_Count <= _My_data._Myres - _Old_size)

  00197	83 f8 08	 cmp	 eax, 8
  0019a	72 21		 jb	 SHORT $LN397@overflow

; 2364 : 			{
; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  0019c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0019f	83 ff 10	 cmp	 edi, 16			; 00000010H

; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  001a2	89 45 e4	 mov	 DWORD PTR __Str$89[ebp+16], eax
  001a5	0f 57 c0	 xorps	 xmm0, xmm0

; 1582 : 		value_type * _Result = _Bx._Buf;

  001a8	8d 45 d4	 lea	 eax, DWORD PTR __Str$89[ebp]

; 1583 : 		if (_Large_string_engaged())

  001ab	0f 43 c6	 cmovae	 eax, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  001ae	66 0f d6 04 08	 movq	 QWORD PTR [eax+ecx], xmm0

; 442  : 		_Left = _Right;

  001b3	c6 44 08 08 00	 mov	 BYTE PTR [eax+ecx+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2369 : 			return (*this);

  001b8	e9 29 ff ff ff	 jmp	 $LN721@overflow
$LN397@overflow:

; 2370 : 			}
; 2371 : 
; 2372 : 		return (_Reallocate_grow_by(_Count,

  001bd	6a 00		 push	 0
  001bf	6a 08		 push	 8
  001c1	c6 45 c4 00	 mov	 BYTE PTR $T58[ebp], 0
  001c5	8d 4d d4	 lea	 ecx, DWORD PTR __Str$89[ebp]
  001c8	ff 75 c4	 push	 DWORD PTR $T58[ebp]
  001cb	6a 08		 push	 8
  001cd	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 452  : 				}

  001d2	e9 0f ff ff ff	 jmp	 $LN721@overflow
$LN716@overflow:
  001d7	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  001da	eb 32		 jmp	 SHORT $LN569@overflow
$LN714@overflow:

; 420  : 				switch (_Pcvt->out(_State,

  001dc	83 f8 03	 cmp	 eax, 3
  001df	75 24		 jne	 SHORT $LN22@overflow

; 93   : 	return (fputc(_Byte, _File) != EOF);

  001e1	ff 73 4c	 push	 DWORD PTR [ebx+76]
  001e4	0f be 45 ef	 movsx	 eax, BYTE PTR __Ch$90[ebp]
  001e8	50		 push	 eax
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputc

; 439  : 							_Str.append(_STRING_INC, '\0');	// try with more space
; 440  : 						else
; 441  : 							return (_Traits::eof());	// conversion failed
; 442  : 						break;
; 443  : 						}
; 444  : 
; 445  : 					case codecvt_base::noconv:
; 446  : 						return (_Fputc(_Ch, _Myfile) ? _Meta

  001ef	8b 7d e8	 mov	 edi, DWORD PTR __Str$89[ebp+20]
  001f2	83 c9 ff	 or	 ecx, -1
  001f5	8b 75 d4	 mov	 esi, DWORD PTR __Str$89[ebp]

; 93   : 	return (fputc(_Byte, _File) != EOF);

  001f8	83 c4 08	 add	 esp, 8
  001fb	3b c1		 cmp	 eax, ecx

; 439  : 							_Str.append(_STRING_INC, '\0');	// try with more space
; 440  : 						else
; 441  : 							return (_Traits::eof());	// conversion failed
; 442  : 						break;
; 443  : 						}
; 444  : 
; 445  : 					case codecvt_base::noconv:
; 446  : 						return (_Fputc(_Ch, _Myfile) ? _Meta

  001fd	0f 45 4d 08	 cmovne	 ecx, DWORD PTR __Meta$[ebp]
  00201	8b d9		 mov	 ebx, ecx
  00203	eb 09		 jmp	 SHORT $LN569@overflow
$LN22@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 477  : 		return (EOF);

  00205	8b 7d e8	 mov	 edi, DWORD PTR __Str$89[ebp+20]
  00208	8b 75 d4	 mov	 esi, DWORD PTR __Str$89[ebp]
$LN715@overflow:
$_Invalid_parameter$728:
  0020b	83 cb ff	 or	 ebx, -1
$LN569@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0020e	83 ff 10	 cmp	 edi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00211	72 3b		 jb	 SHORT $LN609@overflow

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00213	47		 inc	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00214	8b c6		 mov	 eax, esi

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00216	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  0021c	72 26		 jb	 SHORT $LN612@overflow

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0021e	8d 4f 23	 lea	 ecx, DWORD PTR [edi+35]
  00221	3b cf		 cmp	 ecx, edi
  00223	76 19		 jbe	 SHORT $_Invalid_parameter$729

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00225	8b f9		 mov	 edi, ecx
  00227	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00229	75 13		 jne	 SHORT $_Invalid_parameter$729

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0022b	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  0022e	3b f0		 cmp	 esi, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00230	73 0c		 jae	 SHORT $_Invalid_parameter$729

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00232	2b c6		 sub	 eax, esi
  00234	83 f8 04	 cmp	 eax, 4
  00237	72 05		 jb	 SHORT $_Invalid_parameter$729

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00239	83 f8 23	 cmp	 eax, 35			; 00000023H
  0023c	76 06		 jbe	 SHORT $LN612@overflow
$_Invalid_parameter$729:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0023e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN724@overflow:
$LN612@overflow:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00244	57		 push	 edi
  00245	56		 push	 esi
  00246	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0024b	83 c4 08	 add	 esp, 8
$LN609@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 450  : 						return (_Traits::eof());	// conversion failed

  0024e	8b c3		 mov	 eax, ebx
$LN698@overflow:

; 453  : 			}
; 454  : 		}

  00250	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00253	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025a	59		 pop	 ecx
  0025b	5f		 pop	 edi
  0025c	5e		 pop	 esi
  0025d	5b		 pop	 ebx
  0025e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00261	33 cd		 xor	 ecx, ebp
  00263	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00268	8b e5		 mov	 esp, ebp
  0026a	5d		 pop	 ebp
  0026b	c2 04 00	 ret	 4
$LN723@overflow:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Str$89[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 382  : 		if (_Myfile)

  00000	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00003	85 c0		 test	 eax, eax
  00005	74 08		 je	 SHORT $LN2@Unlock

; 383  : 			_CSTD _unlock_file(_Myfile);

  00007	50		 push	 eax
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___unlock_file
  0000e	59		 pop	 ecx
$LN2@Unlock:

; 384  : 		}

  0000f	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 376  : 		if (_Myfile)

  00000	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00003	85 c0		 test	 eax, eax
  00005	74 08		 je	 SHORT $LN2@Lock

; 377  : 			_CSTD _lock_file(_Myfile);

  00007	50		 push	 eax
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___lock_file
  0000e	59		 pop	 ecx
$LN2@Lock:

; 378  : 		}

  0000f	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 161  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 162  : 		if (_Myfile != 0)

  00026	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00030	74 1e		 je	 SHORT $LN6@basic_file
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00032	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  00035	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  00038	39 07		 cmp	 DWORD PTR [edi], eax
  0003a	75 14		 jne	 SHORT $LN6@basic_file

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0003c	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  0003f	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00042	2b d1		 sub	 edx, ecx
  00044	89 0f		 mov	 DWORD PTR [edi], ecx
  00046	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
  0004b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0004e	89 10		 mov	 DWORD PTR [eax], edx
$LN6@basic_file:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 164  : 		if (_Closef)

  00050	80 7e 48 00	 cmp	 BYTE PTR [esi+72], 0
  00054	74 47		 je	 SHORT $LN3@basic_file

; 361  : 		if (_Myfile == 0)

  00056	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0005a	74 13		 je	 SHORT $LN16@basic_file

; 362  : 			_Ans = 0;
; 363  : 		else
; 364  : 			{	// put any homing sequence and close file
; 365  : 			if (!_Endwrite())

  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 366  : 				_Ans = 0;
; 367  : 			if (fclose(_Myfile) != 0)

  00063	ff 76 4c	 push	 DWORD PTR [esi+76]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0006c	83 c4 04	 add	 esp, 4
$LN16@basic_file:

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  0006f	8b ce		 mov	 ecx, esi
  00071	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0
  00075	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;
; 663  : 		_State = _Stinit;

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  00084	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00087	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  0008c	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  00093	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  00096	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
$LN3@basic_file:

; 165  : 			close();
; 166  : 		}

  0009d	8b ce		 mov	 ecx, esi
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  000a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000af	59		 pop	 ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 643  : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 644  : 		return (_Stringbuffer.str());

  00003	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00006	83 c1 18	 add	 ecx, 24			; 00000018H
  00009	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 645  : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 634  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 98	 mov	 eax, DWORD PTR [esi-104]

; 635  : 		}

  00006	8d 4e b0	 lea	 ecx, DWORD PTR [esi-80]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00014	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  0001d	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00026	8d 4e b8	 lea	 ecx, DWORD PTR [esi-72]
  00029	5e		 pop	 esi
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$dead$ = 8					; size = 4
_$initVBases$dead$ = 12					; size = 4
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 590  : 		{	// construct empty character buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00033	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]
  00036	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0003c	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00049	6a 00		 push	 0
  0004b	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	56		 push	 esi
  00056	8b cf		 mov	 ecx, edi
  00058	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00065	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0006c	8b 07		 mov	 eax, DWORD PTR [edi]
  0006e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00071	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00078	8b 07		 mov	 eax, DWORD PTR [edi]
  0007a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  00080	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00083	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax

; 30   : 		{	// construct empty character buffer from mode

  00087	8b ce		 mov	 ecx, esi
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0008f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 591  : 		}

  00095	8b c7		 mov	 eax, edi

; 311  : 		_Seekhigh = 0;

  00097	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 312  : 		_Mystate = _State;

  0009e	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0

; 591  : 		}

  000a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000af	59		 pop	 ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 10 00 00
	00		 je	 $LN5@basic_stri
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_stri:
  0001c	c3		 ret	 0
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1:
  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	83 c1 20	 add	 ecx, 32			; 00000020H
  00023	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3:
  00029	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
  00032	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00036	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00039	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
tv410 = -16						; size = 4
tv411 = -12						; size = 4
tv426 = -8						; size = 4
___$ReturnUdt$GSCopy$1$ = -4				; size = 4
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 24
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT
; _this$ = ecx

; 276  : 		{	// change position to _Pos, according to _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000c	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 63   : 		return (_Myoff + _Fpos);

  0000d	8b 5d 10	 mov	 ebx, DWORD PTR __Ptr$[ebp+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

  00010	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 63   : 		return (_Myoff + _Fpos);

  00011	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00014	03 75 14	 add	 esi, DWORD PTR __Ptr$[ebp+8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

  00017	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 63   : 		return (_Myoff + _Fpos);

  00018	13 5d 18	 adc	 ebx, DWORD PTR __Ptr$[ebp+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

  0001b	8b f9		 mov	 edi, ecx
  0001d	89 44 24 1c	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+32], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00021	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	85 c0		 test	 eax, eax
  00028	74 08		 je	 SHORT $LN2@seekpos
  0002a	39 47 38	 cmp	 DWORD PTR [edi+56], eax
  0002d	73 03		 jae	 SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  0002f	89 47 38	 mov	 DWORD PTR [edi+56], eax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003c	89 4c 24 10	 mov	 DWORD PTR tv410[esp+32], ecx
  00040	89 44 24 14	 mov	 DWORD PTR tv411[esp+32], eax
  00044	3b f1		 cmp	 esi, ecx
  00046	75 08		 jne	 SHORT $LN55@seekpos
  00048	3b d8		 cmp	 ebx, eax
  0004a	0f 84 ba 00 00
	00		 je	 $LN11@seekpos
$LN55@seekpos:

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  00050	8b 55 24	 mov	 edx, DWORD PTR __Mode$[ebp]
  00053	f6 c2 01	 test	 dl, 1
  00056	74 6f		 je	 SHORT $LN5@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00058	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	89 44 24 18	 mov	 DWORD PTR tv426[esp+32], eax
  00061	85 c0		 test	 eax, eax
  00063	74 5e		 je	 SHORT $LN60@seekpos

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00065	85 db		 test	 ebx, ebx
  00067	7c 54		 jl	 SHORT $LN7@seekpos
  00069	7f 04		 jg	 SHORT $LN56@seekpos
  0006b	85 f6		 test	 esi, esi
  0006d	72 4e		 jb	 SHORT $LN7@seekpos
$LN56@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0006f	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00072	8b 08		 mov	 ecx, DWORD PTR [eax]
  00074	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00077	2b c1		 sub	 eax, ecx
  00079	99		 cdq
  0007a	3b da		 cmp	 ebx, edx
  0007c	7f 3b		 jg	 SHORT $LN64@seekpos
  0007e	7c 04		 jl	 SHORT $LN57@seekpos
  00080	3b f0		 cmp	 esi, eax
  00082	77 35		 ja	 SHORT $LN64@seekpos
$LN57@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 246  : 		*_IGcount -= _Off;

  00084	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  00087	2b 4c 24 18	 sub	 ecx, DWORD PTR tv426[esp+32]
  0008b	03 ce		 add	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 246  : 		*_IGcount -= _Off;

  0008d	29 08		 sub	 DWORD PTR [eax], ecx

; 247  : 		*_IGnext += _Off;

  0008f	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00092	01 08		 add	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  00094	f6 45 24 02	 test	 BYTE PTR __Mode$[ebp], 2
  00098	74 70		 je	 SHORT $LN11@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  0009a	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  0009d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000a0	74 68		 je	 SHORT $LN11@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  000a2	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000a5	8b 08		 mov	 ecx, DWORD PTR [eax]

; 226  : 		return (*_IGnext);

  000a7	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]

; 259  : 		return (*_IPnext + *_IPcount);

  000aa	03 0a		 add	 ecx, DWORD PTR [edx]

; 226  : 		return (*_IGnext);

  000ac	8b 00		 mov	 eax, DWORD PTR [eax]

; 302  : 		*_IPcount = (int)(_Last - _Next);

  000ae	2b c8		 sub	 ecx, eax
  000b0	89 02		 mov	 DWORD PTR [edx], eax
  000b2	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000b5	89 08		 mov	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 292  : 			else

  000b7	eb 51		 jmp	 SHORT $LN11@seekpos
$LN64@seekpos:

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000b9	8b 4c 24 10	 mov	 ecx, DWORD PTR tv410[esp+32]
$LN7@seekpos:

; 293  : 				_Off = _BADOFF;

  000bd	8b 5c 24 14	 mov	 ebx, DWORD PTR tv411[esp+32]
  000c1	eb 45		 jmp	 SHORT $LN65@seekpos
$LN60@seekpos:

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  000c3	8b 44 24 14	 mov	 eax, DWORD PTR tv411[esp+32]
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  000c7	f6 c2 02	 test	 dl, 2
  000ca	74 3a		 je	 SHORT $LN10@seekpos
  000cc	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  000cf	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000d2	74 32		 je	 SHORT $LN10@seekpos

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000d4	85 db		 test	 ebx, ebx
  000d6	7c e5		 jl	 SHORT $LN7@seekpos
  000d8	7f 04		 jg	 SHORT $LN58@seekpos
  000da	85 f6		 test	 esi, esi
  000dc	72 df		 jb	 SHORT $LN7@seekpos
$LN58@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  000de	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  000e6	2b c1		 sub	 eax, ecx
  000e8	99		 cdq
  000e9	3b da		 cmp	 ebx, edx
  000eb	7f cc		 jg	 SHORT $LN64@seekpos
  000ed	7c 04		 jl	 SHORT $LN59@seekpos
  000ef	3b f0		 cmp	 esi, eax
  000f1	77 c6		 ja	 SHORT $LN64@seekpos
$LN59@seekpos:

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000f3	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000f6	2b 08		 sub	 ecx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 287  : 		*_IPcount -= _Off;

  000f8	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000fb	03 ce		 add	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 287  : 		*_IPcount -= _Off;

  000fd	29 08		 sub	 DWORD PTR [eax], ecx

; 288  : 		*_IPnext += _Off;

  000ff	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00102	01 08		 add	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 300  : 			else

  00104	eb 04		 jmp	 SHORT $LN11@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  00106	8b d8		 mov	 ebx, eax
$LN65@seekpos:
  00108	8b f1		 mov	 esi, ecx
$LN11@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  0010a	8b 44 24 1c	 mov	 eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+32]
  0010e	0f 57 c0	 xorps	 xmm0, xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 306  : 		}

  00111	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  00112	89 30		 mov	 DWORD PTR [eax], esi
  00114	89 58 04	 mov	 DWORD PTR [eax+4], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 306  : 		}

  00117	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  00118	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0011f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00126	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 306  : 		}

  0012b	5b		 pop	 ebx
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv486 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
tv489 = 24						; size = 4
__Which$ = 24						; size = 4
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT
; _this$ = ecx

; 227  : 		{	// change position by _Off, according to _Way, _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi
  00008	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00009	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
  0000e	85 c0		 test	 eax, eax
  00010	74 08		 je	 SHORT $LN2@seekoff
  00012	39 43 38	 cmp	 DWORD PTR [ebx+56], eax
  00015	73 03		 jae	 SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00017	89 43 38	 mov	 DWORD PTR [ebx+56], eax
$LN2@seekoff:

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  0001a	8b 4d 18	 mov	 ecx, DWORD PTR __Which$[ebp]
  0001d	f6 c1 01	 test	 cl, 1
  00020	0f 84 d0 00 00
	00		 je	 $LN3@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00026	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  00029	8b 30		 mov	 esi, DWORD PTR [eax]
  0002b	89 75 fc	 mov	 DWORD PTR tv486[ebp], esi
  0002e	85 f6		 test	 esi, esi
  00030	0f 84 c0 00 00
	00		 je	 $LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

  00036	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00039	83 f8 02	 cmp	 eax, 2
  0003c	75 15		 jne	 SHORT $LN5@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0003e	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  00041	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00044	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00047	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0004a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004c	99		 cdq
  0004d	03 f0		 add	 esi, eax
  0004f	13 fa		 adc	 edi, edx

; 235  : 			else if (_Way == ios_base::cur

  00051	eb 35		 jmp	 SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

  00053	83 f8 01	 cmp	 eax, 1
  00056	75 19		 jne	 SHORT $LN74@seekoff
  00058	f6 c1 02	 test	 cl, 2
  0005b	75 18		 jne	 SHORT $LN75@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0005d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

  00060	8b c6		 mov	 eax, esi
  00062	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00065	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00068	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006a	99		 cdq
  0006b	03 f0		 add	 esi, eax
  0006d	13 fa		 adc	 edi, edx
  0006f	eb 17		 jmp	 SHORT $LN9@seekoff
$LN74@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

  00071	85 c0		 test	 eax, eax
  00073	74 0d		 je	 SHORT $LN80@seekoff
$LN75@seekoff:

; 239  : 				_Off = _BADOFF;

  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?_BADOFF@std@@3_JB
  0007b	8b 37		 mov	 esi, DWORD PTR [edi]
  0007d	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00080	eb 06		 jmp	 SHORT $LN9@seekoff
$LN80@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

  00082	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00085	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN9@seekoff:

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00088	85 ff		 test	 edi, edi
  0008a	0f 8c 01 01 00
	00		 jl	 $LN10@seekoff
  00090	7f 08		 jg	 SHORT $LN76@seekoff
  00092	85 f6		 test	 esi, esi
  00094	0f 82 f7 00 00
	00		 jb	 $LN10@seekoff
$LN76@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0009a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0009d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009f	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  000a2	2b c1		 sub	 eax, ecx
  000a4	99		 cdq
  000a5	3b fa		 cmp	 edi, edx
  000a7	0f 8f e4 00 00
	00		 jg	 $LN10@seekoff
  000ad	7c 08		 jl	 SHORT $LN77@seekoff
  000af	3b f0		 cmp	 esi, eax
  000b1	0f 87 da 00 00
	00		 ja	 $LN10@seekoff
$LN77@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 246  : 		*_IGcount -= _Off;

  000b7	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  000ba	2b 4d fc	 sub	 ecx, DWORD PTR tv486[ebp]
  000bd	03 ce		 add	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 246  : 		*_IGcount -= _Off;

  000bf	29 08		 sub	 DWORD PTR [eax], ecx

; 247  : 		*_IGnext += _Off;

  000c1	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000c4	01 08		 add	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000c6	f6 45 18 02	 test	 BYTE PTR __Which$[ebp], 2
  000ca	0f 84 cb 00 00
	00		 je	 $LN22@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  000d0	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000d3	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000d6	0f 84 bf 00 00
	00		 je	 $LN22@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  000dc	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000df	8b 08		 mov	 ecx, DWORD PTR [eax]

; 226  : 		return (*_IGnext);

  000e1	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]

; 259  : 		return (*_IPnext + *_IPcount);

  000e4	03 0a		 add	 ecx, DWORD PTR [edx]

; 226  : 		return (*_IGnext);

  000e6	8b 00		 mov	 eax, DWORD PTR [eax]

; 302  : 		*_IPcount = (int)(_Last - _Next);

  000e8	2b c8		 sub	 ecx, eax
  000ea	89 02		 mov	 DWORD PTR [edx], eax
  000ec	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000ef	89 08		 mov	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 248  : 			else

  000f1	e9 a5 00 00 00	 jmp	 $LN22@seekoff
$LN3@seekoff:

; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000f6	f6 c1 02	 test	 cl, 2
  000f9	0f 84 86 00 00
	00		 je	 $LN13@seekoff
  000ff	8b 12		 mov	 edx, DWORD PTR [edx]
  00101	89 55 18	 mov	 DWORD PTR tv489[ebp], edx
  00104	85 d2		 test	 edx, edx
  00106	74 7d		 je	 SHORT $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

  00108	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  0010b	83 f8 02	 cmp	 eax, 2
  0010e	75 15		 jne	 SHORT $LN15@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00110	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  00113	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00116	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00119	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0011c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0011e	99		 cdq
  0011f	03 f0		 add	 esi, eax
  00121	13 fa		 adc	 edi, edx
  00123	eb 30		 jmp	 SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

  00125	83 f8 01	 cmp	 eax, 1
  00128	75 14		 jne	 SHORT $LN17@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0012a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

  0012d	8b c2		 mov	 eax, edx
  0012f	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00132	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00135	2b 01		 sub	 eax, DWORD PTR [ecx]
  00137	99		 cdq
  00138	03 f0		 add	 esi, eax
  0013a	13 fa		 adc	 edi, edx
  0013c	eb 17		 jmp	 SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

  0013e	85 c0		 test	 eax, eax
  00140	74 0d		 je	 SHORT $LN81@seekoff

; 258  : 				_Off = _BADOFF;

  00142	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?_BADOFF@std@@3_JB
  00148	8b 37		 mov	 esi, DWORD PTR [edi]
  0014a	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  0014d	eb 06		 jmp	 SHORT $LN19@seekoff
$LN81@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

  0014f	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00152	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN19@seekoff:

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00155	85 ff		 test	 edi, edi
  00157	7c 38		 jl	 SHORT $LN10@seekoff
  00159	7f 04		 jg	 SHORT $LN78@seekoff
  0015b	85 f6		 test	 esi, esi
  0015d	72 32		 jb	 SHORT $LN10@seekoff
$LN78@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0015f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00162	8b 08		 mov	 ecx, DWORD PTR [eax]
  00164	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00167	2b c1		 sub	 eax, ecx
  00169	99		 cdq
  0016a	3b fa		 cmp	 edi, edx
  0016c	7f 23		 jg	 SHORT $LN10@seekoff
  0016e	7c 04		 jl	 SHORT $LN79@seekoff
  00170	3b f0		 cmp	 esi, eax
  00172	77 1d		 ja	 SHORT $LN10@seekoff
$LN79@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 287  : 		*_IPcount -= _Off;

  00174	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

  00177	2b 4d 18	 sub	 ecx, DWORD PTR tv489[ebp]
  0017a	03 ce		 add	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 287  : 		*_IPcount -= _Off;

  0017c	29 08		 sub	 DWORD PTR [eax], ecx

; 288  : 		*_IPnext += _Off;

  0017e	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00181	01 08		 add	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 263  : 			else

  00183	eb 16		 jmp	 SHORT $LN22@seekoff
$LN13@seekoff:

; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

  00185	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00188	8b c6		 mov	 eax, esi
  0018a	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0018d	0b c7		 or	 eax, edi
  0018f	74 0a		 je	 SHORT $LN22@seekoff
$LN10@seekoff:

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  00191	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
  00196	8b 30		 mov	 esi, DWORD PTR [eax]
  00198	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
$LN22@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  0019b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0019e	0f 57 c0	 xorps	 xmm0, xmm0
  001a1	89 78 04	 mov	 DWORD PTR [eax+4], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 271  : 		return (pos_type(_Off));

  001a4	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  001a5	89 30		 mov	 DWORD PTR [eax], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 271  : 		return (pos_type(_Off));

  001a7	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  001a8	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  001af	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  001b6	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 271  : 		return (pos_type(_Off));

  001bb	5b		 pop	 ebx

; 272  : 		}

  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT
; _this$ = ecx

; 207  : 		{	// get an element from stream, but don't point past it

  00000	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00001	8b 79 1c	 mov	 edi, DWORD PTR [ecx+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 208  : 		if (_Mysb::gptr() == 0)

  00004	8b 17		 mov	 edx, DWORD PTR [edi]
  00006	85 d2		 test	 edx, edx
  00008	75 05		 jne	 SHORT $LN2@underflow

; 209  : 			return (_Traits::eof());	// no character buffer, fail

  0000a	83 c8 ff	 or	 eax, -1
  0000d	5f		 pop	 edi

; 222  : 		}

  0000e	c3		 ret	 0
$LN2@underflow:
  0000f	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00010	8b 59 2c	 mov	 ebx, DWORD PTR [ecx+44]
  00013	8b 03		 mov	 eax, DWORD PTR [ebx]
  00015	03 c2		 add	 eax, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

  00017	3b d0		 cmp	 edx, eax
  00019	73 06		 jae	 SHORT $LN4@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  0001b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0001e	5b		 pop	 ebx
  0001f	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 222  : 		}

  00020	c3		 ret	 0
$LN4@underflow:

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  00021	f6 41 3c 04	 test	 BYTE PTR [ecx+60], 4
  00025	75 31		 jne	 SHORT $LN8@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00027	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	85 c0		 test	 eax, eax
  0002e	74 28		 je	 SHORT $LN8@underflow
  00030	3b c2		 cmp	 eax, edx
  00032	77 05		 ja	 SHORT $LN52@underflow
  00034	39 51 38	 cmp	 DWORD PTR [ecx+56], edx
  00037	76 1f		 jbe	 SHORT $LN8@underflow
$LN52@underflow:
  00039	56		 push	 esi

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

  0003a	8b 71 38	 mov	 esi, DWORD PTR [ecx+56]
  0003d	3b f0		 cmp	 esi, eax
  0003f	73 07		 jae	 SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

  00041	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00044	8b f0		 mov	 esi, eax
  00046	8b 17		 mov	 edx, DWORD PTR [edi]
$LN9@underflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00048	2b f2		 sub	 esi, edx
  0004a	89 33		 mov	 DWORD PTR [ebx], esi

; 226  : 		return (*_IGnext);

  0004c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));

  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00052	8b 00		 mov	 eax, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  00054	0f b6 00	 movzx	 eax, BYTE PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 222  : 		}

  00057	c3		 ret	 0
$LN8@underflow:
  00058	5b		 pop	 ebx

; 214  : 			return (_Traits::eof());	// can't read, fail

  00059	83 c8 ff	 or	 eax, -1
  0005c	5f		 pop	 edi

; 222  : 		}

  0005d	c3		 ret	 0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT
; _this$ = ecx

; 190  : 		{	// put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00003	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 190  : 		{	// put an element back to stream

  00006	56		 push	 esi

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00007	8b 30		 mov	 esi, DWORD PTR [eax]
  00009	85 f6		 test	 esi, esi
  0000b	74 3f		 je	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0000d	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00010	3b 30		 cmp	 esi, DWORD PTR [eax]
  00012	76 38		 jbe	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  00014	8b 55 08	 mov	 edx, DWORD PTR __Meta$[ebp]
  00017	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001a	74 0b		 je	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 447  : 		return (_Left == _Right);

  0001c	3a 56 ff	 cmp	 dl, BYTE PTR [esi-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001f	74 06		 je	 SHORT $LN2@pbackfail
  00021	f6 41 3c 02	 test	 BYTE PTR [ecx+60], 2
  00025	75 25		 jne	 SHORT $LN4@pbackfail
$LN2@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 246  : 		*_IGcount -= _Off;

  00027	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0002a	ff 00		 inc	 DWORD PTR [eax]

; 247  : 		*_IGnext += _Off;

  0002c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0002f	ff 08		 dec	 DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  00031	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

  00034	74 07		 je	 SHORT $LN5@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00036	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

  0003b	88 11		 mov	 BYTE PTR [ecx], dl
$LN5@pbackfail:

; 202  : 			return (_Traits::not_eof(_Meta));

  0003d	33 c0		 xor	 eax, eax
  0003f	83 fa ff	 cmp	 edx, -1
  00042	5e		 pop	 esi
  00043	0f 44 d0	 cmove	 edx, eax
  00046	8b c2		 mov	 eax, edx

; 203  : 			}
; 204  : 		}

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

  0004c	83 c8 ff	 or	 eax, -1
  0004f	5e		 pop	 esi

; 203  : 			}
; 204  : 		}

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$1$ = -12						; size = 4
tv864 = -8						; size = 4
__Newsize$1$ = -8					; size = 4
__Ptr$1$ = -4						; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT
; _this$ = ecx

; 120  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 5d f4	 mov	 DWORD PTR __Meta$1$[ebp], ebx

; 121  : 		if (_Mystate & _Constant)

  00010	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00013	a8 02		 test	 al, 2
  00015	74 0b		 je	 SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

  00017	5e		 pop	 esi
  00018	83 c8 ff	 or	 eax, -1

; 187  : 		}

  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN4@overflow:

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00022	83 fb ff	 cmp	 ebx, -1
  00025	75 11		 jne	 SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  00027	33 c0		 xor	 eax, eax
  00029	3b db		 cmp	 ebx, ebx
  0002b	5e		 pop	 esi
  0002c	0f 44 d8	 cmove	 ebx, eax
  0002f	8b c3		 mov	 eax, ebx

; 187  : 		}

  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN6@overflow:
  00038	57		 push	 edi

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  00039	a8 08		 test	 al, 8
  0003b	74 23		 je	 SHORT $LN7@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  0003d	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  00042	85 d2		 test	 edx, edx
  00044	74 1a		 je	 SHORT $LN7@overflow
  00046	8b 7e 38	 mov	 edi, DWORD PTR [esi+56]
  00049	3b d7		 cmp	 edx, edi
  0004b	73 13		 jae	 SHORT $LN7@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  0004d	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]

; 301  : 		*_IPnext = _Next;

  00052	8b 46 20	 mov	 eax, DWORD PTR [esi+32]

; 259  : 		return (*_IPnext + *_IPcount);

  00055	03 ca		 add	 ecx, edx

; 302  : 		*_IPcount = (int)(_Last - _Next);

  00057	2b cf		 sub	 ecx, edi
  00059	89 38		 mov	 DWORD PTR [eax], edi
  0005b	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0005e	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@overflow:

; 236  : 		return (*_IPnext);

  00060	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00063	8b 08		 mov	 ecx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00065	85 c9		 test	 ecx, ecx
  00067	74 2c		 je	 SHORT $LN161@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00069	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0006c	8b 3a		 mov	 edi, DWORD PTR [edx]
  0006e	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00071	3b c8		 cmp	 ecx, eax
  00073	73 1c		 jae	 SHORT $LN150@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 307  : 		--*_IPcount;

  00075	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 134  : 			return (_Meta);

  00078	8b c3		 mov	 eax, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 307  : 		--*_IPcount;

  0007a	89 0a		 mov	 DWORD PTR [edx], ecx

; 308  : 		return ((*_IPnext)++);

  0007c	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  0007f	5f		 pop	 edi
  00080	8b 32		 mov	 esi, DWORD PTR [edx]
  00082	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00085	89 0a		 mov	 DWORD PTR [edx], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00087	88 1e		 mov	 BYTE PTR [esi], bl
  00089	5e		 pop	 esi

; 187  : 		}

  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 04 00	 ret	 4
$LN150@overflow:

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

  00091	85 c9		 test	 ecx, ecx
  00093	75 04		 jne	 SHORT $LN20@overflow
$LN161@overflow:
  00095	33 ff		 xor	 edi, edi
  00097	eb 0c		 jmp	 SHORT $LN21@overflow
$LN20@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00099	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0009c	8b 38		 mov	 edi, DWORD PTR [eax]

; 221  : 		return (*_IGfirst);

  0009e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 259  : 		return (*_IPnext + *_IPcount);

  000a1	03 f9		 add	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

  000a3	2b 38		 sub	 edi, DWORD PTR [eax]
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

  000a5	8b cf		 mov	 ecx, edi
  000a7	d1 e9		 shr	 ecx, 1
  000a9	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000ac	73 07		 jae	 SHORT $LN22@overflow
  000ae	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000b3	eb 0b		 jmp	 SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000b5	85 c9		 test	 ecx, ecx
  000b7	74 1a		 je	 SHORT $LN163@overflow
  000b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@overflow:
  000c0	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000c5	2b c1		 sub	 eax, ecx
  000c7	3b c7		 cmp	 eax, edi
  000c9	73 04		 jae	 SHORT $LN155@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

  000cb	d1 e9		 shr	 ecx, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000cd	75 f1		 jne	 SHORT $LL2@overflow
$LN155@overflow:

; 146  : 			if (_Inc == 0)

  000cf	85 c9		 test	 ecx, ecx
  000d1	75 0c		 jne	 SHORT $LN10@overflow
$LN163@overflow:
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

  000d5	83 c8 ff	 or	 eax, -1

; 187  : 		}

  000d8	5b		 pop	 ebx
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
$LN10@overflow:

; 148  : 
; 149  : 			_Newsize += _Inc;

  000df	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  000e2	89 45 f8	 mov	 DWORD PTR __Newsize$1$[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  000e5	85 c0		 test	 eax, eax
  000e7	75 04		 jne	 SHORT $LN78@overflow

; 79   : 		{
; 80   : 		return (nullptr);

  000e9	33 db		 xor	 ebx, ebx
  000eb	eb 31		 jmp	 SHORT $LN76@overflow
$LN78@overflow:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  000ed	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000f2	72 1f		 jb	 SHORT $LN79@overflow

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  000f4	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 117  : 			if (_Block_size <= _User_size)

  000f7	3b c8		 cmp	 ecx, eax
  000f9	0f 86 4c 01 00
	00		 jbe	 $LN166@overflow

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00105	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00108	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  0010b	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0010e	89 43 fc	 mov	 DWORD PTR [ebx-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00111	eb 0b		 jmp	 SHORT $LN76@overflow
$LN79@overflow:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00119	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  0011c	8b d8		 mov	 ebx, eax
$LN76@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0011e	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00121	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00123	89 4d fc	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 154  : 			if (0 < _Oldsize)

  00126	85 ff		 test	 edi, edi
  00128	74 12		 je	 SHORT $LN165@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0012a	57		 push	 edi
  0012b	51		 push	 ecx
  0012c	53		 push	 ebx
  0012d	e8 00 00 00 00	 call	 _memcpy
  00132	8b 4d fc	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 157  : 			if (_Oldsize == 0)

  00138	85 ff		 test	 edi, edi
  0013a	75 3f		 jne	 SHORT $LN12@overflow
$LN165@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 293  : 		*_IPfirst = _First;

  0013c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 295  : 		*_IPcount = (int)(_Last - _First);

  0013f	8b 55 f8	 mov	 edx, DWORD PTR __Newsize$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 159  : 				_Seekhigh = _Newptr;

  00142	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 293  : 		*_IPfirst = _First;

  00145	89 18		 mov	 DWORD PTR [eax], ebx

; 294  : 		*_IPnext = _First;

  00147	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0014a	89 18		 mov	 DWORD PTR [eax], ebx

; 295  : 		*_IPcount = (int)(_Last - _First);

  0014c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0014f	89 10		 mov	 DWORD PTR [eax], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 161  : 				if (_Mystate & _Noread)

  00151	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00154	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00157	89 18		 mov	 DWORD PTR [eax], ebx
  00159	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0015c	83 e1 04	 and	 ecx, 4
  0015f	74 0d		 je	 SHORT $LN14@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 253  : 		*_IGnext = _Next;

  00161	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00167	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0016a	89 18		 mov	 DWORD PTR [eax], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 163  : 				else

  0016c	eb 74		 jmp	 SHORT $LN17@overflow
$LN14@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 253  : 		*_IGnext = _Next;

  0016e	89 18		 mov	 DWORD PTR [eax], ebx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00170	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00173	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 166  : 			else

  00179	eb 67		 jmp	 SHORT $LN17@overflow
$LN12@overflow:

; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

  0017b	8b c3		 mov	 eax, ebx
  0017d	2b c1		 sub	 eax, ecx
  0017f	01 46 38	 add	 DWORD PTR [esi+56], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00182	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00185	8b 10		 mov	 edx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  00187	8b c3		 mov	 eax, ebx
  00189	2b 45 fc	 sub	 eax, DWORD PTR __Ptr$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  0018c	2b d1		 sub	 edx, ecx

; 231  : 		return (*_IPfirst);

  0018e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  00191	03 d3		 add	 edx, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 300  : 		*_IPfirst = _First;

  00193	01 01		 add	 DWORD PTR [ecx], eax

; 302  : 		*_IPcount = (int)(_Last - _Next);

  00195	8b cb		 mov	 ecx, ebx
  00197	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0019a	2b ca		 sub	 ecx, edx
  0019c	03 4d f8	 add	 ecx, DWORD PTR __Newsize$1$[ebp]
  0019f	89 10		 mov	 DWORD PTR [eax], edx
  001a1	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001a4	89 08		 mov	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 172  : 				if (_Mystate & _Noread)

  001a6	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  001aa	74 15		 je	 SHORT $LN16@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  001ac	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001af	89 18		 mov	 DWORD PTR [eax], ebx

; 253  : 		*_IGnext = _Next;

  001b1	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001b4	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 254  : 		*_IGcount = (int)(_Last - _Next);

  001ba	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001bd	89 18		 mov	 DWORD PTR [eax], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 174  : 				else

  001bf	eb 21		 jmp	 SHORT $LN17@overflow
$LN16@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  001c1	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  001c4	8b 10		 mov	 edx, DWORD PTR [eax]

; 226  : 		return (*_IGnext);

  001c6	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001c9	8b 08		 mov	 ecx, DWORD PTR [eax]

; 252  : 		*_IGfirst = _First;

  001cb	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 226  : 		return (*_IGnext);

  001ce	2b 4d fc	 sub	 ecx, DWORD PTR __Ptr$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 175  : 					_Mysb::setg(_Newptr,

  001d1	03 cb		 add	 ecx, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  001d3	2b d1		 sub	 edx, ecx
  001d5	89 18		 mov	 DWORD PTR [eax], ebx
  001d7	42		 inc	 edx
  001d8	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001db	89 08		 mov	 DWORD PTR [eax], ecx
  001dd	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001e0	89 10		 mov	 DWORD PTR [eax], edx
$LN17@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 180  : 			if (_Mystate & _Allocated)

  001e2	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  001e6	74 42		 je	 SHORT $LN123@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001e8	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  001ee	72 2d		 jb	 SHORT $LN156@overflow

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001f0	8d 47 23	 lea	 eax, DWORD PTR [edi+35]
  001f3	3b c7		 cmp	 eax, edi
  001f5	76 20		 jbe	 SHORT $_Invalid_parameter$170

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001f7	8b f8		 mov	 edi, eax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001f9	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  001fc	a8 1f		 test	 al, 31			; 0000001fH
  001fe	75 17		 jne	 SHORT $_Invalid_parameter$170

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00200	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00203	3b c8		 cmp	 ecx, eax
  00205	73 10		 jae	 SHORT $_Invalid_parameter$170

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00207	2b c1		 sub	 eax, ecx
  00209	83 f8 04	 cmp	 eax, 4
  0020c	72 09		 jb	 SHORT $_Invalid_parameter$170

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0020e	83 f8 23	 cmp	 eax, 35			; 00000023H
  00211	77 04		 ja	 SHORT $_Invalid_parameter$170

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00213	8b c1		 mov	 eax, ecx
  00215	eb 09		 jmp	 SHORT $LN126@overflow
$_Invalid_parameter$170:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00217	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN168@overflow:
$LN156@overflow:

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0021d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
$LN126@overflow:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00220	57		 push	 edi
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00227	83 c4 08	 add	 esp, 8
$LN123@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 307  : 		--*_IPcount;

  0022a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 182  : 			_Mystate |= _Allocated;

  0022d	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  00231	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 307  : 		--*_IPcount;

  00232	ff 08		 dec	 DWORD PTR [eax]

; 308  : 		return ((*_IPnext)++);

  00234	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00237	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 187  : 		}

  00238	5b		 pop	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 308  : 		return ((*_IPnext)++);

  00239	8b 11		 mov	 edx, DWORD PTR [ecx]
  0023b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0023e	89 01		 mov	 DWORD PTR [ecx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00240	8b 45 f4	 mov	 eax, DWORD PTR __Meta$1$[ebp]
  00243	88 02		 mov	 BYTE PTR [edx], al

; 187  : 		}

  00245	8b e5		 mov	 esp, ebp
  00247	5d		 pop	 ebp
  00248	c2 04 00	 ret	 4
$LN166@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  0024b	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN169@overflow:
$LN159@overflow:
  00250	cc		 int	 3
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 75   : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 338  : 		if (_Mystate & _Allocated)

  00003	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1

; 75   : 		{	// destroy the object

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 338  : 		if (_Mystate & _Allocated)

  0000d	74 57		 je	 SHORT $LN25@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  0000f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	85 c9		 test	 ecx, ecx
  00016	74 09		 je	 SHORT $LN6@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00018	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	03 d1		 add	 edx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  0001f	eb 0a		 jmp	 SHORT $LN7@basic_stri
$LN6@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00021	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00024	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	03 11		 add	 edx, DWORD PTR [ecx]
$LN7@basic_stri:

; 221  : 		return (*_IGfirst);

  0002b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	2b d0		 sub	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00032	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00038	72 22		 jb	 SHORT $LN28@basic_stri

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0003a	8d 4a 23	 lea	 ecx, DWORD PTR [edx+35]
  0003d	3b ca		 cmp	 ecx, edx
  0003f	76 6f		 jbe	 SHORT $_Invalid_parameter$50

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00041	8b d1		 mov	 edx, ecx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00043	a8 1f		 test	 al, 31			; 0000001fH
  00045	75 69		 jne	 SHORT $_Invalid_parameter$50

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00047	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0004a	3b c8		 cmp	 ecx, eax
  0004c	73 62		 jae	 SHORT $_Invalid_parameter$50

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0004e	2b c1		 sub	 eax, ecx
  00050	83 f8 04	 cmp	 eax, 4
  00053	72 5b		 jb	 SHORT $_Invalid_parameter$50

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00055	83 f8 23	 cmp	 eax, 35			; 00000023H
  00058	77 56		 ja	 SHORT $_Invalid_parameter$50

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0005a	8b c1		 mov	 eax, ecx
$LN28@basic_stri:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0005c	52		 push	 edx
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00063	83 c4 08	 add	 esp, 8
$LN25@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00066	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 77   : 		}

  00069	8b ce		 mov	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  0006b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 253  : 		*_IGnext = _Next;

  00071	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00074	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0007a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0007d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 293  : 		*_IPfirst = _First;

  00083	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00086	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 294  : 		*_IPnext = _First;

  0008c	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0008f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 295  : 		*_IPcount = (int)(_Last - _First);

  00095	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00098	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

  0009e	83 66 3c fe	 and	 DWORD PTR [esi+60], -2	; fffffffeH
  000a2	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 77   : 		}

  000a9	5e		 pop	 esi
  000aa	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
$_Invalid_parameter$50:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN49@basic_stri:
$LN48@basic_stri:
  000b6	cc		 int	 3
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$dead$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1352 : 		{	// destroy the object

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 88	 mov	 eax, DWORD PTR [esi-120]
  00009	57		 push	 edi
  0000a	8d 7e 88	 lea	 edi, DWORD PTR [esi-120]

; 1353 : 		}

  0000d	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	c7 44 30 88 00
	00 00 00	 mov	 DWORD PTR [eax+esi-120], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  0001b	8b 07		 mov	 eax, DWORD PTR [edi]
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	8d 42 88	 lea	 eax, DWORD PTR [edx-120]
  00023	89 44 32 84	 mov	 DWORD PTR [edx+esi-124], eax
  00027	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0002c	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00035	8b ce		 mov	 ecx, esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0003d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00041	74 0e		 je	 SHORT $LN10@scalar
  00043	68 c0 00 00 00	 push	 192			; 000000c0H
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1132 : 		{	// destroy the object

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00009	57		 push	 edi
  0000a	8d 7e 98	 lea	 edi, DWORD PTR [esi-104]

; 1133 : 		}

  0000d	8d 4e 9c	 lea	 ecx, DWORD PTR [esi-100]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  0001b	8b 07		 mov	 eax, DWORD PTR [edi]
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  00023	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00027	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0002c	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00035	8b ce		 mov	 ecx, esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0003d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00041	74 0e		 je	 SHORT $LN10@scalar
  00043	68 b0 00 00 00	 push	 176			; 000000b0H
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 917  : 		{	// destroy the object

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 90	 mov	 eax, DWORD PTR [esi-112]
  00009	57		 push	 edi
  0000a	8d 7e 90	 lea	 edi, DWORD PTR [esi-112]

; 918  : 		}

  0000d	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	c7 44 30 90 00
	00 00 00	 mov	 DWORD PTR [eax+esi-112], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  0001b	8b 07		 mov	 eax, DWORD PTR [edi]
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	8d 42 90	 lea	 eax, DWORD PTR [edx-112]
  00023	89 44 32 8c	 mov	 DWORD PTR [edx+esi-116], eax
  00027	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0002c	8d 4e a8	 lea	 ecx, DWORD PTR [esi-88]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00035	8b ce		 mov	 ecx, esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0003d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00041	74 0e		 je	 SHORT $LN10@scalar
  00043	68 b8 00 00 00	 push	 184			; 000000b8H
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 58		 push	 88			; 00000058H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 634  : 		{	// destroy the object

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00009	57		 push	 edi
  0000a	8d 7e 98	 lea	 edi, DWORD PTR [esi-104]

; 635  : 		}

  0000d	8d 4e b0	 lea	 ecx, DWORD PTR [esi-80]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0001b	8b 07		 mov	 eax, DWORD PTR [edi]
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  00023	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00027	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  0002c	8d 4e b8	 lea	 ecx, DWORD PTR [esi-72]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00035	8b ce		 mov	 ecx, esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0003d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00041	74 0e		 je	 SHORT $LN10@scalar
  00043	68 b0 00 00 00	 push	 176			; 000000b0H
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 44		 push	 68			; 00000044H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$dead$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$dead$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z PROC	; std::pointer_traits<char *>::pointer_to, COMDAT
; __Val$ = ecx

; 379  : 		return (_STD addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 380  : 		}

  00002	c3		 ret	 0
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ENDP	; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0?$uniform_int@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0?$uniform_int@H@std@@QAE@HH@Z PROC			; std::uniform_int<int>::uniform_int<int>, COMDAT
; _this$ = ecx

; 2235 : 		{	// construct from parameters

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2224 : 			_Min = _Min0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Min0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 2225 : 			_Max = _Max0;

  00008	8b 45 0c	 mov	 eax, DWORD PTR __Max0$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2236 : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0?$uniform_int@H@std@@QAE@HH@Z ENDP			; std::uniform_int<int>::uniform_int<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ
_TEXT	SEGMENT
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper, COMDAT
; _this$ = ecx

; 1396 : 		{	// compute values for the upper half of the history array

  00000	56		 push	 esi

; 1397 : 		int _Ix;
; 1398 : 		for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix)

  00001	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00004	be 70 02 00 00	 mov	 esi, 624		; 00000270H
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@Refill_upp:

; 1399 : 			{	// fill in values
; 1400 : 			_Ty _Tmp = (this->_Ax[_Ix - _Nx] & _HMSK)
; 1401 : 				| (this->_Ax[_Ix - _Nx + 1] & _LMSK);

  00010	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00013	8d 40 04	 lea	 eax, DWORD PTR [eax+4]
  00016	33 50 fc	 xor	 edx, DWORD PTR [eax-4]
  00019	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  0001f	33 50 f8	 xor	 edx, DWORD PTR [eax-8]

; 1402 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00022	8b ca		 mov	 ecx, edx
  00024	80 e1 01	 and	 cl, 1
  00027	0f b6 c9	 movzx	 ecx, cl
  0002a	f7 d9		 neg	 ecx
  0002c	1b c9		 sbb	 ecx, ecx
  0002e	d1 ea		 shr	 edx, 1
  00030	81 e1 df b0 08
	99		 and	 ecx, -1727483681	; 9908b0dfH
  00036	33 88 2c 06 00
	00		 xor	 ecx, DWORD PTR [eax+1580]
  0003c	33 ca		 xor	 ecx, edx
  0003e	89 88 b8 09 00
	00		 mov	 DWORD PTR [eax+2488], ecx
  00044	83 ee 01	 sub	 esi, 1
  00047	75 c7		 jne	 SHORT $LL4@Refill_upp

; 1403 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1404 : 			}
; 1405 : 		}

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower, COMDAT
; _this$ = ecx

; 1371 : 		{	// compute values for the lower half of the history array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx

; 1372 : 		int _Ix;
; 1373 : 		for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix)

  00007	8b 83 c4 09 00
	00		 mov	 eax, DWORD PTR [ebx+2500]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8d bb c4 09 00
	00		 lea	 edi, DWORD PTR [ebx+2500]
  00015	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
  00018	bb e3 00 00 00	 mov	 ebx, 227		; 000000e3H
  0001d	0f 1f 00	 npad	 3
$LL4@Refill_low:

; 1374 : 			{	// fill in lower region
; 1375 : 			_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK)
; 1376 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00020	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00023	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00026	33 c8		 xor	 ecx, eax
  00028	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0002e	33 c8		 xor	 ecx, eax

; 1377 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00030	8b c1		 mov	 eax, ecx
  00032	24 01		 and	 al, 1
  00034	0f b6 c0	 movzx	 eax, al
  00037	f7 d8		 neg	 eax
  00039	1b c0		 sbb	 eax, eax
  0003b	d1 e9		 shr	 ecx, 1
  0003d	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00042	33 87 34 06 00
	00		 xor	 eax, DWORD PTR [edi+1588]
  00048	33 c1		 xor	 eax, ecx
  0004a	89 87 40 f6 ff
	ff		 mov	 DWORD PTR [edi-2496], eax
  00050	8d 3a		 lea	 edi, DWORD PTR [edx]
  00052	8b 02		 mov	 eax, DWORD PTR [edx]
  00054	83 eb 01	 sub	 ebx, 1
  00057	75 c7		 jne	 SHORT $LL4@Refill_low

; 1378 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];
; 1379 : 			}
; 1380 : 
; 1381 : 		for (; _Ix < _Nx - 1; ++_Ix)

  00059	8b 7d fc	 mov	 edi, DWORD PTR _this$1$[ebp]
  0005c	bb 8c 01 00 00	 mov	 ebx, 396		; 0000018cH
  00061	81 c7 50 0d 00
	00		 add	 edi, 3408		; 00000d50H
  00067	8b 07		 mov	 eax, DWORD PTR [edi]
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@Refill_low:

; 1382 : 			{	// fill in upper region (avoids modulus operation)
; 1383 : 			_Ty _Tmp = (this->_Ax[_Ix +_Nx] & _HMSK)
; 1384 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00070	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00073	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00076	33 c8		 xor	 ecx, eax
  00078	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0007e	33 c8		 xor	 ecx, eax

; 1385 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00080	8b c1		 mov	 eax, ecx
  00082	24 01		 and	 al, 1
  00084	0f b6 c0	 movzx	 eax, al
  00087	f7 d8		 neg	 eax
  00089	1b c0		 sbb	 eax, eax
  0008b	d1 e9		 shr	 ecx, 1
  0008d	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00092	33 87 b4 f2 ff
	ff		 xor	 eax, DWORD PTR [edi-3404]
  00098	33 c1		 xor	 eax, ecx
  0009a	89 87 40 f6 ff
	ff		 mov	 DWORD PTR [edi-2496], eax
  000a0	8d 3a		 lea	 edi, DWORD PTR [edx]
  000a2	8b 02		 mov	 eax, DWORD PTR [edx]
  000a4	83 eb 01	 sub	 ebx, 1
  000a7	75 c7		 jne	 SHORT $LL7@Refill_low

; 1386 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1387 : 			}
; 1388 : 
; 1389 : 		_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

  000a9	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]

; 1390 : 		this->_Ax[_Ix] = (_Tmp >> 1)
; 1391 : 			^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];
; 1392 : 		this->_Idx = 0;

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	8b 8b 80 13 00
	00		 mov	 ecx, DWORD PTR [ebx+4992]
  000b4	33 4b 04	 xor	 ecx, DWORD PTR [ebx+4]
  000b7	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  000bd	33 8b 80 13 00
	00		 xor	 ecx, DWORD PTR [ebx+4992]
  000c3	8b c1		 mov	 eax, ecx
  000c5	24 01		 and	 al, 1
  000c7	0f b6 c0	 movzx	 eax, al
  000ca	f7 d8		 neg	 eax
  000cc	1b c0		 sbb	 eax, eax
  000ce	d1 e9		 shr	 ecx, 1
  000d0	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  000d5	33 83 34 06 00
	00		 xor	 eax, DWORD PTR [ebx+1588]
  000db	33 c1		 xor	 eax, ecx
  000dd	89 83 c0 09 00
	00		 mov	 DWORD PTR [ebx+2496], eax
  000e3	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  000e9	5b		 pop	 ebx

; 1393 : 		}

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
__Dxarg$dead$ = 12					; size = 4
__Fxarg$dead$ = 16					; size = 4
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>, COMDAT
; _this$ = ecx

; 1294 : 		{	// construct with specified seed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1309 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00003	8b 55 08	 mov	 edx, DWORD PTR __X0$[ebp]

; 1294 : 		{	// construct with specified seed

  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	c7 81 84 13 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+4996], -1
  00012	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]

; 1309 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00015	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1293 : 		: _Dxval(_Dxarg)

  00018	be 01 00 00 00	 mov	 esi, 1
  0001d	0f 1f 00	 npad	 3
$LL6@mersenne_t:

; 1311 : 			_Prev = this->_Ax[_Ix] =

  00020	8b c2		 mov	 eax, edx
  00022	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00025	c1 e8 1e	 shr	 eax, 30			; 0000001eH
  00028	33 c2		 xor	 eax, edx
  0002a	69 d0 65 89 07
	6c		 imul	 edx, eax, 1812433253
  00030	03 d6		 add	 edx, esi
  00032	46		 inc	 esi
  00033	89 57 fc	 mov	 DWORD PTR [edi-4], edx
  00036	81 fe 70 02 00
	00		 cmp	 esi, 624		; 00000270H
  0003c	7c e2		 jl	 SHORT $LL6@mersenne_t

; 1295 : 		seed(_X0, _Fxarg);
; 1296 : 		}

  0003e	5f		 pop	 edi

; 1313 : 		this->_Idx = _Nx;

  0003f	c7 01 70 02 00
	00		 mov	 DWORD PTR [ecx], 624	; 00000270H

; 1295 : 		seed(_X0, _Fxarg);
; 1296 : 		}

  00045	8b c1		 mov	 eax, ecx
  00047	5e		 pop	 esi
  00048	5d		 pop	 ebp
  00049	c2 0c 00	 ret	 12			; 0000000cH
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 141  : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 142  : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 128  : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 129  :  #if _HAS_EXCEPTIONS
; 130  : 			if (_STD uncaught_exceptions() == 0)

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ
  0002b	85 c0		 test	 eax, eax
  0002d	75 08		 jne	 SHORT $LN2@sentry

; 131  : 				{
; 132  : 				this->_Myostr._Osfx();

  0002f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 105  : 			{	// destroy after unlocking

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 106  : 			if (_Myostr.rdbuf() != 0)

  0003e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  00049	85 c9		 test	 ecx, ecx
  0004b	74 05		 je	 SHORT $LN5@sentry

; 107  : 				_Myostr.rdbuf()->_Unlock();

  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@sentry:

; 133  : 				}
; 134  :  #else /* _HAS_EXCEPTIONS */
; 135  : 			this->_Myostr._Osfx();
; 136  :  #endif /* _HAS_EXCEPTIONS */
; 137  : 			}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 121  : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002a	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]

; 98   : 			: _Myostr(_Ostr)

  0002d	89 37		 mov	 DWORD PTR [edi], esi

; 100  : 			if (_Myostr.rdbuf() != 0)

  0002f	8b 16		 mov	 edx, DWORD PTR [esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00031	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00034	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

  00038	85 c9		 test	 ecx, ecx
  0003a	74 07		 je	 SHORT $LN6@sentry

; 101  : 				_Myostr.rdbuf()->_Lock();

  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
  00041	8b 16		 mov	 edx, DWORD PTR [esi]
$LN6@sentry:

; 102  : 			}
; 103  : 
; 104  : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 105  : 			{	// destroy after unlocking
; 106  : 			if (_Myostr.rdbuf() != 0)
; 107  : 				_Myostr.rdbuf()->_Unlock();
; 108  : 			}
; 109  : 
; 110  : 		_Myt& _Myostr;	// the output stream, for _Unlock call at destruction
; 111  : 
; 112  : 		_Sentry_base& operator=(const _Sentry_base&) = delete;
; 113  : 		};
; 114  : 
; 115  : 	class sentry
; 116  : 		: public _Sentry_base
; 117  : 		{	// stores thread lock and state of stream
; 118  : 	public:
; 119  : 		explicit __CLR_OR_THIS_CALL sentry(_Myt& _Ostr)
; 120  : 			: _Sentry_base(_Ostr)

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 338  : 		return (rdstate() == goodbit);

  0004a	8b c2		 mov	 eax, edx

; 314  : 		return (_Mystate);

  0004c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 338  : 		return (rdstate() == goodbit);

  0004f	83 7c 31 0c 00	 cmp	 DWORD PTR [ecx+esi+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00054	75 14		 jne	 SHORT $LN2@sentry
  00056	8b 4c 31 3c	 mov	 ecx, DWORD PTR [ecx+esi+60]
  0005a	85 c9		 test	 ecx, ecx
  0005c	74 0c		 je	 SHORT $LN2@sentry
  0005e	3b ce		 cmp	 ecx, esi
  00060	74 08		 je	 SHORT $LN2@sentry

; 123  : 				_Ostr.tie()->flush();

  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  00068	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2@sentry:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 338  : 		return (rdstate() == goodbit);

  0006a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006d	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00072	0f 94 c0	 sete	 al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 124  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00075	88 47 04	 mov	 BYTE PTR [edi+4], al

; 125  : 			}

  00078	8b c7		 mov	 eax, edi
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00084	59		 pop	 ecx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 1421 : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1422 : 		}

  00002	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$dead$ = ecx

; 1641 : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 1629 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00003	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00006	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Size$[ebp]
  0000c	3b c8		 cmp	 ecx, eax
  0000e	0f 42 c1	 cmovb	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1631 : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 1608 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1609 : 		if (_Mysize < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN5@Check_offs

; 1612 : 			}
; 1613 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN5@Check_offs:

; 1610 : 			{
; 1611 : 			_Xran();

  0000f	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN7@Check_offs:
$LN4@Check_offs:
  00014	cc		 int	 3
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	0f 93 c0	 setae	 al

; 1605 : 		}

  00007	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;
; 1594 : 		if (_Large_string_engaged())

  00004	72 03		 jb	 SHORT $LN8@Myptr

; 1595 : 			{
; 1596 : 			_Result = _Unfancy(_Bx._Ptr);
; 1597 : 			}
; 1598 : 
; 1599 : 		return (_Result);

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1600 : 		}

  00008	c3		 ret	 0
$LN8@Myptr:

; 1595 : 			{
; 1596 : 			_Result = _Unfancy(_Bx._Ptr);
; 1597 : 			}
; 1598 : 
; 1599 : 		return (_Result);

  00009	8b c1		 mov	 eax, ecx

; 1600 : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;
; 1583 : 		if (_Large_string_engaged())

  00004	72 03		 jb	 SHORT $LN8@Myptr

; 1584 : 			{
; 1585 : 			_Result = _Unfancy(_Bx._Ptr);
; 1586 : 			}
; 1587 : 
; 1588 : 		return (_Result);

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1589 : 		}

  00008	c3		 ret	 0
$LN8@Myptr:

; 1584 : 			{
; 1585 : 			_Result = _Unfancy(_Bx._Ptr);
; 1586 : 			}
; 1587 : 
; 1588 : 		return (_Result);

  00009	8b c1		 mov	 eax, ecx

; 1589 : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 961  : 		return (_Al);

  00000	8b c1		 mov	 eax, ecx

; 962  : 		}

  00002	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1827 : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 1828 : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1822 : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 1823 : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1817 : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 1818 : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1812 : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 1813 : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 1802 : 		_Get_data()._Orphan_all();
; 1803 : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$dead$ = ecx

; 1707 : 		_Pocma(_Getal(), _Al);
; 1708 : 		}

  00000	c2 04 00	 ret	 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT
; _this$dead$ = ecx

; 1702 : 		_Pocca(_Getal(), _Al);
; 1703 : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1563 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1690 : 		}

  00007	8b c1		 mov	 eax, ecx

; 1564 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1690 : 		}

  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3691 : 		{	// initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3692 : 		this->_Orphan_all();
; 3693 : 		auto& _My_data = this->_Get_data();
; 3694 : 		if (_My_data._Large_string_engaged())

  00009	72 37		 jb	 SHORT $LN36@Tidy_deall
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0000d	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 22		 jb	 SHORT $LN39@Tidy_deall

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00016	8d 51 23	 lea	 edx, DWORD PTR [ecx+35]
  00019	3b d1		 cmp	 edx, ecx
  0001b	76 38		 jbe	 SHORT $_Invalid_parameter$59

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0001d	8b ca		 mov	 ecx, edx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0001f	a8 1f		 test	 al, 31			; 0000001fH
  00021	75 32		 jne	 SHORT $_Invalid_parameter$59

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00023	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00026	3b d0		 cmp	 edx, eax
  00028	73 2b		 jae	 SHORT $_Invalid_parameter$59

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0002a	2b c2		 sub	 eax, edx
  0002c	83 f8 04	 cmp	 eax, 4
  0002f	72 24		 jb	 SHORT $_Invalid_parameter$59

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00031	83 f8 23	 cmp	 eax, 35			; 00000023H
  00034	77 1f		 ja	 SHORT $_Invalid_parameter$59

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00036	8b c2		 mov	 eax, edx
$LN39@Tidy_deall:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00038	51		 push	 ecx
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003f	83 c4 08	 add	 esp, 8
$LN36@Tidy_deall:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00042	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00049	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00050	c6 06 00	 mov	 BYTE PTR [esi], 0
  00053	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3707 : 		}

  00054	c3		 ret	 0
$_Invalid_parameter$59:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN58@Tidy_deall:
$LN57@Tidy_deall:
  0005b	cc		 int	 3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3682 : 		auto& _My_data = this->_Get_data();
; 3683 : 		_My_data._Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00007	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0000e	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3688 : 		}

  00011	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$dead$ = 8					; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 3676 : 		auto& _My_data = this->_Get_data();
; 3677 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00004	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1583 : 		if (_Large_string_engaged())

  0000b	72 08		 jb	 SHORT $LN19@Eos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3678 : 		}

  00012	c2 04 00	 ret	 4
$LN19@Eos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3678 : 		}

  00018	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small, COMDAT
; _this$ = ecx

; 3661 : 		{	// release any held storage and return to small string mode

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 3662 : 			// pre: *this is in large string mode
; 3663 : 			// pre: this is small enough to return to small string mode
; 3664 : 		auto& _My_data = this->_Get_data();
; 3665 : 		_My_data._Orphan_all();
; 3666 : 		const pointer _Ptr = _My_data._Bx._Ptr;
; 3667 : 		auto& _Al = this->_Getal();
; 3668 : 		_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3669 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00004	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00007	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00009	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0000a	50		 push	 eax
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3670 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00012	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3670 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00018	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00019	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001e	72 23		 jb	 SHORT $LN33@Become_sma

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00020	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00023	3b c8		 cmp	 ecx, eax
  00025	76 30		 jbe	 SHORT $_Invalid_parameter$50

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00027	8b c1		 mov	 eax, ecx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00029	f6 c3 1f	 test	 bl, 31			; 0000001fH
  0002c	75 29		 jne	 SHORT $_Invalid_parameter$50

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002e	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00031	3b cb		 cmp	 ecx, ebx
  00033	73 22		 jae	 SHORT $_Invalid_parameter$50

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00035	2b d9		 sub	 ebx, ecx
  00037	83 fb 04	 cmp	 ebx, 4
  0003a	72 1b		 jb	 SHORT $_Invalid_parameter$50

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0003c	83 fb 23	 cmp	 ebx, 35			; 00000023H
  0003f	77 16		 ja	 SHORT $_Invalid_parameter$50

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00041	8b d9		 mov	 ebx, ecx
$LN33@Become_sma:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00043	50		 push	 eax
  00044	53		 push	 ebx
  00045	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004a	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3671 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0004d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 3672 : 		}

  00056	c3		 ret	 0
$_Invalid_parameter$50:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN49@Become_sma:
$LN48@Become_sma:
  0005d	cc		 int	 3
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$dead$ = ecx

; 3568 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3569 : 		return (static_cast<allocator_type>(this->_Getal()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3570 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 3052 : 		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
; 3053 : 		const size_type _Storage_max = // can always store small string
; 3054 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));
; 3055 : 		return (_Min_value(

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 3056 : 			static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3057 : 			_Storage_max - 1 // -1 is for null terminator and/or npos
; 3058 : 			));
; 3059 : 
; 3060 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 32   : 	return (_Left < _Right ? _Right : _Left);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 02		 cmp	 eax, DWORD PTR [edx]
  00004	0f 42 ca	 cmovb	 ecx, edx
  00007	8b c1		 mov	 eax, ecx

; 33   : 	}

  00009	c3		 ret	 0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
$T3 = -4						; size = 1
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 2974 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2975 : 		auto& _My_data = this->_Get_data();
; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]

; 2977 : 		if (_Old_size < _My_data._Myres)

  00007	3b 51 14	 cmp	 edx, DWORD PTR [ecx+20]
  0000a	73 1f		 jae	 SHORT $LN2@push_back

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0000c	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  00010	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00013	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1583 : 		if (_Large_string_engaged())

  00016	72 02		 jb	 SHORT $LN11@push_back
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN11@push_back:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0001a	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  0001d	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00020	c6 44 11 01 00	 mov	 BYTE PTR [ecx+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2993 : 		}

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN2@push_back:

; 2980 : 			_Elem * const _Ptr = _My_data._Myptr();
; 2981 : 			_Traits::assign(_Ptr[_Old_size], _Ch);
; 2982 : 			_Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 2983 : 			return;
; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  0002b	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0002e	c6 45 fc 00	 mov	 BYTE PTR $T3[ebp], 0
  00032	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>

; 2993 : 		}

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z PROC ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator(), COMDAT
; _this$dead$ = ecx

; 2988 : 				const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Old_ptr$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Old_size$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR __New_ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0000e	56		 push	 esi
  0000f	50		 push	 eax
  00010	57		 push	 edi
  00011	e8 00 00 00 00	 call	 _memcpy

; 442  : 		_Left = _Right;

  00016	8a 45 14	 mov	 al, BYTE PTR __Ch$[ebp]

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  0001c	88 04 3e	 mov	 BYTE PTR [esi+edi], al
  0001f	c6 44 3e 01 00	 mov	 BYTE PTR [esi+edi+1], 0
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2992 : 			}, _Ch);

  00026	5d		 pop	 ebp
  00027	c2 10 00	 ret	 16			; 00000010H
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ENDP ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 2825 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1202 : 		: _Ptr(_Parg)

  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1583 : 		if (_Large_string_engaged())

  0000a	72 02		 jb	 SHORT $LN28@begin
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN28@begin:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1202 : 		: _Ptr(_Parg)

  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 2826 : 		auto _My_data = _STD addressof(this->_Get_data());
; 2827 : 		return (iterator(_Refancy<pointer>(_My_data->_Myptr()), _My_data));
; 2828 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__New_capacity$1$ = -4					; size = 4
__Count$dead$ = 8					; size = 4
__Ch$dead$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2441 : 		{	// assign _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 2442 : 		auto& _My_data = this->_Get_data();
; 2443 : 		if (_Count <= _My_data._Myres)

  00008	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  0000b	83 ff 08	 cmp	 edi, 8
  0000e	72 25		 jb	 SHORT $LN2@assign

; 1582 : 		value_type * _Result = _Bx._Buf;

  00010	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00012	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00015	72 02		 jb	 SHORT $LN11@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
$LN11@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2446 : 			_My_data._Mysize = _Count;

  00019	c7 46 10 08 00
	00 00		 mov	 DWORD PTR [esi+16], 8
  00020	0f 57 c0	 xorps	 xmm0, xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00023	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0

; 442  : 		_Left = _Right;

  00027	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2452 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

  0002b	8b c6		 mov	 eax, esi
  0002d	5f		 pop	 edi

; 2456 : 		}

  0002e	5e		 pop	 esi
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN2@assign:

; 3583 : 		if (_Old > _Max - _Old / 2)

  00035	8b cf		 mov	 ecx, edi
  00037	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0003c	d1 e9		 shr	 ecx, 1
  0003e	2b c1		 sub	 eax, ecx
  00040	53		 push	 ebx
  00041	3b f8		 cmp	 edi, eax
  00043	76 07		 jbe	 SHORT $LN57@assign

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);

  00045	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0004a	eb 0d		 jmp	 SHORT $LN154@assign
$LN57@assign:

; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0004c	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0004f	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH
  00054	3b c3		 cmp	 eax, ebx
  00056	0f 47 d8	 cmova	 ebx, eax
$LN154@assign:

; 3605 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00059	33 c9		 xor	 ecx, ecx

; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0005b	89 5d fc	 mov	 DWORD PTR __New_capacity$1$[ebp], ebx

; 3605 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0005e	8b c3		 mov	 eax, ebx
  00060	83 c0 01	 add	 eax, 1
  00063	0f 92 c1	 setb	 cl
  00066	f7 d9		 neg	 ecx
  00068	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0006a	75 04		 jne	 SHORT $LN99@assign

; 79   : 		{
; 80   : 		return (nullptr);

  0006c	33 db		 xor	 ebx, ebx
  0006e	eb 32		 jmp	 SHORT $LN97@assign
$LN99@assign:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00070	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00076	72 1f		 jb	 SHORT $LN100@assign

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00078	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 117  : 			if (_Block_size <= _User_size)

  0007b	3b c1		 cmp	 eax, ecx
  0007d	0f 86 86 00 00
	00		 jbe	 $LN155@assign

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00089	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  0008c	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  0008f	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00092	89 43 fc	 mov	 DWORD PTR [ebx-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00095	eb 0b		 jmp	 SHORT $LN97@assign
$LN100@assign:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009d	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  000a0	8b d8		 mov	 ebx, eax
$LN97@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3608 : 		_My_data._Myres = _New_capacity;

  000a2	8b 45 fc	 mov	 eax, DWORD PTR __New_capacity$1$[ebp]
  000a5	0f 57 c0	 xorps	 xmm0, xmm0

; 3606 : 		_My_data._Orphan_all();
; 3607 : 		_My_data._Mysize = _New_size;

  000a8	c7 46 10 08 00
	00 00		 mov	 DWORD PTR [esi+16], 8

; 3608 : 		_My_data._Myres = _New_capacity;

  000af	89 46 14	 mov	 DWORD PTR [esi+20], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  000b2	66 0f d6 03	 movq	 QWORD PTR [ebx], xmm0

; 442  : 		_Left = _Right;

  000b6	c6 43 08 00	 mov	 BYTE PTR [ebx+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3610 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000ba	83 ff 10	 cmp	 edi, 16			; 00000010H
  000bd	72 37		 jb	 SHORT $LN25@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  000bf	8b 06		 mov	 eax, DWORD PTR [esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3612 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000c1	47		 inc	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000c2	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  000c8	72 22		 jb	 SHORT $LN128@assign

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000ca	8d 4f 23	 lea	 ecx, DWORD PTR [edi+35]
  000cd	3b cf		 cmp	 ecx, edi
  000cf	76 32		 jbe	 SHORT $_Invalid_parameter$159

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000d1	8b f9		 mov	 edi, ecx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000d3	a8 1f		 test	 al, 31			; 0000001fH
  000d5	75 2c		 jne	 SHORT $_Invalid_parameter$159

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000d7	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  000da	3b c8		 cmp	 ecx, eax
  000dc	73 25		 jae	 SHORT $_Invalid_parameter$159

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000de	2b c1		 sub	 eax, ecx
  000e0	83 f8 04	 cmp	 eax, 4
  000e3	72 1e		 jb	 SHORT $_Invalid_parameter$159

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  000e5	83 f8 23	 cmp	 eax, 35			; 00000023H
  000e8	77 19		 ja	 SHORT $_Invalid_parameter$159

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000ea	8b c1		 mov	 eax, ecx
$LN128@assign:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  000ec	57		 push	 edi
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000f3	83 c4 08	 add	 esp, 8
$LN25@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2452 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

  000f6	89 1e		 mov	 DWORD PTR [esi], ebx
  000f8	8b c6		 mov	 eax, esi
  000fa	5b		 pop	 ebx
  000fb	5f		 pop	 edi

; 2456 : 		}

  000fc	5e		 pop	 esi
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 08 00	 ret	 8
$_Invalid_parameter$159:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN157@assign:
$LN155@assign:

; 119  : 				_Traits::_Fail();	// report no memory

  00109	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN158@assign:
$LN152@assign:
  0010e	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBE@QADID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
__Ch$dead$ = 16						; size = 1
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBE@QADID@Z PROC ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator(), COMDAT
; _this$dead$ = ecx

; 2452 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0

; 442  : 		_Left = _Right;

  0000d	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2455 : 			}, _Ch));

  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBE@QADID@Z ENDP ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2436 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2436 : 		{	// assign [_Ptr, <null>)

  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL8@assign:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL8@assign
  00017	2b c7		 sub	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00019	8b ce		 mov	 ecx, esi
  0001b	50		 push	 eax
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 2438 : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -12						; size = 4
__Ptr$GSCopy$1$ = -8					; size = 4
$T39 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2418 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 45 f8	 mov	 DWORD PTR __Ptr$GSCopy$1$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]

; 2419 : 		auto& _My_data = this->_Get_data();
; 2420 : 		if (_Count <= _My_data._Myres)

  00014	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00017	89 4d f4	 mov	 DWORD PTR __Old$1$[ebp], ecx
  0001a	3b f9		 cmp	 edi, ecx
  0001c	77 27		 ja	 SHORT $LN2@assign

; 1582 : 		value_type * _Result = _Bx._Buf;

  0001e	8b de		 mov	 ebx, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00023	72 02		 jb	 SHORT $LN11@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00025	8b 1e		 mov	 ebx, DWORD PTR [esi]
$LN11@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  0002a	89 7e 10	 mov	 DWORD PTR [esi+16], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  00036	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0003a	8b c6		 mov	 eax, esi
  0003c	5f		 pop	 edi

; 2433 : 		}

  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
$LN2@assign:

; 3596 : 		if (_New_size > max_size())

  00045	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  0004b	0f 87 eb 00 00
	00		 ja	 $LN154@assign

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00051	8b df		 mov	 ebx, edi
  00053	83 cb 0f	 or	 ebx, 15			; 0000000fH
  00056	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH

; 3577 : 		if (_Masked > _Max)

  0005c	76 07		 jbe	 SHORT $LN56@assign

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);

  0005e	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00063	eb 1e		 jmp	 SHORT $LN55@assign
$LN56@assign:

; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  00065	8b d1		 mov	 edx, ecx
  00067	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0006c	d1 ea		 shr	 edx, 1
  0006e	2b c2		 sub	 eax, edx
  00070	3b c8		 cmp	 ecx, eax
  00072	76 07		 jbe	 SHORT $LN57@assign

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);

  00074	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00079	eb 08		 jmp	 SHORT $LN55@assign
$LN57@assign:

; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0007b	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0007e	3b d8		 cmp	 ebx, eax
  00080	0f 42 d8	 cmovb	 ebx, eax
$LN55@assign:

; 3605 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00083	33 c9		 xor	 ecx, ecx
  00085	8b c3		 mov	 eax, ebx
  00087	83 c0 01	 add	 eax, 1
  0008a	0f 92 c1	 setb	 cl
  0008d	f7 d9		 neg	 ecx
  0008f	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  00091	75 05		 jne	 SHORT $LN99@assign

; 79   : 		{
; 80   : 		return (nullptr);

  00093	89 4d fc	 mov	 DWORD PTR $T39[ebp], ecx
  00096	eb 38		 jmp	 SHORT $LN97@assign
$LN99@assign:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00098	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009e	72 22		 jb	 SHORT $LN100@assign

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  000a0	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 117  : 			if (_Block_size <= _User_size)

  000a3	3b c1		 cmp	 eax, ecx
  000a5	0f 86 96 00 00
	00		 jbe	 $LN156@assign

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b1	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  000b4	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  000b7	83 e1 e0	 and	 ecx, -32		; ffffffe0H
  000ba	89 4d fc	 mov	 DWORD PTR $T39[ebp], ecx

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000bd	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  000c0	eb 0e		 jmp	 SHORT $LN97@assign
$LN100@assign:

; 67   : 			_Ptr = ::operator new(_Bytes);

  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c8	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  000cb	89 45 fc	 mov	 DWORD PTR $T39[ebp], eax
  000ce	8b c8		 mov	 ecx, eax
$LN97@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000d0	57		 push	 edi
  000d1	ff 75 f8	 push	 DWORD PTR __Ptr$GSCopy$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3607 : 		_My_data._Mysize = _New_size;

  000d4	89 7e 10	 mov	 DWORD PTR [esi+16], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000d7	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3608 : 		_My_data._Myres = _New_capacity;

  000d8	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000db	e8 00 00 00 00	 call	 _memcpy

; 442  : 		_Left = _Right;

  000e0	8b 5d fc	 mov	 ebx, DWORD PTR $T39[ebp]

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3610 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000e6	8b 4d f4	 mov	 ecx, DWORD PTR __Old$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000e9	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3610 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000ed	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000f0	72 37		 jb	 SHORT $LN25@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  000f2	8b 06		 mov	 eax, DWORD PTR [esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3612 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000f4	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000f5	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000fb	72 22		 jb	 SHORT $LN128@assign

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000fd	8d 51 23	 lea	 edx, DWORD PTR [ecx+35]
  00100	3b d1		 cmp	 edx, ecx
  00102	76 32		 jbe	 SHORT $_Invalid_parameter$160

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00104	8b ca		 mov	 ecx, edx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00106	a8 1f		 test	 al, 31			; 0000001fH
  00108	75 2c		 jne	 SHORT $_Invalid_parameter$160

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0010a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0010d	3b d0		 cmp	 edx, eax
  0010f	73 25		 jae	 SHORT $_Invalid_parameter$160

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00111	2b c2		 sub	 eax, edx
  00113	83 f8 04	 cmp	 eax, 4
  00116	72 1e		 jb	 SHORT $_Invalid_parameter$160

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00118	83 f8 23	 cmp	 eax, 35			; 00000023H
  0011b	77 19		 ja	 SHORT $_Invalid_parameter$160

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0011d	8b c2		 mov	 eax, edx
$LN128@assign:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0011f	51		 push	 ecx
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00126	83 c4 08	 add	 esp, 8
$LN25@assign:
  00129	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0012a	89 1e		 mov	 DWORD PTR [esi], ebx
  0012c	8b c6		 mov	 eax, esi

; 2433 : 		}

  0012e	5e		 pop	 esi
  0012f	5b		 pop	 ebx
  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c2 08 00	 ret	 8
$_Invalid_parameter$160:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN157@assign:
$LN154@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3598 : 			_Xlen();	// result too long

  0013c	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN158@assign:
$LN156@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  00141	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN159@assign:
$LN152@assign:
  00146	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$dead$ = ecx

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00007	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  00018	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2432 : 			}, _Ptr));

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
$T3 = 8							; size = 1
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2360 : 		{	// append _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2361 : 		auto& _My_data = this->_Get_data();
; 2362 : 		const size_type _Old_size = _My_data._Mysize;
; 2363 : 		if (_Count <= _My_data._Myres - _Old_size)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0000d	8b c2		 mov	 eax, edx
  0000f	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00012	2b c1		 sub	 eax, ecx
  00014	3b d8		 cmp	 ebx, eax
  00016	77 2f		 ja	 SHORT $LN2@append

; 2364 : 			{
; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  00018	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0001b	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0001e	8b c7		 mov	 eax, edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00020	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00023	72 02		 jb	 SHORT $LN11@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00025	8b 07		 mov	 eax, DWORD PTR [edi]
$LN11@append:
  00027	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2367 : 			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  00028	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  0002b	0f be 45 0c	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0002f	53		 push	 ebx
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 _memset
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  0003a	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2369 : 			return (*this);

  0003e	8b c7		 mov	 eax, edi
  00040	5e		 pop	 esi
  00041	5f		 pop	 edi

; 2373 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2374 : 				const size_type _Count, const _Elem _Ch) {
; 2375 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2376 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2377 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2378 : 			}, _Count, _Ch));
; 2379 : 		}

  00042	5b		 pop	 ebx
  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN2@append:

; 2370 : 			}
; 2371 : 
; 2372 : 		return (_Reallocate_grow_by(_Count,

  00047	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  0004a	c6 45 08 00	 mov	 BYTE PTR $T3[ebp], 0
  0004e	8b cf		 mov	 ecx, edi
  00050	53		 push	 ebx
  00051	ff 75 08	 push	 DWORD PTR $T3[ebp]
  00054	53		 push	 ebx
  00055	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
  0005a	5f		 pop	 edi

; 2373 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2374 : 				const size_type _Count, const _Elem _Ch) {
; 2375 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2376 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2377 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2378 : 			}, _Count, _Ch));
; 2379 : 		}

  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Count$ = 20						; size = 4
__Ch$ = 24						; size = 1
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z PROC ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator(), COMDAT
; _this$dead$ = ecx

; 2374 : 				const size_type _Count, const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2374 : 				const size_type _Count, const _Elem _Ch) {

  00007	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00008	8b 7d 10	 mov	 edi, DWORD PTR __Old_size$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00015	0f be 45 18	 movsx	 eax, BYTE PTR __Ch$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2376 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  00019	03 fe		 add	 edi, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  0001b	8b 75 14	 mov	 esi, DWORD PTR __Count$[ebp]
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 _memset
  00026	83 c4 18	 add	 esp, 24			; 00000018H

; 442  : 		_Left = _Right;

  00029	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2378 : 			}, _Count, _Ch));

  0002f	5d		 pop	 ebp
  00030	c2 14 00	 ret	 20			; 00000014H
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ENDP ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
$T3 = 12						; size = 1
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2333 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2334 : 		auto& _My_data = this->_Get_data();
; 2335 : 		const size_type _Old_size = _My_data._Mysize;
; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0000d	8b c2		 mov	 eax, edx
  0000f	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00012	2b c1		 sub	 eax, ecx
  00014	3b d8		 cmp	 ebx, eax
  00016	77 2e		 ja	 SHORT $LN2@append

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00018	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0001b	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0001e	8b c7		 mov	 eax, edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00020	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00023	72 02		 jb	 SHORT $LN11@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00025	8b 07		 mov	 eax, DWORD PTR [edi]
$LN11@append:
  00027	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00028	53		 push	 ebx
  00029	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0002c	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0002f	56		 push	 esi
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  00039	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0003d	8b c7		 mov	 eax, edi
  0003f	5e		 pop	 esi
  00040	5f		 pop	 edi

; 2346 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2347 : 				const _Elem * const _Ptr, const size_type _Count) {
; 2348 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2349 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2350 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2351 : 			}, _Ptr, _Count));
; 2352 : 		}

  00041	5b		 pop	 ebx
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN2@append:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  00046	53		 push	 ebx
  00047	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0004a	c6 45 0c 00	 mov	 BYTE PTR $T3[ebp], 0
  0004e	8b cf		 mov	 ecx, edi
  00050	ff 75 0c	 push	 DWORD PTR $T3[ebp]
  00053	53		 push	 ebx
  00054	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  00059	5f		 pop	 edi

; 2346 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2347 : 				const _Elem * const _Ptr, const size_type _Count) {
; 2348 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2349 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2350 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2351 : 			}, _Ptr, _Count));
; 2352 : 		}

  0005a	5b		 pop	 ebx
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$dead$ = ecx

; 2347 : 				const _Elem * const _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2347 : 				const _Elem * const _Ptr, const size_type _Count) {

  00007	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00008	8b 7d 10	 mov	 edi, DWORD PTR __Old_size$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2349 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00015	03 fe		 add	 edi, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00017	8b 75 18	 mov	 esi, DWORD PTR __Count$[ebp]
  0001a	56		 push	 esi
  0001b	ff 75 14	 push	 DWORD PTR __Ptr$[ebp]
  0001e	57		 push	 edi
  0001f	e8 00 00 00 00	 call	 _memcpy
  00024	83 c4 18	 add	 esp, 24			; 00000018H

; 442  : 		_Left = _Right;

  00027	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2351 : 			}, _Ptr, _Count));

  0002d	5d		 pop	 ebp
  0002e	c2 14 00	 ret	 20			; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2281 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 2281 : 		{	// append _Right

  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00009	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2281 : 		{	// append _Right

  0000d	8b f9		 mov	 edi, ecx

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0000f	8b c8		 mov	 ecx, eax

; 1594 : 		if (_Large_string_engaged())

  00011	72 02		 jb	 SHORT $LN12@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN12@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00015	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00018	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  0001b	8b c6		 mov	 eax, esi
  0001d	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00020	2b c2		 sub	 eax, edx
  00022	3b d8		 cmp	 ebx, eax
  00024	77 2b		 ja	 SHORT $LN19@operator

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00026	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  00029	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0002c	8b c7		 mov	 eax, edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0002e	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00031	72 02		 jb	 SHORT $LN28@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00033	8b 07		 mov	 eax, DWORD PTR [edi]
$LN28@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00035	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00036	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00039	51		 push	 ecx
  0003a	56		 push	 esi
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  00044	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2282 : 		return (append(_Right));

  00048	8b c7		 mov	 eax, edi
  0004a	5f		 pop	 edi

; 2283 : 		}

  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN19@operator:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  00051	53		 push	 ebx
  00052	51		 push	 ecx
  00053	c6 45 08 00	 mov	 BYTE PTR $T5[ebp], 0
  00057	8b cf		 mov	 ecx, edi
  00059	ff 75 08	 push	 DWORD PTR $T5[ebp]
  0005c	53		 push	 ebx
  0005d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  00062	5f		 pop	 edi

; 2283 : 		}

  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z
_TEXT	SEGMENT
__New_capacity$1$ = -4					; size = 4
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2166 : 		{	// assign by copying data stored in _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0000c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2167 : 			// pre: this != &_Right
; 2168 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2169 : 		auto& _My_data = this->_Get_data();
; 2170 : 		auto& _Right_data = _Right._Get_data();
; 2171 : 		const size_type _Right_size = _Right_data._Mysize;

  00010	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]

; 1594 : 		if (_Large_string_engaged())

  00013	72 02		 jb	 SHORT $LN17@Construct_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00015	8b 36		 mov	 esi, DWORD PTR [esi]
$LN17@Construct_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2173 : 		if (_Right_size < this->_BUF_SIZE)

  00017	83 fb 10	 cmp	 ebx, 16			; 00000010H
  0001a	73 19		 jae	 SHORT $LN2@Construct_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0001c	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  0001f	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2186 : 		_My_data._Mysize = _Right_size;

  00022	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
  00025	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  0002c	5f		 pop	 edi

; 2188 : 		}

  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN2@Construct_:

; 2174 : 			{   // stay small, don't allocate
; 2175 : 			_Traits::copy(_My_data._Bx._Buf, _Right_ptr, this->_BUF_SIZE);
; 2176 : 			_My_data._Mysize = _Right_size;
; 2177 : 			_My_data._Myres = this->_BUF_SIZE - 1;
; 2178 : 			return;
; 2179 : 			}
; 2180 : 
; 2181 : 		auto& _Al = this->_Getal();
; 2182 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  00035	8b c3		 mov	 eax, ebx
  00037	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  0003c	83 c8 0f	 or	 eax, 15			; 0000000fH
  0003f	3b c1		 cmp	 eax, ecx
  00041	0f 47 c1	 cmova	 eax, ecx
  00044	89 45 fc	 mov	 DWORD PTR __New_capacity$1$[ebp], eax

; 2183 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  00047	83 c0 01	 add	 eax, 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0004a	75 04		 jne	 SHORT $LN60@Construct_

; 79   : 		{
; 80   : 		return (nullptr);

  0004c	33 d2		 xor	 edx, edx
  0004e	eb 2d		 jmp	 SHORT $LN58@Construct_
$LN60@Construct_:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00050	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00055	72 1b		 jb	 SHORT $LN61@Construct_

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00057	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 117  : 			if (_Block_size <= _User_size)

  0005a	3b c8		 cmp	 ecx, eax
  0005c	76 41		 jbe	 SHORT $LN88@Construct_

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00064	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00067	8d 50 23	 lea	 edx, DWORD PTR [eax+35]
  0006a	83 e2 e0	 and	 edx, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0006d	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00070	eb 0b		 jmp	 SHORT $LN58@Construct_
$LN61@Construct_:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00078	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  0007b	8b d0		 mov	 edx, eax
$LN58@Construct_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2185 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  0007d	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 944  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00080	89 17		 mov	 DWORD PTR [edi], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00082	51		 push	 ecx
  00083	56		 push	 esi
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2187 : 		_My_data._Myres = _New_capacity;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR __New_capacity$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2186 : 		_My_data._Mysize = _Right_size;

  00090	89 5f 10	 mov	 DWORD PTR [edi+16], ebx

; 2187 : 		_My_data._Myres = _New_capacity;

  00093	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00096	5f		 pop	 edi

; 2188 : 		}

  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 04 00	 ret	 4
$LN88@Construct_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  0009f	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN90@Construct_:
$LN86@Construct_:
  000a4	cc		 int	 3
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2116 : 		{	// assign by stealing _Right's buffer, memcpy optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2117 : 			// pre: this != &_Right
; 2118 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2119 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2120 : 		auto& _Right_data = _Right._Get_data();
; 2121 : 
; 2122 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2123 : 		if (_Right_data._Large_string_engaged())
; 2124 : 			{	// take ownership of _Right's iterators along with its buffer
; 2125 : 			this->_Swap_all(_Right);
; 2126 : 			}
; 2127 : 		else
; 2128 : 			{
; 2129 : 			_Right._Orphan_all();
; 2130 : 			}
; 2131 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2132 : 
; 2133 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2134 : 			+ _Memcpy_move_offset;
; 2135 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2136 : 			+ _Memcpy_move_offset;
; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00009	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0000c	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00011	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  00016	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0001d	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00024	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2139 : 		}

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents, COMDAT
; _this$ = ecx

; 2093 : 		{	// assign either as an rvalue or as an lvalue copy, allocators always equal optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00009	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0000c	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00011	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  00016	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0001d	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00024	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2098 : 		}

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
__Roff$dead$ = 12					; size = 4
__Count$dead$ = 16					; size = 4
__Al$dead$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1940 : 		{	// construct from _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3683 : 		_My_data._Mysize = 0;

  00006	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00014	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00017	a1 10 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0001c	83 f8 05	 cmp	 eax, 5
  0001f	72 32		 jb	 SHORT $LN53@basic_stri

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00021	83 c0 fb	 add	 eax, -5			; fffffffbH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00024	83 ca ff	 or	 edx, -1
  00027	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0002f	0f 42 d0	 cmovb	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00032	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00039	52		 push	 edx

; 1594 : 		if (_Large_string_engaged())

  0003a	0f 43 0d 00 00
	00 00		 cmovae	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00041	83 c1 05	 add	 ecx, 5
  00044	51		 push	 ecx
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1941 : 		_Tidy_init();
; 1942 : 		assign(_Right, _Roff, _Count);
; 1943 : 		}

  0004c	8b c6		 mov	 eax, esi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp
  00050	c2 10 00	 ret	 16			; 00000010H
$LN53@basic_stri:

; 1611 : 			_Xran();

  00053	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN55@basic_stri:
$LN52@basic_stri:
  00058	cc		 int	 3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT
; _this$ = ecx

; 736  : 		{	// set up putback area

  00000	8b d1		 mov	 edx, ecx
  00002	56		 push	 esi
  00003	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00004	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 737  : 		if (_Mysb::eback() != &_Mychar)

  00007	8d 72 3c	 lea	 esi, DWORD PTR [edx+60]
  0000a	8b 07		 mov	 eax, DWORD PTR [edi]
  0000c	3b c6		 cmp	 eax, esi
  0000e	74 10		 je	 SHORT $LN13@Set_back
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00010	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 739  : 			_Set_eback = _Mysb::eback();

  00013	89 42 50	 mov	 DWORD PTR [edx+80], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00016	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	03 01		 add	 eax, DWORD PTR [ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 740  : 			_Set_egptr = _Mysb::egptr();

  0001d	89 42 54	 mov	 DWORD PTR [edx+84], eax
$LN13@Set_back:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00020	89 37		 mov	 DWORD PTR [edi], esi

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  00022	8b ca		 mov	 ecx, edx
  00024	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00027	2b ce		 sub	 ecx, esi
  00029	83 c1 3d	 add	 ecx, 61			; 0000003dH
  0002c	5f		 pop	 edi
  0002d	89 30		 mov	 DWORD PTR [eax], esi
  0002f	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00032	5e		 pop	 esi
  00033	89 08		 mov	 DWORD PTR [eax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 743  : 		}

  00035	c3		 ret	 0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; _this$ = ecx

; 730  : 		{	// restore buffer after putback

  00000	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00001	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  00004	8d 41 3c	 lea	 eax, DWORD PTR [ecx+60]
  00007	39 07		 cmp	 DWORD PTR [edi], eax
  00009	75 16		 jne	 SHORT $LN2@Reset_back

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0000b	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0000e	56		 push	 esi
  0000f	8b 71 54	 mov	 esi, DWORD PTR [ecx+84]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00012	89 17		 mov	 DWORD PTR [edi], edx

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  00014	2b f2		 sub	 esi, edx
  00016	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00019	89 10		 mov	 DWORD PTR [eax], edx
  0001b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi
$LN2@Reset_back:
  00021	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 733  : 		}

  00022	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
__Newpcvt$ = 8						; size = 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT
; _this$ = ecx

; 711  : 		{	// initialize codecvt pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 712  : 		if (_Newpcvt->always_noconv())

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Newpcvt$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b cf		 mov	 ecx, edi
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
  00012	84 c0		 test	 al, al
  00014	74 0d		 je	 SHORT $LN2@Initcvt

; 713  : 			_Pcvt = 0;	// nothing to do

  00016	5f		 pop	 edi
  00017	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 718  : 			}
; 719  : 		}

  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN2@Initcvt:

; 714  : 		else
; 715  : 			{	// set up for nontrivial codecvt facet
; 716  : 			_Pcvt = _Newpcvt;
; 717  : 			_Mysb::_Init();	// reset any buffering

  00023	8b ce		 mov	 ecx, esi
  00025	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
  0002e	5f		 pop	 edi

; 718  : 			}
; 719  : 		}

  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
$T47 = -52						; size = 1
_this$GSCopy$1$ = -48					; size = 4
__Dest$68 = -44						; size = 4
__Str$69 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT
; _this$ = ecx

; 668  : 		{	// put shift to initial conversion state, as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d d0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx

; 669  : 		if (_Pcvt == 0 || !_Wrotesome)

  00030	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00034	0f 84 6e 01 00
	00		 je	 $LN9@Endwrite
  0003a	80 7b 3d 00	 cmp	 BYTE PTR [ebx+61], 0
  0003e	0f 84 64 01 00
	00		 je	 $LN9@Endwrite

; 671  : 		else
; 672  : 			{	// may have to put
; 673  : 			const int _STRING_INC = 8;
; 674  : 			char *_Dest;
; 675  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

  00044	8b 03		 mov	 eax, DWORD PTR [ebx]
  00046	6a ff		 push	 -1
  00048	ff 50 0c	 call	 DWORD PTR [eax+12]
  0004b	83 f8 ff	 cmp	 eax, -1
  0004e	75 07		 jne	 SHORT $LN10@Endwrite

; 676  : 				return (false);

  00050	32 c0		 xor	 al, al
  00052	e9 53 01 00 00	 jmp	 $LN554@Endwrite
$LN10@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1978 : 		assign(_Count, _Ch);

  00057	83 ec 08	 sub	 esp, 8

; 3683 : 		_My_data._Mysize = 0;

  0005a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$69[ebp+16], 0

; 1978 : 		assign(_Count, _Ch);

  00061	8d 4d d8	 lea	 ecx, DWORD PTR __Str$69[ebp]

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00064	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Str$69[ebp+20], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0006b	c6 45 d8 00	 mov	 BYTE PTR __Str$69[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1978 : 		assign(_Count, _Ch);

  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 678  : 			string _Str(_STRING_INC, '\0');

  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
$LN577@Endwrite:
  0007b	8b 7d ec	 mov	 edi, DWORD PTR __Str$69[ebp+20]
  0007e	8b 75 d8	 mov	 esi, DWORD PTR __Str$69[ebp]
$LL2@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00081	83 ff 10	 cmp	 edi, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 681  : 				switch (_Pcvt->unshift(_State,

  00084	8d 45 d4	 lea	 eax, DWORD PTR __Dest$68[ebp]
  00087	50		 push	 eax
  00088	8b 45 e8	 mov	 eax, DWORD PTR __Str$69[ebp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0008b	8d 55 d8	 lea	 edx, DWORD PTR __Str$69[ebp]

; 1583 : 		if (_Large_string_engaged())

  0008e	0f 43 d6	 cmovae	 edx, esi

; 1582 : 		value_type * _Result = _Bx._Buf;

  00091	8d 4d d8	 lea	 ecx, DWORD PTR __Str$69[ebp]

; 1583 : 		if (_Large_string_engaged())

  00094	0f 43 ce	 cmovae	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 681  : 				switch (_Pcvt->unshift(_State,

  00097	03 c2		 add	 eax, edx
  00099	50		 push	 eax
  0009a	51		 push	 ecx
  0009b	8b 4b 38	 mov	 ecx, DWORD PTR [ebx+56]
  0009e	8d 43 40	 lea	 eax, DWORD PTR [ebx+64]
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z
  000a8	83 e8 00	 sub	 eax, 0
  000ab	74 1b		 je	 SHORT $LN11@Endwrite
  000ad	83 e8 01	 sub	 eax, 1
  000b0	74 1a		 je	 SHORT $LN12@Endwrite

; 704  : 						return (false);	// conversion failed

  000b2	8b 7d ec	 mov	 edi, DWORD PTR __Str$69[ebp+20]
  000b5	8b 75 d8	 mov	 esi, DWORD PTR __Str$69[ebp]
  000b8	83 e8 02	 sub	 eax, 2
  000bb	0f 84 a1 00 00
	00		 je	 $LN571@Endwrite
$_Invalid_parameter$581:
$LN570@Endwrite:
  000c1	32 db		 xor	 bl, bl
  000c3	e9 9c 00 00 00	 jmp	 $LN22@Endwrite
$LN11@Endwrite:

; 682  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 683  : 					{	// test result of homing conversion
; 684  : 					case codecvt_base::ok:
; 685  : 						_Wrotesome = false;	// homed successfully

  000c8	c6 43 3d 00	 mov	 BYTE PTR [ebx+61], 0
$LN12@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000cc	8b 7d ec	 mov	 edi, DWORD PTR __Str$69[ebp+20]

; 1582 : 		value_type * _Result = _Bx._Buf;

  000cf	8d 45 d8	 lea	 eax, DWORD PTR __Str$69[ebp]

; 1583 : 		if (_Large_string_engaged())

  000d2	8b 75 d8	 mov	 esi, DWORD PTR __Str$69[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000d5	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1202 : 		: _Ptr(_Parg)

  000d8	8b 5d d4	 mov	 ebx, DWORD PTR __Dest$68[ebp]

; 1583 : 		if (_Large_string_engaged())

  000db	0f 43 c6	 cmovae	 eax, esi

; 1202 : 		: _Ptr(_Parg)

  000de	2b d8		 sub	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 690  : 						if (0 < _Count && _Count !=

  000e0	74 26		 je	 SHORT $LN13@Endwrite
  000e2	8b 4d d0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  000e5	8d 45 d8	 lea	 eax, DWORD PTR __Str$69[ebp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000e8	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  000eb	0f 43 c6	 cmovae	 eax, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 690  : 						if (0 < _Count && _Count !=

  000ee	ff 71 4c	 push	 DWORD PTR [ecx+76]
  000f1	53		 push	 ebx
  000f2	6a 01		 push	 1
  000f4	50		 push	 eax
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  000fb	8b 7d ec	 mov	 edi, DWORD PTR __Str$69[ebp+20]
  000fe	83 c4 10	 add	 esp, 16			; 00000010H
  00101	8b 75 d8	 mov	 esi, DWORD PTR __Str$69[ebp]
  00104	3b d8		 cmp	 ebx, eax
  00106	75 b9		 jne	 SHORT $LN570@Endwrite
$LN13@Endwrite:
$_Invalid_parameter$582:

; 691  : 							fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 692  : 							return (false);	// write failed
; 693  : 						if (!_Wrotesome)

  00108	8b 45 d0	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  0010b	80 78 3d 00	 cmp	 BYTE PTR [eax+61], 0
  0010f	74 51		 je	 SHORT $LN571@Endwrite
$_Invalid_parameter$583:

; 695  : 						if (_Count == 0)

  00111	85 db		 test	 ebx, ebx
  00113	8b d8		 mov	 ebx, eax
  00115	0f 85 66 ff ff
	ff		 jne	 $LL2@Endwrite
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2362 : 		const size_type _Old_size = _My_data._Mysize;

  0011b	8b 4d e8	 mov	 ecx, DWORD PTR __Str$69[ebp+16]
  0011e	8b c7		 mov	 eax, edi
  00120	2b c1		 sub	 eax, ecx

; 2363 : 		if (_Count <= _My_data._Myres - _Old_size)

  00122	83 f8 08	 cmp	 eax, 8
  00125	72 21		 jb	 SHORT $LN335@Endwrite

; 2364 : 			{
; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  00127	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0012a	83 ff 10	 cmp	 edi, 16			; 00000010H

; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  0012d	89 45 e8	 mov	 DWORD PTR __Str$69[ebp+16], eax
  00130	0f 57 c0	 xorps	 xmm0, xmm0

; 1582 : 		value_type * _Result = _Bx._Buf;

  00133	8d 45 d8	 lea	 eax, DWORD PTR __Str$69[ebp]

; 1583 : 		if (_Large_string_engaged())

  00136	0f 43 c6	 cmovae	 eax, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00139	66 0f d6 04 08	 movq	 QWORD PTR [eax+ecx], xmm0

; 442  : 		_Left = _Right;

  0013e	c6 44 08 08 00	 mov	 BYTE PTR [eax+ecx+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2369 : 			return (*this);

  00143	e9 33 ff ff ff	 jmp	 $LN577@Endwrite
$LN335@Endwrite:

; 2370 : 			}
; 2371 : 
; 2372 : 		return (_Reallocate_grow_by(_Count,

  00148	6a 00		 push	 0
  0014a	6a 08		 push	 8
  0014c	c6 45 cc 00	 mov	 BYTE PTR $T47[ebp], 0
  00150	8d 4d d8	 lea	 ecx, DWORD PTR __Str$69[ebp]
  00153	ff 75 cc	 push	 DWORD PTR $T47[ebp]
  00156	6a 08		 push	 8
  00158	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 706  : 				}

  0015d	e9 19 ff ff ff	 jmp	 $LN577@Endwrite
$LN571@Endwrite:

; 694  : 							return (true);

  00162	b3 01		 mov	 bl, 1
$LN22@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00164	83 ff 10	 cmp	 edi, 16			; 00000010H

; 3694 : 		if (_My_data._Large_string_engaged())

  00167	72 3b		 jb	 SHORT $LN465@Endwrite

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00169	47		 inc	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0016a	8b c6		 mov	 eax, esi

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0016c	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  00172	72 26		 jb	 SHORT $LN468@Endwrite

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00174	8d 4f 23	 lea	 ecx, DWORD PTR [edi+35]
  00177	3b cf		 cmp	 ecx, edi
  00179	76 19		 jbe	 SHORT $_Invalid_parameter$584

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0017b	8b f9		 mov	 edi, ecx
  0017d	a8 1f		 test	 al, 31			; 0000001fH

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0017f	75 13		 jne	 SHORT $_Invalid_parameter$584

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00181	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  00184	3b f0		 cmp	 esi, eax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00186	73 0c		 jae	 SHORT $_Invalid_parameter$584

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00188	2b c6		 sub	 eax, esi
  0018a	83 f8 04	 cmp	 eax, 4
  0018d	72 05		 jb	 SHORT $_Invalid_parameter$584

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0018f	83 f8 23	 cmp	 eax, 35			; 00000023H
  00192	76 06		 jbe	 SHORT $LN468@Endwrite
$_Invalid_parameter$584:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN580@Endwrite:
$LN468@Endwrite:

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0019a	57		 push	 edi
  0019b	56		 push	 esi
  0019c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001a1	83 c4 08	 add	 esp, 8
$LN465@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 704  : 						return (false);	// conversion failed

  001a4	8a c3		 mov	 al, bl
  001a6	eb 02		 jmp	 SHORT $LN554@Endwrite
$LN9@Endwrite:

; 670  : 			return (true);

  001a8	b0 01		 mov	 al, 1
$LN554@Endwrite:

; 707  : 			}
; 708  : 		}

  001aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b4	59		 pop	 ecx
  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx
  001b8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bb	33 cd		 xor	 ecx, ebp
  001bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c3		 ret	 0
$LN579@Endwrite:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Str$69[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__Nr$1 = -16						; size = 4
__Pn$2 = -12						; size = 4
__Pb$3 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__File$ = 8						; size = 4
__Which$ = 12						; size = 4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 633  : 		{	// initialize to C stream _File after {new, open, close}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 634  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 635  : 
; 636  : 		_Closef = _Which == _Openfl;

  00010	83 7d 0c 01	 cmp	 DWORD PTR __Which$[ebp], 1
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
  00017	0f 94 c0	 sete	 al
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR __File$[ebp]
  0001e	88 46 48	 mov	 BYTE PTR [esi+72], al

; 637  : 		_Wrotesome = false;

  00021	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)

  0002b	85 ff		 test	 edi, edi
  0002d	74 46		 je	 SHORT $LN2@Init

; 652  : 			::_get_stream_buffer_pointers(

  0002f	8d 45 f0	 lea	 eax, DWORD PTR __Nr$1[ebp]
  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Pb$3[ebp], 0
  00039	50		 push	 eax
  0003a	8d 45 f4	 lea	 eax, DWORD PTR __Pn$2[ebp]
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Pn$2[ebp], 0
  00044	50		 push	 eax
  00045	8d 45 f8	 lea	 eax, DWORD PTR __Pb$3[ebp]
  00048	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Nr$1[ebp], 0
  0004f	50		 push	 eax
  00050	57		 push	 edi
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___get_stream_buffer_pointers
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 331  : 		_IGfirst = _Gf;

  00057	8b 45 f8	 mov	 eax, DWORD PTR __Pb$3[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 652  : 			::_get_stream_buffer_pointers(

  0005a	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 331  : 		_IGfirst = _Gf;

  0005d	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 332  : 		_IPfirst = _Pf;

  00060	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 333  : 		_IGnext = _Gn;

  00063	8b 45 f4	 mov	 eax, DWORD PTR __Pn$2[ebp]
  00066	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 334  : 		_IPnext = _Pn;

  00069	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 335  : 		_IGcount = _Gc;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR __Nr$1[ebp]
  0006f	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 336  : 		_IPcount = _Pc;

  00072	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN2@Init:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 663  : 		_State = _Stinit;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet
; 665  : 		}

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007d	89 7e 4c	 mov	 DWORD PTR [esi+76], edi
  00080	33 cd		 xor	 ecx, ebp
  00082	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00085	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  0008a	5f		 pop	 edi
  0008b	89 46 44	 mov	 DWORD PTR [esi+68], eax
  0008e	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00095	5e		 pop	 esi
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 359  : 		{	// close the C stream

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi

; 360  : 		_Myt *_Ans = this;
; 361  : 		if (_Myfile == 0)

  00005	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00009	75 04		 jne	 SHORT $LN2@close

; 362  : 			_Ans = 0;

  0000b	33 ff		 xor	 edi, edi

; 363  : 		else

  0000d	eb 21		 jmp	 SHORT $LN5@close
$LN2@close:

; 364  : 			{	// put any homing sequence and close file
; 365  : 			if (!_Endwrite())

  0000f	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 366  : 				_Ans = 0;
; 367  : 			if (fclose(_Myfile) != 0)

  00014	ff 76 4c	 push	 DWORD PTR [esi+76]
  00017	33 c9		 xor	 ecx, ecx
  00019	8b fe		 mov	 edi, esi
  0001b	84 c0		 test	 al, al
  0001d	0f 44 f9	 cmove	 edi, ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00026	33 c9		 xor	 ecx, ecx
  00028	83 c4 04	 add	 esp, 4
  0002b	85 c0		 test	 eax, eax
  0002d	0f 45 f9	 cmovne	 edi, ecx
$LN5@close:

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00030	8b ce		 mov	 ecx, esi
  00032	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0
  00036	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 663  : 		_State = _Stinit;

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 368  : 				_Ans = 0;
; 369  : 			}
; 370  : 		_Init(0, _Closefl);
; 371  : 		return (_Ans);

  00046	8b c7		 mov	 eax, edi

; 663  : 		_State = _Stinit;

  00048	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  0004b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4

; 372  : 		}

  00051	5f		 pop	 edi

; 662  : 		_Myfile = _File;

  00052	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0

; 663  : 		_State = _Stinit;

  00059	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  0005c	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 372  : 		}

  00063	5e		 pop	 esi
  00064	59		 pop	 ecx
  00065	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
$T1 = -32						; size = 8
__Nr$5 = -28						; size = 4
__Pn$6 = -24						; size = 4
__Pb$7 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$dead$ = 16					; size = 4
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 275  : 		{	// open a C stream with specified mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f1		 mov	 esi, ecx

; 276  : 		_Filet *_File;
; 277  : 		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)

  0002c	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00030	8b 45 08	 mov	 eax, DWORD PTR __Filename$[ebp]
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR __Mode$[ebp]
  00036	0f 85 e6 00 00
	00		 jne	 $LN3@open
  0003c	6a 40		 push	 64			; 00000040H
  0003e	51		 push	 ecx
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z
  00046	8b f8		 mov	 edi, eax
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	85 ff		 test	 edi, edi
  0004d	0f 84 cf 00 00
	00		 je	 $LN3@open

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00053	8b ce		 mov	 ecx, esi
  00055	c6 46 48 01	 mov	 BYTE PTR [esi+72], 1
  00059	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 652  : 			::_get_stream_buffer_pointers(

  00063	8d 45 e4	 lea	 eax, DWORD PTR __Nr$5[ebp]
  00066	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Pb$7[ebp], 0
  0006d	50		 push	 eax
  0006e	8d 45 e8	 lea	 eax, DWORD PTR __Pn$6[ebp]
  00071	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Pn$6[ebp], 0
  00078	50		 push	 eax
  00079	8d 45 ec	 lea	 eax, DWORD PTR __Pb$7[ebp]
  0007c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Nr$5[ebp], 0
  00083	50		 push	 eax
  00084	57		 push	 edi
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___get_stream_buffer_pointers
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 331  : 		_IGfirst = _Gf;

  0008b	8b 45 ec	 mov	 eax, DWORD PTR __Pb$7[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 652  : 			::_get_stream_buffer_pointers(

  0008e	83 c4 10	 add	 esp, 16			; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 331  : 		_IGfirst = _Gf;

  00091	89 46 0c	 mov	 DWORD PTR [esi+12], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 281  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

  00094	8b ce		 mov	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 332  : 		_IPfirst = _Pf;

  00096	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 333  : 		_IGnext = _Gn;

  00099	8b 45 e8	 mov	 eax, DWORD PTR __Pn$6[ebp]
  0009c	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 334  : 		_IPnext = _Pn;

  0009f	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 335  : 		_IGcount = _Gc;

  000a2	8b 45 e4	 mov	 eax, DWORD PTR __Nr$5[ebp]
  000a5	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 336  : 		_IPcount = _Pc;

  000a8	89 46 30	 mov	 DWORD PTR [esi+48], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 663  : 		_State = _Stinit;

  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  000b0	89 46 40	 mov	 DWORD PTR [esi+64], eax
  000b3	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000b8	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 281  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

  000bb	8d 45 e0	 lea	 eax, DWORD PTR $T1[ebp]
  000be	50		 push	 eax

; 662  : 		_Myfile = _File;

  000bf	89 7e 4c	 mov	 DWORD PTR [esi+76], edi

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c2	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 281  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
  000cf	8b c8		 mov	 ecx, eax
  000d1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d8	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  000dd	8b f8		 mov	 edi, eax

; 712  : 		if (_Newpcvt->always_noconv())

  000df	8b cf		 mov	 ecx, edi
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
  000e7	84 c0		 test	 al, al
  000e9	74 09		 je	 SHORT $LN18@open

; 713  : 			_Pcvt = 0;	// nothing to do

  000eb	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 714  : 		else

  000f2	eb 0b		 jmp	 SHORT $LN19@open
$LN18@open:

; 715  : 			{	// set up for nontrivial codecvt facet
; 716  : 			_Pcvt = _Newpcvt;
; 717  : 			_Mysb::_Init();	// reset any buffering

  000f4	8b ce		 mov	 ecx, esi
  000f6	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
$LN19@open:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale

; 402  : 		{	// destroy the object

  000ff	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 403  : 		if (_Ptr != 0)

  00106	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp+4]
  00109	85 c9		 test	 ecx, ecx
  0010b	74 11		 je	 SHORT $LN30@open

; 404  : 			delete _Ptr->_Decref();

  0010d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0010f	ff 50 08	 call	 DWORD PTR [eax+8]
  00112	85 c0		 test	 eax, eax
  00114	74 08		 je	 SHORT $LN30@open
  00116	8b 10		 mov	 edx, DWORD PTR [eax]
  00118	8b c8		 mov	 ecx, eax
  0011a	6a 01		 push	 1
  0011c	ff 12		 call	 DWORD PTR [edx]
$LN30@open:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 282  : 		return (this);	// open succeeded

  0011e	8b c6		 mov	 eax, esi
  00120	eb 02		 jmp	 SHORT $LN1@open
$LN3@open:

; 278  : 			return (0);	// open failed

  00122	33 c0		 xor	 eax, eax
$LN1@open:

; 283  : 		}

  00124	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00127	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012e	59		 pop	 ecx
  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00134	33 cd		 xor	 ecx, ebp
  00136	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR $T1[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__File$dead$ = 8					; size = 4
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 156  : 		{	// construct from pointer to C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	89 75 ec	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  0003b	8b ce		 mov	 ecx, esi

; 156  : 		{	// construct from pointer to C stream

  0003d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 636  : 		_Closef = _Which == _Openfl;

  00043	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0

; 637  : 		_Wrotesome = false;

  00047	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;
; 663  : 		_State = _Stinit;

  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 157  : 		_Init(_File, _Newfl);
; 158  : 		}

  00057	8b c6		 mov	 eax, esi

; 663  : 		_State = _Stinit;

  00059	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  0005c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  00062	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  00069	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  0006c	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 157  : 		_Init(_File, _Newfl);
; 158  : 		}

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 337  : 		{	// discard any allocated buffer and clear pointers

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 338  : 		if (_Mystate & _Allocated)

  00003	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  00007	74 57		 je	 SHORT $LN23@Tidy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00009	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 09		 je	 SHORT $LN4@Tidy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00012	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00015	8b 10		 mov	 edx, DWORD PTR [eax]
  00017	03 d1		 add	 edx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00019	eb 0a		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0001b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001e	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	03 11		 add	 edx, DWORD PTR [ecx]
$LN5@Tidy:

; 221  : 		return (*_IGfirst);

  00025	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	2b d0		 sub	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0002c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00032	72 22		 jb	 SHORT $LN26@Tidy

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00034	8d 4a 23	 lea	 ecx, DWORD PTR [edx+35]
  00037	3b ca		 cmp	 ecx, edx
  00039	76 68		 jbe	 SHORT $_Invalid_parameter$47

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0003b	8b d1		 mov	 edx, ecx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0003d	a8 1f		 test	 al, 31			; 0000001fH
  0003f	75 62		 jne	 SHORT $_Invalid_parameter$47

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00041	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00044	3b c8		 cmp	 ecx, eax
  00046	73 5b		 jae	 SHORT $_Invalid_parameter$47

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00048	2b c1		 sub	 eax, ecx
  0004a	83 f8 04	 cmp	 eax, 4
  0004d	72 54		 jb	 SHORT $_Invalid_parameter$47

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0004f	83 f8 23	 cmp	 eax, 35			; 00000023H
  00052	77 4f		 ja	 SHORT $_Invalid_parameter$47

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00054	8b c1		 mov	 eax, ecx
$LN26@Tidy:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00056	52		 push	 edx
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005d	83 c4 08	 add	 esp, 8
$LN23@Tidy:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00060	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00063	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 253  : 		*_IGnext = _Next;

  00069	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0006c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00072	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00075	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 293  : 		*_IPfirst = _First;

  0007b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0007e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 294  : 		*_IPnext = _First;

  00084	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00087	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 295  : 		*_IPcount = (int)(_Last - _First);

  0008d	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00090	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

  00096	83 66 3c fe	 and	 DWORD PTR [esi+60], -2	; fffffffeH
  0009a	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  000a1	5e		 pop	 esi

; 346  : 		}

  000a2	c3		 ret	 0
$_Invalid_parameter$47:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN46@Tidy:
$LN45@Tidy:
  000a9	cc		 int	 3
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
__Nul$68 = -48						; size = 24
__Str$69 = -48						; size = 24
__Str$70 = -48						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 93   : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	83 ec 38	 sub	 esp, 56			; 00000038H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 34	 mov	 DWORD PTR __$ArrayPad$[esp+56], eax
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00018	57		 push	 edi
  00019	8b f9		 mov	 edi, ecx

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0001b	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  0001e	f6 c1 02	 test	 cl, 2
  00021	75 3a		 jne	 SHORT $LN2@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00023	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	85 c0		 test	 eax, eax
  0002a	74 31		 je	 SHORT $LN2@str

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  0002c	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  0002f	3b d0		 cmp	 edx, eax
  00031	0f 42 d0	 cmovb	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 231  : 		return (*_IPfirst);

  00034	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00039	2b d1		 sub	 edx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1949 : 		assign(_Ptr, _Count);

  0003b	52		 push	 edx
  0003c	51		 push	 ecx
  0003d	8d 4c 24 18	 lea	 ecx, DWORD PTR __Str$70[esp+72]

; 3683 : 		_My_data._Mysize = 0;

  00041	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR __Str$70[esp+88], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00049	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR __Str$70[esp+92], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00051	c6 44 24 18 00	 mov	 BYTE PTR __Str$70[esp+72], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1949 : 		assign(_Ptr, _Count);

  00056	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 98   : 			return (_Str);

  0005b	eb 53		 jmp	 SHORT $LN487@str
$LN2@str:

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  0005d	f6 c1 04	 test	 cl, 4
  00060	75 39		 jne	 SHORT $LN4@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00062	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  00065	8b 10		 mov	 edx, DWORD PTR [eax]
  00067	85 d2		 test	 edx, edx
  00069	74 30		 je	 SHORT $LN4@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0006b	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]

; 221  : 		return (*_IGfirst);

  00070	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 241  : 		return (*_IGnext + *_IGcount);

  00073	03 ca		 add	 ecx, edx

; 221  : 		return (*_IGfirst);

  00075	8b 00		 mov	 eax, DWORD PTR [eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

  00077	2b c8		 sub	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1949 : 		assign(_Ptr, _Count);

  00079	51		 push	 ecx
  0007a	50		 push	 eax
  0007b	8d 4c 24 18	 lea	 ecx, DWORD PTR __Str$69[esp+72]

; 3683 : 		_My_data._Mysize = 0;

  0007f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR __Str$69[esp+88], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00087	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR __Str$69[esp+92], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0008f	c6 44 24 18 00	 mov	 BYTE PTR __Str$69[esp+72], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1949 : 		assign(_Ptr, _Count);

  00094	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 103  : 			return (_Str);

  00099	eb 15		 jmp	 SHORT $LN487@str
$LN4@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0009b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR __Nul$68[esp+80], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000a3	c7 44 24 24 0f
	00 00 00	 mov	 DWORD PTR __Nul$68[esp+84], 15 ; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000ab	c6 44 24 10 00	 mov	 BYTE PTR __Nul$68[esp+64], 0
$LN487@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000b0	0f 10 44 24 10	 movups	 xmm0, XMMWORD PTR __Nul$68[esp+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 110  : 		}

  000b5	8b 4c 24 3c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+64]
  000b9	8b c6		 mov	 eax, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1563 : 		_Mysize(0),

  000bb	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1564 : 		_Myres(0)

  000c2	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000c9	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 110  : 		}

  000cc	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000cd	f3 0f 7e 44 24
	1c		 movq	 xmm0, QWORD PTR __Nul$68[esp+76]
  000d3	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 110  : 		}

  000d8	5e		 pop	 esi
  000d9	33 cc		 xor	 ecx, esp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 04 00	 ret	 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$dead$ = 8					; size = 4
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}

  00035	8b c6		 mov	 eax, esi

; 311  : 		_Seekhigh = 0;

  00037	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 312  : 		_Mystate = _State;

  0003e	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0

; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}

  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004f	59		 pop	 ecx
  00050	5e		 pop	 esi
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$dead$ = ecx

; 1054 : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 08		 jne	 SHORT $LN5@allocate

; 79   : 		{
; 80   : 		return (nullptr);

  0000a	33 c9		 xor	 ecx, ecx

; 1055 : 		return (static_cast<_Ty *>(_Allocate(_Count, sizeof(_Ty), alignof(_Ty))));

  0000c	8b c1		 mov	 eax, ecx

; 1056 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
$LN5@allocate:

; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1f		 jb	 SHORT $LN6@allocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00019	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 117  : 			if (_Block_size <= _User_size)

  0001c	3b c8		 cmp	 ecx, eax
  0001e	76 27		 jbe	 SHORT $LN16@allocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00029	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  0002c	83 e1 e0	 and	 ecx, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0002f	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 1055 : 		return (static_cast<_Ty *>(_Allocate(_Count, sizeof(_Ty), alignof(_Ty))));

  00032	8b c1		 mov	 eax, ecx

; 1056 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN6@allocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  00041	8b c8		 mov	 ecx, eax

; 1056 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN16@allocate:

; 119  : 				_Traits::_Fail();	// report no memory

  00047	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN18@allocate:
$LN15@allocate:
  0004c	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$dead$ = ecx

; 1049 : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 152  : 		size_t _Allocated_size = _Count * _Sz;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00009	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000f	72 22		 jb	 SHORT $LN6@deallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00011	8d 51 23	 lea	 edx, DWORD PTR [ecx+35]
  00014	3b d1		 cmp	 edx, ecx
  00016	76 29		 jbe	 SHORT $_Invalid_parameter$22

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00018	8b ca		 mov	 ecx, edx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0001a	a8 1f		 test	 al, 31			; 0000001fH
  0001c	75 23		 jne	 SHORT $_Invalid_parameter$22

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00021	3b d0		 cmp	 edx, eax
  00023	73 1c		 jae	 SHORT $_Invalid_parameter$22

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00025	2b c2		 sub	 eax, edx
  00027	83 f8 04	 cmp	 eax, 4
  0002a	72 15		 jb	 SHORT $_Invalid_parameter$22

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0002c	83 f8 23	 cmp	 eax, 35			; 00000023H
  0002f	77 10		 ja	 SHORT $_Invalid_parameter$22

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00031	8b c2		 mov	 eax, edx
$LN6@deallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00033	51		 push	 ecx
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003a	83 c4 08	 add	 esp, 8

; 1051 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$_Invalid_parameter$22:

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN20@deallocate:
  00047	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT
; _this$ = ecx

; 63   : 		return (_Myoff + _Fpos);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	03 01		 add	 eax, DWORD PTR [ecx]
  00005	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00008	13 51 04	 adc	 edx, DWORD PTR [ecx+4]

; 64   : 		}

  0000b	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::seekpos, COMDAT
; _this$ = ecx

; 58   : 		return (_Fpos);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]

; 59   : 		}

  00006	c3		 ret	 0
?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT
; _this$ = ecx

; 47   : 		{	// return conversion state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 		return (_Mystate);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00009	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 49   : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
__State$ = 8						; size = 8
__Fileposition$ = 16					; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with conversion state and C file position

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  00003	8b 45 10	 mov	 eax, DWORD PTR __Fileposition$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00009	8b 45 14	 mov	 eax, DWORD PTR __Fileposition$[ebp+4]
  0000c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0000f	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00012	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR __State$[ebp+4]
  00018	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 44   : 		}

  0001b	8b c1		 mov	 eax, ecx
  0001d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00023	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with stream offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	89 01		 mov	 DWORD PTR [ecx], eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp+4]
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 39   : 		}

  00011	8b c1		 mov	 eax, ecx
  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00021	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0param_type@?$uniform_int@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0param_type@?$uniform_int@H@std@@QAE@HH@Z PROC	; std::uniform_int<int>::param_type::param_type, COMDAT
; _this$ = ecx

; 2195 : 		explicit param_type(result_type _Min0 = 0, result_type _Max0 = 9)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2224 : 			_Min = _Min0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Min0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 2225 : 			_Max = _Max0;

  00008	8b 45 0c	 mov	 eax, DWORD PTR __Max0$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2196 : 			{	// construct from parameters
; 2197 : 			_Init(_Min0, _Max0);
; 2198 : 			}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0param_type@?$uniform_int@H@std@@QAE@HH@Z ENDP	; std::uniform_int<int>::param_type::param_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
__Fx$dead$ = 12						; size = 4
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed, COMDAT
; _this$ = ecx

; 1308 : 		{	// set initial values from specified value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1309 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00003	8b 45 08	 mov	 eax, DWORD PTR __X0$[ebp]
  00006	ba 01 00 00 00	 mov	 edx, 1
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx
  0000f	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00012	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
$LL4@seed:

; 1310 : 		for (int _Ix = 1; _Ix < _Nx; ++_Ix)
; 1311 : 			_Prev = this->_Ax[_Ix] =

  00015	8b c8		 mov	 ecx, eax
  00017	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0001a	c1 e9 1e	 shr	 ecx, 30			; 0000001eH
  0001d	33 c8		 xor	 ecx, eax
  0001f	69 c1 65 89 07
	6c		 imul	 eax, ecx, 1812433253
  00025	03 c2		 add	 eax, edx
  00027	42		 inc	 edx
  00028	89 46 fc	 mov	 DWORD PTR [esi-4], eax
  0002b	81 fa 70 02 00
	00		 cmp	 edx, 624		; 00000270H
  00031	7c e2		 jl	 SHORT $LL4@seed

; 1312 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;
; 1313 : 		this->_Idx = _Nx;

  00033	c7 07 70 02 00
	00		 mov	 DWORD PTR [edi], 624	; 00000270H
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi

; 1314 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 105  : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 106  : 			if (_Myostr.rdbuf() != 0)

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 107  : 				_Myostr.rdbuf()->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 108  : 			}

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 98   : 			: _Myostr(_Ostr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]

; 99   : 			{	// lock the stream buffer, if there

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 100  : 			if (_Myostr.rdbuf() != 0)

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN8@Sentry_bas

; 101  : 				_Myostr.rdbuf()->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 102  : 			}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 352  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 353  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 347  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 348  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 332  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 333  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 327  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 328  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 1211 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1212 : 		_IDL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1213 : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 1214 : 		_IDL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1215 : 			" invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1216 : 		const auto _Contptr = _Mycont->_Myptr();
; 1217 : 		const auto _Rawptr = _Unfancy(_Ptr);
; 1218 : 		_IDL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1219 : 			"cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1220 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 1221 : 
; 1222 : 		_Analysis_assume_(_Ptr);
; 1223 : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1224 : 		}

  00002	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$dead$ = 12					; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 1414 : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1202 : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 1415 : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 1625 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
  0000b	cc		 int	 3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 956  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	83 c8 ff	 or	 eax, -1

; 957  : 		}

  00003	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
__Roff$dead$ = 12					; size = 4
__Count$dead$ = 16					; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2395 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1609 : 		if (_Mysize < _Off)

  00003	a1 10 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00008	83 f8 05	 cmp	 eax, 5
  0000b	72 2d		 jb	 SHORT $LN27@assign

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  0000d	83 c0 fb	 add	 eax, -5			; fffffffbH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00010	83 ca ff	 or	 edx, -1
  00013	83 f8 ff	 cmp	 eax, -1
  00016	0f 42 d0	 cmovb	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00019	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00020	b8 00 00 00 00	 mov	 eax, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1594 : 		if (_Large_string_engaged())

  00025	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2396 : 		auto& _Right_data = _Right._Get_data();
; 2397 : 		_Right_data._Check_offset(_Roff);
; 2398 : 		_Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0002c	52		 push	 edx
  0002d	83 c0 05	 add	 eax, 5
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2400 : 		}

  00036	5d		 pop	 ebp
  00037	c2 0c 00	 ret	 12			; 0000000cH
$LN27@assign:

; 1611 : 			_Xran();

  0003a	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN29@assign:
$LN26@assign:
  0003f	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z
_TEXT	SEGMENT
__Mode$dead$ = 8					; size = 4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT
; _this$dead$ = ecx

; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);

  00000	33 c0		 xor	 eax, eax

; 367  : 		}

  00002	c2 04 00	 ret	 4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
__State$ = 16						; size = 4
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init, COMDAT
; _this$ = ecx

; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 		_Seekhigh = 0;
; 312  : 		_Mystate = _State;

  00003	8b 45 10	 mov	 eax, DWORD PTR __State$[ebp]
  00006	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
  0000d	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}

  00010	5d		 pop	 ebp
  00011	c2 0c 00	 ret	 12			; 0000000cH
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 1039 : 		{	// construct default allocator (do nothing)
; 1040 : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z PROC	; std::uniform_int<int>::param_type::_Init, COMDAT
; _this$ = ecx

; 2221 : 			{	// set internal state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2222 : 			_RNG_ASSERT(_Min0 <= _Max0,
; 2223 : 				"invalid min and max arguments for uniform_int");
; 2224 : 			_Min = _Min0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Min0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 2225 : 			_Max = _Max0;

  00008	8b 45 0c	 mov	 eax, DWORD PTR __Max0$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2226 : 			}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z ENDP	; std::uniform_int<int>::param_type::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$dead$ = 12					; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 1203 : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1202 : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 1204 : 		this->_Adopt(_Pstring);
; 1205 : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 12
__Psave$4 = -24						; size = 4
__Lock$5 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT
; __Loc$ = ecx

; 504  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx

; 505  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  0002d	6a 00		 push	 0
  0002f	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 506  : 		const locale::facet *_Psave =
; 507  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave

; 508  : 
; 509  : 		size_t _Id = _Facet::id;

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  0004a	89 45 e8	 mov	 DWORD PTR __Psave$4[ebp], eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00053	8b f8		 mov	 edi, eax

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00055	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00058	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0005b	73 0c		 jae	 SHORT $LN15@use_facet
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 34 b9	 mov	 esi, DWORD PTR [ecx+edi*4]

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00063	85 f6		 test	 esi, esi
  00065	75 52		 jne	 SHORT $LN7@use_facet
  00067	eb 02		 jmp	 SHORT $LN19@use_facet
$LN15@use_facet:

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00069	33 f6		 xor	 esi, esi
$LN19@use_facet:

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0006b	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  0006f	74 11		 je	 SHORT $LN12@use_facet

; 433  : 			return (_Facptr);	// found facet or not transparent
; 434  : 		else
; 435  : 			{	// look in current locale
; 436  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 437  : 			return (_Id < _Ptr0->_Facetcount

  00077	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0007a	73 0a		 jae	 SHORT $LN20@use_facet
  0007c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007f	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN12@use_facet:

; 510  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 511  : 
; 512  : 		if (_Pf != 0)

  00082	85 f6		 test	 esi, esi
  00084	75 33		 jne	 SHORT $LN7@use_facet
$LN20@use_facet:

; 513  : 			;	// got facet from locale
; 514  : 		else if (_Psave != 0)

  00086	8b 75 e8	 mov	 esi, DWORD PTR __Psave$4[ebp]
  00089	85 f6		 test	 esi, esi
  0008b	75 2c		 jne	 SHORT $LN7@use_facet

; 515  : 			_Pf = _Psave;	// lazy facet already allocated
; 516  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  0008d	8d 45 e8	 lea	 eax, DWORD PTR __Psave$4[ebp]
  00090	53		 push	 ebx
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00098	83 c4 08	 add	 esp, 8
  0009b	83 f8 ff	 cmp	 eax, -1
  0009e	74 40		 je	 SHORT $LN24@use_facet

; 521  : 
; 522  :  #else /* _HAS_EXCEPTIONS */
; 523  : 			abort();	// lazy disallowed
; 524  :  #endif /* _HAS_EXCEPTIONS */
; 525  : 
; 526  : 		else
; 527  : 			{	// queue up lazy facet for destruction
; 528  : 			_Pf = _Psave;

  000a0	8b 75 e8	 mov	 esi, DWORD PTR __Psave$4[ebp]

; 529  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 530  : 
; 531  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 532  : 			_Pfmod->_Incref();

  000a3	8b ce		 mov	 ecx, esi
  000a5	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
  000ab	8b 16		 mov	 edx, DWORD PTR [esi]
  000ad	ff 52 04	 call	 DWORD PTR [edx+4]

; 533  : 
; 534  :  #if defined(_M_CEE)
; 535  : 			_Facet_Register_m(_Pfmod);
; 536  : 
; 537  :  #else /* defined(_M_CEE) */
; 538  : 			_Facet_Register(_Pfmod);

  000b0	56		 push	 esi
  000b1	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000b6	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 539  :  #endif /* defined(_M_CEE) */
; 540  : 			}
; 541  : 
; 542  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000b9	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000c2	8b c6		 mov	 eax, esi

; 543  : 	_END_LOCK()
; 544  : 	}	// end of use_facet body

  000c4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ce	59		 pop	 ecx
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d5	33 cd		 xor	 ecx, ebp
  000d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN24@use_facet:

; 517  : 
; 518  :  #if _HAS_EXCEPTIONS
; 519  : 
; 520  : 			_THROW(bad_cast{});	// lazy disallowed

  000e0	8d 4d dc	 lea	 ecx, DWORD PTR $T1[ebp]
  000e3	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  000e8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000ed	8b c1		 mov	 eax, ecx
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN26@use_facet:
$LN22@use_facet:
  000f5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
_TEXT	SEGMENT
__Pad$30 = -48						; size = 8
__Ok$ = -40						; size = 8
__Ch$1$ = -32						; size = 4
$T21 = -32						; size = 1
tv758 = -28						; size = 4
$T12 = -28						; size = 1
__State$ = -24						; size = 4
__Ostr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Ch$ = edx

; 816  : 	{	// insert a char into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	89 55 e0	 mov	 DWORD PTR __Ch$1$[ebp], edx
  0002e	89 4d ec	 mov	 DWORD PTR __Ostr$[ebp], ecx

; 100  : 			if (_Myostr.rdbuf() != 0)

  00031	8b 39		 mov	 edi, DWORD PTR [ecx]

; 817  : 	typedef char _Elem;
; 818  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 819  : 	ios_base::iostate _State = ios_base::goodbit;

  00033	33 f6		 xor	 esi, esi
  00035	89 75 e8	 mov	 DWORD PTR __State$[ebp], esi

; 98   : 			: _Myostr(_Ostr)

  00038	89 4d d8	 mov	 DWORD PTR __Ok$[ebp], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0003b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003e	8b 54 08 38	 mov	 edx, DWORD PTR [eax+ecx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

  00042	85 d2		 test	 edx, edx
  00044	74 0c		 je	 SHORT $LN27@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

  00046	8b 02		 mov	 eax, DWORD PTR [edx]
  00048	8b ca		 mov	 ecx, edx
  0004a	ff 50 04	 call	 DWORD PTR [eax+4]
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00050	8b 39		 mov	 edi, DWORD PTR [ecx]
$LN27@operator:

; 120  : 			: _Sentry_base(_Ostr)

  00052	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  00059	8b c7		 mov	 eax, edi
  0005b	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0005e	8b d7		 mov	 edx, edi

; 338  : 		return (rdstate() == goodbit);

  00060	83 7c 0b 0c 00	 cmp	 DWORD PTR [ebx+ecx+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00065	75 1b		 jne	 SHORT $LN23@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 79   : 		return (_Tiestr);

  00067	8b 5c 0b 3c	 mov	 ebx, DWORD PTR [ebx+ecx+60]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0006b	85 db		 test	 ebx, ebx
  0006d	74 13		 je	 SHORT $LN23@operator
  0006f	3b d9		 cmp	 ebx, ecx
  00071	74 0f		 je	 SHORT $LN23@operator

; 123  : 				_Ostr.tie()->flush();

  00073	8b cb		 mov	 ecx, ebx
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0007e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00080	8b d0		 mov	 edx, eax
$LN23@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  00082	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00085	8b 44 0b 0c	 mov	 eax, DWORD PTR [ebx+ecx+12]
  00089	03 d9		 add	 ebx, ecx

; 338  : 		return (rdstate() == goodbit);

  0008b	85 c0		 test	 eax, eax

; 314  : 		return (_Mystate);

  0008d	89 5d e4	 mov	 DWORD PTR tv758[ebp], ebx

; 338  : 		return (rdstate() == goodbit);

  00090	0f 94 45 dc	 sete	 BYTE PTR __Ok$[ebp+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 820  : 	const typename _Myos::sentry _Ok(_Ostr);

  00094	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0009b	85 c0		 test	 eax, eax

; 821  : 
; 822  : 	if (_Ok)

  0009d	0f 85 fe 00 00
	00		 jne	 $LN20@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 422  : 		return (_Wide);

  000a3	8b 7b 20	 mov	 edi, DWORD PTR [ebx+32]
  000a6	8b 5b 24	 mov	 ebx, DWORD PTR [ebx+36]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 824  : 		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  000a9	85 db		 test	 ebx, ebx
  000ab	7f 17		 jg	 SHORT $LN15@operator
  000ad	7c 05		 jl	 SHORT $LN110@operator
  000af	83 ff 01	 cmp	 edi, 1
  000b2	77 10		 ja	 SHORT $LN15@operator
$LN110@operator:
  000b4	0f 57 c0	 xorps	 xmm0, xmm0
  000b7	66 0f 13 45 d0	 movlpd	 QWORD PTR __Pad$30[ebp], xmm0
  000bc	8b 5d d4	 mov	 ebx, DWORD PTR __Pad$30[ebp+4]
  000bf	8b 7d d0	 mov	 edi, DWORD PTR __Pad$30[ebp]
  000c2	eb 06		 jmp	 SHORT $LN16@operator
$LN15@operator:
  000c4	83 ef 01	 sub	 edi, 1
  000c7	83 db 00	 sbb	 ebx, 0
$LN16@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 377  : 		return (_Fmtfl);

  000ca	8b 45 e4	 mov	 eax, DWORD PTR tv758[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 826  : 		_TRY_IO_BEGIN

  000cd	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 377  : 		return (_Fmtfl);

  000d1	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 827  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000d4	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000d9	83 f8 40	 cmp	 eax, 64			; 00000040H
  000dc	74 44		 je	 SHORT $LN106@operator
  000de	66 90		 npad	 2
$LL4@operator:

; 828  : 			for (; _State == ios_base::goodbit && 0 < _Pad;

  000e0	85 f6		 test	 esi, esi
  000e2	0f 85 b2 00 00
	00		 jne	 $LN6@operator
  000e8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ea	85 db		 test	 ebx, ebx
  000ec	7c 34		 jl	 SHORT $LN106@operator
  000ee	7f 04		 jg	 SHORT $LN111@operator
  000f0	85 ff		 test	 edi, edi
  000f2	74 2e		 je	 SHORT $LN106@operator
$LN111@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  000f4	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000f7	8a 41 40	 mov	 al, BYTE PTR [ecx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 830  : 				if (_Traits::eq_int_type(_Traits::eof(),

  000fa	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  000fd	88 45 e4	 mov	 BYTE PTR $T12[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 830  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00100	ff 75 e4	 push	 DWORD PTR $T12[ebp]
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00109	8b 4d ec	 mov	 ecx, DWORD PTR __Ostr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  0010c	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 830  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0010f	b8 04 00 00 00	 mov	 eax, 4
  00114	0f 44 f0	 cmove	 esi, eax
  00117	83 c7 ff	 add	 edi, -1
  0011a	89 75 e8	 mov	 DWORD PTR __State$[ebp], esi
  0011d	83 d3 ff	 adc	 ebx, -1
  00120	eb be		 jmp	 SHORT $LL4@operator
$LN106@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00122	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 835  : 			&& _Traits::eq_int_type(_Traits::eof(),

  00125	ff 75 e0	 push	 DWORD PTR __Ch$1$[ebp]
  00128	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00132	83 f8 ff	 cmp	 eax, -1
  00135	b8 04 00 00 00	 mov	 eax, 4
  0013a	0f 44 f0	 cmove	 esi, eax
$LN117@operator:
  0013d	89 75 e8	 mov	 DWORD PTR __State$[ebp], esi

; 836  : 				_Ostr.rdbuf()->sputc(_Ch)))
; 837  : 			_State |= ios_base::badbit;
; 838  : 
; 839  : 		for (; _State == ios_base::goodbit && 0 < _Pad;

  00140	85 f6		 test	 esi, esi
  00142	75 56		 jne	 SHORT $LN6@operator
  00144	85 db		 test	 ebx, ebx
  00146	7c 52		 jl	 SHORT $LN6@operator
  00148	7f 04		 jg	 SHORT $LN112@operator
  0014a	85 ff		 test	 edi, edi
  0014c	74 4c		 je	 SHORT $LN6@operator
$LN112@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  0014e	8b 4d ec	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00156	03 c8		 add	 ecx, eax
  00158	8a 41 40	 mov	 al, BYTE PTR [ecx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 841  : 			if (_Traits::eq_int_type(_Traits::eof(),

  0015b	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  0015e	88 45 e0	 mov	 BYTE PTR $T21[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 841  : 			if (_Traits::eq_int_type(_Traits::eof(),

  00161	ff 75 e0	 push	 DWORD PTR $T21[ebp]
  00164	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  0016a	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 841  : 			if (_Traits::eq_int_type(_Traits::eof(),

  0016d	b8 04 00 00 00	 mov	 eax, 4
  00172	0f 44 f0	 cmove	 esi, eax
  00175	83 c7 ff	 add	 edi, -1
  00178	83 d3 ff	 adc	 ebx, -1
  0017b	eb c0		 jmp	 SHORT $LN117@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0:

; 842  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 843  : 				_State |= ios_base::badbit;
; 844  : 		_CATCH_IO_(_Ostr)

  0017d	8b 55 ec	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00180	6a 01		 push	 1
  00182	6a 04		 push	 4
  00184	8b 02		 mov	 eax, DWORD PTR [edx]
  00186	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00189	03 ca		 add	 ecx, edx
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00191	b8 00 00 00 00	 mov	 eax, $LN21@operator
  00196	c3		 ret	 0
$LN21@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
  00197	8b 75 e8	 mov	 esi, DWORD PTR __State$[ebp]
$LN6@operator:
  0019a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN20@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 845  : 		}
; 846  : 
; 847  : 	_Ostr.width(0);

  001a1	8b 5d ec	 mov	 ebx, DWORD PTR __Ostr$[ebp]

; 848  : 	_Ostr.setstate(_State);

  001a4	6a 00		 push	 0
  001a6	56		 push	 esi
  001a7	8b 03		 mov	 eax, DWORD PTR [ebx]
  001a9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  001ac	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  001b4	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 848  : 	_Ostr.setstate(_State);

  001bc	8b 03		 mov	 eax, DWORD PTR [ebx]
  001be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c1	03 cb		 add	 ecx, ebx
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 128  : 			{	// destroy the object

  001c9	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 129  :  #if _HAS_EXCEPTIONS
; 130  : 			if (_STD uncaught_exceptions() == 0)

  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 131  : 				{
; 132  : 				this->_Myostr._Osfx();

  001d6	8b 75 d8	 mov	 esi, DWORD PTR __Ok$[ebp]
  001d9	85 c0		 test	 eax, eax
  001db	75 08		 jne	 SHORT $LN86@operator
  001dd	8b ce		 mov	 ecx, esi
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN86@operator:

; 105  : 			{	// destroy after unlocking

  001e5	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5

; 106  : 			if (_Myostr.rdbuf() != 0)

  001e9	8b 06		 mov	 eax, DWORD PTR [esi]
  001eb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001ee	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  001f2	85 c9		 test	 ecx, ecx
  001f4	74 05		 je	 SHORT $LN113@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

  001f6	8b 01		 mov	 eax, DWORD PTR [ecx]
  001f8	ff 50 08	 call	 DWORD PTR [eax+8]
$LN113@operator:

; 849  : 	return (_Ostr);

  001fb	8b c3		 mov	 eax, ebx

; 850  : 	}

  001fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00200	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00207	59		 pop	 ecx
  00208	5f		 pop	 edi
  00209	5e		 pop	 esi
  0020a	5b		 pop	 ebx
  0020b	8b e5		 mov	 esp, ebp
  0020d	5d		 pop	 ebp
  0020e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
__Pad$ = -48						; size = 8
__State$ = -40						; size = 4
__Val$1$ = -36						; size = 4
$T20 = -36						; size = 1
__Count$2$ = -32					; size = 4
__Pad$1$ = -28						; size = 4
$T14 = -28						; size = 1
tv803 = -24						; size = 4
tv800 = -24						; size = 4
__Ostr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 770  : 	{	// insert NTBS into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b c2		 mov	 eax, edx
  0002d	89 45 dc	 mov	 DWORD PTR __Val$1$[ebp], eax
  00030	8b d9		 mov	 ebx, ecx
  00032	89 5d ec	 mov	 DWORD PTR __Ostr$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00035	8b c8		 mov	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 773  : 	ios_base::iostate _State = ios_base::goodbit;

  00037	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0003e	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL108@operator:
  00041	8a 01		 mov	 al, BYTE PTR [ecx]
  00043	41		 inc	 ecx
  00044	84 c0		 test	 al, al
  00046	75 f9		 jne	 SHORT $LL108@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 775  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  00048	8b 13		 mov	 edx, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0004a	2b ce		 sub	 ecx, esi
  0004c	89 4d e0	 mov	 DWORD PTR __Count$2$[ebp], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 422  : 		return (_Wide);

  0004f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00052	03 c3		 add	 eax, ebx
  00054	89 45 e8	 mov	 DWORD PTR tv803[ebp], eax
  00057	8b 78 24	 mov	 edi, DWORD PTR [eax+36]
  0005a	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 775  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  0005d	85 ff		 test	 edi, edi
  0005f	7c 17		 jl	 SHORT $LN17@operator
  00061	7f 0e		 jg	 SHORT $LN110@operator
  00063	85 f6		 test	 esi, esi
  00065	74 11		 je	 SHORT $LN17@operator
  00067	85 ff		 test	 edi, edi
  00069	7c 0d		 jl	 SHORT $LN17@operator
  0006b	7f 04		 jg	 SHORT $LN110@operator
  0006d	3b f1		 cmp	 esi, ecx
  0006f	76 07		 jbe	 SHORT $LN17@operator
$LN110@operator:
  00071	2b f1		 sub	 esi, ecx
  00073	83 df 00	 sbb	 edi, 0
  00076	eb 0e		 jmp	 SHORT $LN123@operator
$LN17@operator:
  00078	0f 57 c0	 xorps	 xmm0, xmm0
  0007b	66 0f 13 45 d0	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  00080	8b 7d d4	 mov	 edi, DWORD PTR __Pad$[ebp+4]
  00083	8b 75 d0	 mov	 esi, DWORD PTR __Pad$[ebp]
$LN123@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00086	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00089	8b ca		 mov	 ecx, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 775  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  0008b	89 7d e4	 mov	 DWORD PTR __Pad$1$[ebp], edi

; 98   : 			: _Myostr(_Ostr)

  0008e	89 5d d0	 mov	 DWORD PTR __Ok$[ebp], ebx

; 99   : 			{	// lock the stream buffer, if there
; 100  : 			if (_Myostr.rdbuf() != 0)

  00091	85 c0		 test	 eax, eax
  00093	74 0f		 je	 SHORT $LN38@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

  00095	8b 4d e8	 mov	 ecx, DWORD PTR tv803[ebp]
  00098	8b 00		 mov	 eax, DWORD PTR [eax]
  0009a	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
  0009d	ff 50 04	 call	 DWORD PTR [eax+4]
  000a0	8b 13		 mov	 edx, DWORD PTR [ebx]
  000a2	8b ca		 mov	 ecx, edx
$LN38@operator:

; 120  : 			: _Sentry_base(_Ostr)

  000a4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  000ab	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ae	03 c3		 add	 eax, ebx
  000b0	89 45 e8	 mov	 DWORD PTR tv800[ebp], eax
  000b3	8b c2		 mov	 eax, edx

; 338  : 		return (rdstate() == goodbit);

  000b5	8b 5d e8	 mov	 ebx, DWORD PTR tv800[ebp]
  000b8	83 7b 0c 00	 cmp	 DWORD PTR [ebx+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  000bc	8b 5d ec	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  000bf	75 27		 jne	 SHORT $LN34@operator
  000c1	8b 5d e8	 mov	 ebx, DWORD PTR tv800[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 79   : 		return (_Tiestr);

  000c4	8b ca		 mov	 ecx, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  000c6	83 7b 3c 00	 cmp	 DWORD PTR [ebx+60], 0
  000ca	8b 5d ec	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  000cd	74 19		 je	 SHORT $LN34@operator
  000cf	8b 7d e8	 mov	 edi, DWORD PTR tv800[ebp]
  000d2	8b 57 3c	 mov	 edx, DWORD PTR [edi+60]
  000d5	8b 7d e4	 mov	 edi, DWORD PTR __Pad$1$[ebp]
  000d8	3b d3		 cmp	 edx, ebx
  000da	74 0c		 je	 SHORT $LN34@operator

; 123  : 				_Ostr.tie()->flush();

  000dc	8b ca		 mov	 ecx, edx
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  000e4	8b 03		 mov	 eax, DWORD PTR [ebx]
  000e6	8b c8		 mov	 ecx, eax
$LN34@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  000e8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000eb	8b 44 1a 0c	 mov	 eax, DWORD PTR [edx+ebx+12]

; 338  : 		return (rdstate() == goodbit);

  000ef	85 c0		 test	 eax, eax
  000f1	0f 94 45 d4	 sete	 BYTE PTR __Ok$[ebp+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 777  : 	const typename _Myos::sentry _Ok(_Ostr);

  000f5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000fc	85 c0		 test	 eax, eax

; 778  : 
; 779  : 	if (!_Ok)

  000fe	74 0a		 je	 SHORT $LN8@operator

; 780  : 		_State |= ios_base::badbit;

  00100	b9 04 00 00 00	 mov	 ecx, 4

; 781  : 	else

  00105	e9 e2 00 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 782  : 		{	// state okay, insert
; 783  : 		_TRY_IO_BEGIN

  0010a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 377  : 		return (_Fmtfl);

  0010e	8b 44 1a 14	 mov	 eax, DWORD PTR [edx+ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 784  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  00112	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00117	83 f8 40	 cmp	 eax, 64			; 00000040H
  0011a	74 3b		 je	 SHORT $LN104@operator
  0011c	0f 1f 40 00	 npad	 4
$LL4@operator:

; 785  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00120	85 ff		 test	 edi, edi
  00122	7c 31		 jl	 SHORT $LN3@operator
  00124	7f 04		 jg	 SHORT $LN111@operator
  00126	85 f6		 test	 esi, esi
  00128	74 2b		 je	 SHORT $LN3@operator
$LN111@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  0012a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0012c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012f	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 786  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00133	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  00137	88 45 e4	 mov	 BYTE PTR $T14[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 786  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0013a	ff 75 e4	 push	 DWORD PTR $T14[ebp]
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00143	83 f8 ff	 cmp	 eax, -1
  00146	75 05		 jne	 SHORT $LN2@operator

; 787  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 788  : 					{	// insertion failed, quit
; 789  : 					_State |= ios_base::badbit;

  00148	8d 48 05	 lea	 ecx, DWORD PTR [eax+5]

; 790  : 					break;

  0014b	eb 61		 jmp	 SHORT $LN6@operator
$LN2@operator:

; 785  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  0014d	83 c6 ff	 add	 esi, -1
  00150	83 d7 ff	 adc	 edi, -1
  00153	eb cb		 jmp	 SHORT $LL4@operator
$LN3@operator:

; 794  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  00155	8b 0b		 mov	 ecx, DWORD PTR [ebx]
$LN104@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00157	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 794  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  0015a	6a 00		 push	 0
  0015c	ff 75 e0	 push	 DWORD PTR __Count$2$[ebp]
  0015f	ff 75 dc	 push	 DWORD PTR __Val$1$[ebp]
  00162	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  0016c	3b 45 e0	 cmp	 eax, DWORD PTR __Count$2$[ebp]
  0016f	75 2c		 jne	 SHORT $LN112@operator
  00171	85 d2		 test	 edx, edx
  00173	75 28		 jne	 SHORT $LN112@operator
$LL114@operator:

; 795  : 			_State |= ios_base::badbit;
; 796  : 
; 797  : 		if (_State == ios_base::goodbit)
; 798  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00175	85 ff		 test	 edi, edi
  00177	7c 33		 jl	 SHORT $LN118@operator
  00179	7f 04		 jg	 SHORT $LN113@operator
  0017b	85 f6		 test	 esi, esi
  0017d	74 2d		 je	 SHORT $LN118@operator
$LN113@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  0017f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00181	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00184	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 799  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00188	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  0018c	88 45 dc	 mov	 BYTE PTR $T20[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 799  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0018f	ff 75 dc	 push	 DWORD PTR $T20[ebp]
  00192	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00198	83 f8 ff	 cmp	 eax, -1
  0019b	75 07		 jne	 SHORT $LN5@operator
$LN112@operator:

; 800  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 801  : 					{	// insertion failed, quit
; 802  : 					_State |= ios_base::badbit;

  0019d	b9 04 00 00 00	 mov	 ecx, 4

; 803  : 					break;

  001a2	eb 0a		 jmp	 SHORT $LN6@operator
$LN5@operator:

; 795  : 			_State |= ios_base::badbit;
; 796  : 
; 797  : 		if (_State == ios_base::goodbit)
; 798  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  001a4	83 c6 ff	 add	 esi, -1
  001a7	83 d7 ff	 adc	 edi, -1
  001aa	eb c9		 jmp	 SHORT $LL114@operator
$LN118@operator:
  001ac	33 c9		 xor	 ecx, ecx
$LN6@operator:

; 804  : 					}
; 805  : 		_Ostr.width(0);

  001ae	8b 03		 mov	 eax, DWORD PTR [ebx]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  001b3	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  001bb	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
  001c3	eb 20		 jmp	 SHORT $LN124@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 806  : 		_CATCH_IO_(_Ostr)

  001c5	8b 55 ec	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001c8	6a 01		 push	 1
  001ca	6a 04		 push	 4
  001cc	8b 02		 mov	 eax, DWORD PTR [edx]
  001ce	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d1	03 ca		 add	 ecx, edx
  001d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001d9	b8 00 00 00 00	 mov	 eax, $LN23@operator
  001de	c3		 ret	 0
$LN23@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
  001df	8b 5d ec	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  001e2	8b 4d d8	 mov	 ecx, DWORD PTR __State$[ebp]
$LN124@operator:
  001e5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 807  : 		}
; 808  : 
; 809  : 	_Ostr.setstate(_State);

  001ec	8b 03		 mov	 eax, DWORD PTR [ebx]
  001ee	6a 00		 push	 0
  001f0	51		 push	 ecx
  001f1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001f4	03 cb		 add	 ecx, ebx
  001f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 128  : 			{	// destroy the object

  001fc	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 129  :  #if _HAS_EXCEPTIONS
; 130  : 			if (_STD uncaught_exceptions() == 0)

  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 131  : 				{
; 132  : 				this->_Myostr._Osfx();

  00209	8b 75 d0	 mov	 esi, DWORD PTR __Ok$[ebp]
  0020c	85 c0		 test	 eax, eax
  0020e	75 08		 jne	 SHORT $LN87@operator
  00210	8b ce		 mov	 ecx, esi
  00212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN87@operator:

; 105  : 			{	// destroy after unlocking

  00218	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5

; 106  : 			if (_Myostr.rdbuf() != 0)

  0021c	8b 06		 mov	 eax, DWORD PTR [esi]
  0021e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00221	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00225	85 c9		 test	 ecx, ecx
  00227	74 05		 je	 SHORT $LN115@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

  00229	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022b	ff 50 08	 call	 DWORD PTR [eax+8]
$LN115@operator:

; 810  : 	return (_Ostr);

  0022e	8b c3		 mov	 eax, ebx

; 811  : 	}

  00230	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00233	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0023a	59		 pop	 ecx
  0023b	5f		 pop	 edi
  0023c	5e		 pop	 esi
  0023d	5b		 pop	 ebx
  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$4:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 981  : 	{	// insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 982  : 	_Ostr.put(_Ostr.widen('\n'));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  00007	6a 0a		 push	 10			; 0000000aH
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	03 ce		 add	 ecx, esi
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00016	0f b6 c8	 movzx	 ecx, al
  00019	51		 push	 ecx
  0001a	8b ce		 mov	 ecx, esi
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 983  : 	_Ostr.flush();

  00022	8b ce		 mov	 ecx, esi
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 984  : 	return (_Ostr);

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi

; 985  : 	}

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 137  : 	{	// extract a string

  00000	51		 push	 ecx

; 138  : 	return (_STD move(_Istr) >> _Str);

  00001	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >

; 139  : 	}

  00006	59		 pop	 ecx
  00007	c3		 ret	 0
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z
_TEXT	SEGMENT
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z PROC ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 3930 : 	{	// test for string vs. NTCTS inequality

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx
  00003	8b d1		 mov	 edx, ecx
  00005	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00006	8b fe		 mov	 edi, esi
  00008	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000b	0f 1f 44 00 00	 npad	 5
$LL32@operator:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL32@operator
  00017	2b f9		 sub	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00019	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0001d	8b ca		 mov	 ecx, edx

; 1594 : 		if (_Large_string_engaged())

  0001f	72 02		 jb	 SHORT $LN18@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN18@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00023	8b 52 10	 mov	 edx, DWORD PTR [edx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00026	3b d7		 cmp	 edx, edi
  00028	75 5b		 jne	 SHORT $LN26@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0002a	83 ea 04	 sub	 edx, 4
  0002d	72 12		 jb	 SHORT $LN35@operator
  0002f	90		 npad	 1
$LL36@operator:
  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	3b 06		 cmp	 eax, DWORD PTR [esi]
  00034	75 10		 jne	 SHORT $LN34@operator
  00036	83 c1 04	 add	 ecx, 4
  00039	83 c6 04	 add	 esi, 4
  0003c	83 ea 04	 sub	 edx, 4
  0003f	73 ef		 jae	 SHORT $LL36@operator
$LN35@operator:
  00041	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00044	74 34		 je	 SHORT $LN33@operator
$LN34@operator:
  00046	8a 01		 mov	 al, BYTE PTR [ecx]
  00048	3a 06		 cmp	 al, BYTE PTR [esi]
  0004a	75 27		 jne	 SHORT $LN37@operator
  0004c	83 fa fd	 cmp	 edx, -3			; fffffffdH
  0004f	74 29		 je	 SHORT $LN33@operator
  00051	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00054	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00057	75 1a		 jne	 SHORT $LN37@operator
  00059	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0005c	74 1c		 je	 SHORT $LN33@operator
  0005e	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00061	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00064	75 0d		 jne	 SHORT $LN37@operator
  00066	83 fa ff	 cmp	 edx, -1
  00069	74 0f		 je	 SHORT $LN33@operator
  0006b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0006e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00071	74 07		 je	 SHORT $LN33@operator
$LN37@operator:
  00073	1b c0		 sbb	 eax, eax
  00075	83 c8 01	 or	 eax, 1
  00078	eb 02		 jmp	 SHORT $LN38@operator
$LN33@operator:
  0007a	33 c0		 xor	 eax, eax
$LN38@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0007c	85 c0		 test	 eax, eax
  0007e	75 05		 jne	 SHORT $LN26@operator
  00080	5f		 pop	 edi
  00081	32 c0		 xor	 al, al

; 3931 : 	return (!(_Left == _Right));
; 3932 : 	}

  00083	5e		 pop	 esi
  00084	c3		 ret	 0
$LN26@operator:
  00085	5f		 pop	 edi

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00086	b0 01		 mov	 al, 1

; 3931 : 	return (!(_Left == _Right));
; 3932 : 	}

  00088	5e		 pop	 esi
  00089	c3		 ret	 0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z
_TEXT	SEGMENT
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 3900 : 	{	// test for string vs. NTCTS equality

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx
  00003	8b d1		 mov	 edx, ecx
  00005	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00006	8b fe		 mov	 edi, esi
  00008	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000b	0f 1f 44 00 00	 npad	 5
$LL30@operator:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL30@operator
  00017	2b f9		 sub	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00019	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0001d	8b ca		 mov	 ecx, edx

; 1594 : 		if (_Large_string_engaged())

  0001f	72 02		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN16@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00023	8b 52 10	 mov	 edx, DWORD PTR [edx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00026	3b d7		 cmp	 edx, edi
  00028	75 5b		 jne	 SHORT $LN24@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0002a	83 ea 04	 sub	 edx, 4
  0002d	72 12		 jb	 SHORT $LN33@operator
  0002f	90		 npad	 1
$LL34@operator:
  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	3b 06		 cmp	 eax, DWORD PTR [esi]
  00034	75 10		 jne	 SHORT $LN32@operator
  00036	83 c1 04	 add	 ecx, 4
  00039	83 c6 04	 add	 esi, 4
  0003c	83 ea 04	 sub	 edx, 4
  0003f	73 ef		 jae	 SHORT $LL34@operator
$LN33@operator:
  00041	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00044	74 34		 je	 SHORT $LN31@operator
$LN32@operator:
  00046	8a 01		 mov	 al, BYTE PTR [ecx]
  00048	3a 06		 cmp	 al, BYTE PTR [esi]
  0004a	75 27		 jne	 SHORT $LN35@operator
  0004c	83 fa fd	 cmp	 edx, -3			; fffffffdH
  0004f	74 29		 je	 SHORT $LN31@operator
  00051	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00054	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00057	75 1a		 jne	 SHORT $LN35@operator
  00059	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0005c	74 1c		 je	 SHORT $LN31@operator
  0005e	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00061	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00064	75 0d		 jne	 SHORT $LN35@operator
  00066	83 fa ff	 cmp	 edx, -1
  00069	74 0f		 je	 SHORT $LN31@operator
  0006b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0006e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00071	74 07		 je	 SHORT $LN31@operator
$LN35@operator:
  00073	1b c0		 sbb	 eax, eax
  00075	83 c8 01	 or	 eax, 1
  00078	eb 02		 jmp	 SHORT $LN36@operator
$LN31@operator:
  0007a	33 c0		 xor	 eax, eax
$LN36@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0007c	85 c0		 test	 eax, eax
  0007e	75 05		 jne	 SHORT $LN24@operator
  00080	5f		 pop	 edi
  00081	b0 01		 mov	 al, 1

; 3901 : 	return (_Left._Equal(_Right));
; 3902 : 	}

  00083	5e		 pop	 esi
  00084	c3		 ret	 0
$LN24@operator:
  00085	5f		 pop	 edi

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00086	32 c0		 xor	 al, al

; 3901 : 	return (_Left._Equal(_Right));
; 3902 : 	}

  00088	5e		 pop	 esi
  00089	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??$?RVrandom_device@std@@@?$uniform_int@H@std@@QBEHAAVrandom_device@1@@Z
_TEXT	SEGMENT
tv357 = -8						; size = 4
__Index$1$ = -4						; size = 4
__Eng$dead$ = 8						; size = 4
??$?RVrandom_device@std@@@?$uniform_int@H@std@@QBEHAAVrandom_device@1@@Z PROC ; std::uniform_int<int>::operator()<std::random_device>, COMDAT
; _this$ = ecx

; 2279 : 		{	// return next value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2280 : 		return (_Eval(_Eng, _Par._Min, _Par._Max));

  00007	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00009	56		 push	 esi

; 2328 : 		if (_Umax - _Umin == _Uty(-1))

  0000a	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000d	2b f3		 sub	 esi, ebx

; 2280 : 		return (_Eval(_Eng, _Par._Min, _Par._Max));

  0000f	89 5d f8	 mov	 DWORD PTR tv357[ebp], ebx

; 2328 : 		if (_Umax - _Umin == _Uty(-1))

  00012	83 fe ff	 cmp	 esi, -1
  00015	75 10		 jne	 SHORT $LN4@operator

; 6410 : 		return (_Random_device());

  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ
  0001d	5e		 pop	 esi

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  0001e	03 c3		 add	 eax, ebx

; 2281 : 		}

  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN4@operator:

; 2331 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  00027	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  0002a	57		 push	 edi
  0002b	89 5d fc	 mov	 DWORD PTR __Index$1$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  0002e	eb 03		 jmp	 SHORT $LN44@operator
$LL92@operator:
  00030	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
$LN44@operator:

; 3944 : 			_Udiff _Ret = 0;	// random bits

  00033	33 ff		 xor	 edi, edi

; 3945 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00035	33 c0		 xor	 eax, eax

; 3946 : 
; 3947 : 			while (_Mask < _Udiff(_Index - 1))

  00037	85 f6		 test	 esi, esi
  00039	74 0b		 je	 SHORT $LN48@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3987 : 			_Udiff _Val = _Ref() - (_Urng::min)();

  00041	8b f8		 mov	 edi, eax

; 3954 : 				_Mask |= _Bmask;

  00043	83 c8 ff	 or	 eax, -1
$LN48@operator:

; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00046	33 d2		 xor	 edx, edx
  00048	f7 f3		 div	 ebx
  0004a	8b c8		 mov	 ecx, eax
  0004c	8b da		 mov	 ebx, edx
  0004e	33 d2		 xor	 edx, edx
  00050	8b c7		 mov	 eax, edi
  00052	f7 75 fc	 div	 DWORD PTR __Index$1$[ebp]
  00055	3b c1		 cmp	 eax, ecx
  00057	72 04		 jb	 SHORT $LN78@operator
  00059	3b de		 cmp	 ebx, esi
  0005b	75 d3		 jne	 SHORT $LL92@operator
$LN78@operator:

; 3960 : 				return (_Ret % _Index);

  0005d	8b c7		 mov	 eax, edi
  0005f	33 d2		 xor	 edx, edx
  00061	f7 75 fc	 div	 DWORD PTR __Index$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  00064	8b 45 f8	 mov	 eax, DWORD PTR tv357[ebp]

; 2280 : 		return (_Eval(_Eng, _Par._Min, _Par._Max));

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  00069	03 c2		 add	 eax, edx

; 2281 : 		}

  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
??$?RVrandom_device@std@@@?$uniform_int@H@std@@QBEHAAVrandom_device@1@@Z ENDP ; std::uniform_int<int>::operator()<std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -8					; size = 4
tv684 = -4						; size = 4
__Count$1$ = 8						; size = 4
$T24 = 8						; size = 1
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 3824 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b fa		 mov	 edi, edx
  0000b	8b d9		 mov	 ebx, ecx

; 3825 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 3826 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  0000d	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00010	89 5d f8	 mov	 DWORD PTR ___$ReturnUdt$[ebp], ebx
  00013	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00016	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00019	2b c6		 sub	 eax, esi
  0001b	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0001e	89 45 fc	 mov	 DWORD PTR tv684[ebp], eax
  00021	89 4d 08	 mov	 DWORD PTR __Count$1$[ebp], ecx
  00024	3b c8		 cmp	 ecx, eax
  00026	76 4d		 jbe	 SHORT $LN222@operator
  00028	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0002b	2b c1		 sub	 eax, ecx
  0002d	3b c6		 cmp	 eax, esi
  0002f	72 41		 jb	 SHORT $LN223@operator

; 3828 : 	else
; 3829 : 		return (_STD move(_Right.insert(0, _Left)));

  00031	57		 push	 edi
  00032	51		 push	 ecx
  00033	8b ca		 mov	 ecx, edx
  00035	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1563 : 		_Mysize(0),

  0003a	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 1564 : 		_Myres(0)

  00041	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0
  00048	5f		 pop	 edi

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00049	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]

; 3830 : 	}

  0004c	5e		 pop	 esi

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0004d	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  00050	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00055	66 0f d6 43 10	 movq	 QWORD PTR [ebx+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  0005a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00061	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00068	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3827 : 		return (_STD move(_Left.append(_Right)));

  0006b	8b c3		 mov	 eax, ebx

; 3830 : 	}

  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN223@operator:

; 3825 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 3826 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  00072	8b 45 fc	 mov	 eax, DWORD PTR tv684[ebp]
$LN222@operator:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00075	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00079	72 02		 jb	 SHORT $LN71@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0007b	8b 12		 mov	 edx, DWORD PTR [edx]
$LN71@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  0007d	3b c8		 cmp	 ecx, eax
  0007f	77 27		 ja	 SHORT $LN78@operator

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00081	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00084	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00087	8b c7		 mov	 eax, edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00089	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 1583 : 		if (_Large_string_engaged())

  0008d	72 02		 jb	 SHORT $LN87@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0008f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN87@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00091	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00092	03 f0		 add	 esi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00094	52		 push	 edx
  00095	56		 push	 esi
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 442  : 		_Left = _Right;

  0009c	8b 45 08	 mov	 eax, DWORD PTR __Count$1$[ebp]

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  000a2	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  000a6	eb 13		 jmp	 SHORT $LN77@operator
$LN78@operator:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  000a8	51		 push	 ecx
  000a9	52		 push	 edx
  000aa	c6 45 08 00	 mov	 BYTE PTR $T24[ebp], 0
  000ae	ff 75 08	 push	 DWORD PTR $T24[ebp]
  000b1	51		 push	 ecx
  000b2	8b cf		 mov	 ecx, edi
  000b4	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  000b9	8b f8		 mov	 edi, eax
$LN77@operator:

; 1563 : 		_Mysize(0),

  000bb	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 3827 : 		return (_STD move(_Left.append(_Right)));

  000c2	8b c3		 mov	 eax, ebx

; 1564 : 		_Myres(0)

  000c4	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000cb	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  000ce	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  000d1	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  000d6	66 0f d6 43 10	 movq	 QWORD PTR [ebx+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  000db	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000e2	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000e9	c6 07 00	 mov	 BYTE PTR [edi], 0
  000ec	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3830 : 	}

  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -4					; size = 4
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$dead$ = edx

; 3804 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3805 : 	return (_STD move(_Right.insert(0, _Left)));

  00005	68 00 00 00 00	 push	 OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0000a	8b f1		 mov	 esi, ecx
  0000c	51		 push	 ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00010	89 75 fc	 mov	 DWORD PTR ___$ReturnUdt$[ebp], esi
  00013	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1563 : 		_Mysize(0),

  00018	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1564 : 		_Myres(0)

  0001f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00026	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00029	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0002c	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00031	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  00036	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003d	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00044	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3805 : 	return (_STD move(_Right.insert(0, _Left)));

  00047	8b c6		 mov	 eax, esi
  00049	5e		 pop	 esi

; 3806 : 	}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -28					; size = 4
tv589 = -24						; size = 4
__Count$1$ = -20					; size = 4
$T14 = -20						; size = 1
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T19 = 8						; size = 1
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 3730 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b da		 mov	 ebx, edx
  0002a	8b f9		 mov	 edi, ecx
  0002c	89 7d e4	 mov	 DWORD PTR ___$ReturnUdt$[ebp], edi
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 3683 : 		_My_data._Mysize = 0;

  00036	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003d	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00044	c6 07 00	 mov	 BYTE PTR [edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3735 : 	return (_Ans);

  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 3047 : 		return (this->_Get_data()._Mysize);

  0004e	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  00051	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00054	83 c0 10	 add	 eax, 16			; 00000010H

; 3735 : 	return (_Ans);

  00057	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1

; 3047 : 		return (this->_Get_data()._Mysize);

  0005e	89 45 e8	 mov	 DWORD PTR tv589[ebp], eax

; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());

  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	03 06		 add	 eax, DWORD PTR [esi]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0006b	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  0006f	72 02		 jb	 SHORT $LN57@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00071	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN57@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00073	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00075	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  00078	8b c6		 mov	 eax, esi
  0007a	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  0007d	2b c2		 sub	 eax, edx

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0007f	89 4d ec	 mov	 DWORD PTR __Count$1$[ebp], ecx

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00082	3b c8		 cmp	 ecx, eax
  00084	77 27		 ja	 SHORT $LN64@operator

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00086	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00089	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0008c	8b c7		 mov	 eax, edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0008e	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00091	72 02		 jb	 SHORT $LN124@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00093	8b 07		 mov	 eax, DWORD PTR [edi]
$LN124@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00095	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00096	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00099	53		 push	 ebx
  0009a	56		 push	 esi
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 442  : 		_Left = _Right;

  000a1	8b 45 ec	 mov	 eax, DWORD PTR __Count$1$[ebp]

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  000a7	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  000ab	eb 11		 jmp	 SHORT $LN63@operator
$LN64@operator:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  000ad	51		 push	 ecx
  000ae	53		 push	 ebx
  000af	c6 45 ec 00	 mov	 BYTE PTR $T14[ebp], 0
  000b3	ff 75 ec	 push	 DWORD PTR $T14[ebp]
  000b6	51		 push	 ecx
  000b7	8b cf		 mov	 ecx, edi
  000b9	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN63@operator:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000be	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000c1	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  000c5	72 02		 jb	 SHORT $LN96@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000c7	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN96@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  000c9	8b 5d e8	 mov	 ebx, DWORD PTR tv589[ebp]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  000cc	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  000cf	8b c6		 mov	 eax, esi
  000d1	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  000d4	2b c2		 sub	 eax, edx

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  000d6	8b 1b		 mov	 ebx, DWORD PTR [ebx]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  000d8	3b d8		 cmp	 ebx, eax
  000da	77 36		 ja	 SHORT $LN103@operator

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  000dc	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000df	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  000e2	8b c7		 mov	 eax, edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000e4	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  000e7	72 02		 jb	 SHORT $LN112@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000e9	8b 07		 mov	 eax, DWORD PTR [edi]
$LN112@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000eb	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  000ec	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000ef	51		 push	 ecx
  000f0	56		 push	 esi
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  000fa	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3735 : 	return (_Ans);

  000fe	8b c7		 mov	 eax, edi

; 3736 : 	}

  00100	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00103	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010a	59		 pop	 ecx
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
$LN103@operator:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  00112	53		 push	 ebx
  00113	51		 push	 ecx
  00114	c6 45 08 00	 mov	 BYTE PTR $T19[ebp], 0
  00118	8b cf		 mov	 ecx, edi
  0011a	ff 75 08	 push	 DWORD PTR $T19[ebp]
  0011d	53		 push	 ebx
  0011e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>

; 3735 : 	return (_Ans);

  00123	8b c7		 mov	 eax, edi

; 3736 : 	}

  00125	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00128	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012f	59		 pop	 ecx
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d e4	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z
_TEXT	SEGMENT
$T6 = -4						; size = 1
___$ReturnUdt$ = -4					; size = 4
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 3859 : 	{	// return string + NTCTS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b da		 mov	 ebx, edx
  00008	8b f1		 mov	 esi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0000a	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3859 : 	{	// return string + NTCTS

  0000d	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0000e	8b fa		 mov	 edi, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3859 : 	{	// return string + NTCTS

  00010	89 75 fc	 mov	 DWORD PTR ___$ReturnUdt$[ebp], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00013	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL95@operator:
  00016	8a 07		 mov	 al, BYTE PTR [edi]
  00018	47		 inc	 edi
  00019	84 c0		 test	 al, al
  0001b	75 f9		 jne	 SHORT $LL95@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  0001d	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00020	2b f9		 sub	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2335 : 		const size_type _Old_size = _My_data._Mysize;

  00022	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00025	2b c1		 sub	 eax, ecx
  00027	3b f8		 cmp	 edi, eax
  00029	77 28		 ja	 SHORT $LN13@operator

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0002b	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  0002f	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00032	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00035	8b c3		 mov	 eax, ebx

; 1583 : 		if (_Large_string_engaged())

  00037	72 02		 jb	 SHORT $LN22@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00039	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN22@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0003b	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0003c	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0003f	52		 push	 edx
  00040	56		 push	 esi
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 442  : 		_Left = _Right;

  00047	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  0004e	8b 75 fc	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00051	eb 13		 jmp	 SHORT $LN12@operator
$LN13@operator:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  00053	57		 push	 edi
  00054	52		 push	 edx
  00055	c6 45 fc 00	 mov	 BYTE PTR $T6[ebp], 0
  00059	8b cb		 mov	 ecx, ebx
  0005b	ff 75 fc	 push	 DWORD PTR $T6[ebp]
  0005e	57		 push	 edi
  0005f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  00064	8b d8		 mov	 ebx, eax
$LN12@operator:

; 1563 : 		_Mysize(0),

  00066	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3860 : 	return (_STD move(_Left.append(_Right)));

  0006d	8b c6		 mov	 eax, esi

; 1564 : 		_Myres(0)

  0006f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00076	0f 10 03	 movups	 xmm0, XMMWORD PTR [ebx]

; 3860 : 	return (_STD move(_Left.append(_Right)));

  00079	5f		 pop	 edi

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0007a	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0007d	f3 0f 7e 43 10	 movq	 xmm0, QWORD PTR [ebx+16]
  00082	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  00087	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0008e	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH

; 3860 : 	return (_STD move(_Left.append(_Right)));

  00095	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00096	c6 03 00	 mov	 BYTE PTR [ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3860 : 	return (_STD move(_Left.append(_Right)));

  00099	5b		 pop	 ebx

; 3861 : 	}

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -24					; size = 4
$T17 = -20						; size = 1
$T12 = -20						; size = 1
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$dead$ = edx

; 3774 : 	{	// return string + NTCTS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d e8	 mov	 DWORD PTR ___$ReturnUdt$[ebp], ebx
  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 3683 : 		_My_data._Mysize = 0;

  00034	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003b	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00042	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 405  : 		return (_CSTD strlen(_First));

  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00056	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL113@operator:
  00060	8a 01		 mov	 al, BYTE PTR [ecx]
  00062	41		 inc	 ecx
  00063	84 c0		 test	 al, al
  00065	75 f9		 jne	 SHORT $LL113@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00067	a1 10 00 00 00	 mov	 eax, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0006c	2b ca		 sub	 ecx, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  0006e	03 c1		 add	 eax, ecx
  00070	8b cb		 mov	 ecx, ebx
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00078	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00084	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]
  00087	8b c6		 mov	 eax, esi

; 1594 : 		if (_Large_string_engaged())

  00089	0f 43 0d 00 00
	00 00		 cmovae	 ecx, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2335 : 		const size_type _Old_size = _My_data._Mysize;

  00090	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00093	2b c2		 sub	 eax, edx

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00095	8b 3d 10 00 00
	00		 mov	 edi, DWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  0009b	3b f8		 cmp	 edi, eax
  0009d	77 24		 ja	 SHORT $LN60@operator

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  0009f	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  000a2	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  000a5	8b c3		 mov	 eax, ebx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000a7	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  000aa	72 02		 jb	 SHORT $LN112@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000ac	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN112@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000ae	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  000af	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000b2	51		 push	 ecx
  000b3	56		 push	 esi
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  000bd	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  000c1	eb 11		 jmp	 SHORT $LN59@operator
$LN60@operator:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  000c3	57		 push	 edi
  000c4	51		 push	 ecx
  000c5	c6 45 ec 00	 mov	 BYTE PTR $T12[ebp], 0
  000c9	8b cb		 mov	 ecx, ebx
  000cb	ff 75 ec	 push	 DWORD PTR $T12[ebp]
  000ce	57		 push	 edi
  000cf	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN59@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  000d4	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000d7	8b f1		 mov	 esi, ecx
  000d9	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  000dc	0f 1f 40 00	 npad	 4
$LL114@operator:
  000e0	8a 06		 mov	 al, BYTE PTR [esi]
  000e2	46		 inc	 esi
  000e3	84 c0		 test	 al, al
  000e5	75 f9		 jne	 SHORT $LL114@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  000e7	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  000ea	2b f2		 sub	 esi, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2335 : 		const size_type _Old_size = _My_data._Mysize;

  000ec	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  000ef	8b c7		 mov	 eax, edi
  000f1	2b c2		 sub	 eax, edx
  000f3	3b f0		 cmp	 esi, eax
  000f5	77 36		 ja	 SHORT $LN91@operator

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  000f7	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  000fa	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  000fd	8b c3		 mov	 eax, ebx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000ff	83 ff 10	 cmp	 edi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00102	72 02		 jb	 SHORT $LN100@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00104	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN100@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00106	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00107	8d 3c 10	 lea	 edi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0010a	51		 push	 ecx
  0010b	57		 push	 edi
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  00115	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  00119	8b c3		 mov	 eax, ebx

; 3782 : 	}

  0011b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00125	59		 pop	 ecx
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
$LN91@operator:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  0012d	56		 push	 esi
  0012e	51		 push	 ecx
  0012f	c6 45 ec 00	 mov	 BYTE PTR $T17[ebp], 0
  00133	8b cb		 mov	 ecx, ebx
  00135	ff 75 ec	 push	 DWORD PTR $T17[ebp]
  00138	56		 push	 esi
  00139	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>

; 3781 : 	return (_Ans);

  0013e	8b c3		 mov	 eax, ebx

; 3782 : 	}

  00140	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00143	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014a	59		 pop	 ecx
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi
  0014d	5b		 pop	 ebx
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d e8	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z
_TEXT	SEGMENT
$T4 = -4						; size = 1
___$ReturnUdt$ = -4					; size = 4
__Right$ = 8						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 3869 : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f2		 mov	 esi, edx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	89 7d fc	 mov	 DWORD PTR ___$ReturnUdt$[ebp], edi

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  0000d	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 2977 : 		if (_Old_size < _My_data._Myres)

  00010	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  00013	73 1d		 jae	 SHORT $LN6@operator

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00015	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2979 : 			_My_data._Mysize = _Old_size + 1;

  00019	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0001c	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0001f	8b ce		 mov	 ecx, esi

; 1583 : 		if (_Large_string_engaged())

  00021	72 02		 jb	 SHORT $LN15@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00023	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN15@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00025	8a 45 08	 mov	 al, BYTE PTR __Right$[ebp]
  00028	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0002b	c6 44 11 01 00	 mov	 BYTE PTR [ecx+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  00030	eb 12		 jmp	 SHORT $LN5@operator
$LN6@operator:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  00032	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00035	c6 45 fc 00	 mov	 BYTE PTR $T4[ebp], 0
  00039	ff 75 fc	 push	 DWORD PTR $T4[ebp]
  0003c	51		 push	 ecx
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN5@operator:

; 1563 : 		_Mysize(0),

  00044	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3871 : 	return (_STD move(_Left));

  0004b	8b c7		 mov	 eax, edi

; 1564 : 		_Myres(0)

  0004d	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00054	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00057	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0005a	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  0005f	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0

; 3683 : 		_My_data._Mysize = 0;

  00064	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0006b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3871 : 	return (_STD move(_Left));

  00072	5f		 pop	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00073	c6 06 00	 mov	 BYTE PTR [esi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3871 : 	return (_STD move(_Left));

  00076	5e		 pop	 esi

; 3872 : 	}

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 158  : 	{	// get characters into string, discard newline

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8b f2		 mov	 esi, edx

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00006	6a 0a		 push	 10			; 0000000aH
  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	03 cf		 add	 ecx, edi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00015	0f b6 c0	 movzx	 eax, al
  00018	8b d6		 mov	 edx, esi
  0001a	50		 push	 eax
  0001b	8b cf		 mov	 ecx, edi
  0001d	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00022	83 c4 04	 add	 esp, 4
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 160  : 	}

  00027	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -24					; size = 4
$T12 = -20						; size = 1
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T17 = 8						; size = 1
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$dead$ = edx

; 3744 : 	{	// return NTCTS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d e8	 mov	 DWORD PTR ___$ReturnUdt$[ebp], edi
  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 3683 : 		_My_data._Mysize = 0;

  00034	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0003b	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00042	c6 07 00	 mov	 BYTE PTR [edi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3751 : 	return (_Ans);

  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 3047 : 		return (this->_Get_data()._Mysize);

  0004c	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]

; 3751 : 	return (_Ans);

  0004f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00056	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00059	83 c0 05	 add	 eax, 5
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00062	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00065	8b c2		 mov	 eax, edx
  00067	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0006a	2b c1		 sub	 eax, ecx
  0006c	83 f8 05	 cmp	 eax, 5
  0006f	72 29		 jb	 SHORT $LN52@operator

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00071	8d 41 05	 lea	 eax, DWORD PTR [ecx+5]
  00074	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00077	8b c7		 mov	 eax, edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00079	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  0007c	72 02		 jb	 SHORT $LN112@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0007e	8b 07		 mov	 eax, DWORD PTR [edi]
$LN112@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00080	6a 05		 push	 5
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00082	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00085	68 00 00 00 00	 push	 OFFSET ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  0008a	56		 push	 esi
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  00094	c6 46 05 00	 mov	 BYTE PTR [esi+5], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  00098	eb 17		 jmp	 SHORT $LN51@operator
$LN52@operator:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  0009a	6a 05		 push	 5
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  000a1	c6 45 ec 00	 mov	 BYTE PTR $T12[ebp], 0
  000a5	8b cf		 mov	 ecx, edi
  000a7	ff 75 ec	 push	 DWORD PTR $T12[ebp]
  000aa	6a 05		 push	 5
  000ac	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN51@operator:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000b1	8b cb		 mov	 ecx, ebx
  000b3	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  000b7	72 02		 jb	 SHORT $LN84@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000b9	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN84@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  000bb	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  000be	8b c6		 mov	 eax, esi
  000c0	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  000c3	2b c2		 sub	 eax, edx

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  000c5	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  000c8	3b d8		 cmp	 ebx, eax
  000ca	77 36		 ja	 SHORT $LN91@operator

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  000cc	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000cf	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  000d2	8b c7		 mov	 eax, edi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000d4	83 fe 10	 cmp	 esi, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  000d7	72 02		 jb	 SHORT $LN100@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000d9	8b 07		 mov	 eax, DWORD PTR [edi]
$LN100@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000db	53		 push	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  000dc	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000df	51		 push	 ecx
  000e0	56		 push	 esi
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  000ea	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3751 : 	return (_Ans);

  000ee	8b c7		 mov	 eax, edi

; 3752 : 	}

  000f0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fa	59		 pop	 ecx
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
$LN91@operator:

; 2345 : 		return (_Reallocate_grow_by(_Count,

  00102	53		 push	 ebx
  00103	51		 push	 ecx
  00104	c6 45 08 00	 mov	 BYTE PTR $T17[ebp], 0
  00108	8b cf		 mov	 ecx, edi
  0010a	ff 75 08	 push	 DWORD PTR $T17[ebp]
  0010d	53		 push	 ebx
  0010e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>

; 3751 : 	return (_Ans);

  00113	8b c7		 mov	 eax, edi

; 3752 : 	}

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d e8	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Ostr$ = ecx
; __Str$ = edx

; 168  : 	{	// insert a string

  00000	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00001	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 3047 : 		return (this->_Get_data()._Mysize);

  00005	8b 42 10	 mov	 eax, DWORD PTR [edx+16]

; 1594 : 		if (_Large_string_engaged())

  00008	72 02		 jb	 SHORT $LN22@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000a	8b 12		 mov	 edx, DWORD PTR [edx]
$LN22@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  00012	83 c4 04	 add	 esp, 4

; 170  : 	}

  00015	59		 pop	 ecx
  00016	c3		 ret	 0
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0CA@@std@@YAIAAY0CA@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0CA@@std@@YAIAAY0CA@$$CBD@Z PROC		; std::size<char,32>, COMDAT
; ___formal$dead$ = ecx

; 1611 : 	return (_Size);

  00000	b8 20 00 00 00	 mov	 eax, 32			; 00000020H

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0CA@@std@@YAIAAY0CA@$$CBD@Z ENDP		; std::size<char,32>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0CG@@std@@YAIAAY0CG@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0CG@@std@@YAIAAY0CG@$$CBD@Z PROC		; std::size<char,38>, COMDAT
; ___formal$dead$ = ecx

; 1611 : 	return (_Size);

  00000	b8 26 00 00 00	 mov	 eax, 38			; 00000026H

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0CG@@std@@YAIAAY0CG@$$CBD@Z ENDP		; std::size<char,38>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BM@@std@@YAIAAY0BM@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BM@@std@@YAIAAY0BM@$$CBD@Z PROC		; std::size<char,28>, COMDAT
; ___formal$dead$ = ecx

; 1611 : 	return (_Size);

  00000	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BM@@std@@YAIAAY0BM@$$CBD@Z ENDP		; std::size<char,28>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BL@@std@@YAIAAY0BL@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BL@@std@@YAIAAY0BL@$$CBD@Z PROC		; std::size<char,27>, COMDAT
; ___formal$dead$ = ecx

; 1611 : 	return (_Size);

  00000	b8 1b 00 00 00	 mov	 eax, 27			; 0000001bH

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BL@@std@@YAIAAY0BL@$$CBD@Z ENDP		; std::size<char,27>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BH@@std@@YAIAAY0BH@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BH@@std@@YAIAAY0BH@$$CBD@Z PROC		; std::size<char,23>, COMDAT
; ___formal$dead$ = ecx

; 1611 : 	return (_Size);

  00000	b8 17 00 00 00	 mov	 eax, 23			; 00000017H

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BH@@std@@YAIAAY0BH@$$CBD@Z ENDP		; std::size<char,23>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BB@@std@@YAIAAY0BB@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BB@@std@@YAIAAY0BB@$$CBD@Z PROC		; std::size<char,17>, COMDAT
; ___formal$dead$ = ecx

; 1611 : 	return (_Size);

  00000	b8 11 00 00 00	 mov	 eax, 17			; 00000011H

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BB@@std@@YAIAAY0BB@$$CBD@Z ENDP		; std::size<char,17>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0O@@std@@YAIAAY0O@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0O@@std@@YAIAAY0O@$$CBD@Z PROC		; std::size<char,14>, COMDAT
; ___formal$dead$ = ecx

; 1611 : 	return (_Size);

  00000	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0O@@std@@YAIAAY0O@$$CBD@Z ENDP		; std::size<char,14>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BE@@std@@YAIAAY0BE@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BE@@std@@YAIAAY0BE@$$CBD@Z PROC		; std::size<char,20>, COMDAT
; ___formal$dead$ = ecx

; 1611 : 	return (_Size);

  00000	b8 14 00 00 00	 mov	 eax, 20			; 00000014H

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BE@@std@@YAIAAY0BE@$$CBD@Z ENDP		; std::size<char,20>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BN@@std@@YAIAAY0BN@$$CBD@Z
_TEXT	SEGMENT
??$size@D$0BN@@std@@YAIAAY0BN@$$CBD@Z PROC		; std::size<char,29>, COMDAT
; ___formal$dead$ = ecx

; 1611 : 	return (_Size);

  00000	b8 1d 00 00 00	 mov	 eax, 29			; 0000001dH

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BN@@std@@YAIAAY0BN@$$CBD@Z ENDP		; std::size<char,29>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z
_TEXT	SEGMENT
__Haystack$1$ = -4					; size = 4
__Start_at$dead$ = 8					; size = 4
__Needle$ = 12						; size = 4
__Possible_matches_end$1$ = 16				; size = 4
__Needle_size$ = 16					; size = 4
??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT
; __Haystack$ = ecx
; __Hay_size$ = edx

; 56   : 	{	// search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00005	8b 5d 10	 mov	 ebx, DWORD PTR __Needle_size$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR __Haystack$1$[ebp], ecx
  0000b	3b da		 cmp	 ebx, edx
  0000d	0f 87 c1 00 00
	00		 ja	 $LN6@Traits_fin

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)

  00013	85 db		 test	 ebx, ebx
  00015	75 07		 jne	 SHORT $LN7@Traits_fin

; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);

  00017	33 c0		 xor	 eax, eax
  00019	5b		 pop	 ebx

; 86   : 			}
; 87   : 		}
; 88   : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN7@Traits_fin:

; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0001e	8b c1		 mov	 eax, ecx
  00020	42		 inc	 edx
  00021	2b c3		 sub	 eax, ebx
  00023	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00024	8b 75 0c	 mov	 esi, DWORD PTR __Needle$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00027	03 c2		 add	 eax, edx
  00029	89 45 10	 mov	 DWORD PTR __Possible_matches_end$1$[ebp], eax

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0002c	2b c1		 sub	 eax, ecx
  0002e	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  0002f	50		 push	 eax
  00030	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00033	50		 push	 eax
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  0003b	8b f8		 mov	 edi, eax
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00040	85 ff		 test	 edi, edi
  00042	74 7a		 je	 SHORT $LN18@Traits_fin
$LL4@Traits_fin:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00044	8b cb		 mov	 ecx, ebx
  00046	8b d7		 mov	 edx, edi
  00048	83 e9 04	 sub	 ecx, 4
  0004b	72 14		 jb	 SHORT $LN25@Traits_fin
  0004d	0f 1f 00	 npad	 3
$LL26@Traits_fin:
  00050	8b 02		 mov	 eax, DWORD PTR [edx]
  00052	3b 06		 cmp	 eax, DWORD PTR [esi]
  00054	75 10		 jne	 SHORT $LN24@Traits_fin
  00056	83 c2 04	 add	 edx, 4
  00059	83 c6 04	 add	 esi, 4
  0005c	83 e9 04	 sub	 ecx, 4
  0005f	73 ef		 jae	 SHORT $LL26@Traits_fin
$LN25@Traits_fin:
  00061	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00064	74 34		 je	 SHORT $LN23@Traits_fin
$LN24@Traits_fin:
  00066	8a 02		 mov	 al, BYTE PTR [edx]
  00068	3a 06		 cmp	 al, BYTE PTR [esi]
  0006a	75 27		 jne	 SHORT $LN27@Traits_fin
  0006c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0006f	74 29		 je	 SHORT $LN23@Traits_fin
  00071	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00074	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00077	75 1a		 jne	 SHORT $LN27@Traits_fin
  00079	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0007c	74 1c		 je	 SHORT $LN23@Traits_fin
  0007e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00081	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00084	75 0d		 jne	 SHORT $LN27@Traits_fin
  00086	83 f9 ff	 cmp	 ecx, -1
  00089	74 0f		 je	 SHORT $LN23@Traits_fin
  0008b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0008e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00091	74 07		 je	 SHORT $LN23@Traits_fin
$LN27@Traits_fin:
  00093	1b c0		 sbb	 eax, eax
  00095	83 c8 01	 or	 eax, 1
  00098	eb 02		 jmp	 SHORT $LN28@Traits_fin
$LN23@Traits_fin:
  0009a	33 c0		 xor	 eax, eax
$LN28@Traits_fin:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  0009c	85 c0		 test	 eax, eax
  0009e	74 28		 je	 SHORT $LN19@Traits_fin

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  000a0	8b 45 10	 mov	 eax, DWORD PTR __Possible_matches_end$1$[ebp]
  000a3	47		 inc	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  000a4	8b 75 0c	 mov	 esi, DWORD PTR __Needle$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  000a7	2b c7		 sub	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  000a9	50		 push	 eax
  000aa	0f be 06	 movsx	 eax, BYTE PTR [esi]
  000ad	50		 push	 eax
  000ae	57		 push	 edi
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  000b5	8b f8		 mov	 edi, eax
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  000ba	85 ff		 test	 edi, edi
  000bc	75 86		 jne	 SHORT $LL4@Traits_fin
$LN18@Traits_fin:
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  000c0	83 c8 ff	 or	 eax, -1
  000c3	5b		 pop	 ebx

; 86   : 			}
; 87   : 		}
; 88   : 	}

  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN19@Traits_fin:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  000c8	2b 7d fc	 sub	 edi, DWORD PTR __Haystack$1$[ebp]
  000cb	8b c7		 mov	 eax, edi
  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx

; 86   : 			}
; 87   : 		}
; 88   : 	}

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN6@Traits_fin:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

  000d4	83 c8 ff	 or	 eax, -1
  000d7	5b		 pop	 ebx

; 86   : 			}
; 87   : 		}
; 88   : 	}

  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00004	0f 42 ca	 cmovb	 ecx, edx
  00007	8b c1		 mov	 eax, ecx

; 24   : 	}

  00009	c3		 ret	 0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT
; __Ptr$ = ecx

; 265  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 266  : 	}

  00002	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT
; __Val$ = ecx

; 249  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 250  : 	}

  00002	c3		 ret	 0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Val$ = ecx

; 249  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 250  : 	}

  00002	c3		 ret	 0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; __Arg$ = ecx

; 1553 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1554 : 	}

  00002	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT
; __Arg$ = ecx

; 1553 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1554 : 	}

  00002	c3		 ret	 0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>, COMDAT
; _this$ = ecx

; 1563 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1698 : 		}

  00007	8b c1		 mov	 eax, ecx

; 1564 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1698 : 		}

  00010	c2 04 00	 ret	 4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 12
__Psave$4 = -24						; size = 4
__Lock$5 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT
; __Loc$ = ecx

; 504  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx

; 505  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  0002d	6a 00		 push	 0
  0002f	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 506  : 		const locale::facet *_Psave =
; 507  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave

; 508  : 
; 509  : 		size_t _Id = _Facet::id;

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
  0004a	89 45 e8	 mov	 DWORD PTR __Psave$4[ebp], eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00053	8b f8		 mov	 edi, eax

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00055	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00058	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0005b	73 0c		 jae	 SHORT $LN15@use_facet
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 34 b9	 mov	 esi, DWORD PTR [ecx+edi*4]

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00063	85 f6		 test	 esi, esi
  00065	75 52		 jne	 SHORT $LN7@use_facet
  00067	eb 02		 jmp	 SHORT $LN19@use_facet
$LN15@use_facet:

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00069	33 f6		 xor	 esi, esi
$LN19@use_facet:

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0006b	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  0006f	74 11		 je	 SHORT $LN12@use_facet

; 433  : 			return (_Facptr);	// found facet or not transparent
; 434  : 		else
; 435  : 			{	// look in current locale
; 436  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 437  : 			return (_Id < _Ptr0->_Facetcount

  00077	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0007a	73 0a		 jae	 SHORT $LN20@use_facet
  0007c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007f	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN12@use_facet:

; 510  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 511  : 
; 512  : 		if (_Pf != 0)

  00082	85 f6		 test	 esi, esi
  00084	75 33		 jne	 SHORT $LN7@use_facet
$LN20@use_facet:

; 513  : 			;	// got facet from locale
; 514  : 		else if (_Psave != 0)

  00086	8b 75 e8	 mov	 esi, DWORD PTR __Psave$4[ebp]
  00089	85 f6		 test	 esi, esi
  0008b	75 2c		 jne	 SHORT $LN7@use_facet

; 515  : 			_Pf = _Psave;	// lazy facet already allocated
; 516  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  0008d	8d 45 e8	 lea	 eax, DWORD PTR __Psave$4[ebp]
  00090	53		 push	 ebx
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00098	83 c4 08	 add	 esp, 8
  0009b	83 f8 ff	 cmp	 eax, -1
  0009e	74 40		 je	 SHORT $LN24@use_facet

; 521  : 
; 522  :  #else /* _HAS_EXCEPTIONS */
; 523  : 			abort();	// lazy disallowed
; 524  :  #endif /* _HAS_EXCEPTIONS */
; 525  : 
; 526  : 		else
; 527  : 			{	// queue up lazy facet for destruction
; 528  : 			_Pf = _Psave;

  000a0	8b 75 e8	 mov	 esi, DWORD PTR __Psave$4[ebp]

; 529  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 530  : 
; 531  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 532  : 			_Pfmod->_Incref();

  000a3	8b ce		 mov	 ecx, esi
  000a5	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
  000ab	8b 16		 mov	 edx, DWORD PTR [esi]
  000ad	ff 52 04	 call	 DWORD PTR [edx+4]

; 533  : 
; 534  :  #if defined(_M_CEE)
; 535  : 			_Facet_Register_m(_Pfmod);
; 536  : 
; 537  :  #else /* defined(_M_CEE) */
; 538  : 			_Facet_Register(_Pfmod);

  000b0	56		 push	 esi
  000b1	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000b6	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 539  :  #endif /* defined(_M_CEE) */
; 540  : 			}
; 541  : 
; 542  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000b9	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000c2	8b c6		 mov	 eax, esi

; 543  : 	_END_LOCK()
; 544  : 	}	// end of use_facet body

  000c4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ce	59		 pop	 ecx
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d5	33 cd		 xor	 ecx, ebp
  000d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN24@use_facet:

; 517  : 
; 518  :  #if _HAS_EXCEPTIONS
; 519  : 
; 520  : 			_THROW(bad_cast{});	// lazy disallowed

  000e0	8d 4d dc	 lea	 ecx, DWORD PTR $T1[ebp]
  000e3	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  000e8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000ed	8b c1		 mov	 eax, ecx
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN26@use_facet:
$LN22@use_facet:
  000f5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT
; __Val$ = ecx

; 249  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 250  : 	}

  00002	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1150 : 	typename allocator_traits<_Alloc>::propagate_on_container_move_assignment _Tag;
; 1151 : 	_Pocma(_Left, _Right, _Tag);
; 1152 : 	}

  00000	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1131 : 	typename allocator_traits<_Alloc>::propagate_on_container_copy_assignment _Tag;
; 1132 : 	_Pocca(_Left, _Right, _Tag);
; 1133 : 	}

  00000	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1563 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 313  : 		}

  00007	8b c1		 mov	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1564 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 313  : 		}

  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT
; __Val$ = ecx

; 249  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 250  : 	}

  00002	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z
_TEXT	SEGMENT
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$dead$ = edx

; 951  : 		_Ptr->~_Uty();
; 952  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$dead$ = 8				; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 3626 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 3627 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3628 : 		auto& _My_data = this->_Get_data();
; 3629 : 		const size_type _Old_size = _My_data._Mysize;
; 3630 : 		if (max_size() - _Old_size < _Size_increase)

  0000b	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00010	8b c1		 mov	 eax, ecx
  00012	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00015	2b c2		 sub	 eax, edx
  00017	89 55 fc	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  0001a	83 f8 01	 cmp	 eax, 1
  0001d	0f 82 0f 01 00
	00		 jb	 $LN147@Reallocate

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  00023	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  00026	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00029	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  0002c	89 75 f8	 mov	 DWORD PTR __Old$1$[ebp], esi

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0002f	3b d9		 cmp	 ebx, ecx

; 3577 : 		if (_Masked > _Max)

  00031	76 04		 jbe	 SHORT $LN34@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);

  00033	8b d9		 mov	 ebx, ecx
  00035	eb 18		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  00037	8b c6		 mov	 eax, esi
  00039	d1 e8		 shr	 eax, 1
  0003b	2b c8		 sub	 ecx, eax
  0003d	3b f1		 cmp	 esi, ecx
  0003f	76 07		 jbe	 SHORT $LN35@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);

  00041	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00046	eb 07		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00048	03 c6		 add	 eax, esi
  0004a	3b d8		 cmp	 ebx, eax
  0004c	0f 42 d8	 cmovb	 ebx, eax
$LN33@Reallocate:

; 3637 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3638 : 		auto& _Al = this->_Getal();
; 3639 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0004f	33 c9		 xor	 ecx, ecx
  00051	8b c3		 mov	 eax, ebx
  00053	83 c0 01	 add	 eax, 1
  00056	0f 92 c1	 setb	 cl
  00059	f7 d9		 neg	 ecx
  0005b	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0005d	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  0005f	33 f6		 xor	 esi, esi
  00061	eb 35		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00063	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00069	72 1f		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  0006b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 117  : 			if (_Block_size <= _User_size)

  0006e	3b c1		 cmp	 eax, ecx
  00070	0f 86 c1 00 00
	00		 jbe	 $LN149@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007c	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  0007f	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00082	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00085	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00088	eb 0b		 jmp	 SHORT $LN146@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00090	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  00093	8b f0		 mov	 esi, eax
$LN146@Reallocate:
  00095	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  00098	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  0009c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0009f	89 47 10	 mov	 DWORD PTR [edi+16], eax
  000a2	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000a5	52		 push	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000a6	72 65		 jb	 SHORT $LN3@Reallocate

; 3645 : 			{
; 3646 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000a8	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000aa	53		 push	 ebx
  000ab	56		 push	 esi
  000ac	e8 00 00 00 00	 call	 _memcpy

; 442  : 		_Left = _Right;

  000b1	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  000b7	8a 45 10	 mov	 al, BYTE PTR _<_Args_0>$[ebp]
  000ba	88 04 16	 mov	 BYTE PTR [esi+edx], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000bd	8b 45 f8	 mov	 eax, DWORD PTR __Old$1$[ebp]
  000c0	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000c1	c6 44 16 01 00	 mov	 BYTE PTR [esi+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000c6	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000cb	72 23		 jb	 SHORT $LN111@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000cd	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  000d0	3b c8		 cmp	 ecx, eax
  000d2	76 33		 jbe	 SHORT $_Invalid_parameter$153

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000d4	8b c1		 mov	 eax, ecx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000d6	f6 c3 1f	 test	 bl, 31			; 0000001fH
  000d9	75 2c		 jne	 SHORT $_Invalid_parameter$153

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000db	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  000de	3b cb		 cmp	 ecx, ebx
  000e0	73 25		 jae	 SHORT $_Invalid_parameter$153

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000e2	2b d9		 sub	 ebx, ecx
  000e4	83 fb 04	 cmp	 ebx, 4
  000e7	72 1e		 jb	 SHORT $_Invalid_parameter$153

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  000e9	83 fb 23	 cmp	 ebx, 35			; 00000023H
  000ec	77 19		 ja	 SHORT $_Invalid_parameter$153

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000ee	8b d9		 mov	 ebx, ecx
$LN111@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  000f0	50		 push	 eax
  000f1	53		 push	 ebx
  000f2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000f7	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  000fa	89 37		 mov	 DWORD PTR [edi], esi
  000fc	8b c7		 mov	 eax, edi
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx

; 3658 : 		}

  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 0c 00	 ret	 12			; 0000000cH
$_Invalid_parameter$153:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN150@Reallocate:
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0010d	57		 push	 edi
  0010e	56		 push	 esi
  0010f	e8 00 00 00 00	 call	 _memcpy

; 442  : 		_Left = _Right;

  00114	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00117	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 		_Left = _Right;

  0011a	8a 4d 10	 mov	 cl, BYTE PTR _<_Args_0>$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  0011d	8b c7		 mov	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0011f	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00122	c6 44 16 01 00	 mov	 BYTE PTR [esi+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  00127	89 37		 mov	 DWORD PTR [edi], esi
  00129	5f		 pop	 edi
  0012a	5e		 pop	 esi
  0012b	5b		 pop	 ebx

; 3658 : 		}

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 0c 00	 ret	 12			; 0000000cH
$LN147@Reallocate:

; 3631 : 			{
; 3632 : 			_Xlen();	// result too long

  00132	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN151@Reallocate:
$LN149@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  00137	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN152@Reallocate:
$LN145@Reallocate:
  0013c	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT
; __Val$ = ecx

; 249  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 250  : 	}

  00002	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Refancy@PAD$0A@@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z PROC		; std::_Refancy<char *,0>, COMDAT
; __Ptr$ = ecx

; 400  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 401  : 	}

  00002	c3		 ret	 0
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z ENDP		; std::_Refancy<char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__New_size$dead$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 1
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>, COMDAT
; _this$ = ecx

; 3594 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 3583 : 		if (_Old > _Max - _Old / 2)

  00009	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 3595 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3596 : 		if (_New_size > max_size())
; 3597 : 			{
; 3598 : 			_Xlen();	// result too long
; 3599 : 			}
; 3600 : 
; 3601 : 		auto& _My_data = this->_Get_data();
; 3602 : 		const size_type _Old_capacity = _My_data._Myres;

  0000e	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]

; 3583 : 		if (_Old > _Max - _Old / 2)

  00011	8b d1		 mov	 edx, ecx
  00013	d1 ea		 shr	 edx, 1
  00015	2b c2		 sub	 eax, edx

; 3595 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3596 : 		if (_New_size > max_size())
; 3597 : 			{
; 3598 : 			_Xlen();	// result too long
; 3599 : 			}
; 3600 : 
; 3601 : 		auto& _My_data = this->_Get_data();
; 3602 : 		const size_type _Old_capacity = _My_data._Myres;

  00017	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx

; 3583 : 		if (_Old > _Max - _Old / 2)

  0001a	3b c8		 cmp	 ecx, eax
  0001c	76 07		 jbe	 SHORT $LN35@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);

  0001e	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00023	eb 0d		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00025	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00028	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH
  0002d	3b c3		 cmp	 eax, ebx
  0002f	0f 47 d8	 cmova	 ebx, eax
$LN33@Reallocate:

; 3603 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3604 : 		auto& _Al = this->_Getal();
; 3605 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00032	33 c9		 xor	 ecx, ecx
  00034	8b c3		 mov	 eax, ebx
  00036	83 c0 01	 add	 eax, 1
  00039	0f 92 c1	 setb	 cl
  0003c	f7 d9		 neg	 ecx
  0003e	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  00040	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  00042	33 f6		 xor	 esi, esi
  00044	eb 32		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00046	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0004c	72 1f		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 117  : 			if (_Block_size <= _User_size)

  00051	3b c1		 cmp	 eax, ecx
  00053	0f 86 86 00 00
	00		 jbe	 $LN130@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00062	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00065	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00068	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  0006b	eb 0b		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00073	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  00076	8b f0		 mov	 esi, eax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3610 : 		if (this->_BUF_SIZE <= _Old_capacity)

  00078	8b 4d fc	 mov	 ecx, DWORD PTR __Old$1$[ebp]
  0007b	0f 57 c0	 xorps	 xmm0, xmm0
  0007e	c7 47 10 08 00
	00 00		 mov	 DWORD PTR [edi+16], 8
  00085	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00088	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0

; 442  : 		_Left = _Right;

  0008c	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3610 : 		if (this->_BUF_SIZE <= _Old_capacity)

  00090	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00093	72 37		 jb	 SHORT $LN3@Reallocate
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00095	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3612 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  00097	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00098	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009e	72 22		 jb	 SHORT $LN106@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000a0	8d 51 23	 lea	 edx, DWORD PTR [ecx+35]
  000a3	3b d1		 cmp	 edx, ecx
  000a5	76 32		 jbe	 SHORT $_Invalid_parameter$134

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000a7	8b ca		 mov	 ecx, edx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000a9	a8 1f		 test	 al, 31			; 0000001fH
  000ab	75 2c		 jne	 SHORT $_Invalid_parameter$134

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000ad	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  000b0	3b d0		 cmp	 edx, eax
  000b2	73 25		 jae	 SHORT $_Invalid_parameter$134

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000b4	2b c2		 sub	 eax, edx
  000b6	83 f8 04	 cmp	 eax, 4
  000b9	72 1e		 jb	 SHORT $_Invalid_parameter$134

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  000bb	83 f8 23	 cmp	 eax, 35			; 00000023H
  000be	77 19		 ja	 SHORT $_Invalid_parameter$134

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000c0	8b c2		 mov	 eax, edx
$LN106@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  000c2	51		 push	 ecx
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000c9	83 c4 08	 add	 esp, 8
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3620 : 		return (*this);

  000cc	89 37		 mov	 DWORD PTR [edi], esi
  000ce	8b c7		 mov	 eax, edi
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx

; 3621 : 		}

  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 0c 00	 ret	 12			; 0000000cH
$_Invalid_parameter$134:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN132@Reallocate:
$LN130@Reallocate:

; 119  : 				_Traits::_Fail();	// report no memory

  000df	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN133@Reallocate:
$LN129@Reallocate:
  000e4	cc		 int	 3
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
_<_Args_0>$GSCopy$1$ = -4				; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 3594 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00009	53		 push	 ebx
  0000a	89 45 fc	 mov	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp], eax
  0000d	8b d9		 mov	 ebx, ecx

; 3595 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3596 : 		if (_New_size > max_size())

  0000f	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00012	57		 push	 edi
  00013	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00018	0f 87 ee 00 00
	00		 ja	 $LN130@Reallocate

; 3599 : 			}
; 3600 : 
; 3601 : 		auto& _My_data = this->_Get_data();
; 3602 : 		const size_type _Old_capacity = _My_data._Myres;

  0001e	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00021	56		 push	 esi

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00022	8b f0		 mov	 esi, eax

; 3599 : 			}
; 3600 : 
; 3601 : 		auto& _My_data = this->_Get_data();
; 3602 : 		const size_type _Old_capacity = _My_data._Myres;

  00024	89 4d f8	 mov	 DWORD PTR __Old$1$[ebp], ecx

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00027	83 ce 0f	 or	 esi, 15			; 0000000fH
  0002a	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 3577 : 		if (_Masked > _Max)

  00030	76 07		 jbe	 SHORT $LN34@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);

  00032	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00037	eb 1e		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  00039	8b d1		 mov	 edx, ecx
  0003b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00040	d1 ea		 shr	 edx, 1
  00042	2b c2		 sub	 eax, edx
  00044	3b c8		 cmp	 ecx, eax
  00046	76 07		 jbe	 SHORT $LN35@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);

  00048	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0004d	eb 08		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0004f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00052	3b f0		 cmp	 esi, eax
  00054	0f 42 f0	 cmovb	 esi, eax
$LN33@Reallocate:

; 3603 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3604 : 		auto& _Al = this->_Getal();
; 3605 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00057	33 c9		 xor	 ecx, ecx
  00059	8b c6		 mov	 eax, esi
  0005b	83 c0 01	 add	 eax, 1
  0005e	0f 92 c1	 setb	 cl
  00061	f7 d9		 neg	 ecx
  00063	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  00065	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  00067	33 ff		 xor	 edi, edi
  00069	eb 32		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  0006b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00071	72 1f		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00073	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 117  : 			if (_Block_size <= _User_size)

  00076	3b c1		 cmp	 eax, ecx
  00078	0f 86 93 00 00
	00		 jbe	 $LN132@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00084	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00087	8d 78 23	 lea	 edi, DWORD PTR [eax+35]
  0008a	83 e7 e0	 and	 edi, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0008d	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00090	eb 0b		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00098	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  0009b	8b f8		 mov	 edi, eax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3607 : 		_My_data._Mysize = _New_size;

  0009d	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000a0	50		 push	 eax
  000a1	ff 75 fc	 push	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3607 : 		_My_data._Mysize = _New_size;

  000a4	89 43 10	 mov	 DWORD PTR [ebx+16], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000a7	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3608 : 		_My_data._Myres = _New_capacity;

  000a8	89 73 14	 mov	 DWORD PTR [ebx+20], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000ab	e8 00 00 00 00	 call	 _memcpy

; 442  : 		_Left = _Right;

  000b0	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3610 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000b6	8b 4d f8	 mov	 ecx, DWORD PTR __Old$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000b9	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3610 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000bd	5e		 pop	 esi
  000be	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000c1	72 37		 jb	 SHORT $LN3@Reallocate
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  000c3	8b 03		 mov	 eax, DWORD PTR [ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3612 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000c5	41		 inc	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000c6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000cc	72 22		 jb	 SHORT $LN106@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000ce	8d 51 23	 lea	 edx, DWORD PTR [ecx+35]
  000d1	3b d1		 cmp	 edx, ecx
  000d3	76 31		 jbe	 SHORT $_Invalid_parameter$136

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000d5	8b ca		 mov	 ecx, edx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000d7	a8 1f		 test	 al, 31			; 0000001fH
  000d9	75 2b		 jne	 SHORT $_Invalid_parameter$136

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000db	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  000de	3b d0		 cmp	 edx, eax
  000e0	73 24		 jae	 SHORT $_Invalid_parameter$136

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000e2	2b c2		 sub	 eax, edx
  000e4	83 f8 04	 cmp	 eax, 4
  000e7	72 1d		 jb	 SHORT $_Invalid_parameter$136

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  000e9	83 f8 23	 cmp	 eax, 35			; 00000023H
  000ec	77 18		 ja	 SHORT $_Invalid_parameter$136

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000ee	8b c2		 mov	 eax, edx
$LN106@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  000f0	51		 push	 ecx
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000f7	83 c4 08	 add	 esp, 8
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3620 : 		return (*this);

  000fa	89 3b		 mov	 DWORD PTR [ebx], edi
  000fc	8b c3		 mov	 eax, ebx
  000fe	5f		 pop	 edi
  000ff	5b		 pop	 ebx

; 3621 : 		}

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 0c 00	 ret	 12			; 0000000cH
$_Invalid_parameter$136:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN133@Reallocate:
$LN130@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3598 : 			_Xlen();	// result too long

  0010c	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN134@Reallocate:
$LN132@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  00111	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN135@Reallocate:
$LN129@Reallocate:
  00116	cc		 int	 3
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z
_TEXT	SEGMENT
tv638 = -16						; size = 4
__Old$1$ = -12						; size = 4
tv632 = -8						; size = 4
__New_size$1$ = -8					; size = 4
tv635 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 1
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>, COMDAT
; _this$ = ecx

; 3626 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 3627 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3628 : 		auto& _My_data = this->_Get_data();
; 3629 : 		const size_type _Old_size = _My_data._Mysize;
; 3630 : 		if (max_size() - _Old_size < _Size_increase)

  00008	8b 75 08	 mov	 esi, DWORD PTR __Size_increase$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00013	8b c1		 mov	 eax, ecx
  00015	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00018	2b c2		 sub	 eax, edx
  0001a	89 55 fc	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  0001d	3b c6		 cmp	 eax, esi
  0001f	0f 82 33 01 00
	00		 jb	 $LN147@Reallocate

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;

  00025	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]

; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  00028	8b 77 14	 mov	 esi, DWORD PTR [edi+20]

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0002b	8b d8		 mov	 ebx, eax

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;

  0002d	89 45 f8	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00030	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  00033	89 75 f4	 mov	 DWORD PTR __Old$1$[ebp], esi

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00036	3b d9		 cmp	 ebx, ecx

; 3577 : 		if (_Masked > _Max)

  00038	76 04		 jbe	 SHORT $LN34@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);

  0003a	8b d9		 mov	 ebx, ecx
  0003c	eb 18		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  0003e	8b c6		 mov	 eax, esi
  00040	d1 e8		 shr	 eax, 1
  00042	2b c8		 sub	 ecx, eax
  00044	3b f1		 cmp	 esi, ecx
  00046	76 07		 jbe	 SHORT $LN35@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);

  00048	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0004d	eb 07		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0004f	03 c6		 add	 eax, esi
  00051	3b d8		 cmp	 ebx, eax
  00053	0f 42 d8	 cmovb	 ebx, eax
$LN33@Reallocate:

; 3637 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3638 : 		auto& _Al = this->_Getal();
; 3639 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00056	33 c9		 xor	 ecx, ecx
  00058	8b c3		 mov	 eax, ebx
  0005a	83 c0 01	 add	 eax, 1
  0005d	0f 92 c1	 setb	 cl
  00060	f7 d9		 neg	 ecx
  00062	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  00064	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  00066	33 f6		 xor	 esi, esi
  00068	eb 35		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  0006a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00070	72 1f		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00072	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 117  : 			if (_Block_size <= _User_size)

  00075	3b c1		 cmp	 eax, ecx
  00077	0f 86 e0 00 00
	00		 jbe	 $LN149@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00083	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00086	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00089	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0008c	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  0008f	eb 0b		 jmp	 SHORT $LN146@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00097	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  0009a	8b f0		 mov	 esi, eax
$LN146@Reallocate:
  0009c	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3641 : 		_My_data._Mysize = _New_size;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  000a2	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 3642 : 		_My_data._Myres = _New_capacity;

  000a5	0f be 45 14	 movsx	 eax, BYTE PTR _<_Args_1>$[ebp]
  000a9	89 45 fc	 mov	 DWORD PTR tv635[ebp], eax
  000ac	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000af	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  000b2	8d 1c 16	 lea	 ebx, DWORD PTR [esi+edx]
  000b5	03 c3		 add	 eax, ebx
  000b7	89 5d f0	 mov	 DWORD PTR tv638[ebp], ebx

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000ba	83 7d f4 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000be	89 45 f8	 mov	 DWORD PTR tv632[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000c1	52		 push	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000c2	72 6b		 jb	 SHORT $LN3@Reallocate

; 3645 : 			{
; 3646 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000c4	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000c6	53		 push	 ebx
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 _memcpy

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  000cd	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000d0	ff 75 fc	 push	 DWORD PTR tv635[ebp]
  000d3	ff 75 f0	 push	 DWORD PTR tv638[ebp]
  000d6	e8 00 00 00 00	 call	 _memset

; 442  : 		_Left = _Right;

  000db	8b 45 f8	 mov	 eax, DWORD PTR tv632[ebp]

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  000de	83 c4 18	 add	 esp, 24			; 00000018H

; 442  : 		_Left = _Right;

  000e1	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000e4	8b 45 f4	 mov	 eax, DWORD PTR __Old$1$[ebp]
  000e7	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000e8	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000ed	72 23		 jb	 SHORT $LN111@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000ef	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  000f2	3b c8		 cmp	 ecx, eax
  000f4	76 33		 jbe	 SHORT $_Invalid_parameter$153

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000f6	8b c1		 mov	 eax, ecx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000f8	f6 c3 1f	 test	 bl, 31			; 0000001fH
  000fb	75 2c		 jne	 SHORT $_Invalid_parameter$153

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000fd	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00100	3b cb		 cmp	 ecx, ebx
  00102	73 25		 jae	 SHORT $_Invalid_parameter$153

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00104	2b d9		 sub	 ebx, ecx
  00106	83 fb 04	 cmp	 ebx, 4
  00109	72 1e		 jb	 SHORT $_Invalid_parameter$153

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0010b	83 fb 23	 cmp	 ebx, 35			; 00000023H
  0010e	77 19		 ja	 SHORT $_Invalid_parameter$153

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00110	8b d9		 mov	 ebx, ecx
$LN111@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00112	50		 push	 eax
  00113	53		 push	 ebx
  00114	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00119	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  0011c	89 37		 mov	 DWORD PTR [edi], esi
  0011e	8b c7		 mov	 eax, edi
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx

; 3658 : 		}

  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c2 10 00	 ret	 16			; 00000010H
$_Invalid_parameter$153:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN150@Reallocate:
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0012f	57		 push	 edi
  00130	56		 push	 esi
  00131	e8 00 00 00 00	 call	 _memcpy

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00136	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00139	ff 75 fc	 push	 DWORD PTR tv635[ebp]
  0013c	53		 push	 ebx
  0013d	e8 00 00 00 00	 call	 _memset

; 442  : 		_Left = _Right;

  00142	8b 45 f8	 mov	 eax, DWORD PTR tv632[ebp]

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00145	83 c4 18	 add	 esp, 24			; 00000018H

; 442  : 		_Left = _Right;

  00148	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  0014b	8b c7		 mov	 eax, edi
  0014d	89 37		 mov	 DWORD PTR [edi], esi
  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx

; 3658 : 		}

  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c2 10 00	 ret	 16			; 00000010H
$LN147@Reallocate:

; 3631 : 			{
; 3632 : 			_Xlen();	// result too long

  00158	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN151@Reallocate:
$LN149@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  0015d	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN152@Reallocate:
$LN145@Reallocate:
  00162	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
_<_Args_0>$GSCopy$1$ = -16				; size = 4
__Old$1$ = -12						; size = 4
tv640 = -8						; size = 4
__New_size$1$ = -8					; size = 4
tv636 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 3626 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 3627 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3628 : 		auto& _My_data = this->_Get_data();
; 3629 : 		const size_type _Old_size = _My_data._Mysize;
; 3630 : 		if (max_size() - _Old_size < _Size_increase)

  0000b	8b 75 08	 mov	 esi, DWORD PTR __Size_increase$[ebp]
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	89 45 f0	 mov	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp], eax
  00014	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00019	8b c1		 mov	 eax, ecx
  0001b	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  0001e	2b c2		 sub	 eax, edx
  00020	89 55 fc	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  00023	3b c6		 cmp	 eax, esi
  00025	0f 82 2c 01 00
	00		 jb	 $LN147@Reallocate

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;

  0002b	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]

; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  0002e	8b 77 14	 mov	 esi, DWORD PTR [edi+20]

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00031	8b d8		 mov	 ebx, eax

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;

  00033	89 45 f8	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00036	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  00039	89 75 f4	 mov	 DWORD PTR __Old$1$[ebp], esi

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0003c	3b d9		 cmp	 ebx, ecx

; 3577 : 		if (_Masked > _Max)

  0003e	76 04		 jbe	 SHORT $LN34@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);

  00040	8b d9		 mov	 ebx, ecx
  00042	eb 18		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  00044	8b c6		 mov	 eax, esi
  00046	d1 e8		 shr	 eax, 1
  00048	2b c8		 sub	 ecx, eax
  0004a	3b f1		 cmp	 esi, ecx
  0004c	76 07		 jbe	 SHORT $LN35@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);

  0004e	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00053	eb 07		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00055	03 c6		 add	 eax, esi
  00057	3b d8		 cmp	 ebx, eax
  00059	0f 42 d8	 cmovb	 ebx, eax
$LN33@Reallocate:

; 3637 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3638 : 		auto& _Al = this->_Getal();
; 3639 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0005c	33 c9		 xor	 ecx, ecx
  0005e	8b c3		 mov	 eax, ebx
  00060	83 c0 01	 add	 eax, 1
  00063	0f 92 c1	 setb	 cl
  00066	f7 d9		 neg	 ecx
  00068	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0006a	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  0006c	33 f6		 xor	 esi, esi
  0006e	eb 35		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00070	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00076	72 1f		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00078	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 117  : 			if (_Block_size <= _User_size)

  0007b	3b c1		 cmp	 eax, ecx
  0007d	0f 86 d9 00 00
	00		 jbe	 $LN149@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00089	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  0008c	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  0008f	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00092	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00095	eb 0b		 jmp	 SHORT $LN146@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009d	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  000a0	8b f0		 mov	 esi, eax
$LN146@Reallocate:
  000a2	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3641 : 		_My_data._Mysize = _New_size;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  000a8	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 3642 : 		_My_data._Myres = _New_capacity;

  000ab	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  000ae	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  000b1	8d 1c 16	 lea	 ebx, DWORD PTR [esi+edx]
  000b4	03 c3		 add	 eax, ebx
  000b6	89 5d f8	 mov	 DWORD PTR tv640[ebp], ebx

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000b9	83 7d f4 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000bd	89 45 fc	 mov	 DWORD PTR tv636[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000c0	52		 push	 edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000c1	72 6b		 jb	 SHORT $LN3@Reallocate

; 3645 : 			{
; 3646 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000c3	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000c5	53		 push	 ebx
  000c6	56		 push	 esi
  000c7	e8 00 00 00 00	 call	 _memcpy
  000cc	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000cf	ff 75 f0	 push	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp]
  000d2	ff 75 f8	 push	 DWORD PTR tv640[ebp]
  000d5	e8 00 00 00 00	 call	 _memcpy

; 442  : 		_Left = _Right;

  000da	8b 45 fc	 mov	 eax, DWORD PTR tv636[ebp]

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000dd	83 c4 18	 add	 esp, 24			; 00000018H

; 442  : 		_Left = _Right;

  000e0	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000e3	8b 45 f4	 mov	 eax, DWORD PTR __Old$1$[ebp]
  000e6	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000e7	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000ec	72 23		 jb	 SHORT $LN111@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000ee	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  000f1	3b c8		 cmp	 ecx, eax
  000f3	76 33		 jbe	 SHORT $_Invalid_parameter$153

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000f5	8b c1		 mov	 eax, ecx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000f7	f6 c3 1f	 test	 bl, 31			; 0000001fH
  000fa	75 2c		 jne	 SHORT $_Invalid_parameter$153

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000fc	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  000ff	3b cb		 cmp	 ecx, ebx
  00101	73 25		 jae	 SHORT $_Invalid_parameter$153

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00103	2b d9		 sub	 ebx, ecx
  00105	83 fb 04	 cmp	 ebx, 4
  00108	72 1e		 jb	 SHORT $_Invalid_parameter$153

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  0010a	83 fb 23	 cmp	 ebx, 35			; 00000023H
  0010d	77 19		 ja	 SHORT $_Invalid_parameter$153

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0010f	8b d9		 mov	 ebx, ecx
$LN111@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00111	50		 push	 eax
  00112	53		 push	 ebx
  00113	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00118	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  0011b	89 37		 mov	 DWORD PTR [edi], esi
  0011d	8b c7		 mov	 eax, edi
  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi
  00121	5b		 pop	 ebx

; 3658 : 		}

  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 10 00	 ret	 16			; 00000010H
$_Invalid_parameter$153:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN150@Reallocate:
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0012e	57		 push	 edi
  0012f	56		 push	 esi
  00130	e8 00 00 00 00	 call	 _memcpy
  00135	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00138	ff 75 f0	 push	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp]
  0013b	53		 push	 ebx
  0013c	e8 00 00 00 00	 call	 _memcpy

; 442  : 		_Left = _Right;

  00141	8b 45 fc	 mov	 eax, DWORD PTR tv636[ebp]

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00144	83 c4 18	 add	 esp, 24			; 00000018H

; 442  : 		_Left = _Right;

  00147	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  0014a	8b c7		 mov	 eax, edi
  0014c	89 37		 mov	 DWORD PTR [edi], esi
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx

; 3658 : 		}

  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 10 00	 ret	 16			; 00000010H
$LN147@Reallocate:

; 3631 : 			{
; 3632 : 			_Xlen();	// result too long

  00157	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN151@Reallocate:
$LN149@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  0015c	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN152@Reallocate:
$LN145@Reallocate:
  00161	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 943  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 944  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 02		 mov	 DWORD PTR [edx], eax

; 945  : 			_Objty(_STD forward<_Types>(_Args)...);
; 946  : 		}

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 1563 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1698 : 		}

  00007	8b c1		 mov	 eax, ecx

; 1564 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1698 : 		}

  00010	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPAXIII@Z
_TEXT	SEGMENT
__Align$dead$ = 8					; size = 4
??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPAXIII@Z PROC ; std::_Allocate<std::_Default_allocate_traits<1> >, COMDAT
; __Count$ = ecx
; __Sz$dead$ = edx

; 78   : 	if (_Count == 0)

  00000	85 c9		 test	 ecx, ecx
  00002	75 03		 jne	 SHORT $LN3@Allocate

; 79   : 		{
; 80   : 		return (nullptr);

  00004	33 c0		 xor	 eax, eax

; 133  : 			}
; 134  : 		}
; 135  :  #pragma warning(pop)
; 136  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));
; 139  : 	}

  00006	c3		 ret	 0
$LN3@Allocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00007	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000d	72 20		 jb	 SHORT $LN4@Allocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  0000f	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 117  : 			if (_Block_size <= _User_size)

  00012	3b c1		 cmp	 eax, ecx
  00014	0f 86 00 00 00
	00		 jbe	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail

; 118  : 				{
; 119  : 				_Traits::_Fail();	// report no memory
; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00023	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00026	83 e1 e0	 and	 ecx, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00029	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  0002c	8b c1		 mov	 eax, ecx

; 133  : 			}
; 134  : 		}
; 135  :  #pragma warning(pop)
; 136  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));
; 139  : 	}

  0002e	c3		 ret	 0
$LN4@Allocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00035	83 c4 04	 add	 esp, 4

; 133  : 			}
; 134  : 		}
; 135  :  #pragma warning(pop)
; 136  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));
; 139  : 	}

  00038	c3		 ret	 0
??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPAXIII@Z ENDP ; std::_Allocate<std::_Default_allocate_traits<1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 65   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_copy
  00024	83 c4 08	 add	 esp, 8
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
  0002d	8b c6		 mov	 eax, esi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?_Get_bytes@?$_Default_allocate_traits@$00@std@@SAPAXII@Z
_TEXT	SEGMENT
?_Get_bytes@?$_Default_allocate_traits@$00@std@@SAPAXII@Z PROC ; std::_Default_allocate_traits<1>::_Get_bytes, COMDAT
; __Bytes$ = ecx
; __Align$dead$ = edx

; 56   : 		(void)_Align;
; 57   : 
; 58   : 		void * _Ptr = nullptr;
; 59   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 60   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 61   : 			{
; 62   : 			_Ptr = ::operator new(_Bytes, align_val_t{_Align});
; 63   : 			}
; 64   : 		else
; 65   :  #endif /* _HAS_ALIGNED_NEW */
; 66   : 			{
; 67   : 			_Ptr = ::operator new(_Bytes);

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00006	83 c4 04	 add	 esp, 4

; 68   : 			}
; 69   : 
; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != nullptr);
; 71   : 		return (_Ptr);
; 72   : 		}

  00009	c3		 ret	 0
?_Get_bytes@?$_Default_allocate_traits@$00@std@@SAPAXII@Z ENDP ; std::_Default_allocate_traits<1>::_Get_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ
_TEXT	SEGMENT
?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ PROC	; std::_Default_allocate_traits<1>::_Fail, COMDAT

; 51   : 		_Xbad_alloc();

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ENDP	; std::_Default_allocate_traits<1>::_Fail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 1563 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1566 : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 3711 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
  0000b	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 3573 : 		{	// determines the next array size to allocate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3574 : 		const size_type _Max = max_size();
; 3575 : 		auto& _My_data = this->_Get_data();
; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00006	83 c8 0f	 or	 eax, 15			; 0000000fH
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH

; 3577 : 		if (_Masked > _Max)

  0000e	76 09		 jbe	 SHORT $LN2@Calculate_

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);

  00010	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 3589 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN2@Calculate_:
  00019	56		 push	 esi

; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;

  0001a	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]

; 3583 : 		if (_Old > _Max - _Old / 2)

  0001d	8b d6		 mov	 edx, esi
  0001f	d1 ea		 shr	 edx, 1
  00021	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00026	2b ca		 sub	 ecx, edx
  00028	3b f1		 cmp	 esi, ecx
  0002a	76 0a		 jbe	 SHORT $LN3@Calculate_

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);

  0002c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00031	5e		 pop	 esi

; 3589 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN3@Calculate_:

; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00036	8d 0c 32	 lea	 ecx, DWORD PTR [edx+esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 32   : 	return (_Left < _Right ? _Right : _Left);

  00039	3b c1		 cmp	 eax, ecx
  0003b	5e		 pop	 esi
  0003c	0f 42 c1	 cmovb	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3589 : 		}

  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT
; _this$ = ecx

; 3479 : 		{	// compare [0, size()) with _Ptr for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3479 : 		{	// compare [0, size()) with _Ptr for equality

  00007	8b d1		 mov	 edx, ecx
  00009	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0000a	8b fe		 mov	 edi, esi
  0000c	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000f	90		 npad	 1
$LL27@Equal:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL27@Equal
  00017	2b f9		 sub	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00019	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0001d	8b ca		 mov	 ecx, edx

; 1594 : 		if (_Large_string_engaged())

  0001f	72 02		 jb	 SHORT $LN13@Equal
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN13@Equal:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00023	8b 52 10	 mov	 edx, DWORD PTR [edx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00026	3b d7		 cmp	 edx, edi
  00028	75 5e		 jne	 SHORT $LN21@Equal
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0002a	83 ea 04	 sub	 edx, 4
  0002d	72 12		 jb	 SHORT $LN30@Equal
  0002f	90		 npad	 1
$LL31@Equal:
  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	3b 06		 cmp	 eax, DWORD PTR [esi]
  00034	75 10		 jne	 SHORT $LN29@Equal
  00036	83 c1 04	 add	 ecx, 4
  00039	83 c6 04	 add	 esi, 4
  0003c	83 ea 04	 sub	 edx, 4
  0003f	73 ef		 jae	 SHORT $LL31@Equal
$LN30@Equal:
  00041	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00044	74 34		 je	 SHORT $LN28@Equal
$LN29@Equal:
  00046	8a 01		 mov	 al, BYTE PTR [ecx]
  00048	3a 06		 cmp	 al, BYTE PTR [esi]
  0004a	75 27		 jne	 SHORT $LN32@Equal
  0004c	83 fa fd	 cmp	 edx, -3			; fffffffdH
  0004f	74 29		 je	 SHORT $LN28@Equal
  00051	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00054	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00057	75 1a		 jne	 SHORT $LN32@Equal
  00059	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0005c	74 1c		 je	 SHORT $LN28@Equal
  0005e	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00061	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00064	75 0d		 jne	 SHORT $LN32@Equal
  00066	83 fa ff	 cmp	 edx, -1
  00069	74 0f		 je	 SHORT $LN28@Equal
  0006b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0006e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00071	74 07		 je	 SHORT $LN28@Equal
$LN32@Equal:
  00073	1b c0		 sbb	 eax, eax
  00075	83 c8 01	 or	 eax, 1
  00078	eb 02		 jmp	 SHORT $LN33@Equal
$LN28@Equal:
  0007a	33 c0		 xor	 eax, eax
$LN33@Equal:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0007c	85 c0		 test	 eax, eax
  0007e	75 08		 jne	 SHORT $LN21@Equal
  00080	5f		 pop	 edi
  00081	b0 01		 mov	 al, 1

; 3482 : 		}

  00083	5e		 pop	 esi
  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
$LN21@Equal:
  00088	5f		 pop	 edi

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00089	32 c0		 xor	 al, al

; 3482 : 		}

  0008b	5e		 pop	 esi
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T2 = 8							; size = 1
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 3081 : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3082 : 		auto& _My_data = this->_Get_data();
; 3083 : 		if (_My_data._Mysize > _Newcap)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcap$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f8		 cmp	 edi, eax
  0000f	77 7e		 ja	 SHORT $LN5@reserve

; 3084 : 			{	// requested capacity is not large enough for current size, ignore
; 3085 : 			return;	// nothing to do
; 3086 : 			}
; 3087 : 
; 3088 : 		if (_My_data._Myres == _Newcap)

  00011	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00014	3b c8		 cmp	 ecx, eax
  00016	74 77		 je	 SHORT $LN5@reserve

; 3089 : 			{	// we're already at the requested capacity
; 3090 : 			return;	// nothing to do
; 3091 : 			}
; 3092 : 
; 3093 : 		if (_My_data._Myres < _Newcap)

  00018	73 1a		 jae	 SHORT $LN4@reserve

; 3094 : 			{	// reallocate to grow
; 3095 : 			const size_type _Old_size = _My_data._Mysize;
; 3096 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  0001a	c6 45 08 00	 mov	 BYTE PTR $T2[ebp], 0
  0001e	2b c7		 sub	 eax, edi
  00020	ff 75 08	 push	 DWORD PTR $T2[ebp]
  00023	8b ce		 mov	 ecx, esi
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >

; 3097 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3098 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3099 : 				});
; 3100 : 
; 3101 : 			_My_data._Mysize = _Old_size;

  0002b	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0002e	5f		 pop	 edi

; 3112 : 		}

  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@reserve:

; 3102 : 			return;
; 3103 : 			}
; 3104 : 
; 3105 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  00034	83 f8 10	 cmp	 eax, 16			; 00000010H
  00037	73 56		 jae	 SHORT $LN5@reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00039	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3102 : 			return;
; 3103 : 			}
; 3104 : 
; 3105 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  0003c	72 51		 jb	 SHORT $LN5@reserve

; 3666 : 		const pointer _Ptr = _My_data._Bx._Ptr;

  0003e	53		 push	 ebx
  0003f	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 3667 : 		auto& _Al = this->_Getal();
; 3668 : 		_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3669 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00041	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00044	50		 push	 eax
  00045	53		 push	 ebx
  00046	56		 push	 esi
  00047	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3670 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0004c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3670 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00052	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00053	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00058	72 23		 jb	 SHORT $LN47@reserve

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0005a	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  0005d	3b c8		 cmp	 ecx, eax
  0005f	76 34		 jbe	 SHORT $_Invalid_parameter$65

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00061	8b c1		 mov	 eax, ecx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00063	f6 c3 1f	 test	 bl, 31			; 0000001fH
  00066	75 2d		 jne	 SHORT $_Invalid_parameter$65

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00068	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0006b	3b cb		 cmp	 ecx, ebx
  0006d	73 26		 jae	 SHORT $_Invalid_parameter$65

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0006f	2b d9		 sub	 ebx, ecx
  00071	83 fb 04	 cmp	 ebx, 4
  00074	72 1f		 jb	 SHORT $_Invalid_parameter$65

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  00076	83 fb 23	 cmp	 ebx, 35			; 00000023H
  00079	77 1a		 ja	 SHORT $_Invalid_parameter$65

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0007b	8b d9		 mov	 ebx, ecx
$LN47@reserve:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0007d	50		 push	 eax
  0007e	53		 push	 ebx
  0007f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00084	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3671 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00087	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0008e	5b		 pop	 ebx
$LN5@reserve:
  0008f	5f		 pop	 edi

; 3112 : 		}

  00090	5e		 pop	 esi
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
$_Invalid_parameter$65:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN64@reserve:
$LN63@reserve:
  0009b	cc		 int	 3
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z PROC ; <lambda_67d87d4aa1269033985980465fd1d824>::operator(), COMDAT
; _this$dead$ = ecx

; 3097 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3098 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00006	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00007	50		 push	 eax
  00008	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __New_ptr$[ebp]
  0000e	e8 00 00 00 00	 call	 _memcpy
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3099 : 				});

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z ENDP ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 3077 : 		return (this->_Get_data()._Myres);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 3078 : 		}

  00003	c3		 ret	 0
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00004	72 03		 jb	 SHORT $LN16@data

; 3030 : 		return (this->_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3031 : 		}

  00008	c3		 ret	 0
$LN16@data:

; 3030 : 		return (this->_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 3031 : 		}

  0000b	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z
_TEXT	SEGMENT
$T5 = -4						; size = 4
__Off$dead$ = 8						; size = 4
__Ptr_shifted_after$1$ = 12				; size = 4
$T4 = 12						; size = 1
__Right$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2466 : 		{	// insert _Right at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Right$[ebp]

; 2466 : 		{	// insert _Right at _Off

  00008	56		 push	 esi
  00009	89 4d fc	 mov	 DWORD PTR $T5[ebp], ecx

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0000c	8b f3		 mov	 esi, ebx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0000e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1594 : 		if (_Large_string_engaged())

  00012	72 02		 jb	 SHORT $LN10@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00014	8b 33		 mov	 esi, DWORD PTR [ebx]
$LN10@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2501 : 		if (_Count <= _My_data._Myres - _Old_size)

  00016	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1609 : 		if (_Mysize < _Off)

  00019	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]

; 2501 : 		if (_Count <= _My_data._Myres - _Old_size)

  0001c	2b c2		 sub	 eax, edx

; 2468 : 		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));

  0001e	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]

; 2501 : 		if (_Count <= _My_data._Myres - _Old_size)

  00021	3b d8		 cmp	 ebx, eax
  00023	77 77		 ja	 SHORT $LN17@insert

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00025	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2503 : 			_My_data._Mysize = _Old_size + _Count;

  00029	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  0002c	57		 push	 edi
  0002d	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00030	8b f9		 mov	 edi, ecx

; 1583 : 		if (_Large_string_engaged())

  00032	72 02		 jb	 SHORT $LN35@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00034	8b 39		 mov	 edi, DWORD PTR [ecx]
$LN35@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2509 : 			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)

  00036	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  00039	3b c7		 cmp	 eax, edi
  0003b	76 1d		 jbe	 SHORT $LN20@insert
  0003d	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00040	3b f0		 cmp	 esi, eax
  00042	77 16		 ja	 SHORT $LN20@insert

; 2512 : 				}
; 2513 : 			else if (_Insert_at <= _Ptr)

  00044	3b fe		 cmp	 edi, esi
  00046	77 09		 ja	 SHORT $LN21@insert

; 2514 : 				{	// all of [_Ptr, _Ptr + _Count) shifts
; 2515 : 				_Ptr_shifted_after = 0;

  00048	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR __Ptr_shifted_after$1$[ebp], 0

; 2516 : 				}
; 2517 : 			else

  0004f	eb 0c		 jmp	 SHORT $LN22@insert
$LN21@insert:

; 2518 : 				{	// [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
; 2519 : 				_Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  00051	8b c7		 mov	 eax, edi
  00053	2b c6		 sub	 eax, esi
  00055	89 45 0c	 mov	 DWORD PTR __Ptr_shifted_after$1$[ebp], eax
  00058	eb 03		 jmp	 SHORT $LN22@insert
$LN20@insert:

; 2510 : 				{	// inserted content is before the shifted region, or does not alias
; 2511 : 				_Ptr_shifted_after = _Count; // none of _Ptr's data shifts

  0005a	89 5d 0c	 mov	 DWORD PTR __Ptr_shifted_after$1$[ebp], ebx
$LN22@insert:

; 2522 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  0005d	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00060	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2522 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00061	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00064	57		 push	 edi
  00065	50		 push	 eax
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0006c	ff 75 0c	 push	 DWORD PTR __Ptr_shifted_after$1$[ebp]
  0006f	56		 push	 esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2524 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00076	8b 45 0c	 mov	 eax, DWORD PTR __Ptr_shifted_after$1$[ebp]
  00079	8b cb		 mov	 ecx, ebx
  0007b	2b c8		 sub	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0007d	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2524 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  0007e	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
  00081	03 ce		 add	 ecx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00083	51		 push	 ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2524 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00084	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2468 : 		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));

  0008d	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00090	83 c4 24	 add	 esp, 36			; 00000024H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2468 : 		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi

; 2469 : 		}

  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 08 00	 ret	 8
$LN17@insert:

; 2529 : 		return (_Reallocate_grow_by(_Count,

  0009c	53		 push	 ebx
  0009d	56		 push	 esi
  0009e	51		 push	 ecx
  0009f	c6 45 0c 00	 mov	 BYTE PTR $T4[ebp], 0
  000a3	ff 75 0c	 push	 DWORD PTR $T4[ebp]
  000a6	53		 push	 ebx
  000a7	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>
  000ac	5e		 pop	 esi

; 2469 : 		}

  000ad	5b		 pop	 ebx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 08 00	 ret	 8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1636 : 			{	// user-provided, for fancy pointers
; 1637 : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Off$dead$ = 8						; size = 4
__Ptr$ = 12						; size = 4
$T2 = 16						; size = 1
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2497 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1609 : 		if (_Mysize < _Off)

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]

; 2497 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  00007	53		 push	 ebx

; 2498 : 		auto& _My_data = this->_Get_data();
; 2499 : 		_My_data._Check_offset(_Off);
; 2500 : 		const size_type _Old_size = _My_data._Mysize;
; 2501 : 		if (_Count <= _My_data._Myres - _Old_size)

  00008	8b 59 14	 mov	 ebx, DWORD PTR [ecx+20]
  0000b	8b c3		 mov	 eax, ebx
  0000d	57		 push	 edi
  0000e	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  00011	2b c2		 sub	 eax, edx
  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	3b f8		 cmp	 edi, eax
  00018	77 6f		 ja	 SHORT $LN2@insert

; 2502 : 			{
; 2503 : 			_My_data._Mysize = _Old_size + _Count;

  0001a	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  0001d	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00020	56		 push	 esi

; 1582 : 		value_type * _Result = _Bx._Buf;

  00021	8b f1		 mov	 esi, ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00023	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00026	72 02		 jb	 SHORT $LN20@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00028	8b 31		 mov	 esi, DWORD PTR [ecx]
$LN20@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2509 : 			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)

  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002d	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00030	3b c6		 cmp	 eax, esi
  00032	76 15		 jbe	 SHORT $LN5@insert
  00034	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00037	3b c8		 cmp	 ecx, eax
  00039	77 0e		 ja	 SHORT $LN5@insert

; 2512 : 				}
; 2513 : 			else if (_Insert_at <= _Ptr)

  0003b	3b f1		 cmp	 esi, ecx
  0003d	77 04		 ja	 SHORT $LN6@insert

; 2514 : 				{	// all of [_Ptr, _Ptr + _Count) shifts
; 2515 : 				_Ptr_shifted_after = 0;

  0003f	33 db		 xor	 ebx, ebx

; 2516 : 				}
; 2517 : 			else

  00041	eb 08		 jmp	 SHORT $LN7@insert
$LN6@insert:

; 2518 : 				{	// [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
; 2519 : 				_Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  00043	8b de		 mov	 ebx, esi
  00045	2b d9		 sub	 ebx, ecx
  00047	eb 02		 jmp	 SHORT $LN7@insert
$LN5@insert:

; 2510 : 				{	// inserted content is before the shifted region, or does not alias
; 2511 : 				_Ptr_shifted_after = _Count; // none of _Ptr's data shifts

  00049	8b df		 mov	 ebx, edi
$LN7@insert:

; 2522 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  0004b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0004e	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2522 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  0004f	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00052	56		 push	 esi
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0005a	53		 push	 ebx
  0005b	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2524 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00064	8b c7		 mov	 eax, edi
  00066	2b c3		 sub	 eax, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00068	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2524 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00069	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006c	03 c3		 add	 eax, ebx
  0006e	03 c7		 add	 eax, edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00070	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2524 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00071	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2526 : 			return (*this);

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0007d	83 c4 24	 add	 esp, 36			; 00000024H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2526 : 			return (*this);

  00080	5e		 pop	 esi
  00081	5f		 pop	 edi

; 2530 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2531 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {
; 2532 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2533 : 			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 2534 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2535 : 			}, _Off, _Ptr, _Count));
; 2536 : 		}

  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 0c 00	 ret	 12			; 0000000cH
$LN2@insert:

; 2527 : 			}
; 2528 : 
; 2529 : 		return (_Reallocate_grow_by(_Count,

  00089	57		 push	 edi
  0008a	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0008d	c6 45 10 00	 mov	 BYTE PTR $T2[ebp], 0
  00091	51		 push	 ecx
  00092	ff 75 10	 push	 DWORD PTR $T2[ebp]
  00095	57		 push	 edi
  00096	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>
  0009b	5f		 pop	 edi

; 2530 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2531 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {
; 2532 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2533 : 			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 2534 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2535 : 			}, _Off, _Ptr, _Count));
; 2536 : 		}

  0009c	5b		 pop	 ebx
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBE@QADQBDII1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Off$dead$ = 20					; size = 4
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBE@QADQBDII1I@Z PROC ; <lambda_4d79bb85f269e6e8002a4599002d832c>::operator(), COMDAT
; _this$dead$ = ecx

; 2531 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00005	8b 7d 08	 mov	 edi, DWORD PTR __New_ptr$[ebp]
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 _memcpy
  00013	8b 75 1c	 mov	 esi, DWORD PTR __Count$[ebp]
  00016	56		 push	 esi
  00017	ff 75 18	 push	 DWORD PTR __Ptr$[ebp]
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2534 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00020	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00024	50		 push	 eax
  00025	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2534 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00028	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _memcpy
  00031	83 c4 24	 add	 esp, 36			; 00000024H
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2535 : 			}, _Off, _Ptr, _Count));

  00036	5d		 pop	 ebp
  00037	c2 18 00	 ret	 24			; 00000018H
??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBE@QADQBDII1I@Z ENDP ; <lambda_4d79bb85f269e6e8002a4599002d832c>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
$T4 = -60						; size = 8
__Ok$ = -52						; size = 8
__State$ = -44						; size = 4
$T43 = -40						; size = 1
__Ctype_fac$1$ = -36					; size = 4
__Istr$GSCopy$ = -32					; size = 4
__Result$1$ = -28					; size = 4
__Size$1$ = -24						; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 23   : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f2		 mov	 esi, edx
  0002d	8b f9		 mov	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 29   : 	ios_base::iostate _State = ios_base::goodbit;

  00031	33 db		 xor	 ebx, ebx
  00033	89 7d e0	 mov	 DWORD PTR __Istr$GSCopy$[ebp], edi
  00036	89 5d d4	 mov	 DWORD PTR __State$[ebp], ebx

; 30   : 	bool _Changed = false;

  00039	88 5d ef	 mov	 BYTE PTR __Changed$[ebp], bl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0003c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 92   : 			: _Myistr(_Istr)

  0003f	89 7d cc	 mov	 DWORD PTR __Ok$[ebp], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00042	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  00046	85 c9		 test	 ecx, ecx
  00048	74 05		 je	 SHORT $LN25@operator

; 95   : 				_Myistr.rdbuf()->_Lock();

  0004a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004c	ff 50 04	 call	 DWORD PTR [eax+4]
$LN25@operator:

; 116  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0004f	6a 00		 push	 0
  00051	8b cf		 mov	 ecx, edi
  00053	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00060	88 45 d0	 mov	 BYTE PTR __Ok$[ebp+4], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 31   : 	const typename _Myis::sentry _Ok(_Istr);

  00063	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 32   : 
; 33   : 	if (_Ok)

  0006a	84 c0		 test	 al, al
  0006c	0f 84 45 01 00
	00		 je	 $LN19@operator

; 34   : 		{	// state okay, extract characters
; 35   : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00072	8d 45 c4	 lea	 eax, DWORD PTR $T4[ebp]
  00075	50		 push	 eax
  00076	8b 07		 mov	 eax, DWORD PTR [edi]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	03 cf		 add	 ecx, edi
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  00083	8b c8		 mov	 ecx, eax
  00085	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00089	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0008e	89 45 dc	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale

; 402  : 		{	// destroy the object

  00091	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 403  : 		if (_Ptr != 0)

  00095	8b 4d c8	 mov	 ecx, DWORD PTR $T4[ebp+4]
  00098	85 c9		 test	 ecx, ecx
  0009a	74 11		 je	 SHORT $LN36@operator

; 404  : 			delete _Ptr->_Decref();

  0009c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009e	ff 50 08	 call	 DWORD PTR [eax+8]
  000a1	8b c8		 mov	 ecx, eax
  000a3	85 c9		 test	 ecx, ecx
  000a5	74 06		 je	 SHORT $LN36@operator
  000a7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a9	6a 01		 push	 1
  000ab	ff 10		 call	 DWORD PTR [eax]
$LN36@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000ad	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1582 : 		value_type * _Result = _Bx._Buf;

  000b1	8b c6		 mov	 eax, esi

; 3677 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  000b3	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1583 : 		if (_Large_string_engaged())

  000ba	72 02		 jb	 SHORT $LN60@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000bc	8b 06		 mov	 eax, DWORD PTR [esi]
$LN60@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000be	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 38   : 		_TRY_IO_BEGIN

  000c1	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 422  : 		return (_Wide);

  000c5	8b 07		 mov	 eax, DWORD PTR [edi]
  000c7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 40   : 			&& (_Mysizt)_Istr.width() < _Str.max_size()

  000ca	83 7c 38 24 00	 cmp	 DWORD PTR [eax+edi+36], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 422  : 		return (_Wide);

  000cf	8b 5c 38 20	 mov	 ebx, DWORD PTR [eax+edi+32]
  000d3	89 5d e8	 mov	 DWORD PTR __Size$1$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 40   : 			&& (_Mysizt)_Istr.width() < _Str.max_size()

  000d6	7c 0e		 jl	 SHORT $LN174@operator
  000d8	7f 04		 jg	 SHORT $LN175@operator
  000da	85 db		 test	 ebx, ebx
  000dc	74 08		 je	 SHORT $LN174@operator
$LN175@operator:
  000de	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  000e4	72 08		 jb	 SHORT $LN98@operator
$LN174@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3055 : 		return (_Min_value(

  000e6	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  000eb	89 5d e8	 mov	 DWORD PTR __Size$1$[ebp], ebx
$LN98@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 42   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  000ee	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
$LL4@operator:

; 44   : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  000f8	85 db		 test	 ebx, ebx
  000fa	0f 84 8c 00 00
	00		 je	 $LN178@operator

; 45   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00100	83 f8 ff	 cmp	 eax, -1
  00103	75 08		 jne	 SHORT $LN7@operator

; 46   : 				{	// end of file, quit
; 47   : 				_State |= ios_base::eofbit;

  00105	8d 58 02	 lea	 ebx, DWORD PTR [eax+2]

; 48   : 				break;

  00108	e9 a3 00 00 00	 jmp	 $LN3@operator
$LN7@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale

; 2343 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

  0010d	8a d8		 mov	 bl, al
  0010f	8b 45 dc	 mov	 eax, DWORD PTR __Ctype_fac$1$[ebp]
  00112	0f b6 cb	 movzx	 ecx, bl
  00115	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00118	f6 04 48 48	 test	 BYTE PTR [eax+ecx*2], 72 ; 00000048H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 50   : 			else if (_Ctype_fac.is(_Ctype::space,

  0011c	75 6e		 jne	 SHORT $LN178@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2363 : 		if (_Count <= _My_data._Myres - _Old_size)

  0011e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00121	8b c1		 mov	 eax, ecx
  00123	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00126	2b c2		 sub	 eax, edx
  00128	83 f8 01	 cmp	 eax, 1
  0012b	72 2d		 jb	 SHORT $LN137@operator

; 1582 : 		value_type * _Result = _Bx._Buf;

  0012d	89 75 e4	 mov	 DWORD PTR __Result$1$[ebp], esi

; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  00130	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00133	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00136	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  00139	72 05		 jb	 SHORT $LN146@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0013b	8b 06		 mov	 eax, DWORD PTR [esi]
  0013d	89 45 e4	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN146@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00140	0f be cb	 movsx	 ecx, bl
  00143	0f b6 c1	 movzx	 eax, cl
  00146	66 c1 e1 08	 shl	 cx, 8
  0014a	66 0b c8	 or	 cx, ax
  0014d	8b 45 e4	 mov	 eax, DWORD PTR __Result$1$[ebp]
  00150	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 442  : 		_Left = _Right;

  00153	c6 44 10 01 00	 mov	 BYTE PTR [eax+edx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2369 : 			return (*this);

  00158	eb 13		 jmp	 SHORT $LN136@operator
$LN137@operator:

; 2370 : 			}
; 2371 : 
; 2372 : 		return (_Reallocate_grow_by(_Count,

  0015a	53		 push	 ebx
  0015b	6a 01		 push	 1
  0015d	c6 45 d8 00	 mov	 BYTE PTR $T43[ebp], 0
  00161	8b ce		 mov	 ecx, esi
  00163	ff 75 d8	 push	 DWORD PTR $T43[ebp]
  00166	6a 01		 push	 1
  00168	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN136@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0016d	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 44   : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  0016f	8b 5d e8	 mov	 ebx, DWORD PTR __Size$1$[ebp]
  00172	4b		 dec	 ebx

; 51   : 				_Traits::to_char_type(_Meta)))
; 52   : 				break;	// whitespace, quit
; 53   : 			else
; 54   : 				{	// add character to string
; 55   : 				_Str.append(1, _Traits::to_char_type(_Meta));
; 56   : 				_Changed = true;

  00173	c6 45 ef 01	 mov	 BYTE PTR __Changed$[ebp], 1
  00177	89 5d e8	 mov	 DWORD PTR __Size$1$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0017a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 44   : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  0017d	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00187	e9 6c ff ff ff	 jmp	 $LL4@operator
$LN178@operator:
  0018c	33 db		 xor	 ebx, ebx
  0018e	eb 20		 jmp	 SHORT $LN3@operator
__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:

; 57   : 				}
; 58   : 		_CATCH_IO_(_Istr)

  00190	8b 55 e0	 mov	 edx, DWORD PTR __Istr$GSCopy$[ebp]
  00193	6a 01		 push	 1
  00195	6a 04		 push	 4
  00197	8b 02		 mov	 eax, DWORD PTR [edx]
  00199	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0019c	03 ca		 add	 ecx, edx
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001a4	b8 00 00 00 00	 mov	 eax, $LN20@operator
  001a9	c3		 ret	 0
$LN20@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
  001aa	8b 5d d4	 mov	 ebx, DWORD PTR __State$[ebp]
  001ad	8b 7d e0	 mov	 edi, DWORD PTR __Istr$GSCopy$[ebp]
$LN3@operator:
  001b0	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN19@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 62   : 	if (!_Changed)

  001b7	80 7d ef 00	 cmp	 BYTE PTR __Changed$[ebp], 0
  001bb	8b 07		 mov	 eax, DWORD PTR [edi]
  001bd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  001c0	c7 44 38 20 00
	00 00 00	 mov	 DWORD PTR [eax+edi+32], 0
  001c8	c7 44 38 24 00
	00 00 00	 mov	 DWORD PTR [eax+edi+36], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 62   : 	if (!_Changed)

  001d0	75 03		 jne	 SHORT $LN11@operator

; 63   : 		_State |= ios_base::failbit;

  001d2	83 cb 02	 or	 ebx, 2
$LN11@operator:

; 64   : 	_Istr.setstate(_State);

  001d5	8b 07		 mov	 eax, DWORD PTR [edi]
  001d7	6a 00		 push	 0
  001d9	53		 push	 ebx
  001da	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001dd	03 cf		 add	 ecx, edi
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 99   : 			{	// destroy after unlocking

  001e5	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6

; 100  : 			if (_Myistr.rdbuf() != 0)

  001ec	8b 45 cc	 mov	 eax, DWORD PTR __Ok$[ebp]
  001ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  001f4	8b 4c 01 38	 mov	 ecx, DWORD PTR [ecx+eax+56]
  001f8	85 c9		 test	 ecx, ecx
  001fa	74 05		 je	 SHORT $LN176@operator

; 101  : 				_Myistr.rdbuf()->_Unlock();

  001fc	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fe	ff 52 08	 call	 DWORD PTR [edx+8]
$LN176@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 65   : 	return (_Istr);

  00201	8b c7		 mov	 eax, edi

; 66   : 	}

  00203	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00206	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0020d	59		 pop	 ecx
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	5b		 pop	 ebx
  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$4:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3:
  00010	8d 4d c4	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > &>, COMDAT
; __Arg$ = ecx

; 1553 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1554 : 	}

  00002	c3		 ret	 0
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@ABEHAAVrandom_device@1@HH@Z
_TEXT	SEGMENT
__Umin$1$ = -4						; size = 4
__Eng$dead$ = 8						; size = 4
__Index$1$ = 12						; size = 4
__Min$ = 12						; size = 4
__Max$ = 16						; size = 4
??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@ABEHAAVrandom_device@1@HH@Z PROC ; std::uniform_int<int>::_Eval<std::random_device>, COMDAT
; _this$dead$ = ecx

; 2320 : 		{	// compute next value in range [_Min, _Max]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2345 : 		if (_Uval < _Adjuster)

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Min$[ebp]

; 2320 : 		{	// compute next value in range [_Min, _Max]

  00008	56		 push	 esi

; 2321 : 		_Rng_from_urng<_Uty, _Engine> _Rng(_Eng);
; 2322 : 
; 2323 : 		const _Uty _Umin = _Adjust(_Uty(_Min));
; 2324 : 		const _Uty _Umax = _Adjust(_Uty(_Max));
; 2325 : 
; 2326 : 		_Uty _Uret = 0;
; 2327 : 
; 2328 : 		if (_Umax - _Umin == _Uty(-1))

  00009	8b 75 10	 mov	 esi, DWORD PTR __Max$[ebp]

; 2345 : 		if (_Uval < _Adjuster)

  0000c	81 c3 00 00 00
	80		 add	 ebx, -2147483648	; 80000000H

; 2321 : 		_Rng_from_urng<_Uty, _Engine> _Rng(_Eng);
; 2322 : 
; 2323 : 		const _Uty _Umin = _Adjust(_Uty(_Min));
; 2324 : 		const _Uty _Umax = _Adjust(_Uty(_Max));
; 2325 : 
; 2326 : 		_Uty _Uret = 0;
; 2327 : 
; 2328 : 		if (_Umax - _Umin == _Uty(-1))

  00012	2b f3		 sub	 esi, ebx

; 2345 : 		if (_Uval < _Adjuster)

  00014	89 5d fc	 mov	 DWORD PTR __Umin$1$[ebp], ebx

; 2321 : 		_Rng_from_urng<_Uty, _Engine> _Rng(_Eng);
; 2322 : 
; 2323 : 		const _Uty _Umin = _Adjust(_Uty(_Min));
; 2324 : 		const _Uty _Umax = _Adjust(_Uty(_Max));
; 2325 : 
; 2326 : 		_Uty _Uret = 0;
; 2327 : 
; 2328 : 		if (_Umax - _Umin == _Uty(-1))

  00017	81 c6 00 00 00
	80		 add	 esi, -2147483648	; 80000000H
  0001d	83 fe ff	 cmp	 esi, -1
  00020	75 15		 jne	 SHORT $LN2@Eval

; 6410 : 		return (_Random_device());

  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  00028	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  0002d	5e		 pop	 esi
  0002e	03 c3		 add	 eax, ebx

; 2334 : 		}

  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Eval:

; 2329 : 			_Uret = static_cast<_Uty>(_Rng._Get_all_bits());
; 2330 : 		else
; 2331 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  00037	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  0003a	57		 push	 edi
  0003b	89 5d 0c	 mov	 DWORD PTR __Index$1$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  0003e	eb 03		 jmp	 SHORT $LN42@Eval
$LL90@Eval:
  00040	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
$LN42@Eval:

; 3944 : 			_Udiff _Ret = 0;	// random bits

  00043	33 ff		 xor	 edi, edi

; 3945 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00045	33 c0		 xor	 eax, eax

; 3946 : 
; 3947 : 			while (_Mask < _Udiff(_Index - 1))

  00047	85 f6		 test	 esi, esi
  00049	74 0b		 je	 SHORT $LN46@Eval
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3987 : 			_Udiff _Val = _Ref() - (_Urng::min)();

  00051	8b f8		 mov	 edi, eax

; 3954 : 				_Mask |= _Bmask;

  00053	83 c8 ff	 or	 eax, -1
$LN46@Eval:

; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00056	33 d2		 xor	 edx, edx
  00058	f7 f3		 div	 ebx
  0005a	8b c8		 mov	 ecx, eax
  0005c	8b da		 mov	 ebx, edx
  0005e	33 d2		 xor	 edx, edx
  00060	8b c7		 mov	 eax, edi
  00062	f7 75 0c	 div	 DWORD PTR __Index$1$[ebp]
  00065	3b c1		 cmp	 eax, ecx
  00067	72 04		 jb	 SHORT $LN76@Eval
  00069	3b de		 cmp	 ebx, esi
  0006b	75 d3		 jne	 SHORT $LL90@Eval
$LN76@Eval:

; 3960 : 				return (_Ret % _Index);

  0006d	8b c7		 mov	 eax, edi
  0006f	33 d2		 xor	 edx, edx
  00071	f7 75 0c	 div	 DWORD PTR __Index$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  00074	8b 45 fc	 mov	 eax, DWORD PTR __Umin$1$[ebp]
  00077	5f		 pop	 edi
  00078	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  0007d	5e		 pop	 esi
  0007e	03 c2		 add	 eax, edx

; 2334 : 		}

  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 0c 00	 ret	 12			; 0000000cH
??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@ABEHAAVrandom_device@1@HH@Z ENDP ; std::uniform_int<int>::_Eval<std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
__State$ = -40						; size = 4
$T30 = -36						; size = 1
tv712 = -32						; size = 4
__Istr$GSCopy$ = -28					; size = 4
__Changed$ = -21					; size = 1
__Ch$ = -20						; size = 1
__$EHRec$ = -16						; size = 16
__Delim$ = 8						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 75   : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f2		 mov	 esi, edx
  0002d	8b f9		 mov	 edi, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 79   : 	bool _Changed = false;

  00031	32 db		 xor	 bl, bl
  00033	89 7d e4	 mov	 DWORD PTR __Istr$GSCopy$[ebp], edi
  00036	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0
  0003d	88 5d eb	 mov	 BYTE PTR __Changed$[ebp], bl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 92   : 			: _Myistr(_Istr)

  00043	89 7d d0	 mov	 DWORD PTR __Ok$[ebp], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00046	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  0004a	85 c9		 test	 ecx, ecx
  0004c	74 05		 je	 SHORT $LN24@getline

; 95   : 				_Myistr.rdbuf()->_Lock();

  0004e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00050	ff 50 04	 call	 DWORD PTR [eax+4]
$LN24@getline:

; 116  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00053	6a 01		 push	 1
  00055	8b cf		 mov	 ecx, edi
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00064	88 45 d4	 mov	 BYTE PTR __Ok$[ebp+4], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 80   : 	const typename _Myis::sentry _Ok(_Istr, true);

  00067	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 81   : 
; 82   : 	if (_Ok)

  0006e	84 c0		 test	 al, al
  00070	0f 84 ed 00 00
	00		 je	 $LN156@getline

; 83   : 		{	// state okay, extract characters
; 84   : 		_TRY_IO_BEGIN

  00076	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0007a	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0007c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 3677 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00080	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1583 : 		if (_Large_string_engaged())

  00087	72 02		 jb	 SHORT $LN154@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00089	8b 06		 mov	 eax, DWORD PTR [esi]
$LN154@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0008b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 462  : 		return (static_cast<unsigned char>(_Ch));

  0008e	0f b6 45 08	 movzx	 eax, BYTE PTR __Delim$[ebp]
  00092	89 45 e0	 mov	 DWORD PTR tv712[ebp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00095	8b 07		 mov	 eax, DWORD PTR [edi]
  00097	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 88   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  0009a	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
$LN158@getline:
  000a4	8b d0		 mov	 edx, eax

; 91   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000a6	83 fa ff	 cmp	 edx, -1
  000a9	75 08		 jne	 SHORT $LN7@getline

; 92   : 				{	// end of file, quit
; 93   : 				_State |= ios_base::eofbit;

  000ab	8d 42 02	 lea	 eax, DWORD PTR [edx+2]

; 94   : 				break;

  000ae	e9 a3 00 00 00	 jmp	 $LN3@getline
$LN7@getline:

; 95   : 				}
; 96   : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  000b3	3b 55 e0	 cmp	 edx, DWORD PTR tv712[ebp]
  000b6	75 1b		 jne	 SHORT $LN9@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  000b8	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 98   : 				_Changed = true;

  000ba	b3 01		 mov	 bl, 1
  000bc	88 5d eb	 mov	 BYTE PTR __Changed$[ebp], bl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  000bf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 99   : 				_Istr.rdbuf()->sbumpc();

  000c2	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ

; 100  : 				break;

  000cc	33 c0		 xor	 eax, eax
  000ce	e9 83 00 00 00	 jmp	 $LN3@getline
$LN9@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3047 : 		return (this->_Get_data()._Mysize);

  000d3	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 102  : 			else if (_Str.max_size() <= _Str.size())

  000d6	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  000dc	72 07		 jb	 SHORT $LN11@getline

; 103  : 				{	// string too large, quit
; 104  : 				_State |= ios_base::failbit;

  000de	b8 02 00 00 00	 mov	 eax, 2
  000e3	eb 71		 jmp	 SHORT $LN3@getline
$LN11@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2977 : 		if (_Old_size < _My_data._Myres)

  000e5	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]

; 2299 : 		push_back(_Ch);

  000e8	88 55 ec	 mov	 BYTE PTR __Ch$[ebp], dl

; 2977 : 		if (_Old_size < _My_data._Myres)

  000eb	3b cb		 cmp	 ecx, ebx
  000ed	73 19		 jae	 SHORT $LN117@getline

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  000ef	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000f2	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1582 : 		value_type * _Result = _Bx._Buf;

  000f5	8b c6		 mov	 eax, esi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000f7	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 1583 : 		if (_Large_string_engaged())

  000fa	72 02		 jb	 SHORT $LN126@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000fc	8b 06		 mov	 eax, DWORD PTR [esi]
$LN126@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000fe	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  00101	c6 44 08 01 00	 mov	 BYTE PTR [eax+ecx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  00106	eb 12		 jmp	 SHORT $LN116@getline
$LN117@getline:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  00108	ff 75 ec	 push	 DWORD PTR __Ch$[ebp]
  0010b	c6 45 dc 00	 mov	 BYTE PTR $T30[ebp], 0
  0010f	ff 75 dc	 push	 DWORD PTR $T30[ebp]
  00112	51		 push	 ecx
  00113	8b ce		 mov	 ecx, esi
  00115	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN116@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0011a	8b 07		 mov	 eax, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 110  : 				_Changed = true;

  0011c	b3 01		 mov	 bl, 1
  0011e	88 5d eb	 mov	 BYTE PTR __Changed$[ebp], bl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00121	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 90   : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  00124	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  0012e	e9 71 ff ff ff	 jmp	 $LN158@getline
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:

; 111  : 				}
; 112  : 		_CATCH_IO_(_Istr)

  00133	8b 55 e4	 mov	 edx, DWORD PTR __Istr$GSCopy$[ebp]
  00136	6a 01		 push	 1
  00138	6a 04		 push	 4
  0013a	8b 02		 mov	 eax, DWORD PTR [edx]
  0013c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013f	03 ca		 add	 ecx, edx
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00147	b8 00 00 00 00	 mov	 eax, $LN19@getline
  0014c	c3		 ret	 0
$LN19@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
  0014d	8b 45 d8	 mov	 eax, DWORD PTR __State$[ebp]
  00150	8a 5d eb	 mov	 bl, BYTE PTR __Changed$[ebp]
  00153	8b 7d e4	 mov	 edi, DWORD PTR __Istr$GSCopy$[ebp]
$LN3@getline:
  00156	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 113  : 		}
; 114  : 
; 115  : 	if (!_Changed)

  0015d	84 db		 test	 bl, bl
  0015f	75 07		 jne	 SHORT $LN13@getline

; 81   : 
; 82   : 	if (_Ok)

  00161	eb 02		 jmp	 SHORT $LN153@getline
$LN156@getline:
  00163	33 c0		 xor	 eax, eax
$LN153@getline:

; 116  : 		_State |= ios_base::failbit;

  00165	83 c8 02	 or	 eax, 2
$LN13@getline:

; 117  : 	_Istr.setstate(_State);

  00168	6a 00		 push	 0
  0016a	50		 push	 eax
  0016b	8b 07		 mov	 eax, DWORD PTR [edi]
  0016d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00170	03 cf		 add	 ecx, edi
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 99   : 			{	// destroy after unlocking

  00178	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 100  : 			if (_Myistr.rdbuf() != 0)

  0017f	8b 45 d0	 mov	 eax, DWORD PTR __Ok$[ebp]
  00182	8b 08		 mov	 ecx, DWORD PTR [eax]
  00184	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00187	8b 4c 01 38	 mov	 ecx, DWORD PTR [ecx+eax+56]
  0018b	85 c9		 test	 ecx, ecx
  0018d	74 05		 je	 SHORT $LN155@getline

; 101  : 				_Myistr.rdbuf()->_Unlock();

  0018f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00191	ff 52 08	 call	 DWORD PTR [edx+8]
$LN155@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 118  : 	return (_Istr);

  00194	8b c7		 mov	 eax, edi

; 119  : 	}

  00196	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00199	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a0	59		 pop	 ecx
  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi
  001a3	5b		 pop	 ebx
  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
_TEXT	SEGMENT
__Ok$ = -44						; size = 8
__Data$1$ = -36						; size = 4
$T19 = -36						; size = 1
__State$ = -32						; size = 4
__Ostr$ = -28						; size = 4
$T28 = -24						; size = 4
$T13 = -24						; size = 1
tv834 = -20						; size = 4
tv832 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Size$ = 8						; size = 4
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned int>, COMDAT
; __Ostr$ = ecx
; __Data$ = edx

; 24   : 	{	// insert a character-type sequence into _Ostr as if through a basic_string copy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	89 55 dc	 mov	 DWORD PTR __Data$1$[ebp], edx
  0002e	8b d9		 mov	 ebx, ecx
  00030	89 5d e4	 mov	 DWORD PTR __Ostr$[ebp], ebx

; 26   : 	_SizeT _Pad = _Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size

  00033	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00035	33 ff		 xor	 edi, edi
  00037	89 7d e0	 mov	 DWORD PTR __State$[ebp], edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 422  : 		return (_Wide);

  0003a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003d	03 d3		 add	 edx, ebx
  0003f	89 55 ec	 mov	 DWORD PTR tv834[ebp], edx
  00042	8b 72 20	 mov	 esi, DWORD PTR [edx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 26   : 	_SizeT _Pad = _Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size

  00045	39 7a 24	 cmp	 DWORD PTR [edx+36], edi
  00048	7c 11		 jl	 SHORT $LN17@Insert_str
  0004a	7f 04		 jg	 SHORT $LN107@Insert_str
  0004c	85 f6		 test	 esi, esi
  0004e	74 0b		 je	 SHORT $LN17@Insert_str
$LN107@Insert_str:
  00050	8b 45 08	 mov	 eax, DWORD PTR __Size$[ebp]
  00053	3b f0		 cmp	 esi, eax
  00055	76 04		 jbe	 SHORT $LN17@Insert_str
  00057	2b f0		 sub	 esi, eax
  00059	eb 02		 jmp	 SHORT $LN18@Insert_str
$LN17@Insert_str:
  0005b	33 f6		 xor	 esi, esi
$LN18@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0005d	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00060	8b d1		 mov	 edx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 98   : 			: _Myostr(_Ostr)

  00062	89 5d d4	 mov	 DWORD PTR __Ok$[ebp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00065	89 55 e8	 mov	 DWORD PTR $T28[ebp], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

  00068	85 c0		 test	 eax, eax
  0006a	74 12		 je	 SHORT $LN35@Insert_str

; 101  : 				_Myostr.rdbuf()->_Lock();

  0006c	8b 4d ec	 mov	 ecx, DWORD PTR tv834[ebp]
  0006f	8b 00		 mov	 eax, DWORD PTR [eax]
  00071	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
  00074	ff 50 04	 call	 DWORD PTR [eax+4]
  00077	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00079	8b d1		 mov	 edx, ecx
  0007b	89 4d e8	 mov	 DWORD PTR $T28[ebp], ecx
$LN35@Insert_str:

; 120  : 			: _Sentry_base(_Ostr)

  0007e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  00085	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00088	03 c3		 add	 eax, ebx
  0008a	89 45 ec	 mov	 DWORD PTR tv832[ebp], eax
  0008d	8b c1		 mov	 eax, ecx

; 338  : 		return (rdstate() == goodbit);

  0008f	8b 7d ec	 mov	 edi, DWORD PTR tv832[ebp]
  00092	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00096	bf 00 00 00 00	 mov	 edi, 0
  0009b	75 2c		 jne	 SHORT $LN31@Insert_str
  0009d	8b 7d ec	 mov	 edi, DWORD PTR tv832[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 79   : 		return (_Tiestr);

  000a0	8b d1		 mov	 edx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  000a2	83 7f 3c 00	 cmp	 DWORD PTR [edi+60], 0
  000a6	bf 00 00 00 00	 mov	 edi, 0
  000ab	74 1c		 je	 SHORT $LN31@Insert_str
  000ad	8b 7d ec	 mov	 edi, DWORD PTR tv832[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 79   : 		return (_Tiestr);

  000b0	8b 55 e8	 mov	 edx, DWORD PTR $T28[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  000b3	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  000b6	bf 00 00 00 00	 mov	 edi, 0
  000bb	3b cb		 cmp	 ecx, ebx
  000bd	74 0a		 je	 SHORT $LN31@Insert_str

; 123  : 				_Ostr.tie()->flush();

  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  000c5	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c7	8b d0		 mov	 edx, eax
$LN31@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  000c9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cc	8b 44 19 0c	 mov	 eax, DWORD PTR [ecx+ebx+12]

; 338  : 		return (rdstate() == goodbit);

  000d0	85 c0		 test	 eax, eax
  000d2	0f 94 45 d8	 sete	 BYTE PTR __Ok$[ebp+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 28   : 	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

  000d6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000dd	85 c0		 test	 eax, eax

; 29   : 
; 30   : 	if (!_Ok)

  000df	74 0a		 je	 SHORT $LN8@Insert_str

; 31   : 		_State |= ios_base::badbit;

  000e1	bf 04 00 00 00	 mov	 edi, 4

; 32   : 	else

  000e6	e9 d2 00 00 00	 jmp	 $LN22@Insert_str
$LN8@Insert_str:

; 33   : 		{	// state okay, insert characters
; 34   : 		_TRY_IO_BEGIN

  000eb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 377  : 		return (_Fmtfl);

  000ef	8b 44 19 14	 mov	 eax, DWORD PTR [ecx+ebx+20]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 35   : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000f3	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000f8	83 f8 40	 cmp	 eax, 64			; 00000040H
  000fb	74 34		 je	 SHORT $LN103@Insert_str
  000fd	0f 1f 00	 npad	 3
$LL4@Insert_str:

; 36   : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00100	85 f6		 test	 esi, esi
  00102	74 2b		 je	 SHORT $LN3@Insert_str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  00104	8b 03		 mov	 eax, DWORD PTR [ebx]
  00106	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00109	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 37   : 				if (_Traits::eq_int_type(_Traits::eof(),

  0010d	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  00111	88 45 e8	 mov	 BYTE PTR $T13[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 37   : 				if (_Traits::eq_int_type(_Traits::eof(),

  00114	ff 75 e8	 push	 DWORD PTR $T13[ebp]
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0011d	83 f8 ff	 cmp	 eax, -1
  00120	75 0a		 jne	 SHORT $LN2@Insert_str

; 38   : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 39   : 					{	// insertion failed, quit
; 40   : 					_State |= ios_base::badbit;

  00122	bf 04 00 00 00	 mov	 edi, 4
  00127	89 7d e0	 mov	 DWORD PTR __State$[ebp], edi

; 41   : 					break;

  0012a	eb 24		 jmp	 SHORT $LL109@Insert_str
$LN2@Insert_str:

; 36   : 			for (; 0 < _Pad; --_Pad)	// pad on left

  0012c	4e		 dec	 esi
  0012d	eb d1		 jmp	 SHORT $LL4@Insert_str
$LN3@Insert_str:

; 45   : 			&& _Ostr.rdbuf()->sputn(_Data, (streamsize)_Size)

  0012f	8b 13		 mov	 edx, DWORD PTR [ebx]
$LN103@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00131	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 45   : 			&& _Ostr.rdbuf()->sputn(_Data, (streamsize)_Size)

  00134	6a 00		 push	 0
  00136	ff 75 08	 push	 DWORD PTR __Size$[ebp]
  00139	ff 75 dc	 push	 DWORD PTR __Data$1$[ebp]
  0013c	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  00146	3b 45 08	 cmp	 eax, DWORD PTR __Size$[ebp]
  00149	75 2f		 jne	 SHORT $LN108@Insert_str
  0014b	85 d2		 test	 edx, edx
  0014d	75 2b		 jne	 SHORT $LN108@Insert_str
  0014f	90		 npad	 1
$LL109@Insert_str:

; 48   : 		else
; 49   : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00150	85 f6		 test	 esi, esi
  00152	74 2b		 je	 SHORT $LN6@Insert_str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  00154	8b 03		 mov	 eax, DWORD PTR [ebx]
  00156	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00159	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 50   : 				if (_Traits::eq_int_type(_Traits::eof(),

  0015d	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 112  : 		return (_Fillch);

  00161	88 45 dc	 mov	 BYTE PTR $T19[ebp], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 50   : 				if (_Traits::eq_int_type(_Traits::eof(),

  00164	ff 75 dc	 push	 DWORD PTR $T19[ebp]
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0016d	83 f8 ff	 cmp	 eax, -1
  00170	75 05		 jne	 SHORT $LN5@Insert_str

; 51   : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 52   : 					{	// insertion failed, quit
; 53   : 					_State |= ios_base::badbit;

  00172	83 cf 04	 or	 edi, 4

; 54   : 					break;

  00175	eb 08		 jmp	 SHORT $LN6@Insert_str
$LN5@Insert_str:

; 48   : 		else
; 49   : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00177	4e		 dec	 esi
  00178	eb d6		 jmp	 SHORT $LL109@Insert_str
$LN108@Insert_str:

; 46   : 				!= (streamsize)_Size)
; 47   : 				_State |= ios_base::badbit;

  0017a	bf 04 00 00 00	 mov	 edi, 4
$LN6@Insert_str:

; 55   : 					}
; 56   : 		_Ostr.width(0);

  0017f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00181	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  00184	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  0018c	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
  00194	eb 20		 jmp	 SHORT $LN115@Insert_str
__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0:

; 57   : 		_CATCH_IO_(_Ostr)

  00196	8b 55 e4	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00199	6a 01		 push	 1
  0019b	6a 04		 push	 4
  0019d	8b 02		 mov	 eax, DWORD PTR [edx]
  0019f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001a2	03 ca		 add	 ecx, edx
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001aa	b8 00 00 00 00	 mov	 eax, $LN23@Insert_str
  001af	c3		 ret	 0
$LN23@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
  001b0	8b 5d e4	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  001b3	8b 7d e0	 mov	 edi, DWORD PTR __State$[ebp]
$LN115@Insert_str:
  001b6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN22@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 58   : 		}
; 59   : 
; 60   : 	_Ostr.setstate(_State);

  001bd	8b 03		 mov	 eax, DWORD PTR [ebx]
  001bf	6a 00		 push	 0
  001c1	57		 push	 edi
  001c2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c5	03 cb		 add	 ecx, ebx
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 128  : 			{	// destroy the object

  001cd	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 129  :  #if _HAS_EXCEPTIONS
; 130  : 			if (_STD uncaught_exceptions() == 0)

  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 131  : 				{
; 132  : 				this->_Myostr._Osfx();

  001da	8b 75 d4	 mov	 esi, DWORD PTR __Ok$[ebp]
  001dd	85 c0		 test	 eax, eax
  001df	75 08		 jne	 SHORT $LN84@Insert_str
  001e1	8b ce		 mov	 ecx, esi
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN84@Insert_str:

; 105  : 			{	// destroy after unlocking

  001e9	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5

; 106  : 			if (_Myostr.rdbuf() != 0)

  001ed	8b 06		 mov	 eax, DWORD PTR [esi]
  001ef	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f2	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  001f6	85 c9		 test	 ecx, ecx
  001f8	74 05		 je	 SHORT $LN110@Insert_str

; 107  : 				_Myostr.rdbuf()->_Unlock();

  001fa	8b 01		 mov	 eax, DWORD PTR [ecx]
  001fc	ff 50 08	 call	 DWORD PTR [eax+8]
$LN110@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 61   : 	return (_Ostr);

  001ff	8b c3		 mov	 eax, ebx

; 62   : 	}

  00201	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00204	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0020b	59		 pop	 ecx
  0020c	5f		 pop	 edi
  0020d	5e		 pop	 esi
  0020e	5b		 pop	 ebx
  0020f	8b e5		 mov	 esp, ebp
  00211	5d		 pop	 ebp
  00212	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT
; __Arg$ = ecx

; 1538 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1539 : 	}

  00002	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1563 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 322  : 		}

  00007	8b c1		 mov	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1564 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 322  : 		}

  00010	c2 08 00	 ret	 8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1139 : 	_Left = _STD move(_Right);
; 1140 : 	}

  00000	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1126 : 	}

  00000	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT
; __Arg$ = ecx

; 1538 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1539 : 	}

  00002	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT
; __Arg$ = ecx

; 1538 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1539 : 	}

  00002	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1563 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 322  : 		}

  00007	8b c1		 mov	 eax, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1564 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 322  : 		}

  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Right_size$ = 12					; size = 4
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z PROC ; std::_Traits_equal<std::char_traits<char> >, COMDAT
; __Left$ = ecx
; __Left_size$ = edx

; 24   : 	{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00003	3b 55 0c	 cmp	 edx, DWORD PTR __Right_size$[ebp]
  00006	75 5e		 jne	 SHORT $LN3@Traits_equ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  0000c	83 ea 04	 sub	 edx, 4
  0000f	72 11		 jb	 SHORT $LN10@Traits_equ
$LL11@Traits_equ:
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	3b 06		 cmp	 eax, DWORD PTR [esi]
  00015	75 10		 jne	 SHORT $LN9@Traits_equ
  00017	83 c1 04	 add	 ecx, 4
  0001a	83 c6 04	 add	 esi, 4
  0001d	83 ea 04	 sub	 edx, 4
  00020	73 ef		 jae	 SHORT $LL11@Traits_equ
$LN10@Traits_equ:
  00022	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00025	74 34		 je	 SHORT $LN8@Traits_equ
$LN9@Traits_equ:
  00027	8a 01		 mov	 al, BYTE PTR [ecx]
  00029	3a 06		 cmp	 al, BYTE PTR [esi]
  0002b	75 27		 jne	 SHORT $LN12@Traits_equ
  0002d	83 fa fd	 cmp	 edx, -3			; fffffffdH
  00030	74 29		 je	 SHORT $LN8@Traits_equ
  00032	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00035	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00038	75 1a		 jne	 SHORT $LN12@Traits_equ
  0003a	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0003d	74 1c		 je	 SHORT $LN8@Traits_equ
  0003f	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00042	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00045	75 0d		 jne	 SHORT $LN12@Traits_equ
  00047	83 fa ff	 cmp	 edx, -1
  0004a	74 0f		 je	 SHORT $LN8@Traits_equ
  0004c	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0004f	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00052	74 07		 je	 SHORT $LN8@Traits_equ
$LN12@Traits_equ:
  00054	1b c0		 sbb	 eax, eax
  00056	83 c8 01	 or	 eax, 1
  00059	eb 02		 jmp	 SHORT $LN13@Traits_equ
$LN8@Traits_equ:
  0005b	33 c0		 xor	 eax, eax
$LN13@Traits_equ:
  0005d	5e		 pop	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0005e	85 c0		 test	 eax, eax
  00060	75 04		 jne	 SHORT $LN3@Traits_equ
  00062	b0 01		 mov	 al, 1

; 26   : 	}

  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN3@Traits_equ:

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00066	32 c0		 xor	 al, al

; 26   : 	}

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z ENDP ; std::_Traits_equal<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z
_TEXT	SEGMENT
__Old_size$1$ = -12					; size = 4
__New_size$1$ = -8					; size = 4
__Old$1$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >, COMDAT
; _this$ = ecx

; 3626 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3627 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3628 : 		auto& _My_data = this->_Get_data();
; 3629 : 		const size_type _Old_size = _My_data._Mysize;
; 3630 : 		if (max_size() - _Old_size < _Size_increase)

  00006	8b 55 08	 mov	 edx, DWORD PTR __Size_increase$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00012	8b c1		 mov	 eax, ecx
  00014	57		 push	 edi
  00015	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00018	2b c3		 sub	 eax, ebx
  0001a	89 5d f4	 mov	 DWORD PTR __Old_size$1$[ebp], ebx
  0001d	3b c2		 cmp	 eax, edx
  0001f	0f 82 f9 00 00
	00		 jb	 $LN134@Reallocate

; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  00025	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  00028	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0002b	8b d8		 mov	 ebx, eax

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;

  0002d	89 45 f8	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00030	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  00033	89 7d fc	 mov	 DWORD PTR __Old$1$[ebp], edi

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00036	3b d9		 cmp	 ebx, ecx

; 3577 : 		if (_Masked > _Max)

  00038	76 04		 jbe	 SHORT $LN34@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);

  0003a	8b d9		 mov	 ebx, ecx
  0003c	eb 18		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  0003e	8b c7		 mov	 eax, edi
  00040	d1 e8		 shr	 eax, 1
  00042	2b c8		 sub	 ecx, eax
  00044	3b f9		 cmp	 edi, ecx
  00046	76 07		 jbe	 SHORT $LN35@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);

  00048	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0004d	eb 07		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0004f	03 c7		 add	 eax, edi
  00051	3b d8		 cmp	 ebx, eax
  00053	0f 42 d8	 cmovb	 ebx, eax
$LN33@Reallocate:

; 3637 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3638 : 		auto& _Al = this->_Getal();
; 3639 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00056	33 c9		 xor	 ecx, ecx
  00058	8b c3		 mov	 eax, ebx
  0005a	83 c0 01	 add	 eax, 1
  0005d	0f 92 c1	 setb	 cl
  00060	f7 d9		 neg	 ecx
  00062	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  00064	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  00066	33 ff		 xor	 edi, edi
  00068	eb 32		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  0006a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00070	72 1f		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00072	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 117  : 			if (_Block_size <= _User_size)

  00075	3b c1		 cmp	 eax, ecx
  00077	0f 86 a6 00 00
	00		 jbe	 $LN136@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00083	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00086	8d 78 23	 lea	 edi, DWORD PTR [eax+35]
  00089	83 e7 e0	 and	 edi, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0008c	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  0008f	eb 0b		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00097	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  0009a	8b f8		 mov	 edi, eax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3641 : 		_My_data._Mysize = _New_size;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  0009f	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 3642 : 		_My_data._Myres = _New_capacity;

  000a2	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$1$[ebp]
  000a5	40		 inc	 eax
  000a6	89 5e 14	 mov	 DWORD PTR [esi+20], ebx

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000a9	83 7d fc 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000ad	50		 push	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000ae	72 57		 jb	 SHORT $LN3@Reallocate

; 3645 : 			{
; 3646 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000b0	8b 1e		 mov	 ebx, DWORD PTR [esi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000b2	53		 push	 ebx
  000b3	57		 push	 edi
  000b4	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000b9	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000bf	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000c0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000c5	72 23		 jb	 SHORT $LN105@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000c7	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  000ca	3b c8		 cmp	 ecx, eax
  000cc	76 33		 jbe	 SHORT $_Invalid_parameter$140

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000ce	8b c1		 mov	 eax, ecx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000d0	f6 c3 1f	 test	 bl, 31			; 0000001fH
  000d3	75 2c		 jne	 SHORT $_Invalid_parameter$140

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000d5	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  000d8	3b cb		 cmp	 ecx, ebx
  000da	73 25		 jae	 SHORT $_Invalid_parameter$140

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000dc	2b d9		 sub	 ebx, ecx
  000de	83 fb 04	 cmp	 ebx, 4
  000e1	72 1e		 jb	 SHORT $_Invalid_parameter$140

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  000e3	83 fb 23	 cmp	 ebx, 35			; 00000023H
  000e6	77 19		 ja	 SHORT $_Invalid_parameter$140

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000e8	8b d9		 mov	 ebx, ecx
$LN105@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  000ea	50		 push	 eax
  000eb	53		 push	 ebx
  000ec	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000f1	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  000f4	89 3e		 mov	 DWORD PTR [esi], edi
  000f6	8b c6		 mov	 eax, esi
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx

; 3658 : 		}

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 08 00	 ret	 8
$_Invalid_parameter$140:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN137@Reallocate:
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00107	56		 push	 esi
  00108	57		 push	 edi
  00109	e8 00 00 00 00	 call	 _memcpy
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  00111	89 3e		 mov	 DWORD PTR [esi], edi
  00113	8b c6		 mov	 eax, esi
  00115	5f		 pop	 edi
  00116	5e		 pop	 esi
  00117	5b		 pop	 ebx

; 3658 : 		}

  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 08 00	 ret	 8
$LN134@Reallocate:

; 3631 : 			{
; 3632 : 			_Xlen();	// result too long

  0011e	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN138@Reallocate:
$LN136@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  00123	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN139@Reallocate:
$LN133@Reallocate:
  00128	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z
_TEXT	SEGMENT
__New_size$1$ = -16					; size = 4
_<_Args_1>$GSCopy$1$ = -12				; size = 4
__Old$1$ = -8						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 3626 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]

; 3627 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3628 : 		auto& _My_data = this->_Get_data();
; 3629 : 		const size_type _Old_size = _My_data._Mysize;
; 3630 : 		if (max_size() - _Old_size < _Size_increase)

  00009	8b 55 08	 mov	 edx, DWORD PTR __Size_increase$[ebp]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	89 45 f4	 mov	 DWORD PTR _<_Args_1>$GSCopy$1$[ebp], eax
  00014	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00019	8b c1		 mov	 eax, ecx
  0001b	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  0001e	2b c3		 sub	 eax, ebx
  00020	89 5d fc	 mov	 DWORD PTR __Old_size$1$[ebp], ebx
  00023	3b c2		 cmp	 eax, edx
  00025	0f 82 1a 01 00
	00		 jb	 $LN146@Reallocate

; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  0002b	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  0002e	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00031	8b d8		 mov	 ebx, eax

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;

  00033	89 45 f0	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00036	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  00039	89 75 f8	 mov	 DWORD PTR __Old$1$[ebp], esi

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0003c	3b d9		 cmp	 ebx, ecx

; 3577 : 		if (_Masked > _Max)

  0003e	76 04		 jbe	 SHORT $LN34@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);

  00040	8b d9		 mov	 ebx, ecx
  00042	eb 18		 jmp	 SHORT $LN33@Reallocate
$LN34@Reallocate:

; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  00044	8b c6		 mov	 eax, esi
  00046	d1 e8		 shr	 eax, 1
  00048	2b c8		 sub	 ecx, eax
  0004a	3b f1		 cmp	 esi, ecx
  0004c	76 07		 jbe	 SHORT $LN35@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);

  0004e	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00053	eb 07		 jmp	 SHORT $LN33@Reallocate
$LN35@Reallocate:

; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00055	03 c6		 add	 eax, esi
  00057	3b d8		 cmp	 ebx, eax
  00059	0f 42 d8	 cmovb	 ebx, eax
$LN33@Reallocate:

; 3637 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3638 : 		auto& _Al = this->_Getal();
; 3639 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0005c	33 c9		 xor	 ecx, ecx
  0005e	8b c3		 mov	 eax, ebx
  00060	83 c0 01	 add	 eax, 1
  00063	0f 92 c1	 setb	 cl
  00066	f7 d9		 neg	 ecx
  00068	0b c8		 or	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0006a	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  0006c	33 f6		 xor	 esi, esi
  0006e	eb 32		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00070	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00076	72 1f		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00078	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 117  : 			if (_Block_size <= _User_size)

  0007b	3b c1		 cmp	 eax, ecx
  0007d	0f 86 c7 00 00
	00		 jbe	 $LN148@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00089	83 c4 04	 add	 esp, 4

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  0008c	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  0008f	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00092	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00095	eb 0b		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009d	83 c4 04	 add	 esp, 4

; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));

  000a0	8b f0		 mov	 esi, eax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3642 : 		_My_data._Myres = _New_capacity;

  000a2	8b 4d 18	 mov	 ecx, DWORD PTR _<_Args_2>$[ebp]
  000a5	8b 45 f0	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  000a8	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  000ab	8b 5d fc	 mov	 ebx, DWORD PTR __Old_size$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000ae	51		 push	 ecx
  000af	ff 75 f4	 push	 DWORD PTR _<_Args_1>$GSCopy$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3642 : 		_My_data._Myres = _New_capacity;

  000b2	43		 inc	 ebx
  000b3	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000b6	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000ba	56		 push	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000bb	72 66		 jb	 SHORT $LN3@Reallocate

; 3645 : 			{
; 3646 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000bd	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000bf	e8 00 00 00 00	 call	 _memcpy
  000c4	8b 45 fc	 mov	 eax, DWORD PTR __Old_size$1$[ebp]
  000c7	40		 inc	 eax
  000c8	50		 push	 eax
  000c9	8b 45 18	 mov	 eax, DWORD PTR _<_Args_2>$[ebp]
  000cc	03 c6		 add	 eax, esi
  000ce	53		 push	 ebx
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000d5	8b 45 f8	 mov	 eax, DWORD PTR __Old$1$[ebp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000d8	83 c4 18	 add	 esp, 24			; 00000018H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000db	40		 inc	 eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000dc	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000e1	72 23		 jb	 SHORT $LN111@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000e3	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  000e6	3b c8		 cmp	 ecx, eax
  000e8	76 33		 jbe	 SHORT $_Invalid_parameter$152

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000ea	8b c1		 mov	 eax, ecx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000ec	f6 c3 1f	 test	 bl, 31			; 0000001fH
  000ef	75 2c		 jne	 SHORT $_Invalid_parameter$152

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000f1	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  000f4	3b cb		 cmp	 ecx, ebx
  000f6	73 25		 jae	 SHORT $_Invalid_parameter$152

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000f8	2b d9		 sub	 ebx, ecx
  000fa	83 fb 04	 cmp	 ebx, 4
  000fd	72 1e		 jb	 SHORT $_Invalid_parameter$152

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)

  000ff	83 fb 23	 cmp	 ebx, 35			; 00000023H
  00102	77 19		 ja	 SHORT $_Invalid_parameter$152

; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00104	8b d9		 mov	 ebx, ecx
$LN111@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00106	50		 push	 eax
  00107	53		 push	 ebx
  00108	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010d	83 c4 08	 add	 esp, 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  00110	89 37		 mov	 DWORD PTR [edi], esi
  00112	8b c7		 mov	 eax, edi
  00114	5f		 pop	 edi
  00115	5e		 pop	 esi
  00116	5b		 pop	 ebx

; 3658 : 		}

  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 14 00	 ret	 20			; 00000014H
$_Invalid_parameter$152:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN149@Reallocate:
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00123	e8 00 00 00 00	 call	 _memcpy
  00128	8b 45 18	 mov	 eax, DWORD PTR _<_Args_2>$[ebp]
  0012b	53		 push	 ebx
  0012c	03 c6		 add	 eax, esi
  0012e	57		 push	 edi
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 _memcpy
  00135	83 c4 18	 add	 esp, 24			; 00000018H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  00138	89 37		 mov	 DWORD PTR [edi], esi
  0013a	8b c7		 mov	 eax, edi
  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx

; 3658 : 		}

  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c2 14 00	 ret	 20			; 00000014H
$LN146@Reallocate:

; 3631 : 			{
; 3632 : 			_Xlen();	// result too long

  00145	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN150@Reallocate:
$LN148@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  0014a	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
$LN151@Reallocate:
$LN145@Reallocate:
  0014f	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 99   : 			{	// destroy after unlocking

  00022	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 100  : 			if (_Myistr.rdbuf() != 0)

  00029	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00030	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  00034	85 c9		 test	 ecx, ecx
  00036	74 05		 je	 SHORT $LN4@sentry

; 101  : 				_Myistr.rdbuf()->_Unlock();

  00038	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003a	ff 50 08	 call	 DWORD PTR [eax+8]
$LN4@sentry:
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEIXZ
_TEXT	SEGMENT
__Num$1$ = -4						; size = 4
?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEIXZ PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits, COMDAT
; _this$ = ecx

; 3965 : 		{	// return a random value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3966 : 		_Udiff _Ret = 0;
; 3967 : 
; 3968 : 		for (size_t _Num = 0; _Num < CHAR_BIT * sizeof (_Udiff);
; 3969 : 			_Num += _Bits)

  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?_Random_device@std@@YAIXZ
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx
  0000f	33 f6		 xor	 esi, esi
  00011	89 75 fc	 mov	 DWORD PTR __Num$1$[ebp], esi
  00014	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
$LL4@Get_all_bi:

; 3970 : 			{	// don't mask away any bits
; 3971 : 			_Ret <<= _Bits - 1;	// avoid full shift

  00017	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0001a	d3 e6		 shl	 esi, cl

; 3972 : 			_Ret <<= 1;

  0001c	03 f6		 add	 esi, esi
  0001e	66 90		 npad	 2
$LL7@Get_all_bi:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  00020	ff d3		 call	 ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3989 : 			if (_Val <= _Bmask)

  00022	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00025	77 f9		 ja	 SHORT $LL7@Get_all_bi

; 3973 : 			_Ret |= _Get_bits();

  00027	8b 55 fc	 mov	 edx, DWORD PTR __Num$1$[ebp]
  0002a	0b f0		 or	 esi, eax
  0002c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002f	03 d0		 add	 edx, eax
  00031	89 55 fc	 mov	 DWORD PTR __Num$1$[ebp], edx
  00034	83 fa 20	 cmp	 edx, 32			; 00000020H
  00037	72 de		 jb	 SHORT $LL4@Get_all_bi

; 3974 : 			}
; 3975 : 
; 3976 : 		return (_Ret);

  00039	5f		 pop	 edi
  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx

; 3977 : 		}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEII@Z
_TEXT	SEGMENT
__Index$ = 8						; size = 4
??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEII@Z PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::operator(), COMDAT
; _this$ = ecx

; 3941 : 		{	// adapt _Urng closed range to [0, _Index)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Index$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	48		 dec	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Index$[ebp]
  0000f	90		 npad	 1
$LL2@operator:

; 3942 : 		for (;;)
; 3943 : 			{	// try a sample random value
; 3944 : 			_Udiff _Ret = 0;	// random bits

  00010	33 f6		 xor	 esi, esi

; 3945 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00012	33 db		 xor	 ebx, ebx

; 3946 : 
; 3947 : 			while (_Mask < _Udiff(_Index - 1))

  00014	85 c0		 test	 eax, eax
  00016	74 36		 je	 SHORT $LN6@operator

; 3954 : 				_Mask |= _Bmask;

  00018	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0001b	0f 1f 44 00 00	 npad	 5
$LL5@operator:

; 3948 : 				{	// need more random bits
; 3949 : 				_Ret <<= _Bits - 1;	// avoid full shift

  00020	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]
  00023	d3 e6		 shl	 esi, cl

; 3950 : 				_Ret <<= 1;

  00025	03 f6		 add	 esi, esi
$LL11@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3987 : 			_Udiff _Val = _Ref() - (_Urng::min)();

  0002d	8b c8		 mov	 ecx, eax

; 3988 : 
; 3989 : 			if (_Val <= _Bmask)

  0002f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00032	3b c8		 cmp	 ecx, eax
  00034	77 f1		 ja	 SHORT $LL11@operator

; 3951 : 				_Ret |= _Get_bits();

  00036	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00039	0b f1		 or	 esi, ecx

; 3952 : 				_Mask <<= _Bits - 1;	// avoid full shift

  0003b	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]
  0003e	d3 e3		 shl	 ebx, cl
  00040	8b 4d 08	 mov	 ecx, DWORD PTR __Index$[ebp]

; 3953 : 				_Mask <<= 1;

  00043	03 db		 add	 ebx, ebx

; 3954 : 				_Mask |= _Bmask;

  00045	0b d8		 or	 ebx, eax
  00047	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0004a	3b d8		 cmp	 ebx, eax
  0004c	72 d2		 jb	 SHORT $LL5@operator
$LN6@operator:

; 3955 : 				}
; 3956 : 
; 3957 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3958 : 			if (_Ret / _Index < _Mask / _Index
; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  0004e	33 d2		 xor	 edx, edx
  00050	8b c3		 mov	 eax, ebx
  00052	f7 f1		 div	 ecx
  00054	8b c8		 mov	 ecx, eax
  00056	8b da		 mov	 ebx, edx
  00058	33 d2		 xor	 edx, edx
  0005a	8b c6		 mov	 eax, esi
  0005c	f7 75 08	 div	 DWORD PTR __Index$[ebp]
  0005f	3b c1		 cmp	 eax, ecx
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Index$[ebp]
  00064	72 07		 jb	 SHORT $LN25@operator
  00066	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00069	3b d8		 cmp	 ebx, eax
  0006b	75 a3		 jne	 SHORT $LL2@operator
$LN25@operator:

; 3960 : 				return (_Ret % _Index);

  0006d	8b c6		 mov	 eax, esi
  0006f	33 d2		 xor	 edx, edx
  00071	f7 f1		 div	 ecx
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	8b c2		 mov	 eax, edx
  00077	5b		 pop	 ebx

; 3961 : 			}
; 3962 : 		}

  00078	5d		 pop	 ebp
  00079	c2 04 00	 ret	 4
??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QAEII@Z ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QAE@AAVrandom_device@1@@Z
_TEXT	SEGMENT
__Func$ = 8						; size = 4
??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QAE@AAVrandom_device@1@@Z PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>, COMDAT
; _this$ = ecx

; 3935 : 		{	// construct from URNG

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3934 : 		: _Ref(_Func), _Bits(CHAR_BIT * sizeof (_Udiff)), _Bmask(_Udiff(-1))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Func$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 3936 : 		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
; 3937 : 			--_Bits;
; 3938 : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	c7 41 04 20 00
	00 00		 mov	 DWORD PTR [ecx+4], 32	; 00000020H
  00011	c7 41 08 ff ff
	ff ff		 mov	 DWORD PTR [ecx+8], -1
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QAE@AAVrandom_device@1@@Z ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAII@Z
_TEXT	SEGMENT
?_Adjust@?$uniform_int@H@std@@CAII@Z PROC		; std::uniform_int<int>::_Adjust, COMDAT
; __Uval$ = ecx

; 2337 : 		{	// convert signed ranges to unsigned ranges and vice versa

  00000	8d 81 00 00 00
	80		 lea	 eax, DWORD PTR [ecx-2147483648]

; 2338 : 		return (_Adjust(_Uval, is_signed<_Ty>()));
; 2339 : 		}

  00006	c3		 ret	 0
?_Adjust@?$uniform_int@H@std@@CAII@Z ENDP		; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 121  : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 122  : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 115  : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 92   : 			: _Myistr(_Istr)

  00029	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0002c	89 16		 mov	 DWORD PTR [esi], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00033	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  00037	85 c9		 test	 ecx, ecx
  00039	74 05		 je	 SHORT $LN5@sentry

; 95   : 				_Myistr.rdbuf()->_Lock();

  0003b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003d	ff 50 04	 call	 DWORD PTR [eax+4]
$LN5@sentry:

; 116  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00040	ff 75 0c	 push	 DWORD PTR __Noskip$[ebp]
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00052	88 46 04	 mov	 BYTE PTR [esi+4], al

; 117  : 			}

  00055	8b c6		 mov	 eax, esi
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 100  : 			if (_Myistr.rdbuf() != 0)

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 101  : 				_Myistr.rdbuf()->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 102  : 			}

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 3677 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00004	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1583 : 		if (_Large_string_engaged())

  0000b	72 0a		 jb	 SHORT $LN31@erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2595 : 		return (*this);

  00012	8b c1		 mov	 eax, ecx

; 2596 : 		}

  00014	c2 04 00	 ret	 4
$LN31@erase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00017	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2595 : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 2596 : 		}

  0001c	c2 04 00	 ret	 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AAEIXZ
_TEXT	SEGMENT
?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AAEIXZ PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits, COMDAT
; _this$ = ecx

; 3984 : 		{	// return a random value within [0, _Bmask]

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?_Random_device@std@@YAIXZ
  00008	8b f1		 mov	 esi, ecx
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL2@Get_bits:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  00010	ff d7		 call	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3989 : 			if (_Val <= _Bmask)

  00012	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00015	77 f9		 ja	 SHORT $LL2@Get_bits

; 3990 : 				return (_Val);

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi

; 3991 : 			}
; 3992 : 		}

  00019	c3		 ret	 0
?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AAEIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z PROC ; std::uniform_int<int>::_Adjust, COMDAT
; __Uval$ = ecx

; 2342 : 		{	// convert signed ranges to unsigned ranges and vice versa

  00000	8d 81 00 00 00
	80		 lea	 eax, DWORD PTR [ecx-2147483648]

; 2343 : 		const _Uty _Adjuster = (_Uty(-1) >> 1) + 1;	// 2^(N-1)
; 2344 : 
; 2345 : 		if (_Uval < _Adjuster)
; 2346 : 			return (_Uval + _Adjuster);
; 2347 : 		else
; 2348 : 			return (_Uval - _Adjuster);
; 2349 : 		}

  00006	c3		 ret	 0
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ENDP ; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 93   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 			: _Myistr(_Istr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]

; 93   : 			{	// lock the stream buffer, if there

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 94   : 			if (_Myistr.rdbuf() != 0)

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN8@Sentry_bas

; 95   : 				_Myistr.rdbuf()->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 96   : 			}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
END
