; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_06JGCGFIEG@polish?$AA@			; `string'
PUBLIC	??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@		; `string'
PUBLIC	??_C@_05PDJBBECF@pause?$AA@			; `string'
PUBLIC	??_C@_0DL@POFCNLON@Jak?$LJ?5opcje?5chcesz?5obstawi?f?$DP?5?$CIzgo@ ; `string'
PUBLIC	??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@		; `string'
PUBLIC	??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@	; `string'
PUBLIC	??_C@_0BD@LEDAOJLK@r?5?9?5czerwone?5?$CIred?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BD@EPLAAEJB@b?5?9?5czarne?5?$CIblack?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@ ; `string'
PUBLIC	??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@	; `string'
PUBLIC	??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@ ; `string'
PUBLIC	??_C@_0CK@OAIPJBPB@w1?0?5w2?0?5?4?4?4?5?0?5w12?5?9?5wiersz?5trzec@ ; `string'
PUBLIC	??_C@_0CN@CGIAAFPM@0?936?5?9?5pojedy?qcze?5pole?5o?5odpowie@ ; `string'
PUBLIC	??_C@_01JBBJJEPG@p?$AA@				; `string'
PUBLIC	??_C@_01EFFIKLCJ@n?$AA@				; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_01OJONOECF@b?$AA@				; `string'
PUBLIC	??_C@_01JEJKBAGA@g?$AA@				; `string'
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	??_C@_02ICGBAFJO@k1?$AA@			; `string'
PUBLIC	??_C@_02KJEMFGFN@k2?$AA@			; `string'
PUBLIC	??_C@_02LAFHGHBM@k3?$AA@			; `string'
PUBLIC	??_C@_02JHFNFPIK@w1?$AA@			; `string'
PUBLIC	??_C@_02LMHAAMEJ@w2?$AA@			; `string'
PUBLIC	??_C@_02KFGLDNAI@w3?$AA@			; `string'
PUBLIC	??_C@_02OKCKKLMP@w4?$AA@			; `string'
PUBLIC	??_C@_02PDDBJKIO@w5?$AA@			; `string'
PUBLIC	??_C@_02NIBMMJEN@w6?$AA@			; `string'
PUBLIC	??_C@_02MBAHPIAM@w7?$AA@			; `string'
PUBLIC	??_C@_02EGJPOEMD@w8?$AA@			; `string'
PUBLIC	??_C@_02FPIENFIC@w9?$AA@			; `string'
PUBLIC	??_C@_03NCLMABJC@w10?$AA@			; `string'
PUBLIC	??_C@_03MLKHDAND@w11?$AA@			; `string'
PUBLIC	??_C@_03OAIKGDBA@w12?$AA@			; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_01FDFGLJHB@2?$AA@				; `string'
PUBLIC	??_C@_01EKENIIDA@3?$AA@				; `string'
PUBLIC	??_C@_01FAMBOPH@4?$AA@				; `string'
PUBLIC	??_C@_01BMBHCPLG@5?$AA@				; `string'
PUBLIC	??_C@_01DHDKHMHF@6?$AA@				; `string'
PUBLIC	??_C@_01COCBENDE@7?$AA@				; `string'
PUBLIC	??_C@_01KJLJFBPL@8?$AA@				; `string'
PUBLIC	??_C@_01LAKCGALK@9?$AA@				; `string'
PUBLIC	??_C@_02PKFBJPLJ@10?$AA@			; `string'
PUBLIC	??_C@_02ODEKKOPI@11?$AA@			; `string'
PUBLIC	??_C@_02MIGHPNDL@12?$AA@			; `string'
PUBLIC	??_C@_02NBHMMMHK@13?$AA@			; `string'
PUBLIC	??_C@_02JODNFKLN@14?$AA@			; `string'
PUBLIC	??_C@_02IHCGGLPM@15?$AA@			; `string'
PUBLIC	??_C@_02KMALDIDP@16?$AA@			; `string'
PUBLIC	??_C@_02LFBAAJHO@17?$AA@			; `string'
PUBLIC	??_C@_02DCIIBFLB@18?$AA@			; `string'
PUBLIC	??_C@_02CLJDCEPA@19?$AA@			; `string'
PUBLIC	??_C@_02PIBHCBOA@20?$AA@			; `string'
PUBLIC	??_C@_02OBAMBAKB@21?$AA@			; `string'
PUBLIC	??_C@_02MKCBEDGC@22?$AA@			; `string'
PUBLIC	??_C@_02NDDKHCCD@23?$AA@			; `string'
PUBLIC	??_C@_02JMHLOEOE@24?$AA@			; `string'
PUBLIC	??_C@_02IFGANFKF@25?$AA@			; `string'
PUBLIC	??_C@_02KOENIGGG@26?$AA@			; `string'
PUBLIC	??_C@_02LHFGLHCH@27?$AA@			; `string'
PUBLIC	??_C@_02DAMOKLOI@28?$AA@			; `string'
PUBLIC	??_C@_02CJNFJKKJ@29?$AA@			; `string'
PUBLIC	??_C@_02PJNFELNH@30?$AA@			; `string'
PUBLIC	??_C@_02OAMOHKJG@31?$AA@			; `string'
PUBLIC	??_C@_02MLODCJFF@32?$AA@			; `string'
PUBLIC	??_C@_02NCPIBIBE@33?$AA@			; `string'
PUBLIC	??_C@_02JNLJIOND@34?$AA@			; `string'
PUBLIC	??_C@_02IEKCLPJC@35?$AA@			; `string'
PUBLIC	??_C@_02KPIPOMFB@36?$AA@			; `string'
PUBLIC	??_C@_0CF@MANFGHNE@$?0?5jak?$LJ?5kwot?$LJ?5chcesz?5obstawi?f?5wy@ ; `string'
PUBLIC	??_C@_05OMMBNPEF@Masz?5?$AA@			; `string'
PUBLIC	??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@ ; `string'
PUBLIC	??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@ ; `string'
PUBLIC	??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@ ; `string'
PUBLIC	??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@ ; `string'
PUBLIC	??_C@_02MGHEPNFN@?$AI?$AI?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@	; `string'
PUBLIC	??_C@_02KHOJGJKF@?4?5?$AA@			; `string'
PUBLIC	??_C@_02DEPNMBPN@$?4?$AA@			; `string'
PUBLIC	??_C@_0CB@GINPHDN@Obstawi?$LDe?$JM?5poprawnie?0?5wygrywasz?5@ ; `string'
PUBLIC	??_C@_0EF@MDKBMGPE@Obstawi?$LDe?$JM?5niepoprawnie?5lecz?5uda@ ; `string'
PUBLIC	??_C@_0CF@BAJKLKHM@Obstawi?$LDe?$JM?5niepoprawnie?0?5przegra@ ; `string'
PUBLIC	??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@ ; `string'
PUBLIC	??_C@_0CO@DOCNGCMI@$?0?5czy?5chcesz?5grac?5dalej?5?$CI?8t?8?9ta@ ; `string'
PUBLIC	??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@	; `string'
PUBLIC	??_C@_01PFHFFBPC@t?$AA@				; `string'
PUBLIC	??_C@_03PFPKAEFD@tak?$AA@			; `string'
PUBLIC	??_C@_03FFMIKLGN@Tak?$AA@			; `string'
PUBLIC	??_C@_03PIABMJCP@TAK?$AA@			; `string'
PUBLIC	??_C@_03FKMOMPJO@nie?$AA@			; `string'
PUBLIC	??_C@_03PKPMGAKA@Nie?$AA@			; `string'
PUBLIC	??_C@_03FHDFACOC@NIE?$AA@			; `string'
PUBLIC	??_C@_04IBLEHOMF@?4wav?$AA@			; `string'
PUBLIC	??_C@_05PNHGCFLK@p?4wav?$AA@			; `string'
PUBLIC	??_C@_05MEKKEGFB@n?4wav?$AA@			; `string'
PUBLIC	??_C@_05LALOIELB@r?4wav?$AA@			; `string'
PUBLIC	??_C@_05LDGIIGCK@b?4wav?$AA@			; `string'
PUBLIC	??_C@_05ODKFBHJJ@g?4wav?$AA@			; `string'
PUBLIC	??_C@_05GFDBGFDH@d?4wav?$AA@			; `string'
PUBLIC	??_C@_01DICPFPGM@k?$AA@				; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@	; `string'
PUBLIC	??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@ ; `string'
PUBLIC	??_C@_09LFKNBKJA@Posiadasz?$AA@			; `string'
PUBLIC	??_C@_0L@DAFLKCID@Wylosowano?$AA@		; `string'
PUBLIC	??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@		; `string'
PUBLIC	??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@	; `string'
PUBLIC	??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@		; `string'
PUBLIC	??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@	; `string'
PUBLIC	??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@	; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@ ; `string'
PUBLIC	??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@	; `string'
PUBLIC	??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@ ; `string'
PUBLIC	??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ ; `string'
PUBLIC	??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@ ; `string'
PUBLIC	??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@ ; `string'
PUBLIC	??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@ ; `string'
PUBLIC	??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@ ; `string'
PUBLIC	??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@ ; `string'
PUBLIC	??_C@_05CMOJBPHN@G?$LDos?1?$AA@			; `string'
PUBLIC	??_C@_05KFCKMKOB@Jacek?$AA@			; `string'
PUBLIC	??_C@_03FPCJKMNP@Ewa?$AA@			; `string'
PUBLIC	??_C@_04CDICBAGM@Maja?$AA@			; `string'
PUBLIC	??_C@_03JIHJHPIE@Jan?$AA@			; `string'
PUBLIC	??_C@_06DKNIKMFF@Jacek2?$AA@			; `string'
PUBLIC	??_C@_04PLEDLCJI@Ewa2?$AA@			; `string'
PUBLIC	??_C@_05KJFHPLBC@Maja2?$AA@			; `string'
PUBLIC	??_C@_04HDNGKDH@Jan2?$AA@			; `string'
PUBLIC	??_C@_05NKPCGME@Agata?$AA@			; `string'
PUBLIC	??_C@_01IDAFKMJL@_?$AA@				; `string'
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_04JLFAMLOH@G?$LDos?$AA@			; `string'
PUBLIC	??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ ; `string'
PUBLIC	??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@ ; `string'
PUBLIC	??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@ ; `string'
PUBLIC	??_C@_0M@COFBHHKL@setting?4txt?$AA@		; `string'
PUBLIC	??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@ ; `string'
PUBLIC	??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ ; `string'
PUBLIC	??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@ ; `string'
PUBLIC	??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@ ; `string'
PUBLIC	??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@ ; `string'
PUBLIC	??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@ ; `string'
PUBLIC	??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@	; `string'
PUBLIC	??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@	; `string'
PUBLIC	??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@ ; `string'
PUBLIC	??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@ ; `string'
PUBLIC	??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@	; `string'
PUBLIC	??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@ ; `string'
PUBLIC	??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@ ; `string'
PUBLIC	??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@ ; `string'
PUBLIC	??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@ ; `string'
PUBLIC	??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@ ; `string'
PUBLIC	??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@ ; `string'
PUBLIC	??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@ ; `string'
PUBLIC	??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@ ; `string'
PUBLIC	??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@ ; `string'
PUBLIC	??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@ ; `string'
PUBLIC	??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@ ; `string'
PUBLIC	??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@ ; `string'
PUBLIC	??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@ ; `string'
PUBLIC	??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ ; `string'
PUBLIC	??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ ; `string'
PUBLIC	??_C@_01EPMOAMKG@$?$AA@				; `string'
PUBLIC	??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@		; `string'
PUBLIC	??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@		; `string'
PUBLIC	??_C@_07KIPBKJCE@win?4wav?$AA@			; `string'
PUBLIC	??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@ ; `string'
PUBLIC	??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@		; `string'
PUBLIC	??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@ ; `string'
PUBLIC	??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@ ; `string'
PUBLIC	??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@ ; `string'
PUBLIC	??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@ ; `string'
PUBLIC	??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@		; `string'
PUBLIC	??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@	; `string'
PUBLIC	??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@	; `string'
PUBLIC	??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@ ; `string'
PUBLIC	??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@		; `string'
PUBLIC	??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@ ; `string'
PUBLIC	??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ ; `string'
PUBLIC	??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@ ; `string'
PUBLIC	??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@ ; `string'
PUBLIC	??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@	; `string'
PUBLIC	??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@	; `string'
PUBLIC	??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@	; `string'
PUBLIC	??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@	; `string'
PUBLIC	??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@	; `string'
PUBLIC	??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@ ; `string'
PUBLIC	??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	_CTA2?AVbad_cast@std@@
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	?EfektyKompletne@@3_NA				; EfektyKompletne
PUBLIC	_TI2?AVbad_cast@std@@
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Czas@@3U_SYSTEMTIME@@A				; Czas
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?G³osyKompletne@@3_NA				; G³osyKompletne
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
EXTRN	__imp_??Bid@locale@std@@QEAA_KXZ:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?is@?$ctype@D@std@@QEBA_NFD@Z:PROC
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z:PROC
EXTRN	__imp_?rdstate@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?eof@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_?getloc@ios_base@std@@QEBA?AVlocale@2@XZ:PROC
EXTRN	__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	__imp_?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z:PROC
EXTRN	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync
EXTRN	__imp_?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC
EXTRN	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
EXTRN	__imp_?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z:PROC
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC
EXTRN	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow
EXTRN	__imp_?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC
EXTRN	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC
EXTRN	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAPEAD0PEAH001@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z:PROC
EXTRN	__imp__get_stream_buffer_pointers:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_GetSystemTime:PROC
EXTRN	__imp_CreateDirectoryA:PROC
EXTRN	__imp_fsetpos:PROC
EXTRN	__imp___std_terminate:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp_memchr:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp_fgetpos:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp__lock_file:PROC
EXTRN	__imp__unlock_file:PROC
EXTRN	__imp_SetConsoleCursorInfo:PROC
EXTRN	__imp__access:PROC
EXTRN	__imp_system:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_PlaySoundA:PROC
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__imp__invalid_parameter_noinfo:PROC
EXTRN	__imp_fgetc:PROC
EXTRN	atexit:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp___std_exception_copy:PROC
EXTRN	__imp_URLDownloadToFileA:PROC
EXTRN	__imp_remove:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Random_device@std@@YAIXZ:PROC
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:QWORD
EXTRN	__imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z:PROC
EXTRN	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:QWORD
EXTRN	__imp_?_BADOFF@std@@3_JB:QWORD
EXTRN	__imp_?_Xout_of_range@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exceptions@std@@YAHXZ:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	__imp_fclose:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	__imp_fflush:PROC
EXTRN	__imp_GetConsoleCursorInfo:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_SetConsoleTextAttribute:PROC
EXTRN	__imp_memmove:PROC
EXTRN	__imp_fputc:PROC
EXTRN	__imp_setlocale:PROC
EXTRN	__imp___std_exception_destroy:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp___CxxFrameHandler3:PROC
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
?Czas@@3U_SYSTEMTIME@@A DB 010H DUP (?)			; Czas
_BSS	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0b8H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	imagerel ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	098H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	0b8H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 01H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	098H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
	DD	imagerel ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 01H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
	DD	imagerel ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_cast@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 01H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	imagerel ??_R3bad_cast@std@@8
	DD	imagerel ??_R4bad_cast@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	0b0H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DQ	FLAT:??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0b0H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT _TI2?AVbad_cast@std@@
xdata$x	SEGMENT
_TI2?AVbad_cast@std@@ DD 00H
	DD	imagerel ??1bad_cast@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVbad_cast@std@@
?EfektyKompletne@@3_NA DB 01H				; EfektyKompletne
?G³osyKompletne@@3_NA DB 01H				; G³osyKompletne
_DATA	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DQ	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT _CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
_CTA2?AVbad_cast@std@@ DD 02H
	DD	imagerel _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
	DD	0a8H
CONST	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DQ FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DQ	FLAT:??_Ebad_cast@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD imagerel ??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	088H
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	imagerel ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD imagerel ??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	0a8H
?Ruletka_ko³o@@3QBGB DW 00H				; Ruletka_ko³o
	DW	020H
	DW	0fH
	DW	013H
	DW	04H
	DW	015H
	DW	02H
	DW	019H
	DW	011H
	DW	022H
	DW	06H
	DW	01bH
	DW	0dH
	DW	024H
	DW	0bH
	DW	01eH
	DW	08H
	DW	017H
	DW	0aH
	DW	05H
	DW	018H
	DW	010H
	DW	021H
	DW	01H
	DW	014H
	DW	0eH
	DW	01fH
	DW	09H
	DW	016H
	DW	012H
	DW	01dH
	DW	07H
	DW	01cH
	DW	0cH
	DW	023H
	DW	03H
	DW	01aH
	ORG $+6
?Ruletka_plansza_kolor_col@@3QBGB DW 02H		; Ruletka_plansza_kolor_col
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	DW	08H
	DW	04H
	ORG $+6
?Ruletka_plansza_kolor@@3QBDB DB 067H			; Ruletka_plansza_kolor
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0a8H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$alloc'
	DB	'ator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	imagerel ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@
CONST	SEGMENT
??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@ DB 'efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@
CONST	SEGMENT
??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@ DB 'g', 0b3H, 'o'
	DB	's_szybko', 09cH, 0e6H, '_odczytu_numeru', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@
CONST	SEGMENT
??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@ DB 'g', 0b3H, 'os_odczytu_n'
	DB	'umeru', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@
CONST	SEGMENT
??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@ DB 'czy_kontynuowa', 0e6H, '_'
	DB	'gr', 0eaH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@
CONST	SEGMENT
??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@ DB 'stan_d', 09fH, 'wi', 0eaH, 'k'
	DB	0f3H, 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@
CONST	SEGMENT
??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@ DB 'kwota_pocz', 0b9H, 'tkowa'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@
CONST	SEGMENT
??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@ DB 'styl_liczenia_wygranej'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@
CONST	SEGMENT
??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@ DB 'czas_przeskoku_kul'
	DB	'ki_wolny', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@
CONST	SEGMENT
??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@ DB 'czas_przeskoku_ku'
	DB	'lki_szybki', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
CONST	SEGMENT
??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ DB 'ilo', 09cH, 0e6H
	DB	'_max_dodatkowych_obrot', 0f3H, 'w_ruletki', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@
CONST	SEGMENT
??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@ DB 'ilo', 09cH
	DB	0e6H, '_minimalna_obrot', 0f3H, 'w_ruletki', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
CONST	SEGMENT
??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@ DB ' Wylosowano ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@
CONST	SEGMENT
??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@ DB 'Kulka w gr'
	DB	'ze, zaczekaj na wylosowanie numeru...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
CONST	SEGMENT
??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@ DB ' Obstawiono zaklad ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@
CONST	SEGMENT
??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@ DB 'Obstawiono zak', 0b3H
	DB	'ad ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
CONST	SEGMENT
??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@ DB 'Obstawiono za ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@
CONST	SEGMENT
??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@ DB 'Gratuluje zwi'
	DB	0eaH, 'kszy', 0b3H, 'e', 09cH, ' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@
CONST	SEGMENT
??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@ DB ' krotnie '
	DB	'sw', 0f3H, 'j zas', 0f3H, 'b finansowy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@
CONST	SEGMENT
??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@ DB 'Grat'
	DB	'uluje zwi', 0eaH, 'kszy', 0b3H, 'e', 09cH, ' sw', 0f3H, 'j za'
	DB	's', 0f3H, 'b finansowy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
CONST	SEGMENT
??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@ DB 'Ko', 0f1H, 'cz'
	DB	'ysz gr', 0eaH, ' z wynikiem ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
CONST	SEGMENT
??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@ DB ' Przegrales ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
CONST	SEGMENT
??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@ DB ' Dostajesz '
	DB	'polowe zak', 0b3H, 'adu ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KIPBKJCE@win?4wav?$AA@
CONST	SEGMENT
??_C@_07KIPBKJCE@win?4wav?$AA@ DB 'win.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
CONST	SEGMENT
??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@ DB ' Posiadasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
CONST	SEGMENT
??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@ DB ' Wygrywasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EPMOAMKG@$?$AA@
CONST	SEGMENT
??_C@_01EPMOAMKG@$?$AA@ DB '$', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
CONST	SEGMENT
??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ DB 'N'
	DB	'ie mo', 0bfH, 'esz mie', 0e6H, ' wy', 0b3H, 0b9H, 'czonych d', 09fH
	DB	'wi', 0eaH, 'k', 0f3H, 'w i w', 0b3H, 0b9H, 'czon', 0b9H, ' mo'
	DB	'w', 0eaH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
CONST	SEGMENT
??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ DB 'N'
	DB	'ie mo', 0bfH, 'esz mie', 0e6H, ' wy', 0b3H, 0b9H, 'czonych d', 09fH
	DB	'wi', 0eaH, 'k', 0f3H, 'w i w', 0b3H, 0b9H, 'czonych efekt', 0f3H
	DB	'w d', 09fH, 'wi', 0eaH, 'kowych', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@
CONST	SEGMENT
??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@ DB 'Opcja efe'
	DB	'kty d', 09fH, 'wi', 0eaH, 'kowe przyjmuje warto', 09cH, 'ci 0'
	DB	' lub 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@
CONST	SEGMENT
??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@ DB 'Opcja'
	DB	' szybko', 09cH, 0e6H, ' g', 0b3H, 'osu odczytu przyjmuje wart'
	DB	'o', 09cH, 'ci w przedziale [1;5]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@
CONST	SEGMENT
??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@ DB 'Opcja g', 0b3H
	DB	'os odczytu numeru przyjmuje warto', 09cH, 'ci w przedziale [0'
	DB	';10]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@
CONST	SEGMENT
??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@ DB 'Opcja kontynu'
	DB	'owania gry przyjmuje warto', 09cH, 'ci tylko 0 lub 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@
CONST	SEGMENT
??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@ DB 'Stan '
	DB	'd', 09fH, 'wi', 0eaH, 'k', 0f3H, 'w przyjmuje warto', 09cH, 'c'
	DB	'i tylko 0 lub 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@
CONST	SEGMENT
??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@ DB 'Kwot'
	DB	'a pocz', 0b9H, 'tkowa nie mo', 0bfH, 'e by', 0e6H, ' mniejsza'
	DB	' od zera', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@
CONST	SEGMENT
??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@ DB 'Czas'
	DB	' przerwy d', 09fH, 'wi', 0eaH, 'ku nie mo', 0bfH, 'e by', 0e6H
	DB	' mniejszy od zera', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@
CONST	SEGMENT
??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@ DB 'Styl liczeia '
	DB	'wygranej przyjmuje warto', 09cH, 'ci tylko 0 lub 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@
CONST	SEGMENT
??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@ DB 'Jedna z dek'
	DB	'laracji w sprawie obrot', 0f3H, 'w ruletki musi by', 0e6H, ' '
	DB	'wi', 0eaH, 'ksza od zera', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@
CONST	SEGMENT
??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@ DB 'Ilo', 09cH
	DB	0e6H, ' max obrot', 0f3H, 'w ruletki nie mo', 0bfH, 'e by', 0e6H
	DB	' mniejsza od 0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@
CONST	SEGMENT
??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@ DB 'Ilo', 09cH
	DB	0e6H, ' minimalna obrot', 0f3H, 'w ruletki nie mo', 0bfH, 'e b'
	DB	'y', 0e6H, ' mniejsza od 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
CONST	SEGMENT
??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@ DB 'Ustawiam do'
	DB	'my', 09cH, 'lne ustawienie', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@
CONST	SEGMENT
??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@ DB 'Warto', 09cH
	DB	0e6H, ' wolnego czasu przeskoku kulki musi by', 0e6H, ' ni', 0bfH
	DB	'sza ni', 0bfH, ' warto', 09cH, 0e6H, ' szybkiego czasu przesk'
	DB	'oku kulki', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@
CONST	SEGMENT
??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@ DB 'efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@
CONST	SEGMENT
??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@ DB 'g', 0b3H
	DB	'os_szybko', 09cH, 0e6H, '_odczytu_numeru 4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@
CONST	SEGMENT
??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@ DB 'g', 0b3H, 'os_odczyt'
	DB	'u_numeru 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@
CONST	SEGMENT
??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@ DB 'czy_kontynuowa', 0e6H
	DB	'_gr', 0eaH, ' 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@
CONST	SEGMENT
??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@ DB 'stan_d', 09fH, 'wi', 0eaH
	DB	'k', 0f3H, 'w 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@
CONST	SEGMENT
??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@ DB 'kwota_pocz', 0b9H, 't'
	DB	'kowa 1000', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@
CONST	SEGMENT
??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@ DB 'styl_liczenia_wygra'
	DB	'nej 1', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@
CONST	SEGMENT
??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@ DB 'czas_przerwy_dzwi', 0eaH
	DB	'ku 500', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@
CONST	SEGMENT
??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@ DB 'czas_przeskoku'
	DB	'_kulki_wolny 75', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@
CONST	SEGMENT
??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@ DB 'czas_przeskok'
	DB	'u_kulki_szybki 50', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
CONST	SEGMENT
??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ DB 'ilo', 09cH, 0e6H
	DB	'_max_dodatkowych_obrot', 0f3H, 'w_ruletki 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@
CONST	SEGMENT
??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@ DB 'ilo', 09cH
	DB	0e6H, '_minimalna_obrot', 0f3H, 'w_ruletki 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COFBHHKL@setting?4txt?$AA@
CONST	SEGMENT
??_C@_0M@COFBHHKL@setting?4txt?$AA@ DB 'setting.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@
CONST	SEGMENT
??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@ DB 'Pobr'
	DB	'ano brakuj', 0b9H, 'ce pliki g', 0b3H, 'os', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
CONST	SEGMENT
??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@ DB 'Brak p'
	DB	'lik', 0f3H, 'w dla g', 0b3H, 'osu oraz nie mo', 0bfH, 'na pob'
	DB	'ra', 0e6H, ' danych, wy', 0b3H, 0b9H, 'czono odczytywanie wyn'
	DB	'iku', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
CONST	SEGMENT
??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ DB 'Rozpoczynam'
	DB	' pobieranie brakuj', 0b9H, 'cych plik', 0f3H, 'w g', 0b3H, 'o'
	DB	's', 0f3H, 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLFAMLOH@G?$LDos?$AA@
CONST	SEGMENT
??_C@_04JLFAMLOH@G?$LDos?$AA@ DB 'G', 0b3H, 'os', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/G%C5%82os/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IDAFKMJL@_?$AA@
CONST	SEGMENT
??_C@_01IDAFKMJL@_?$AA@ DB '_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NKPCGME@Agata?$AA@
CONST	SEGMENT
??_C@_05NKPCGME@Agata?$AA@ DB 'Agata', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDNGKDH@Jan2?$AA@
CONST	SEGMENT
??_C@_04HDNGKDH@Jan2?$AA@ DB 'Jan2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KJFHPLBC@Maja2?$AA@
CONST	SEGMENT
??_C@_05KJFHPLBC@Maja2?$AA@ DB 'Maja2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PLEDLCJI@Ewa2?$AA@
CONST	SEGMENT
??_C@_04PLEDLCJI@Ewa2?$AA@ DB 'Ewa2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKNIKMFF@Jacek2?$AA@
CONST	SEGMENT
??_C@_06DKNIKMFF@Jacek2?$AA@ DB 'Jacek2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JIHJHPIE@Jan?$AA@
CONST	SEGMENT
??_C@_03JIHJHPIE@Jan?$AA@ DB 'Jan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CDICBAGM@Maja?$AA@
CONST	SEGMENT
??_C@_04CDICBAGM@Maja?$AA@ DB 'Maja', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FPCJKMNP@Ewa?$AA@
CONST	SEGMENT
??_C@_03FPCJKMNP@Ewa?$AA@ DB 'Ewa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFCKMKOB@Jacek?$AA@
CONST	SEGMENT
??_C@_05KFCKMKOB@Jacek?$AA@ DB 'Jacek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
CONST	SEGMENT
??_C@_05CMOJBPHN@G?$LDos?1?$AA@ DB 'G', 0b3H, 'os/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@
CONST	SEGMENT
??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@ DB 'Pobran'
	DB	'o brakuj', 0b9H, 'ce pliki efekt', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/zwielokrotnenie.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
CONST	SEGMENT
??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/zwielokrotnenie.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/wygrana2.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
CONST	SEGMENT
??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/wygrana2.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/wygrana1.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
CONST	SEGMENT
??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/wygrana1.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
CONST	SEGMENT
??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@ DB 'Brak p'
	DB	'lik', 0f3H, 'w dla efekt', 0f3H, 'w d', 09fH, 'wi', 0eaH, 'ko'
	DB	'wych oraz nie mo', 0bfH, 'na pobra', 0e6H, ' danych, wy', 0b3H
	DB	0b9H, 'czono efekty d', 09fH, 'wi', 0eaH, 'kowe muzyczne, w', 0b3H
	DB	0b9H, 'czono efekty systemowe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/bankrut.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
CONST	SEGMENT
??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ DB 'Rozpoczynam'
	DB	' pobieranie brakuj', 0b9H, 'cych plik', 0f3H, 'w efekt', 0f3H
	DB	'w', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
CONST	SEGMENT
??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/bankrut.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
CONST	SEGMENT
??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@ DB 'Efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@
CONST	SEGMENT
??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@ DB 'Nowa gra rozpoc'
	DB	'zeta dnia ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@
CONST	SEGMENT
??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@ DB 'Gra rozpoczeta dnia ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
CONST	SEGMENT
??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@ DB ' o godzinie ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@
CONST	SEGMENT
??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@ DB 'Gra rozpoczeta dnia', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@
CONST	SEGMENT
??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@ DB 'Obstawiono za', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
CONST	SEGMENT
??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@ DB 'Obstawiono zaklad', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
CONST	SEGMENT
??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@ DB ' Wylosowano', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DAFLKCID@Wylosowano?$AA@
CONST	SEGMENT
??_C@_0L@DAFLKCID@Wylosowano?$AA@ DB 'Wylosowano', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LFKNBKJA@Posiadasz?$AA@
CONST	SEGMENT
??_C@_09LFKNBKJA@Posiadasz?$AA@ DB 'Posiadasz', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@
CONST	SEGMENT
??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@ DB 'Uruch'
	DB	'omiono ponownie gr', 0eaH, ' z wy', 0b3H, 0b9H, 'czon', 0b9H, ' '
	DB	'opcj', 0b9H, ' kontynuowania', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
CONST	SEGMENT
??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@ DB 'log_aktualny.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DICPFPGM@k?$AA@
CONST	SEGMENT
??_C@_01DICPFPGM@k?$AA@ DB 'k', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFDBGFDH@d?4wav?$AA@
CONST	SEGMENT
??_C@_05GFDBGFDH@d?4wav?$AA@ DB 'd.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ODKFBHJJ@g?4wav?$AA@
CONST	SEGMENT
??_C@_05ODKFBHJJ@g?4wav?$AA@ DB 'g.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LDGIIGCK@b?4wav?$AA@
CONST	SEGMENT
??_C@_05LDGIIGCK@b?4wav?$AA@ DB 'b.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LALOIELB@r?4wav?$AA@
CONST	SEGMENT
??_C@_05LALOIELB@r?4wav?$AA@ DB 'r.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEKKEGFB@n?4wav?$AA@
CONST	SEGMENT
??_C@_05MEKKEGFB@n?4wav?$AA@ DB 'n.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PNHGCFLK@p?4wav?$AA@
CONST	SEGMENT
??_C@_05PNHGCFLK@p?4wav?$AA@ DB 'p.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBLEHOMF@?4wav?$AA@
CONST	SEGMENT
??_C@_04IBLEHOMF@?4wav?$AA@ DB '.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FHDFACOC@NIE?$AA@
CONST	SEGMENT
??_C@_03FHDFACOC@NIE?$AA@ DB 'NIE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PKPMGAKA@Nie?$AA@
CONST	SEGMENT
??_C@_03PKPMGAKA@Nie?$AA@ DB 'Nie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKMOMPJO@nie?$AA@
CONST	SEGMENT
??_C@_03FKMOMPJO@nie?$AA@ DB 'nie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PIABMJCP@TAK?$AA@
CONST	SEGMENT
??_C@_03PIABMJCP@TAK?$AA@ DB 'TAK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFMIKLGN@Tak?$AA@
CONST	SEGMENT
??_C@_03FFMIKLGN@Tak?$AA@ DB 'Tak', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFPKAEFD@tak?$AA@
CONST	SEGMENT
??_C@_03PFPKAEFD@tak?$AA@ DB 'tak', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PFHFFBPC@t?$AA@
CONST	SEGMENT
??_C@_01PFHFFBPC@t?$AA@ DB 't', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@
CONST	SEGMENT
??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@ DB 'Na koncie masz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DOCNGCMI@$?0?5czy?5chcesz?5grac?5dalej?5?$CI?8t?8?9ta@
CONST	SEGMENT
??_C@_0CO@DOCNGCMI@$?0?5czy?5chcesz?5grac?5dalej?5?$CI?8t?8?9ta@ DB '$, c'
	DB	'zy chcesz grac dalej (''t''-tak, ''n''-nie) ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@
CONST	SEGMENT
??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@ DB 'Nie m'
	DB	'o', 0bfH, 'esz kontynuowa', 0e6H, ', przegra', 0b3H, 'e', 09cH
	DB	' wszystko', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BAJKLKHM@Obstawi?$LDe?$JM?5niepoprawnie?0?5przegra@
CONST	SEGMENT
??_C@_0CF@BAJKLKHM@Obstawi?$LDe?$JM?5niepoprawnie?0?5przegra@ DB 'Obstawi'
	DB	0b3H, 'e', 09cH, ' niepoprawnie, przegra', 0b3H, 'e', 09cH, ' '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@MDKBMGPE@Obstawi?$LDe?$JM?5niepoprawnie?5lecz?5uda@
CONST	SEGMENT
??_C@_0EF@MDKBMGPE@Obstawi?$LDe?$JM?5niepoprawnie?5lecz?5uda@ DB 'Obstawi'
	DB	0b3H, 'e', 09cH, ' niepoprawnie lecz uda', 0b3H, 'o Ci si', 0eaH
	DB	', dostajesz po', 0b3H, 'ow', 0eaH, ' zak', 0b3H, 'adu ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GINPHDN@Obstawi?$LDe?$JM?5poprawnie?0?5wygrywasz?5@
CONST	SEGMENT
??_C@_0CB@GINPHDN@Obstawi?$LDe?$JM?5poprawnie?0?5wygrywasz?5@ DB 'Obstawi'
	DB	0b3H, 'e', 09cH, ' poprawnie, wygrywasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DEPNMBPN@$?4?$AA@
CONST	SEGMENT
??_C@_02DEPNMBPN@$?4?$AA@ DB '$.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KHOJGJKF@?4?5?$AA@
CONST	SEGMENT
??_C@_02KHOJGJKF@?4?5?$AA@ DB '. ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
CONST	SEGMENT
??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@ DB 'Wylosowano numer ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
CONST	SEGMENT
??_C@_02MGHEPNFN@?$AI?$AI?$AA@ DB 08H, 08H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@
CONST	SEGMENT
??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@ DB 'Ni'
	DB	'e mo', 0bfH, 'esz obstawi', 0e6H, ' ujemn', 0b9H, ' kwot', 0b9H
	DB	' zak', 0b3H, 'adu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@
CONST	SEGMENT
??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@ DB 'Nie masz tyle pie'
	DB	'ni', 0eaH, 'dzy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@
CONST	SEGMENT
??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@ DB 'Nie mo', 0bfH
	DB	'esz obstawi', 0e6H, ' zerowego zak', 0b3H, 'adu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@
CONST	SEGMENT
??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@ DB 'Wpro'
	DB	'wadzi', 0b3H, 'e', 0e6H, ' nieprawid', 0b3H, 'ow', 0b9H, ' wa'
	DB	'rto', 09cH, 0e6H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OMMBNPEF@Masz?5?$AA@
CONST	SEGMENT
??_C@_05OMMBNPEF@Masz?5?$AA@ DB 'Masz ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MANFGHNE@$?0?5jak?$LJ?5kwot?$LJ?5chcesz?5obstawi?f?5wy@
CONST	SEGMENT
??_C@_0CF@MANFGHNE@$?0?5jak?$LJ?5kwot?$LJ?5chcesz?5obstawi?f?5wy@ DB '$, '
	DB	'jak', 0b9H, ' kwot', 0b9H, ' chcesz obstawi', 0e6H, ' wynik?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPIPOMFB@36?$AA@
CONST	SEGMENT
??_C@_02KPIPOMFB@36?$AA@ DB '36', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IEKCLPJC@35?$AA@
CONST	SEGMENT
??_C@_02IEKCLPJC@35?$AA@ DB '35', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JNLJIOND@34?$AA@
CONST	SEGMENT
??_C@_02JNLJIOND@34?$AA@ DB '34', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NCPIBIBE@33?$AA@
CONST	SEGMENT
??_C@_02NCPIBIBE@33?$AA@ DB '33', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MLODCJFF@32?$AA@
CONST	SEGMENT
??_C@_02MLODCJFF@32?$AA@ DB '32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OAMOHKJG@31?$AA@
CONST	SEGMENT
??_C@_02OAMOHKJG@31?$AA@ DB '31', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PJNFELNH@30?$AA@
CONST	SEGMENT
??_C@_02PJNFELNH@30?$AA@ DB '30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CJNFJKKJ@29?$AA@
CONST	SEGMENT
??_C@_02CJNFJKKJ@29?$AA@ DB '29', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DAMOKLOI@28?$AA@
CONST	SEGMENT
??_C@_02DAMOKLOI@28?$AA@ DB '28', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LHFGLHCH@27?$AA@
CONST	SEGMENT
??_C@_02LHFGLHCH@27?$AA@ DB '27', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KOENIGGG@26?$AA@
CONST	SEGMENT
??_C@_02KOENIGGG@26?$AA@ DB '26', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IFGANFKF@25?$AA@
CONST	SEGMENT
??_C@_02IFGANFKF@25?$AA@ DB '25', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMHLOEOE@24?$AA@
CONST	SEGMENT
??_C@_02JMHLOEOE@24?$AA@ DB '24', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NDDKHCCD@23?$AA@
CONST	SEGMENT
??_C@_02NDDKHCCD@23?$AA@ DB '23', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MKCBEDGC@22?$AA@
CONST	SEGMENT
??_C@_02MKCBEDGC@22?$AA@ DB '22', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OBAMBAKB@21?$AA@
CONST	SEGMENT
??_C@_02OBAMBAKB@21?$AA@ DB '21', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PIBHCBOA@20?$AA@
CONST	SEGMENT
??_C@_02PIBHCBOA@20?$AA@ DB '20', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLJDCEPA@19?$AA@
CONST	SEGMENT
??_C@_02CLJDCEPA@19?$AA@ DB '19', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCIIBFLB@18?$AA@
CONST	SEGMENT
??_C@_02DCIIBFLB@18?$AA@ DB '18', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFBAAJHO@17?$AA@
CONST	SEGMENT
??_C@_02LFBAAJHO@17?$AA@ DB '17', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KMALDIDP@16?$AA@
CONST	SEGMENT
??_C@_02KMALDIDP@16?$AA@ DB '16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IHCGGLPM@15?$AA@
CONST	SEGMENT
??_C@_02IHCGGLPM@15?$AA@ DB '15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JODNFKLN@14?$AA@
CONST	SEGMENT
??_C@_02JODNFKLN@14?$AA@ DB '14', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NBHMMMHK@13?$AA@
CONST	SEGMENT
??_C@_02NBHMMMHK@13?$AA@ DB '13', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MIGHPNDL@12?$AA@
CONST	SEGMENT
??_C@_02MIGHPNDL@12?$AA@ DB '12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ODEKKOPI@11?$AA@
CONST	SEGMENT
??_C@_02ODEKKOPI@11?$AA@ DB '11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PKFBJPLJ@10?$AA@
CONST	SEGMENT
??_C@_02PKFBJPLJ@10?$AA@ DB '10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LAKCGALK@9?$AA@
CONST	SEGMENT
??_C@_01LAKCGALK@9?$AA@ DB '9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8?$AA@
CONST	SEGMENT
??_C@_01KJLJFBPL@8?$AA@ DB '8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01COCBENDE@7?$AA@
CONST	SEGMENT
??_C@_01COCBENDE@7?$AA@ DB '7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DHDKHMHF@6?$AA@
CONST	SEGMENT
??_C@_01DHDKHMHF@6?$AA@ DB '6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BMBHCPLG@5?$AA@
CONST	SEGMENT
??_C@_01BMBHCPLG@5?$AA@ DB '5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FAMBOPH@4?$AA@
CONST	SEGMENT
??_C@_01FAMBOPH@4?$AA@ DB '4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EKENIIDA@3?$AA@
CONST	SEGMENT
??_C@_01EKENIIDA@3?$AA@ DB '3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FDFGLJHB@2?$AA@
CONST	SEGMENT
??_C@_01FDFGLJHB@2?$AA@ DB '2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OAIKGDBA@w12?$AA@
CONST	SEGMENT
??_C@_03OAIKGDBA@w12?$AA@ DB 'w12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MLKHDAND@w11?$AA@
CONST	SEGMENT
??_C@_03MLKHDAND@w11?$AA@ DB 'w11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NCLMABJC@w10?$AA@
CONST	SEGMENT
??_C@_03NCLMABJC@w10?$AA@ DB 'w10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FPIENFIC@w9?$AA@
CONST	SEGMENT
??_C@_02FPIENFIC@w9?$AA@ DB 'w9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGJPOEMD@w8?$AA@
CONST	SEGMENT
??_C@_02EGJPOEMD@w8?$AA@ DB 'w8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MBAHPIAM@w7?$AA@
CONST	SEGMENT
??_C@_02MBAHPIAM@w7?$AA@ DB 'w7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NIBMMJEN@w6?$AA@
CONST	SEGMENT
??_C@_02NIBMMJEN@w6?$AA@ DB 'w6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDDBJKIO@w5?$AA@
CONST	SEGMENT
??_C@_02PDDBJKIO@w5?$AA@ DB 'w5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OKCKKLMP@w4?$AA@
CONST	SEGMENT
??_C@_02OKCKKLMP@w4?$AA@ DB 'w4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KFGLDNAI@w3?$AA@
CONST	SEGMENT
??_C@_02KFGLDNAI@w3?$AA@ DB 'w3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMHAAMEJ@w2?$AA@
CONST	SEGMENT
??_C@_02LMHAAMEJ@w2?$AA@ DB 'w2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JHFNFPIK@w1?$AA@
CONST	SEGMENT
??_C@_02JHFNFPIK@w1?$AA@ DB 'w1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LAFHGHBM@k3?$AA@
CONST	SEGMENT
??_C@_02LAFHGHBM@k3?$AA@ DB 'k3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KJEMFGFN@k2?$AA@
CONST	SEGMENT
??_C@_02KJEMFGFN@k2?$AA@ DB 'k2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ICGBAFJO@k1?$AA@
CONST	SEGMENT
??_C@_02ICGBAFJO@k1?$AA@ DB 'k1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JEJKBAGA@g?$AA@
CONST	SEGMENT
??_C@_01JEJKBAGA@g?$AA@ DB 'g', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OJONOECF@b?$AA@
CONST	SEGMENT
??_C@_01OJONOECF@b?$AA@ DB 'b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n?$AA@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n?$AA@ DB 'n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p?$AA@
CONST	SEGMENT
??_C@_01JBBJJEPG@p?$AA@ DB 'p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CGIAAFPM@0?936?5?9?5pojedy?qcze?5pole?5o?5odpowie@
CONST	SEGMENT
??_C@_0CN@CGIAAFPM@0?936?5?9?5pojedy?qcze?5pole?5o?5odpowie@ DB '0-36 - p'
	DB	'ojedy', 0f1H, 'cze pole o odpowiednim numerze', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OAIPJBPB@w1?0?5w2?0?5?4?4?4?5?0?5w12?5?9?5wiersz?5trzec@
CONST	SEGMENT
??_C@_0CK@OAIPJBPB@w1?0?5w2?0?5?4?4?4?5?0?5w12?5?9?5wiersz?5trzec@ DB 'w1'
	DB	', w2, ... , w12 - wiersz trzech numer', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@
CONST	SEGMENT
??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@ DB 'k1, k'
	DB	'2, k3 - kolumna 1, kolumna 2, kolumna 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@
CONST	SEGMENT
??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@ DB 'd - dolna po', 0b3H, 'o'
	DB	'wa', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@
CONST	SEGMENT
??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@ DB 'g - g', 0f3H, 'rna p'
	DB	'o', 0b3H, 'owa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EPLAAEJB@b?5?9?5czarne?5?$CIblack?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@EPLAAEJB@b?5?9?5czarne?5?$CIblack?$CJ?$AA@ DB 'b - czarne (blac'
	DB	'k)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LEDAOJLK@r?5?9?5czerwone?5?$CIred?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@LEDAOJLK@r?5?9?5czerwone?5?$CIred?$CJ?$AA@ DB 'r - czerwone (re'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@
CONST	SEGMENT
??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@ DB 'n - nieparzyste', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@
CONST	SEGMENT
??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@ DB 'p - parzyste', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@POFCNLON@Jak?$LJ?5opcje?5chcesz?5obstawi?f?$DP?5?$CIzgo@
CONST	SEGMENT
??_C@_0DL@POFCNLON@Jak?$LJ?5opcje?5chcesz?5obstawi?f?$DP?5?$CIzgo@ DB 'Ja'
	DB	'k', 0b9H, ' opcje chcesz obstawi', 0e6H, '? (zgodnie z poni', 0bfH
	DB	'szym opisem) :', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause?$AA@
CONST	SEGMENT
??_C@_05PDJBBECF@pause?$AA@ DB 'pause', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@
CONST	SEGMENT
??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@ DB 'log_og', 0f3H, 'lny.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGCGFIEG@polish?$AA@
CONST	SEGMENT
??_C@_06JGCGFIEG@polish?$AA@ DB 'polish', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ; std::uniform_int<int>::_Adjust
PUBLIC	?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAII@Z		; std::uniform_int<int>::_Adjust
PUBLIC	??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAA@AEAVrandom_device@1@@Z ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>
PUBLIC	??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z ; std::_Rng_from_urng<unsigned int,std::random_device>::operator()
PUBLIC	?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ; std::_Traits_equal<std::char_traits<char> >
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const & __ptr64>
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const & __ptr64>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * __ptr64 const & __ptr64>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z ; std::uniform_int<int>::_Eval<std::random_device>
PUBLIC	??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > & __ptr64>
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
PUBLIC	?_Get_bytes@?$_Default_allocate_traits@$00@std@@SAPEAX_K0@Z ; std::_Default_allocate_traits<1>::_Get_bytes
PUBLIC	??0bad_cast@std@@QEAA@AEBV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPEAX_K0_K@Z ; std::_Allocate<std::_Default_allocate_traits<1> >
PUBLIC	??$?0AEBV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const & __ptr64,void>
PUBLIC	??$construct@PEADAEBQEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEADAEBQEAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 const & __ptr64>
PUBLIC	??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z		; std::_Refancy<char * __ptr64,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$destroy@PEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char * __ptr64>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char * __ptr64>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> & __ptr64>
PUBLIC	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > & __ptr64>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z		; std::_Min_value<unsigned __int64>
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$size@D$0BN@@std@@YA_KAEAY0BN@$$CBD@Z		; std::size<char,29>
PUBLIC	??$size@D$0BE@@std@@YA_KAEAY0BE@$$CBD@Z		; std::size<char,20>
PUBLIC	??$size@D$0O@@std@@YA_KAEAY0O@$$CBD@Z		; std::size<char,14>
PUBLIC	??$size@D$0BB@@std@@YA_KAEAY0BB@$$CBD@Z		; std::size<char,17>
PUBLIC	??$size@D$0BH@@std@@YA_KAEAY0BH@$$CBD@Z		; std::size<char,23>
PUBLIC	??$size@D$0BL@@std@@YA_KAEAY0BL@$$CBD@Z		; std::size<char,27>
PUBLIC	??$size@D$0BM@@std@@YA_KAEAY0BM@$$CBD@Z		; std::size<char,28>
PUBLIC	??$size@D$0CG@@std@@YA_KAEAY0CG@$$CBD@Z		; std::size<char,38>
PUBLIC	??$size@D$0CA@@std@@YA_KAEAY0CA@$$CBD@Z		; std::size<char,32>
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z ; std::uniform_int<int>::operator()<std::random_device>
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Init@param_type@?$uniform_int@H@std@@QEAAXHH@Z ; std::uniform_int<int>::param_type::_Init
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?seed@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAAX_K0@Z ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::seed
PUBLIC	??0param_type@?$uniform_int@H@std@@QEAA@HH@Z	; std::uniform_int<int>::param_type::param_type
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	?seekpos@?$fpos@U_Mbstatet@@@std@@QEBA_JXZ	; std::fpos<_Mbstatet>::seekpos
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z		; std::_Max_value<unsigned __int64>
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
PUBLIC	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEBV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
PUBLIC	?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEAV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA@_K00@Z ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>
PUBLIC	?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_lower
PUBLIC	?_Refill_upper@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_upper
PUBLIC	??0?$uniform_int@H@std@@QEAA@HH@Z		; std::uniform_int<int>::uniform_int<int>
PUBLIC	?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ; std::pointer_traits<char * __ptr64>::pointer_to
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ; std::basic_fstream<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_fstream<char,std::char_traits<char> >::close
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	??0?$mersenne_twister_engine@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0FFFFFFFFFFFFFFFF@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@$0FIFBPECNEMJFHPCN@@std@@QEAA@_K@Z ; std::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>
PUBLIC	??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::operator()
PUBLIC	??0?$uniform_int_distribution@H@std@@QEAA@HH@Z	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
PUBLIC	?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ustaw_ustawienia
PUBLIC	?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; Pêtla_g³ówna
PUBLIC	?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z ; Koniec_gry
PUBLIC	?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ; Og³o_wynik
PUBLIC	?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?Sprawd_ustawienia@@YAXXZ			; Sprawd_ustawienia
PUBLIC	?Sprawd_Pliki@@YAXXZ				; Sprawd_Pliki
PUBLIC	?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Wczytaj_z_pliku
PUBLIC	?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
PUBLIC	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Odczytaj_liczbê
PUBLIC	?Wylosuj@@YAHAEBH0@Z				; Wylosuj
PUBLIC	?Show_Cursor@@YAXXZ				; Show_Cursor
PUBLIC	?Hide_Cursor@@YAXXZ				; Hide_Cursor
PUBLIC	?Change_Col@@YAXAEBH@Z				; Change_Col
PUBLIC	?Czy_Kontynuowaæ@@YA_NAEBH@Z			; Czy_Kontynuowaæ
PUBLIC	?Sprawd_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Sprawd_Zak³ad
PUBLIC	?Zakrêæ_Ruletk¹@@YAHXZ				; Zakrêæ_Ruletk¹
PUBLIC	?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z		; Wczytaj_Kwotê_Zak³adu
PUBLIC	?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Obstaw
PUBLIC	?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	main
PUBLIC	??0S_Ustawienia@@QEAA@XZ			; S_Ustawienia::S_Ustawienia
PUBLIC	??Rrandom_device@std@@QEAAIXZ			; std::random_device::operator()
PUBLIC	?entropy@random_device@std@@QEBANXZ		; std::random_device::entropy
PUBLIC	?max@random_device@std@@SAIXZ			; std::random_device::max
PUBLIC	?min@random_device@std@@SAIXZ			; std::random_device::min
PUBLIC	??0random_device@std@@QEAA@XZ			; std::random_device::random_device
PUBLIC	??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z	; std::_Ungetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z	; std::locale::_Getfacet
PUBLIC	??1locale@std@@QEAA@XZ				; std::locale::~locale
PUBLIC	??1bad_cast@std@@UEAA@XZ			; std::bad_cast::~bad_cast
PUBLIC	??_Gbad_cast@std@@UEAAPEAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QEAA@XZ			; std::bad_cast::bad_cast
PUBLIC	??$_Convert_size@_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64>
PUBLIC	?_Deallocate@std@@YAXPEAX_K1_K@Z		; std::_Deallocate
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?not_eof@?$char_traits@D@std@@SAHAEBH@Z		; std::char_traits<char>::not_eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHAEBD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?to_char_type@?$char_traits@D@std@@SADAEBH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?eq@?$char_traits@D@std@@SA_NAEBD0@Z		; std::char_traits<char>::eq
PUBLIC	?assign@?$char_traits@D@std@@SAXAEADAEBD@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z	; std::char_traits<char>::move
PUBLIC	?find@?$char_traits@D@std@@SAPEBDQEBD_KAEBD@Z	; std::char_traits<char>::find
PUBLIC	?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SA_KQEBD@Z		; std::char_traits<char>::length
PUBLIC	?compare@?$char_traits@D@std@@SAHQEBD0_K@Z	; std::char_traits<char>::compare
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	?Ustawienia@@3US_Ustawienia@@A			; Ustawienia
PUBLIC	__real@4040000000000000
PUBLIC	__real@4042800000000000
PUBLIC	__xmm@000000000000000f0000000000000000
EXTRN	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UEAAPEAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH:PROC
EXTRN	__std_terminate:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN10
	DD	imagerel $LN10+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ DD imagerel $LN17
	DD	imagerel $LN17+33
	DD	imagerel $unwind$?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+45
	DD	imagerel $unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD imagerel $LN12
	DD	imagerel $LN12+88
	DD	imagerel $unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z DD imagerel $LN33
	DD	imagerel $LN33+166
	DD	imagerel $unwind$??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ DD imagerel $LN25
	DD	imagerel $LN25+92
	DD	imagerel $unwind$?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+45
	DD	imagerel $unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+61
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+61
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+382
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+382
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+388
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+388
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+394
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+41
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+328
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+328
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+334
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+334
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+340
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD imagerel $LN9
	DD	imagerel $LN9+41
	DD	imagerel $unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD imagerel $LN112
	DD	imagerel $LN112+467
	DD	imagerel $unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+56
	DD	imagerel $unwind$?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD imagerel $LN159
	DD	imagerel $LN159+427
	DD	imagerel $unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA+56
	DD	imagerel $unwind$?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z DD imagerel $LN91
	DD	imagerel $LN91+141
	DD	imagerel $unwind$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN180
	DD	imagerel $LN180+529
	DD	imagerel $unwind$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA DD imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA+56
	DD	imagerel $unwind$?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z DD imagerel ??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z
	DD	imagerel ??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z+86
	DD	imagerel $unwind$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN36
	DD	imagerel $LN36+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN36+48
	DD	imagerel $LN36+198
	DD	imagerel $chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN36+198
	DD	imagerel $LN36+236
	DD	imagerel $chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD imagerel $LN52
	DD	imagerel $LN52+59
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD imagerel $LN52+59
	DD	imagerel $LN52+210
	DD	imagerel $chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD imagerel $LN52+210
	DD	imagerel $LN52+248
	DD	imagerel $chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN66
	DD	imagerel $LN66+76
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN66+76
	DD	imagerel $LN66+175
	DD	imagerel $chain$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN66+175
	DD	imagerel $LN66+186
	DD	imagerel $chain$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN66+186
	DD	imagerel $LN66+193
	DD	imagerel $chain$2$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD imagerel $LN29
	DD	imagerel $LN29+73
	DD	imagerel $unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+11
	DD	imagerel $unwind$?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@AEBV01@@Z DD imagerel $LN6
	DD	imagerel $LN6+64
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPEAX_K0_K@Z DD imagerel $LN15
	DD	imagerel $LN15+77
	DD	imagerel $unwind$??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPEAX_K0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+56
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+388
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+388
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+394
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+394
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+400
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+46
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+418
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+418
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+424
	DD	imagerel $chain$5$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+424
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+430
	DD	imagerel $chain$6$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+39
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+298
	DD	imagerel $chain$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+298
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+305
	DD	imagerel $chain$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+305
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+311
	DD	imagerel $chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+311
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+317
	DD	imagerel $chain$5$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z DD imagerel ??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z
	DD	imagerel ??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z+278
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+47
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+352
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+352
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+358
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+358
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+364
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel $LN25
	DD	imagerel $LN25+275
	DD	imagerel $unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN26
	DD	imagerel $LN26+60
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN26+60
	DD	imagerel $LN26+191
	DD	imagerel $chain$1$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN26+191
	DD	imagerel $LN26+199
	DD	imagerel $chain$3$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN26+199
	DD	imagerel $LN26+220
	DD	imagerel $chain$4$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD imagerel $LN69
	DD	imagerel $LN69+144
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z DD imagerel $LN89
	DD	imagerel $LN89+124
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z DD imagerel $LN71
	DD	imagerel $LN71+173
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA DD imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD imagerel $LN75
	DD	imagerel $LN75+87
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z DD imagerel $LN81
	DD	imagerel $LN81+161
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA DD imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z DD imagerel $LN67
	DD	imagerel $LN67+74
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD imagerel $LN203
	DD	imagerel $LN203+128
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z DD imagerel $LN93
	DD	imagerel $LN93+121
	DD	imagerel $unwind$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD imagerel $LN32
	DD	imagerel $LN32+73
	DD	imagerel $unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD imagerel $LN34
	DD	imagerel $LN34+71
	DD	imagerel $unwind$??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN114
	DD	imagerel $LN114+461
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+56
	DD	imagerel $unwind$?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DD imagerel $LN114
	DD	imagerel $LN114+442
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA DD imagerel ?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
	DD	imagerel ?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA+56
	DD	imagerel $unwind$?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD imagerel $LN25
	DD	imagerel $LN25+275
	DD	imagerel $unwind$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD imagerel $LN51
	DD	imagerel $LN51+30
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD imagerel $LN51+30
	DD	imagerel $LN51+141
	DD	imagerel $chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD imagerel $LN51+141
	DD	imagerel $LN51+163
	DD	imagerel $chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD imagerel $LN51+163
	DD	imagerel $LN51+169
	DD	imagerel $chain$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN10
	DD	imagerel $LN10+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+45
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN22
	DD	imagerel $LN22+79
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN18
	DD	imagerel $LN18+83
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel $LN51
	DD	imagerel $LN51+53
	DD	imagerel $unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN533
	DD	imagerel $LN533+293
	DD	imagerel $unwind$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DD imagerel $LN47
	DD	imagerel $LN47+182
	DD	imagerel $unwind$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD imagerel $LN16
	DD	imagerel $LN16+90
	DD	imagerel $unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel $LN23
	DD	imagerel $LN23+212
	DD	imagerel $unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD imagerel $LN19
	DD	imagerel $LN19+127
	DD	imagerel $unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD imagerel $LN13
	DD	imagerel $LN13+192
	DD	imagerel $unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN580
	DD	imagerel $LN580+501
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN77
	DD	imagerel $LN77+49
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN77+49
	DD	imagerel $LN77+160
	DD	imagerel $chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN77+160
	DD	imagerel $LN77+182
	DD	imagerel $chain$3$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN77+182
	DD	imagerel $LN77+188
	DD	imagerel $chain$4$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z DD imagerel $LN90
	DD	imagerel $LN90+60
	DD	imagerel $unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z DD imagerel $LN90+60
	DD	imagerel $LN90+182
	DD	imagerel $chain$0$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z DD imagerel $LN90+182
	DD	imagerel $LN90+188
	DD	imagerel $chain$2$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD imagerel ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
	DD	imagerel ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z+72
	DD	imagerel $unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24+35
	DD	imagerel $LN24+99
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24+99
	DD	imagerel $LN24+129
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z DD imagerel ??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
	DD	imagerel ??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z+72
	DD	imagerel $unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN24+35
	DD	imagerel $LN24+102
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN24+102
	DD	imagerel $LN24+132
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z DD imagerel ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z
	DD	imagerel ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z+42
	DD	imagerel $unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24
	DD	imagerel $LN24+25
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24+25
	DD	imagerel $LN24+78
	DD	imagerel $chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24+78
	DD	imagerel $LN24+99
	DD	imagerel $chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN32
	DD	imagerel $LN32+35
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN32+35
	DD	imagerel $LN32+91
	DD	imagerel $chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN32+91
	DD	imagerel $LN32+112
	DD	imagerel $chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN159
	DD	imagerel $LN159+65
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN159+65
	DD	imagerel $LN159+313
	DD	imagerel $chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN159+313
	DD	imagerel $LN159+326
	DD	imagerel $chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z DD imagerel ??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z
	DD	imagerel ??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z+57
	DD	imagerel $unwind$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN50
	DD	imagerel $LN50+123
	DD	imagerel $unwind$?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN59
	DD	imagerel $LN59+113
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD imagerel $LN7
	DD	imagerel $LN7+21
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN27
	DD	imagerel $LN27+126
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+72
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ DD imagerel $LN18
	DD	imagerel $LN18+264
	DD	imagerel $unwind$?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+52
	DD	imagerel $unwind$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+146
	DD	imagerel $unwind$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN18
	DD	imagerel $LN18+149
	DD	imagerel $unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD imagerel $LN50
	DD	imagerel $LN50+201
	DD	imagerel $unwind$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN171
	DD	imagerel $LN171+32
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN171+32
	DD	imagerel $LN171+69
	DD	imagerel $chain$0$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN171+69
	DD	imagerel $LN171+183
	DD	imagerel $chain$2$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN171+183
	DD	imagerel $LN171+286
	DD	imagerel $chain$5$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN171+286
	DD	imagerel $LN171+734
	DD	imagerel $chain$10$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN171+734
	DD	imagerel $LN171+741
	DD	imagerel $chain$12$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN171+741
	DD	imagerel $LN171+747
	DD	imagerel $chain$13$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN77
	DD	imagerel $LN77+425
	DD	imagerel $unwind$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN57
	DD	imagerel $LN57+270
	DD	imagerel $unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel $LN59
	DD	imagerel $LN59+192
	DD	imagerel $unwind$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN539
	DD	imagerel $LN539+333
	DD	imagerel $unwind$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+115
	DD	imagerel $unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN724
	DD	imagerel $LN724+717
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN85
	DD	imagerel $LN85+229
	DD	imagerel $unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN26
	DD	imagerel $LN26+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN26+51
	DD	imagerel $LN26+79
	DD	imagerel $chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN26+79
	DD	imagerel $LN26+103
	DD	imagerel $chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN721
	DD	imagerel $LN721+778
	DD	imagerel $unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN23
	DD	imagerel $LN23+268
	DD	imagerel $unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN18
	DD	imagerel $LN18+240
	DD	imagerel $unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN9
	DD	imagerel $LN9+89
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN15
	DD	imagerel $LN15+67
	DD	imagerel $unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD imagerel $LN14
	DD	imagerel $LN14+80
	DD	imagerel $unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN23
	DD	imagerel $LN23+212
	DD	imagerel $unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+198
	DD	imagerel $unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN23
	DD	imagerel $LN23+212
	DD	imagerel $unwind$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+198
	DD	imagerel $unwind$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD imagerel $LN6
	DD	imagerel $LN6+69
	DD	imagerel $unwind$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN23
	DD	imagerel $LN23+220
	DD	imagerel $unwind$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+198
	DD	imagerel $unwind$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN112
	DD	imagerel $LN112+187
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD imagerel $LN47
	DD	imagerel $LN47+44
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD imagerel $LN47+44
	DD	imagerel $LN47+97
	DD	imagerel $chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD imagerel $LN47+97
	DD	imagerel $LN47+122
	DD	imagerel $chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN54
	DD	imagerel $LN54+38
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN54+38
	DD	imagerel $LN54+103
	DD	imagerel $chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN54+103
	DD	imagerel $LN54+129
	DD	imagerel $chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel $LN24
	DD	imagerel $LN24+42
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN71
	DD	imagerel $LN71+73
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN74
	DD	imagerel $LN74+113
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN66
	DD	imagerel $LN66+22
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN66+22
	DD	imagerel $LN66+104
	DD	imagerel $chain$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN66+104
	DD	imagerel $LN66+126
	DD	imagerel $chain$3$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN66+126
	DD	imagerel $LN66+135
	DD	imagerel $chain$4$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN33
	DD	imagerel $LN33+21
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN33+21
	DD	imagerel $LN33+95
	DD	imagerel $chain$0$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN33+95
	DD	imagerel $LN33+123
	DD	imagerel $chain$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD imagerel $LN27
	DD	imagerel $LN27+79
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z DD imagerel $LN32
	DD	imagerel $LN32+89
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN46
	DD	imagerel $LN46+86
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN46+86
	DD	imagerel $LN46+206
	DD	imagerel $chain$1$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN46+206
	DD	imagerel $LN46+214
	DD	imagerel $chain$3$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN46+214
	DD	imagerel $LN46+234
	DD	imagerel $chain$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN91
	DD	imagerel $LN91+49
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN91+49
	DD	imagerel $LN91+160
	DD	imagerel $chain$1$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN91+160
	DD	imagerel $LN91+185
	DD	imagerel $chain$3$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN91+185
	DD	imagerel $LN91+191
	DD	imagerel $chain$4$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD imagerel $LN32
	DD	imagerel $LN32+126
	DD	imagerel $unwind$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD imagerel $LN32+126
	DD	imagerel $LN32+371
	DD	imagerel $chain$1$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD imagerel $LN32+371
	DD	imagerel $LN32+458
	DD	imagerel $chain$2$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN1761
	DD	imagerel $LN1761+307
	DD	imagerel $unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN1761+307
	DD	imagerel $LN1761+1423
	DD	imagerel $chain$2$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN1761+1423
	DD	imagerel $LN1761+1775
	DD	imagerel $chain$3$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN1761+1775
	DD	imagerel $LN1761+3343
	DD	imagerel $chain$4$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN1761+3343
	DD	imagerel $LN1761+3361
	DD	imagerel $chain$5$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD imagerel $LN284
	DD	imagerel $LN284+314
	DD	imagerel $unwind$?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD imagerel $LN284+314
	DD	imagerel $LN284+1260
	DD	imagerel $chain$0$?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z DD imagerel $LN28
	DD	imagerel $LN28+596
	DD	imagerel $unwind$?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z DD imagerel $LN189
	DD	imagerel $LN189+1171
	DD	imagerel $unwind$?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA DD imagerel ?dtor$1@?0??Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA
	DD	imagerel ?dtor$1@?0??Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+22
	DD	imagerel $unwind$?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN19
	DD	imagerel $LN19+210
	DD	imagerel $unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Sprawd_ustawienia@@YAXXZ DD imagerel $LN176
	DD	imagerel $LN176+2313
	DD	imagerel $unwind$?Sprawd_ustawienia@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??Sprawd_ustawienia@@YAXXZ@4HA DD imagerel ?dtor$4@?0??Sprawd_ustawienia@@YAXXZ@4HA
	DD	imagerel ?dtor$4@?0??Sprawd_ustawienia@@YAXXZ@4HA+46
	DD	imagerel $unwind$?dtor$4@?0??Sprawd_ustawienia@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Sprawd_Pliki@@YAXXZ DD imagerel $LN4777
	DD	imagerel $LN4777+9192
	DD	imagerel $unwind$?Sprawd_Pliki@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$118@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$118@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$118@?0??Sprawd_Pliki@@YAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$118@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$148@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$148@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$148@?0??Sprawd_Pliki@@YAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$148@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$178@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$178@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$178@?0??Sprawd_Pliki@@YAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$178@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$208@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$208@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$208@?0??Sprawd_Pliki@@YAXXZ@4HA+41
	DD	imagerel $unwind$?dtor$208@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$243@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$243@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$243@?0??Sprawd_Pliki@@YAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$243@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$365@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$365@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$365@?0??Sprawd_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$365@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$395@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$395@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$395@?0??Sprawd_Pliki@@YAXXZ@4HA+46
	DD	imagerel $unwind$?dtor$395@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$430@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$430@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$430@?0??Sprawd_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$430@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$546@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$546@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$546@?0??Sprawd_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$546@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$573@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$573@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$573@?0??Sprawd_Pliki@@YAXXZ@4HA+46
	DD	imagerel $unwind$?dtor$573@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$608@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$608@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$608@?0??Sprawd_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$608@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$712@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$712@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$712@?0??Sprawd_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$712@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$739@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$739@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$739@?0??Sprawd_Pliki@@YAXXZ@4HA+46
	DD	imagerel $unwind$?dtor$739@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$774@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$774@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$774@?0??Sprawd_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$774@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$878@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$878@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$878@?0??Sprawd_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$878@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$905@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$905@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$905@?0??Sprawd_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$905@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$940@?0??Sprawd_Pliki@@YAXXZ@4HA DD imagerel ?dtor$940@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$940@?0??Sprawd_Pliki@@YAXXZ@4HA+46
	DD	imagerel $unwind$?dtor$940@?0??Sprawd_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel $LN3061
	DD	imagerel $LN3061+6287
	DD	imagerel $unwind$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+22
	DD	imagerel $unwind$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+95
	DD	imagerel $unwind$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN2536
	DD	imagerel $LN2536+3881
	DD	imagerel $unwind$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+49
	DD	imagerel $unwind$?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$119@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$119@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$119@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+38
	DD	imagerel $unwind$?dtor$119@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$149@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$149@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$149@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+38
	DD	imagerel $unwind$?dtor$149@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$191@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$191@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$191@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+38
	DD	imagerel $unwind$?dtor$191@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$221@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$221@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$221@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+38
	DD	imagerel $unwind$?dtor$221@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$263@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$263@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$263@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+43
	DD	imagerel $unwind$?dtor$263@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$293@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$293@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$293@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+43
	DD	imagerel $unwind$?dtor$293@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$325@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$325@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$325@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+43
	DD	imagerel $unwind$?dtor$325@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$427@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$427@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$427@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+54
	DD	imagerel $unwind$?dtor$427@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$433@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$433@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$433@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+43
	DD	imagerel $unwind$?dtor$433@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Wylosuj@@YAHAEBH0@Z DD imagerel $LN130
	DD	imagerel $LN130+141
	DD	imagerel $unwind$?Wylosuj@@YAHAEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Show_Cursor@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+97
	DD	imagerel $unwind$?Show_Cursor@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Hide_Cursor@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$?Hide_Cursor@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Change_Col@@YAXAEBH@Z DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$?Change_Col@@YAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Czy_Kontynuowaæ@@YA_NAEBH@Z DD imagerel $LN635
	DD	imagerel $LN635+885
	DD	imagerel $unwind$?Czy_Kontynuowaæ@@YA_NAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Sprawd_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD imagerel $LN349
	DD	imagerel $LN349+808
	DD	imagerel $unwind$?Sprawd_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN166
	DD	imagerel $LN166+29
	DD	imagerel $unwind$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN166+29
	DD	imagerel $LN166+41
	DD	imagerel $chain$2$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN166+41
	DD	imagerel $LN166+204
	DD	imagerel $chain$6$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN166+204
	DD	imagerel $LN166+422
	DD	imagerel $chain$7$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN166+422
	DD	imagerel $LN166+450
	DD	imagerel $chain$8$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN166+450
	DD	imagerel $LN166+937
	DD	imagerel $chain$9$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN166+937
	DD	imagerel $LN166+989
	DD	imagerel $chain$10$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z DD imagerel $LN181
	DD	imagerel $LN181+488
	DD	imagerel $unwind$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel $LN2069
	DD	imagerel $LN2069+2423
	DD	imagerel $unwind$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+22
	DD	imagerel $unwind$?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN19
	DD	imagerel $LN19+210
	DD	imagerel $unwind$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+22
	DD	imagerel $unwind$?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN19
	DD	imagerel $LN19+210
	DD	imagerel $unwind$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN138
	DD	imagerel $LN138+824
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$5 DD imagerel main$dtor$5
	DD	imagerel main$dtor$5+49
	DD	imagerel $unwind$main$dtor$5
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FG³os@@YAXXZ DD imagerel ??__FG³os@@YAXXZ
	DD	imagerel ??__FG³os@@YAXXZ+118
	DD	imagerel $unwind$??__FG³os@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD imagerel $LN6
	DD	imagerel $LN6+41
	DD	imagerel $unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1locale@std@@QEAA@XZ DD imagerel $LN7
	DD	imagerel $LN7+54
	DD	imagerel $unwind$??1locale@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_cast@std@@UEAAPEAXI@Z DD imagerel $LN11
	DD	imagerel $LN11+67
	DD	imagerel $unwind$??_Gbad_cast@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate@std@@YAXPEAX_K1_K@Z DD imagerel $LN19
	DD	imagerel $LN19+71
	DD	imagerel $unwind$?_Deallocate@std@@YAXPEAX_K1_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?compare@?$char_traits@D@std@@SAHQEBD0_K@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$?compare@?$char_traits@D@std@@SAHQEBD0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+67
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memcpy_s DD imagerel memcpy_s
	DD	imagerel memcpy_s+59
	DD	imagerel $unwind$memcpy_s
pdata	ENDS
CRT$XCU	SEGMENT
?G³os$initializer$@@3P6AXXZEA DQ FLAT:??__EG³os@@YAXXZ	; G³os$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@000000000000000f0000000000000000
CONST	SEGMENT
__xmm@000000000000000f0000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 0fH, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@4042800000000000
CONST	SEGMENT
__real@4042800000000000 DQ 04042800000000000r	; 37
CONST	ENDS
;	COMDAT __real@4040000000000000
CONST	SEGMENT
__real@4040000000000000 DQ 04040000000000000r	; 32
	ORG $+6
?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; G³os
	DB	23 DUP(00H)
	DQ	000000000000000fH
?Ustawienia@@3US_Ustawienia@@A DW 02H			; Ustawienia
	DW	03H
	DW	032H
	DW	04bH
	DW	01f4H
	DW	01H
	DD	03e8H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memcpy_s DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?compare@?$char_traits@D@std@@SAHQEBD0_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate@std@@YAXPEAX_K1_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_cast@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1locale@std@@QEAA@XZ DD imagerel ??1locale@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1locale@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1locale@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1locale@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1locale@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FG³os@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$5 DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DD imagerel main
	DD	0ffffffffH
	DD	imagerel main+191
	DD	00H
	DD	imagerel main+318
	DD	01H
	DD	imagerel main+344
	DD	02H
	DD	imagerel main+402
	DD	03H
	DD	imagerel main+458
	DD	04H
	DD	imagerel main+487
	DD	05H
	DD	imagerel main+664
	DD	04H
	DD	imagerel main+768
	DD	00H
	DD	imagerel main+778
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DD 0ffffffffH
	DD	imagerel main$dtor$0
	DD	00H
	DD	imagerel main$dtor$5
	DD	01H
	DD	imagerel main$dtor$6
	DD	02H
	DD	imagerel main$dtor$8
	DD	00H
	DD	imagerel main$dtor$1
	DD	04H
	DD	imagerel main$dtor$2
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$main DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$main
	DD	00H
	DD	00H
	DD	0aH
	DD	imagerel $ip2state$main
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	053319H
	DD	05a3422H
	DD	0580111H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$main
	DD	02b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	0ffffffffH
	DD	imagerel ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+84
	DD	00H
	DD	imagerel ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+176
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	0ffffffffH
	DD	imagerel ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+84
	DD	00H
	DD	imagerel ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+176
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	0ffffffffH
	DD	imagerel ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+22
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z DD imagerel ?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
	DD	0ffffffffH
	DD	imagerel ?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z+80
	DD	00H
	DD	imagerel ?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z+378
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z DD 062819H
	DD	0f6419H
	DD	0e3414H
	DD	070029206H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?Zakrêæ_Ruletk¹@@YAHXZ DD 021H
	DD	imagerel $LN166
	DD	imagerel $LN166+29
	DD	imagerel $unwind$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?Zakrêæ_Ruletk¹@@YAHXZ DD 020021H
	DD	066800H
	DD	imagerel $LN166+29
	DD	imagerel $LN166+41
	DD	imagerel $chain$2$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?Zakrêæ_Ruletk¹@@YAHXZ DD 021H
	DD	imagerel $LN166+41
	DD	imagerel $LN166+204
	DD	imagerel $chain$6$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?Zakrêæ_Ruletk¹@@YAHXZ DD 020521H
	DD	0fe405H
	DD	imagerel $LN166+41
	DD	imagerel $LN166+204
	DD	imagerel $chain$6$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?Zakrêæ_Ruletk¹@@YAHXZ DD 081321H
	DD	048813H
	DD	05780eH
	DD	066809H
	DD	0ef404H
	DD	imagerel $LN166+29
	DD	imagerel $LN166+41
	DD	imagerel $chain$2$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?Zakrêæ_Ruletk¹@@YAHXZ DD 060c21H
	DD	016d40cH
	DD	0156408H
	DD	0145404H
	DD	imagerel $LN166
	DD	imagerel $LN166+29
	DD	imagerel $unwind$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Zakrêæ_Ruletk¹@@YAHXZ DD 041d19H
	DD	0c007f20eH
	DD	030047005H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Sprawd_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Czy_Kontynuowaæ@@YA_NAEBH@Z DD imagerel ?Czy_Kontynuowaæ@@YA_NAEBH@Z
	DD	0ffffffffH
	DD	imagerel ?Czy_Kontynuowaæ@@YA_NAEBH@Z+62
	DD	00H
	DD	imagerel ?Czy_Kontynuowaæ@@YA_NAEBH@Z+785
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Czy_Kontynuowaæ@@YA_NAEBH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Czy_Kontynuowaæ@@YA_NAEBH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Czy_Kontynuowaæ@@YA_NAEBH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?Czy_Kontynuowaæ@@YA_NAEBH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?Czy_Kontynuowaæ@@YA_NAEBH@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Czy_Kontynuowaæ@@YA_NAEBH@Z DD 042319H
	DD	0d3414H
	DD	070029206H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?Czy_Kontynuowaæ@@YA_NAEBH@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Change_Col@@YAXAEBH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Hide_Cursor@@YAXXZ DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Show_Cursor@@YAXXZ DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Wylosuj@@YAHAEBH0@Z DD 064201H
	DD	086442H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$433@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$427@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$325@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$293@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$263@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$221@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$191@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$149@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$119@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+173
	DD	00H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+205
	DD	01H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+280
	DD	02H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+308
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+341
	DD	04H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+400
	DD	05H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+594
	DD	04H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+698
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+906
	DD	06H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1042
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1134
	DD	0ffffffffH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1263
	DD	07H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1399
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1597
	DD	08H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1733
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1822
	DD	09H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1958
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2151
	DD	0aH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2287
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2376
	DD	0bH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2512
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2622
	DD	0cH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2864
	DD	0dH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3060
	DD	0cH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3163
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3313
	DD	0eH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3339
	DD	0fH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3396
	DD	010H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3408
	DD	011H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3454
	DD	013H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3681
	DD	014H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3783
	DD	013H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3794
	DD	012H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3805
	DD	011H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3815
	DD	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$20@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$22@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$1@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	04H
	DD	imagerel ?dtor$2@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$119@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$149@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$191@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$221@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$263@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$293@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$325@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0cH
	DD	imagerel ?dtor$11@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$427@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0eH
	DD	imagerel ?dtor$428@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0fH
	DD	imagerel ?dtor$430@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$13@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	011H
	DD	imagerel ?dtor$14@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	012H
	DD	imagerel ?dtor$433@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	013H
	DD	imagerel ?dtor$16@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	015H
	DD	imagerel $stateUnwindMap$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	00H
	DD	00H
	DD	024H
	DD	imagerel $ip2state$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	090H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0d3f19H
	DD	063742eH
	DD	062642aH
	DD	0613426H
	DD	05a011aH
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	02c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	0ffffffffH
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+266
	DD	00H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+281
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+1440
	DD	02H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+1588
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+1921
	DD	03H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+3301
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+3489
	DD	04H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+4469
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+4720
	DD	05H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+5157
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+5348
	DD	00H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+5447
	DD	0ffffffffH
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+6215
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+6221
	DD	02H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+6227
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+6233
	DD	03H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+6257
	DD	04H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+6275
	DD	05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$4@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$5@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	00H
	DD	00H
	DD	013H
	DD	imagerel $ip2state$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0a2f19H
	DD	0170119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	0a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$940@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$905@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$878@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$774@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$739@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$712@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$608@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$573@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$546@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$430@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$395@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$365@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$243@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$208@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$178@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$148@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$118@?0??Sprawd_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Sprawd_Pliki@@YAXXZ DD imagerel ?Sprawd_Pliki@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+783
	DD	00H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+785
	DD	0ffffffffH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+1082
	DD	00H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+1213
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+1248
	DD	02H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+1386
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+1479
	DD	03H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+1616
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+1704
	DD	04H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+1838
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+1972
	DD	05H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+2141
	DD	07H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+2491
	DD	06H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+2593
	DD	05H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+2697
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+2795
	DD	08H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+2933
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+3070
	DD	09H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+3239
	DD	0bH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+3603
	DD	0aH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+3705
	DD	09H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+3815
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+3910
	DD	0cH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+4047
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+4183
	DD	0dH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+4354
	DD	0fH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+4718
	DD	0eH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+4820
	DD	0dH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+4931
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+5068
	DD	010H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+5208
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+5345
	DD	011H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+5514
	DD	013H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+5878
	DD	012H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+5980
	DD	011H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+6090
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+6185
	DD	014H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+6322
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+6458
	DD	015H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+6633
	DD	017H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+6979
	DD	016H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+6989
	DD	015H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7000
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7133
	DD	018H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7156
	DD	019H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7181
	DD	01aH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7253
	DD	019H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7264
	DD	018H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7275
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7315
	DD	01bH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7337
	DD	01cH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7387
	DD	01bH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7398
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7476
	DD	01dH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7496
	DD	01eH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7513
	DD	01fH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7535
	DD	020H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7560
	DD	021H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7581
	DD	022H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7599
	DD	023H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7671
	DD	022H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7682
	DD	021H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7693
	DD	020H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7704
	DD	01fH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7714
	DD	01eH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7724
	DD	01dH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7734
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7789
	DD	024H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7825
	DD	025H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7842
	DD	026H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7858
	DD	027H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7908
	DD	026H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7918
	DD	025H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+7928
	DD	024H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8007
	DD	028H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8024
	DD	029H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8045
	DD	02aH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8062
	DD	02bH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8085
	DD	02cH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8104
	DD	02dH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8128
	DD	02eH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8148
	DD	02fH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8164
	DD	030H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8236
	DD	02fH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8246
	DD	02eH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8256
	DD	02dH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8266
	DD	02cH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8276
	DD	02bH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8287
	DD	02aH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8298
	DD	029H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8309
	DD	028H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8319
	DD	024H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8336
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8393
	DD	031H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8427
	DD	032H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8440
	DD	033H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8490
	DD	032H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8500
	DD	031H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8580
	DD	034H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8597
	DD	035H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8613
	DD	036H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8635
	DD	037H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8654
	DD	038H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8678
	DD	039H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8694
	DD	03aH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8766
	DD	039H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8776
	DD	038H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8786
	DD	037H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8796
	DD	036H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8806
	DD	035H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8816
	DD	034H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8826
	DD	031H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8844
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8912
	DD	00H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8925
	DD	0ffffffffH
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+8985
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+9029
	DD	024H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+9071
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+9088
	DD	031H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+9130
	DD	01H
	DD	imagerel ?Sprawd_Pliki@@YAXXZ+9147
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Sprawd_Pliki@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$118@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$148@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$178@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$208@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	05H
	DD	imagerel ?dtor$6@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	06H
	DD	imagerel ?dtor$243@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$365@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$395@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	09H
	DD	imagerel ?dtor$11@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	0aH
	DD	imagerel ?dtor$430@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$546@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$573@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	0dH
	DD	imagerel ?dtor$16@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	0eH
	DD	imagerel ?dtor$608@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$712@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$739@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	011H
	DD	imagerel ?dtor$21@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	012H
	DD	imagerel ?dtor$774@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$878@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$905@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	015H
	DD	imagerel ?dtor$26@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	016H
	DD	imagerel ?dtor$940@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$30@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	018H
	DD	imagerel ?dtor$31@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	019H
	DD	imagerel ?dtor$32@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$34@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01bH
	DD	imagerel ?dtor$35@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$37@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01dH
	DD	imagerel ?dtor$38@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01eH
	DD	imagerel ?dtor$39@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01fH
	DD	imagerel ?dtor$40@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	020H
	DD	imagerel ?dtor$41@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	021H
	DD	imagerel ?dtor$42@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	022H
	DD	imagerel ?dtor$43@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$45@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	024H
	DD	imagerel ?dtor$46@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	025H
	DD	imagerel ?dtor$47@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	026H
	DD	imagerel ?dtor$48@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	024H
	DD	imagerel ?dtor$50@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	028H
	DD	imagerel ?dtor$51@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	029H
	DD	imagerel ?dtor$52@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	02aH
	DD	imagerel ?dtor$53@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	02bH
	DD	imagerel ?dtor$54@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	02cH
	DD	imagerel ?dtor$55@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	02dH
	DD	imagerel ?dtor$56@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	02eH
	DD	imagerel ?dtor$57@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	02fH
	DD	imagerel ?dtor$58@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$60@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	031H
	DD	imagerel ?dtor$61@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	032H
	DD	imagerel ?dtor$62@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	031H
	DD	imagerel ?dtor$64@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	034H
	DD	imagerel ?dtor$65@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	035H
	DD	imagerel ?dtor$66@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	036H
	DD	imagerel ?dtor$67@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	037H
	DD	imagerel ?dtor$68@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	038H
	DD	imagerel ?dtor$69@?0??Sprawd_Pliki@@YAXXZ@4HA
	DD	039H
	DD	imagerel ?dtor$70@?0??Sprawd_Pliki@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Sprawd_Pliki@@YAXXZ DD 019930522H
	DD	03bH
	DD	imagerel $stateUnwindMap$?Sprawd_Pliki@@YAXXZ
	DD	00H
	DD	00H
	DD	07aH
	DD	imagerel $ip2state$?Sprawd_Pliki@@YAXXZ
	DD	0178H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Sprawd_Pliki@@YAXXZ DD 0d3f19H
	DD	062742eH
	DD	061642aH
	DD	0603426H
	DD	05a011aH
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?Sprawd_Pliki@@YAXXZ
	DD	02c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??Sprawd_ustawienia@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Sprawd_ustawienia@@YAXXZ DD imagerel ?Sprawd_ustawienia@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ?Sprawd_ustawienia@@YAXXZ+124
	DD	00H
	DD	imagerel ?Sprawd_ustawienia@@YAXXZ+151
	DD	01H
	DD	imagerel ?Sprawd_ustawienia@@YAXXZ+213
	DD	02H
	DD	imagerel ?Sprawd_ustawienia@@YAXXZ+261
	DD	03H
	DD	imagerel ?Sprawd_ustawienia@@YAXXZ+347
	DD	04H
	DD	imagerel ?Sprawd_ustawienia@@YAXXZ+427
	DD	03H
	DD	imagerel ?Sprawd_ustawienia@@YAXXZ+527
	DD	0ffffffffH
	DD	imagerel ?Sprawd_ustawienia@@YAXXZ+569
	DD	05H
	DD	imagerel ?Sprawd_ustawienia@@YAXXZ+976
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Sprawd_ustawienia@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$4@?0??Sprawd_ustawienia@@YAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$5@?0??Sprawd_ustawienia@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$7@?0??Sprawd_ustawienia@@YAXXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0??Sprawd_ustawienia@@YAXXZ@4HA
	DD	03H
	DD	imagerel ?dtor$1@?0??Sprawd_ustawienia@@YAXXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??Sprawd_ustawienia@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Sprawd_ustawienia@@YAXXZ DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$?Sprawd_ustawienia@@YAXXZ
	DD	00H
	DD	00H
	DD	0aH
	DD	imagerel $ip2state$?Sprawd_ustawienia@@YAXXZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Sprawd_ustawienia@@YAXXZ DD 093319H
	DD	0347425H
	DD	0336421H
	DD	032341dH
	DD	0300110H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?Sprawd_ustawienia@@YAXXZ
	DD	0172H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	0ffffffffH
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+84
	DD	00H
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+176
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z DD imagerel ?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
	DD	0ffffffffH
	DD	imagerel ?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z+332
	DD	00H
	DD	imagerel ?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z+472
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0??Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
	DD	048H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z DD 081811H
	DD	0f00b920fH
	DD	0c007e009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD 020821H
	DD	0117408H
	DD	imagerel $LN284
	DD	imagerel $LN284+314
	DD	imagerel $unwind$?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD 0a1c01H
	DD	013541cH
	DD	012341cH
	DD	0f018921cH
	DD	0d014e016H
	DD	06010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 021H
	DD	imagerel $LN1761
	DD	imagerel $LN1761+307
	DD	imagerel $unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 020021H
	DD	0bf400H
	DD	imagerel $LN1761
	DD	imagerel $LN1761+307
	DD	imagerel $unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 021H
	DD	imagerel $LN1761
	DD	imagerel $LN1761+307
	DD	imagerel $unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 020521H
	DD	0bf405H
	DD	imagerel $LN1761
	DD	imagerel $LN1761+307
	DD	imagerel $unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 082a01H
	DD	0ae42aH
	DD	096425H
	DD	070043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+126
	DD	imagerel $unwind$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD 041a21H
	DD	0741aH
	DD	023405H
	DD	imagerel $LN32
	DD	imagerel $LN32+126
	DD	imagerel $unwind$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 021H
	DD	imagerel $LN91
	DD	imagerel $LN91+49
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 020021H
	DD	087400H
	DD	imagerel $LN91
	DD	imagerel $LN91+49
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 043921H
	DD	066439H
	DD	087405H
	DD	imagerel $LN91
	DD	imagerel $LN91+49
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 021H
	DD	imagerel $LN46
	DD	imagerel $LN46+86
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 040021H
	DD	07e400H
	DD	063400H
	DD	imagerel $LN46
	DD	imagerel $LN46+86
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 040d21H
	DD	07e40dH
	DD	063405H
	DD	imagerel $LN46
	DD	imagerel $LN46+86
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 060f01H
	DD	09640fH
	DD	08540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+21
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 020521H
	DD	043405H
	DD	imagerel $LN33
	DD	imagerel $LN33+21
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+22
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020021H
	DD	077400H
	DD	imagerel $LN66
	DD	imagerel $LN66+22
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 041c21H
	DD	06641cH
	DD	077405H
	DD	imagerel $LN66
	DD	imagerel $LN66+22
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 021H
	DD	imagerel $LN54
	DD	imagerel $LN54+38
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 020521H
	DD	067405H
	DD	imagerel $LN54
	DD	imagerel $LN54+38
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+44
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD 020521H
	DD	066405H
	DD	imagerel $LN47
	DD	imagerel $LN47+44
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 062b01H
	DD	0a642bH
	DD	070043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+82
	DD	00H
	DD	imagerel ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+174
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+71
	DD	00H
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+99
	DD	01H
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+149
	DD	02H
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+206
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 041411H
	DD	0d3414H
	DD	070029206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+82
	DD	00H
	DD	imagerel ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+174
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+60
	DD	00H
	DD	imagerel ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+91
	DD	01H
	DD	imagerel ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+141
	DD	02H
	DD	imagerel ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+198
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 041411H
	DD	0d3414H
	DD	070029206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+82
	DD	00H
	DD	imagerel ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+174
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+60
	DD	00H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+91
	DD	01H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+141
	DD	02H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+198
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 041411H
	DD	0d3414H
	DD	070029206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 061c19H
	DD	0d340dH
	DD	0e009520dH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 061a19H
	DD	0e007520bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	0ffffffffH
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+228
	DD	00H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+664
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 072d19H
	DD	016741fH
	DD	015341bH
	DD	012010fH
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	082H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020021H
	DD	067400H
	DD	imagerel $LN26
	DD	imagerel $LN26+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020521H
	DD	067405H
	DD	imagerel $LN26
	DD	imagerel $LN26+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DD	0ffffffffH
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+261
	DD	00H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+604
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 093019H
	DD	0196422H
	DD	018341eH
	DD	0120112H
	DD	07005e007H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DD	082H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 041919H
	DD	012340aH
	DD	07006d20aH
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+75
	DD	00H
	DD	imagerel ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+103
	DD	01H
	DD	imagerel ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+153
	DD	02H
	DD	imagerel ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+178
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 041d11H
	DD	09341dH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 080021H
	DD	04f400H
	DD	05c400H
	DD	067400H
	DD	0b5400H
	DD	imagerel $LN171
	DD	imagerel $LN171+32
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 0a0021H
	DD	04f400H
	DD	05c400H
	DD	067400H
	DD	0c6400H
	DD	0b5400H
	DD	imagerel $LN171
	DD	imagerel $LN171+32
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 0a5521H
	DD	0c6455H
	DD	04f40aH
	DD	0b5405H
	DD	05c400H
	DD	067400H
	DD	imagerel $LN171
	DD	imagerel $LN171+32
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 040821H
	DD	067408H
	DD	05c400H
	DD	imagerel $LN171
	DD	imagerel $LN171+32
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 020021H
	DD	05c400H
	DD	imagerel $LN171
	DD	imagerel $LN171+32
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 020521H
	DD	05c405H
	DD	imagerel $LN171
	DD	imagerel $LN171+32
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 030801H
	DD	0e0046208H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DD	0ffffffffH
	DD	imagerel ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z+25
	DD	00H
	DD	imagerel ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z+115
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+39
	DD	00H
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+66
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	0ffffffffH
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+59
	DD	00H
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+112
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 040021H
	DD	086400H
	DD	075400H
	DD	imagerel $LN159
	DD	imagerel $LN159+65
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 043821H
	DD	086438H
	DD	075405H
	DD	imagerel $LN159
	DD	imagerel $LN159+65
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+35
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 020521H
	DD	066405H
	DD	imagerel $LN32
	DD	imagerel $LN32+35
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN24
	DD	imagerel $LN24+25
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	066405H
	DD	imagerel $LN24
	DD	imagerel $LN24+25
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 021H
	DD	imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 020521H
	DD	083405H
	DD	imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	083405H
	DD	imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z DD 020021H
	DD	0a5400H
	DD	imagerel $LN90
	DD	imagerel $LN90+60
	DD	imagerel $unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z DD 020521H
	DD	0a5405H
	DD	imagerel $LN90
	DD	imagerel $LN90+60
	DD	imagerel $unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 021H
	DD	imagerel $LN77
	DD	imagerel $LN77+49
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 020021H
	DD	087400H
	DD	imagerel $LN77
	DD	imagerel $LN77+49
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 043921H
	DD	076439H
	DD	087405H
	DD	imagerel $LN77
	DD	imagerel $LN77+49
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+120
	DD	00H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+388
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 082d19H
	DD	013741fH
	DD	012641bH
	DD	0113417H
	DD	05004d20bH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD 061e19H
	DD	0d640fH
	DD	0c340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	0ffffffffH
	DD	imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+101
	DD	00H
	DD	imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+149
	DD	01H
	DD	imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+185
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 041411H
	DD	0a3414H
	DD	070027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD imagerel ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z+30
	DD	00H
	DD	imagerel ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z+81
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 020f11H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 041919H
	DD	0e340aH
	DD	07006920aH
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+25
	DD	00H
	DD	imagerel ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+44
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 020f11H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+30
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD 020021H
	DD	087400H
	DD	imagerel $LN51
	DD	imagerel $LN51+30
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD 043921H
	DD	076439H
	DD	087405H
	DD	imagerel $LN51
	DD	imagerel $LN51+30
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD imagerel ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z+55
	DD	00H
	DD	imagerel ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z+201
	DD	0ffffffffH
	DD	imagerel ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z+247
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD 062719H
	DD	0106418H
	DD	0f3414H
	DD	07004b208H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DD imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
	DD	0ffffffffH
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z+81
	DD	00H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z+140
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z+153
	DD	02H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z+320
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z+377
	DD	04H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z+397
	DD	05H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z+421
	DD	0ffffffffH
	DD	imagerel ?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
	DD	00H
	DD	imagerel ?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA+13
	DD	03H
	DD	imagerel ?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
	DD	04H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
	DD	01H
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
	DD	0bH
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DD 081f19H
	DD	0f341fH
	DD	0f00d7211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0ffffffffH
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+124
	DD	00H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+187
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+201
	DD	02H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+354
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+395
	DD	04H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+415
	DD	05H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+440
	DD	0ffffffffH
	DD	imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	00H
	DD	imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+13
	DD	03H
	DD	imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 0ffffffffH
	DD	imagerel ?dtor$2@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
	DD	04H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	01H
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0bH
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 081f19H
	DD	0f341fH
	DD	0f00d7211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z DD 062e01H
	DD	06742eH
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z DD imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
	DD	0ffffffffH
	DD	imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z DD 082111H
	DD	0c6421H
	DD	0b341cH
	DD	0f00a520eH
	DD	07006e008H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z DD imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
	DD	0ffffffffH
	DD	imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z+35
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z DD 061d11H
	DD	0a641dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
	DD	0ffffffffH
	DD	imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z+35
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD 061d11H
	DD	0a641dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+60
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 040021H
	DD	075400H
	DD	063400H
	DD	imagerel $LN26
	DD	imagerel $LN26+60
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 040a21H
	DD	07540aH
	DD	063405H
	DD	imagerel $LN26
	DD	imagerel $LN26+60
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 061001H
	DD	097410H
	DD	086410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+55
	DD	00H
	DD	imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+201
	DD	0ffffffffH
	DD	imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+247
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 062719H
	DD	0106418H
	DD	0f3414H
	DD	07004b208H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 060021H
	DD	04f400H
	DD	0ce400H
	DD	0b6400H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 021H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 064521H
	DD	0b6445H
	DD	04f40eH
	DD	0ce405H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 050a01H
	DD	0c006420aH
	DD	050037004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z DD 084901H
	DD	073449H
	DD	09640fH
	DD	08540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 040021H
	DD	047400H
	DD	0c5400H
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 021H
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 040021H
	DD	047400H
	DD	0c5400H
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 043c21H
	DD	04743cH
	DD	0c5405H
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 050b01H
	DD	0f007420bH
	DD	06003e005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 060021H
	DD	07d400H
	DD	097400H
	DD	0105400H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 021H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 0aa121H
	DD	06e4a1H
	DD	08c499H
	DD	097448H
	DD	07d411H
	DD	0105408H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 040901H
	DD	0f0059209H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 060021H
	DD	04e400H
	DD	057400H
	DD	0e5400H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 021H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 064521H
	DD	057445H
	DD	04e40eH
	DD	0e5405H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 060d01H
	DD	0f009520dH
	DD	0c005d007H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPEAX_K0_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 020021H
	DD	063400H
	DD	imagerel $LN66
	DD	imagerel $LN66+76
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+76
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN66
	DD	imagerel $LN66+76
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD 021H
	DD	imagerel $LN52
	DD	imagerel $LN52+59
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD 041521H
	DD	09f415H
	DD	086405H
	DD	imagerel $LN52
	DD	imagerel $LN52+59
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD 061001H
	DD	0b7410H
	DD	0a3410H
	DD	0e00c5210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 041521H
	DD	096415H
	DD	083405H
	DD	imagerel $LN36
	DD	imagerel $LN36+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 061001H
	DD	0be410H
	DD	0a7410H
	DD	0f00c5210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+88
	DD	00H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+103
	DD	01H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+133
	DD	02H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+144
	DD	03H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+179
	DD	01H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+203
	DD	04H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+275
	DD	01H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+280
	DD	04H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+409
	DD	01H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+475
	DD	06H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+500
	DD	0ffffffffH
	DD	imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA+13
	DD	05H
	DD	imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 04H
	DD	04H
	DD	05H
	DD	01H
	DD	imagerel $handlerMap$0$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$2@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$1@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	01H
	DD	imagerel __imp___std_terminate
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	07H
	DD	imagerel $stateUnwindMap$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	0fH
	DD	imagerel $ip2state$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0a2019H
	DD	0176420H
	DD	016341cH
	DD	0f00cd210H
	DD	0d008e00aH
	DD	07004c006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z DD 063c01H
	DD	06743cH
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	0ffffffffH
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+92
	DD	00H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+107
	DD	01H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+115
	DD	02H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+237
	DD	01H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+239
	DD	02H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+323
	DD	01H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+373
	DD	04H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+398
	DD	0ffffffffH
	DD	imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	00H
	DD	imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA+13
	DD	03H
	DD	imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	01H
	DD	imagerel $tryMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	0cH
	DD	imagerel $ip2state$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0a2019H
	DD	0136420H
	DD	012341cH
	DD	0f00c9210H
	DD	0d008e00aH
	DD	07004c006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	0ffffffffH
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+114
	DD	00H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+177
	DD	01H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+191
	DD	02H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+315
	DD	01H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+317
	DD	02H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+363
	DD	01H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+402
	DD	04H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+422
	DD	05H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+446
	DD	0ffffffffH
	DD	imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+13
	DD	03H
	DD	imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
	DD	04H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	01H
	DD	imagerel $tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	0dH
	DD	imagerel $ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 081f19H
	DD	0f341fH
	DD	0f00d7211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD 060021H
	DD	04f400H
	DD	056400H
	DD	0c5400H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD 021H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD 064521H
	DD	056445H
	DD	04f40eH
	DD	0c5405H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD 040901H
	DD	0e0055209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD 060021H
	DD	04f400H
	DD	057400H
	DD	0e5400H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+61
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD 021H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+61
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD 064521H
	DD	057445H
	DD	04f40eH
	DD	0e5405H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+61
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD 060d01H
	DD	0e009520dH
	DD	0c005d007H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ+13
	DD	00H
	DD	imagerel ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ+40
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD imagerel ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
	DD	0ffffffffH
	DD	imagerel ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z+58
	DD	00H
	DD	imagerel ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z+74
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h
;	COMDAT time
_TEXT	SEGMENT
_Time$dead$ = 8
time	PROC						; COMDAT

; 535  :             return _time64(_Time);

  00000	33 c9		 xor	 ecx, ecx
  00002	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__time64
time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
;	COMDAT memcpy_s
_TEXT	SEGMENT
_Destination$ = 48
_DestinationSize$dead$ = 56
_Source$ = 64
_SourceSize$dead$ = 72
memcpy_s PROC						; COMDAT

; 41   :     {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 42   :         if (_SourceSize == 0)
; 43   :         {
; 44   :             return 0;
; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 16		 je	 SHORT $LN10@memcpy_s

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00009	4d 85 c0	 test	 r8, r8
  0000c	74 0d		 je	 SHORT $LN5@memcpy_s

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;
; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

  0000e	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00012	88 01		 mov	 BYTE PTR [rcx], al

; 60   :         return 0;

  00014	33 c0		 xor	 eax, eax

; 61   :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  0001b	33 c0		 xor	 eax, eax
  0001d	88 01		 mov	 BYTE PTR [rcx], al
$LN10@memcpy_s:

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00025	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo
  00031	b8 16 00 00 00	 mov	 eax, 22

; 61   :     }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
memcpy_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
__formal$ = 24
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 60   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	33 c0		 xor	 eax, eax
  0000c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 61   :         _Data._What = _Message;
; 62   :     }

  00010	48 8b c1	 mov	 rax, rcx
  00013	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  00017	c3		 ret	 0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx
  0000c	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00017	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  0001a	33 c9		 xor	 ecx, ecx
  0001c	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0001f	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  00023	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_copy

; 68   :     }

  0002d	48 8b c3	 mov	 rax, rbx
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 83   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 84   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp___std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
  0000b	48 85 d2	 test	 rdx, rdx
  0000e	48 0f 45 c2	 cmovne	 rax, rdx

; 90   :     }

  00012	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 83   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 84   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_destroy
  00023	f6 c3 01	 test	 bl, 1
  00026	74 0d		 je	 SHORT $LN6@scalar
  00028	ba 18 00 00 00	 mov	 edx, 24
  0002d	48 8b cf	 mov	 rcx, rdi
  00030	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN6@scalar:
  00035	48 8b c7	 mov	 rax, rdi
  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 973  : 		return (LLONG_MAX);

  00000	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH

; 974  : 		}

  0000a	c3		 ret	 0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$dead$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 179  :         (void)_Size;
; 180  :         return _Where;

  00000	48 8b c2	 mov	 rax, rdx

; 181  :     }

  00003	c3		 ret	 0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHQEBD0_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?compare@?$char_traits@D@std@@SAHQEBD0_K@Z PROC		; std::char_traits<char>::compare, COMDAT

; 399  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00004	e8 00 00 00 00	 call	 memcmp

; 401  : 		}

  00009	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000d	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHQEBD0_K@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SA_KQEBD@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$char_traits@D@std@@SA_KQEBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 405  : 		return (_CSTD strlen(_First));

  00000	48 83 c8 ff	 or	 rax, -1
$LL3@length:
  00004	48 ff c0	 inc	 rax
  00007	80 3c 01 00	 cmp	 BYTE PTR [rcx+rax], 0
  0000b	75 f7		 jne	 SHORT $LL3@length

; 406  : 		}

  0000d	c3		 ret	 0
?length@?$char_traits@D@std@@SA_KQEBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z PROC	; std::char_traits<char>::copy, COMDAT

; 410  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00009	e8 00 00 00 00	 call	 memcpy
  0000e	48 8b c3	 mov	 rax, rbx

; 412  : 		}

  00011	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00015	5b		 pop	 rbx
  00016	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z ENDP	; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?find@?$char_traits@D@std@@SAPEBDQEBD_KAEBD@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Ch$ = 24
?find@?$char_traits@D@std@@SAPEBDQEBD_KAEBD@Z PROC	; std::char_traits<char>::find, COMDAT

; 424  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	48 8b c2	 mov	 rax, rdx

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00003	41 0f be 10	 movsx	 edx, BYTE PTR [r8]
  00007	4c 8b c0	 mov	 r8, rax
  0000a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_memchr
?find@?$char_traits@D@std@@SAPEBDQEBD_KAEBD@Z ENDP	; std::char_traits<char>::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 8
_First2$ = 16
_Count$ = 24
?move@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z PROC	; std::char_traits<char>::move, COMDAT

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_memmove
?move@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z ENDP	; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z PROC	; std::char_traits<char>::assign, COMDAT

; 436  : 		{	// assign _Count * _Ch to [_First, ...)

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  0000c	41 0f be d0	 movsx	 edx, r8b
  00010	4c 8b c0	 mov	 r8, rax
  00013	e8 00 00 00 00	 call	 memset
  00018	48 8b c3	 mov	 rax, rbx

; 438  : 		}

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z ENDP	; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$char_traits@D@std@@SAXAEADAEBD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 442  : 		_Left = _Right;

  00000	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00003	88 01		 mov	 BYTE PTR [rcx], al

; 443  : 		}

  00005	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAEADAEBD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?eq@?$char_traits@D@std@@SA_NAEBD0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq@?$char_traits@D@std@@SA_NAEBD0@Z PROC		; std::char_traits<char>::eq, COMDAT

; 447  : 		return (_Left == _Right);

  00000	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00003	38 01		 cmp	 BYTE PTR [rcx], al
  00005	0f 94 c0	 sete	 al

; 448  : 		}

  00008	c3		 ret	 0
?eq@?$char_traits@D@std@@SA_NAEBD0@Z ENDP		; std::char_traits<char>::eq
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADAEBH@Z
_TEXT	SEGMENT
_Meta$ = 8
?to_char_type@?$char_traits@D@std@@SADAEBH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 457  : 		return (static_cast<char>(_Meta));

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 458  : 		}

  00003	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADAEBH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHAEBD@Z
_TEXT	SEGMENT
_Ch$ = 8
?to_int_type@?$char_traits@D@std@@SAHAEBD@Z PROC	; std::char_traits<char>::to_int_type, COMDAT

; 462  : 		return (static_cast<unsigned char>(_Ch));

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 463  : 		}

  00003	c3		 ret	 0
?to_int_type@?$char_traits@D@std@@SAHAEBD@Z ENDP	; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 467  : 		return (_Left == _Right);

  00000	8b 02		 mov	 eax, DWORD PTR [rdx]
  00002	39 01		 cmp	 DWORD PTR [rcx], eax
  00004	0f 94 c0	 sete	 al

; 468  : 		}

  00007	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHAEBH@Z
_TEXT	SEGMENT
_Meta$ = 8
?not_eof@?$char_traits@D@std@@SAHAEBH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 471  : 		{	// return anything but EOF

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]

; 472  : 		return (_Meta != eof() ? _Meta : !eof());

  00002	33 c9		 xor	 ecx, ecx
  00004	83 f8 ff	 cmp	 eax, -1
  00007	0f 44 c1	 cmove	 eax, ecx

; 473  : 		}

  0000a	c3		 ret	 0
?not_eof@?$char_traits@D@std@@SAHAEBH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 477  : 		return (EOF);

  00000	83 c8 ff	 or	 eax, -1

; 478  : 		}

  00003	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 74   : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 85   : 		}

  00000	c2 00 00	 ret	 0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPEAX_K1_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Count$ = 56
_Sz$dead$ = 64
_Align$dead$ = 72
?_Deallocate@std@@YAXPEAX_K1_K@Z PROC			; std::_Deallocate, COMDAT

; 143  : 	{	// deallocate storage for _Count elements of size _Sz with alignment _Align

$LN19:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 144  : 	(void)_Align;
; 145  : 
; 146  : 	if (_Count > static_cast<size_t>(-1) / _Sz)
; 147  : 		{
; 148  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 149  : 		}
; 150  : 
; 151  : 		{
; 152  : 		size_t _Allocated_size = _Count * _Sz;
; 153  : 
; 154  : #if defined(_M_IX86) || defined(_M_X64)
; 155  : 		// Boost the alignment of big allocations to help autovectorization.
; 156  :  #pragma warning(push)
; 157  :  #pragma warning(disable: 4127) // conditional expression is constant
; 158  :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00004	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0000b	72 2a		 jb	 SHORT $LN4@Deallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0000d	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00011	48 3b c2	 cmp	 rax, rdx
  00014	76 2a		 jbe	 SHORT $_Invalid_parameter$20

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00016	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00019	f6 c1 1f	 test	 cl, 31
  0001c	75 22		 jne	 SHORT $_Invalid_parameter$20

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001e	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00022	48 3b c1	 cmp	 rax, rcx
  00025	73 19		 jae	 SHORT $_Invalid_parameter$20

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00027	48 2b c8	 sub	 rcx, rax
  0002a	48 83 e9 08	 sub	 rcx, 8
  0002e	48 83 f9 1f	 cmp	 rcx, 31
  00032	77 0c		 ja	 SHORT $_Invalid_parameter$20

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00034	48 8b c8	 mov	 rcx, rax
$LN4@Deallocate:

; 245  : 	}

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0003b	e9 00 00 00 00	 jmp	 ??3@YAXPEAX_K@Z		; operator delete
$_Invalid_parameter$20:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00046	cc		 int	 3
$LN18@Deallocate:
?_Deallocate@std@@YAXPEAX_K1_K@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Convert_size@_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K@std@@YA_K_K@Z PROC			; std::_Convert_size<unsigned __int64>, COMDAT

; 1259 : 	return (_Len);

  00000	48 8b c1	 mov	 rax, rcx

; 1260 : 	}

  00003	c3		 ret	 0
??$_Convert_size@_K@std@@YA_K_K@Z ENDP			; std::_Convert_size<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_typeinfo.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_cast@std@@QEAA@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h

; 59   :         : _Data()

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 60   :     {
; 61   :         _Data._What = _Message;

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  0000d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_typeinfo.h

; 127  :     {

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_cast@std@@6B@
  00018	48 89 01	 mov	 QWORD PTR [rcx], rax

; 128  :     }

  0001b	48 8b c1	 mov	 rax, rcx
  0001e	c3		 ret	 0
??0bad_cast@std@@QEAA@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_cast@std@@UEAAPEAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 83   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 84   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_destroy
  00023	f6 c3 01	 test	 bl, 1
  00026	74 0d		 je	 SHORT $LN9@scalar
  00028	ba 18 00 00 00	 mov	 edx, 24
  0002d	48 8b cf	 mov	 rcx, rdi
  00030	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN9@scalar:
  00035	48 8b c7	 mov	 rax, rdi
  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
??_Gbad_cast@std@@UEAAPEAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_cast@std@@UEAA@XZ PROC				; std::bad_cast::~bad_cast, COMDAT

; 83   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 84   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp___std_exception_destroy
??1bad_cast@std@@UEAA@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
;	COMDAT ??1locale@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1locale@std@@QEAA@XZ PROC				; std::locale::~locale, COMDAT

; 402  : 		{	// destroy the object

$LN7:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2

; 403  : 		if (_Ptr != 0)

  0000d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00011	48 85 c9	 test	 rcx, rcx
  00014	74 1b		 je	 SHORT $LN4@locale

; 404  : 			delete _Ptr->_Decref();

  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00019	ff 50 10	 call	 QWORD PTR [rax+16]
  0001c	90		 npad	 1
  0001d	48 85 c0	 test	 rax, rax
  00020	74 0f		 je	 SHORT $LN4@locale
  00022	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00025	ba 01 00 00 00	 mov	 edx, 1
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	41 ff 10	 call	 QWORD PTR [r8]
  00030	90		 npad	 1
$LN4@locale:

; 405  : 		}

  00031	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00035	c3		 ret	 0
??1locale@std@@QEAA@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
_TEXT	SEGMENT
this$ = 48
_Id$ = 56
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z PROC	; std::locale::_Getfacet, COMDAT

; 429  : 		{	// look up a facet in locale object

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0000d	33 ff		 xor	 edi, edi
  0000f	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00013	48 3b 5a 18	 cmp	 rbx, QWORD PTR [rdx+24]
  00017	73 0f		 jae	 SHORT $LN6@Getfacet
  00019	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  0001d	48 8b 04 d8	 mov	 rax, QWORD PTR [rax+rbx*8]

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00021	48 85 c0	 test	 rax, rax
  00024	75 22		 jne	 SHORT $LN4@Getfacet
  00026	eb 03		 jmp	 SHORT $LN10@Getfacet
$LN6@Getfacet:

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00028	48 8b c7	 mov	 rax, rdi
$LN10@Getfacet:

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0002b	40 38 7a 24	 cmp	 BYTE PTR [rdx+36], dil
  0002f	74 17		 je	 SHORT $LN4@Getfacet

; 433  : 			return (_Facptr);	// found facet or not transparent
; 434  : 		else
; 435  : 			{	// look in current locale
; 436  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ

; 437  : 			return (_Id < _Ptr0->_Facetcount

  00037	48 3b 58 18	 cmp	 rbx, QWORD PTR [rax+24]
  0003b	73 08		 jae	 SHORT $LN8@Getfacet
  0003d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00041	48 8b 3c d8	 mov	 rdi, QWORD PTR [rax+rbx*8]
$LN8@Getfacet:
  00045	48 8b c7	 mov	 rax, rdi
$LN4@Getfacet:

; 438  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 439  : 				: 0);	// no entry in current locale
; 440  : 			}
; 441  : 		}

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ENDP	; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT

; 47   : 	{	// get a char element from a C stream

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 48   : 	int _Meta;
; 49   : 	if ((_Meta = fgetc(_File)) == EOF)

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  00012	83 f8 ff	 cmp	 eax, -1
  00015	75 08		 jne	 SHORT $LN2@Fgetc

; 50   : 		return (false);

  00017	32 c0		 xor	 al, al

; 55   : 		}
; 56   : 	}

  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5b		 pop	 rbx
  0001e	c3		 ret	 0
$LN2@Fgetc:

; 51   : 	else
; 52   : 		{	// got one, convert to char
; 53   : 		_Byte = (char)_Meta;

  0001f	88 03		 mov	 BYTE PTR [rbx], al

; 54   : 		return (true);

  00021	b0 01		 mov	 al, 1

; 55   : 		}
; 56   : 	}

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT

; 92   : 	{	// put a char element to a C stream

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 93   : 	return (fputc(_Byte, _File) != EOF);

  00004	0f be c9	 movsx	 ecx, cl
  00007	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	0f 95 c0	 setne	 al

; 94   : 	}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT

; 116  : 	{	// put back a char element to a C stream

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 117  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  00004	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00007	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	0f 95 c0	 setne	 al

; 118  : 	}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0random_device@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0random_device@std@@QEAA@XZ PROC			; std::random_device::random_device, COMDAT

; 6386 : 		{	// construct
; 6387 : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0random_device@std@@QEAA@XZ ENDP			; std::random_device::random_device
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?min@random_device@std@@SAIXZ
_TEXT	SEGMENT
?min@random_device@std@@SAIXZ PROC			; std::random_device::min, COMDAT

; 6395 : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 6396 : 		}

  00002	c3		 ret	 0
?min@random_device@std@@SAIXZ ENDP			; std::random_device::min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?max@random_device@std@@SAIXZ
_TEXT	SEGMENT
?max@random_device@std@@SAIXZ PROC			; std::random_device::max, COMDAT

; 6400 : 		return (static_cast<result_type>(-1));

  00000	83 c8 ff	 or	 eax, -1			; ffffffffH

; 6401 : 		}

  00003	c3		 ret	 0
?max@random_device@std@@SAIXZ ENDP			; std::random_device::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?entropy@random_device@std@@QEBANXZ
_TEXT	SEGMENT
this$dead$ = 8
?entropy@random_device@std@@QEBANXZ PROC		; std::random_device::entropy, COMDAT

; 6405 : 		return (32.0);

  00000	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4040000000000000

; 6406 : 		}

  00008	c3		 ret	 0
?entropy@random_device@std@@QEBANXZ ENDP		; std::random_device::entropy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??Rrandom_device@std@@QEAAIXZ
_TEXT	SEGMENT
this$dead$ = 8
??Rrandom_device@std@@QEAAIXZ PROC			; std::random_device::operator(), COMDAT

; 6410 : 		return (_Random_device());

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?_Random_device@std@@YAIXZ
??Rrandom_device@std@@QEAAIXZ ENDP			; std::random_device::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ??__EG³os@@YAXXZ
text$di	SEGMENT
??__EG³os@@YAXXZ PROC					; `dynamic initializer for 'G³os'', COMDAT

; 72   : string G³os;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FG³os@@YAXXZ ; `dynamic atexit destructor for 'G³os''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EG³os@@YAXXZ ENDP					; `dynamic initializer for 'G³os''
text$di	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??__FG³os@@YAXXZ
text$yd	SEGMENT
??__FG³os@@YAXXZ PROC					; `dynamic atexit destructor for 'G³os'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00004	48 8b 15 18 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24
  0000b	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  0000f	72 42		 jb	 SHORT $LN41@dynamic
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00018	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0001b	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00022	72 2a		 jb	 SHORT $LN44@dynamic

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00024	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00028	48 3b c2	 cmp	 rax, rdx
  0002b	76 42		 jbe	 SHORT $_Invalid_parameter$78

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0002d	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00030	f6 c1 1f	 test	 cl, 31
  00033	75 3a		 jne	 SHORT $_Invalid_parameter$78

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00035	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00039	48 3b c1	 cmp	 rax, rcx
  0003c	73 31		 jae	 SHORT $_Invalid_parameter$78

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0003e	48 2b c8	 sub	 rcx, rax
  00041	48 83 e9 08	 sub	 rcx, 8
  00045	48 83 f9 1f	 cmp	 rcx, 31
  00049	77 24		 ja	 SHORT $_Invalid_parameter$78

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004b	48 8b c8	 mov	 rcx, rax
$LN44@dynamic:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0004e	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN41@dynamic:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00053	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  0005b	f3 0f 7f 05 10
	00 00 00	 movdqu	 XMMWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00063	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  0006a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006e	c3		 ret	 0
$_Invalid_parameter$78:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00075	cc		 int	 3
$LN77@dynamic:
??__FG³os@@YAXXZ ENDP					; `dynamic atexit destructor for 'G³os''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0S_Ustawienia@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??0S_Ustawienia@@QEAA@XZ PROC				; S_Ustawienia::S_Ustawienia, COMDAT
  00000	b9 01 00 00 00	 mov	 ecx, 1
  00005	c7 05 00 00 00
	00 02 00 03 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A, 196610 ; 00030002H
  0000f	66 89 0d 18 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, cx
  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?Ustawienia@@3US_Ustawienia@@A ; Ustawienia
  0001d	c7 05 04 00 00
	00 32 00 4b 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+4, 4915250 ; 004b0032H
  00027	c7 05 08 00 00
	00 f4 01 01 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+8, 66036 ; 000101f4H
  00031	c7 05 0c 00 00
	00 e8 03 00 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, 1000 ; 000003e8H
  0003b	c7 05 10 00 00
	00 01 00 01 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 65537 ; 00010001H
  00045	c7 05 14 00 00
	00 01 00 04 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, 262145 ; 00040001H
  0004f	c3		 ret	 0
??0S_Ustawienia@@QEAA@XZ ENDP				; S_Ustawienia::S_Ustawienia
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT main
_TEXT	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main	PROC						; COMDAT

; 77   : {

$LN138:
  00000	40 55		 push	 rbp
  00002	48 8d ac 24 40
	fe ff ff	 lea	 rbp, QWORD PTR [rsp-448]
  0000a	48 81 ec c0 02
	00 00		 sub	 rsp, 704		; 000002c0H
  00011	48 c7 44 24 50
	fe ff ff ff	 mov	 QWORD PTR $T11[rsp], -2
  0001a	48 89 9c 24 d0
	02 00 00	 mov	 QWORD PTR [rsp+720], rbx
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 85 b0 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  00033	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0

; 78   : 	//Inicjowanie funkcji
; 79   : 	setlocale(LC_ALL, "polish"); // W celu polskich liter w konsoli

  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JGCGFIEG@polish?$AA@
  00042	33 c9		 xor	 ecx, ecx
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setlocale
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h

; 535  :             return _time64(_Time);

  0004a	33 c9		 xor	 ecx, ecx
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64
  00052	48 8b c8	 mov	 rcx, rax
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 80   : 	srand((unsigned int)time(nullptr)); //Zainicjowanie generatorza LCG (Liniowy Generator Kongruentny) dla ma³o wa¿nych liczb

  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_srand

; 396  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  0005b	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle
  00066	48 8b d8	 mov	 rbx, rax

; 397  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 398  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  00069	48 8d 54 24 58	 lea	 rdx, QWORD PTR hCCI$12[rsp]
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCursorInfo

; 399  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoæ widocznoci kursorsora tekstego w konsoli jest ró¿na od prawdy

  00077	83 7c 24 5c 01	 cmp	 DWORD PTR hCCI$12[rsp+4], 1
  0007c	74 16		 je	 SHORT $LN12@main

; 400  : 	{
; 401  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoci kursora na widoczny

  0007e	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR hCCI$12[rsp+4], 1

; 402  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  00086	48 8d 54 24 58	 lea	 rdx, QWORD PTR hCCI$12[rsp]
  0008b	48 8b cb	 mov	 rcx, rbx
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCursorInfo
$LN12@main:

; 81   : 	Show_Cursor(); //Pokazanie kursora tekstowego w konsoli
; 82   : 
; 83   : 	Sprawd_ustawienia(); //Wczytanie ustawieñ z pliku

  00094	e8 00 00 00 00	 call	 ?Sprawd_ustawienia@@YAXXZ ; Sprawd_ustawienia

; 84   : 	Sprawd_Pliki(); //Wczytanie plików audio

  00099	e8 00 00 00 00	 call	 ?Sprawd_Pliki@@YAXXZ	; Sprawd_Pliki
  0009e	33 d2		 xor	 edx, edx
  000a0	41 b8 08 01 00
	00		 mov	 r8d, 264		; 00000108H
  000a6	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-256]
  000ad	e8 00 00 00 00	 call	 memset

; 85   : 
; 86   : 	//Inicjowanie zmiennych lokalnych
; 87   : 	ofstream log_ogólny; //Utworzenie typu do celu zapisu do pliku

  000b2	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-256]
  000b9	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
  000be	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000bf	41 b8 0a 00 00
	00		 mov	 r8d, 10
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@
  000cc	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-248]
  000d3	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1150 : 			_Myios::setstate(ios_base::failbit);

  000d8	45 33 c0	 xor	 r8d, r8d

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000db	48 85 c0	 test	 rax, rax

; 1150 : 			_Myios::setstate(ios_base::failbit);

  000de	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR log_ogólny$[rbp-256]
  000e5	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000e9	48 8d 85 a0 00
	00 00		 lea	 rax, QWORD PTR log_ogólny$[rbp-256]

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000f0	75 0f		 jne	 SHORT $LN18@main

; 1150 : 			_Myios::setstate(ios_base::failbit);

  000f2	48 03 c8	 add	 rcx, rax
  000f5	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1151 : 		else

  000ff	eb 0b		 jmp	 SHORT $LN19@main
$LN18@main:

; 1152 : 			_Myios::clear();	// added with C++11

  00101	48 03 c8	 add	 rcx, rax
  00104	33 d2		 xor	 edx, edx
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN19@main:
  0010c	33 d2		 xor	 edx, edx
  0010e	41 b8 18 01 00
	00		 mov	 r8d, 280		; 00000118H
  00114	48 8d 4d 80	 lea	 rcx, QWORD PTR log$[rbp-256]
  00118	e8 00 00 00 00	 call	 memset

; 1206 : 		{	// construct unopened

  0011d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00124	48 89 45 80	 mov	 QWORD PTR log$[rbp-256], rax
  00128	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0012f	48 89 45 90	 mov	 QWORD PTR log$[rbp-240], rax
  00133	48 8d 4d 38	 lea	 rcx, QWORD PTR log$[rbp-72]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0013d	90		 npad	 1
  0013e	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 1153 : 		}
; 1154 : 
; 1155 : 	void open(const string& _Str,
; 1156 : 		ios_base::openmode _Mode = ios_base::out,
; 1157 : 		int _Prot = (int)ios_base::_Openprot)
; 1158 : 		{	// open a C stream with specified mode
; 1159 : 		open(_Str.c_str(), _Mode, _Prot);
; 1160 : 		}
; 1161 : 
; 1162 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1163 : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 1164 : 		{	// open a C stream with specified mode (old style)
; 1165 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1166 : 		}
; 1167 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1168 : 
; 1169 : 	void close()
; 1170 : 		{	// close the C stream
; 1171 : 		if (_Filebuffer.close() == 0)
; 1172 : 			_Myios::setstate(ios_base::failbit);
; 1173 : 		}
; 1174 : 
; 1175 : private:
; 1176 : 	_Myfb _Filebuffer;	// the file buffer
; 1177 : 	};
; 1178 : 
; 1179 : template<class _Elem,
; 1180 : 	class _Traits> inline
; 1181 : 	void swap(basic_ofstream<_Elem, _Traits>& _Left,
; 1182 : 		basic_ofstream<_Elem, _Traits>& _Right)
; 1183 : 	{	// swap _Left and _Right basic_ofstreams
; 1184 : 	_Left.swap(_Right);
; 1185 : 	}
; 1186 : 
; 1187 : 		// CLASS TEMPLATE basic_fstream
; 1188 : template<class _Elem,
; 1189 : 	class _Traits>
; 1190 : 	class basic_fstream
; 1191 : 		: public basic_iostream<_Elem, _Traits>
; 1192 : 	{	// input/output stream associated with a C stream
; 1193 : public:
; 1194 : 	typedef basic_fstream<_Elem, _Traits> _Myt;
; 1195 : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 1196 : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 1197 : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 1198 : 	typedef _Elem char_type;
; 1199 : 	typedef _Traits traits_type;
; 1200 : 	typedef typename _Traits::int_type int_type;
; 1201 : 	typedef typename _Traits::pos_type pos_type;
; 1202 : 	typedef typename _Traits::off_type off_type;
; 1203 : 
; 1204 : 	basic_fstream()
; 1205 : 		: _Mybase(&_Filebuffer)

  00146	45 33 c0	 xor	 r8d, r8d
  00149	48 8d 55 98	 lea	 rdx, QWORD PTR log$[rbp-232]
  0014d	48 8d 4d 80	 lea	 rcx, QWORD PTR log$[rbp-256]
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00157	90		 npad	 1

; 1206 : 		{	// construct unopened

  00158	48 8b 45 80	 mov	 rax, QWORD PTR log$[rbp-256]
  0015c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00160	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00167	48 89 44 0d 80	 mov	 QWORD PTR log$[rbp+rcx-256], rax
  0016c	48 8b 45 80	 mov	 rax, QWORD PTR log$[rbp-256]
  00170	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00174	8d 91 48 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-184]
  0017a	89 54 0c 7c	 mov	 DWORD PTR log$[rsp+rcx-4], edx
  0017e	48 8d 45 98	 lea	 rax, QWORD PTR log$[rbp-232]
  00182	48 89 44 24 58	 mov	 QWORD PTR this$[rsp], rax

; 155  : 		: _Mysb()

  00187	48 8d 4d 98	 lea	 rcx, QWORD PTR log$[rbp-232]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00191	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  00192	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00199	48 89 45 98	 mov	 QWORD PTR log$[rbp-232], rax

; 636  : 		_Closef = _Which == _Openfl;

  0019d	c6 45 14 00	 mov	 BYTE PTR log$[rbp-108], 0

; 637  : 		_Wrotesome = false;

  001a1	c6 45 09 00	 mov	 BYTE PTR log$[rbp-119], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  001a5	48 8d 4d 98	 lea	 rcx, QWORD PTR log$[rbp-232]
  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;

  001af	48 c7 45 18 00
	00 00 00	 mov	 QWORD PTR log$[rbp-104], 0

; 663  : 		_State = _Stinit;

  001b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  001be	48 89 45 0c	 mov	 QWORD PTR log$[rbp-116], rax

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  001c2	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR log$[rbp-128], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 90   : 	int iloæ_pieniêdzy = Ustawienia.kwota_pocz¹tkowa, kwota_zak³adu, wylosowana_liczba, wygrana; //Zmienne do których wczytuje siê wartoci liczbowe pobrane od u¿ytkownika takie jak kwota zak³adu a przechowuje iloæ posiadanych pieniêdzy a tak¿e przechowuje wyniki funkcji losowania liczby z ruletki i kwote wygran¹ z zak³adu

  001ca	8b 05 0c 00 00
	00		 mov	 eax, DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12
  001d0	89 44 24 44	 mov	 DWORD PTR iloæ_pieniêdzy$[rsp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  001d4	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  001dc	f3 0f 7f 44 24
	70		 movdqu	 XMMWORD PTR typ_zak³adu$[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  001e2	c6 44 24 60 00	 mov	 BYTE PTR typ_zak³adu$[rsp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 94   : 	Wczytaj_z_pliku(log_ogólny, log, co_kontynuowaæ, iloæ_pieniêdzy, kwota_zak³adu, wylosowana_liczba, typ_zak³adu); //Wczytanie stanu gry z pliku

  001e7	48 8d 44 24 60	 lea	 rax, QWORD PTR typ_zak³adu$[rsp]
  001ec	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001f1	48 8d 44 24 48	 lea	 rax, QWORD PTR wylosowana_liczba$[rsp]
  001f6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001fb	48 8d 44 24 4c	 lea	 rax, QWORD PTR kwota_zak³adu$[rsp]
  00200	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00205	4c 8d 4c 24 44	 lea	 r9, QWORD PTR iloæ_pieniêdzy$[rsp]
  0020a	4c 8d 44 24 40	 lea	 r8, QWORD PTR co_kontynuowaæ$[rsp]
  0020f	48 8d 55 80	 lea	 rdx, QWORD PTR log$[rbp-256]
  00213	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-256]
  0021a	e8 00 00 00 00	 call	 ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Wczytaj_z_pliku
  0021f	90		 npad	 1
$LL4@main:

; 95   : 
; 96   : 	do
; 97   : 	{
; 98   : 		Pêtla_g³ówna(wygrana, kwota_zak³adu, iloæ_pieniêdzy, log_ogólny, log, co_kontynuowaæ, typ_zak³adu, wylosowana_liczba); //Funkcja obs³uguj¹ca wszystkie elementy gry

  00220	48 8d 44 24 48	 lea	 rax, QWORD PTR wylosowana_liczba$[rsp]
  00225	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0022a	48 8d 44 24 60	 lea	 rax, QWORD PTR typ_zak³adu$[rsp]
  0022f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00234	48 8d 44 24 40	 lea	 rax, QWORD PTR co_kontynuowaæ$[rsp]
  00239	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0023e	48 8d 45 80	 lea	 rax, QWORD PTR log$[rbp-256]
  00242	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00247	4c 8d 8d a0 00
	00 00		 lea	 r9, QWORD PTR log_ogólny$[rbp-256]
  0024e	4c 8d 44 24 44	 lea	 r8, QWORD PTR iloæ_pieniêdzy$[rsp]
  00253	48 8d 54 24 4c	 lea	 rdx, QWORD PTR kwota_zak³adu$[rsp]
  00258	48 8d 4c 24 58	 lea	 rcx, QWORD PTR wygrana$[rsp]
  0025d	e8 00 00 00 00	 call	 ?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; Pêtla_g³ówna

; 99   : 		co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  00262	c6 44 24 40 6e	 mov	 BYTE PTR co_kontynuowaæ$[rsp], 110 ; 0000006eH

; 100  : 	} while (Czy_Kontynuowaæ(iloæ_pieniêdzy)); //Pêtla dza³aj¹ca do czasu wartoci fa³sz zwróconej przez funkcjê Czy_kontynuowaæ

  00267	48 8d 4c 24 44	 lea	 rcx, QWORD PTR iloæ_pieniêdzy$[rsp]
  0026c	e8 00 00 00 00	 call	 ?Czy_Kontynuowaæ@@YA_NAEBH@Z ; Czy_Kontynuowaæ
  00271	84 c0		 test	 al, al
  00273	75 ab		 jne	 SHORT $LL4@main

; 101  : 
; 102  : 	Koniec_gry(log_ogólny, log, iloæ_pieniêdzy); //Zakoñczenie gry i wskazanie wyniku

  00275	4c 8d 44 24 44	 lea	 r8, QWORD PTR iloæ_pieniêdzy$[rsp]
  0027a	48 8d 55 80	 lea	 rdx, QWORD PTR log$[rbp-256]
  0027e	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-256]
  00285	e8 00 00 00 00	 call	 ?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z ; Koniec_gry

; 103  : 
; 104  : 	system("pause"); //Wywo³anie funkcji wymagaj¹cej do zamkniêcia naciniêcie dowolnego klawisza

  0028a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05PDJBBECF@pause?$AA@
  00291	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_system
  00297	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00298	48 8b 54 24 78	 mov	 rdx, QWORD PTR typ_zak³adu$[rsp+24]
  0029d	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  002a1	72 4a		 jb	 SHORT $LN98@main

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002a3	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002a6	48 8b 44 24 60	 mov	 rax, QWORD PTR typ_zak³adu$[rsp]
  002ab	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  002ae	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  002b5	72 2e		 jb	 SHORT $LN101@main

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  002b7	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  002bb	4c 3b c2	 cmp	 r8, rdx
  002be	76 1e		 jbe	 SHORT $_Invalid_parameter$139

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  002c0	49 8b d0	 mov	 rdx, r8
  002c3	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  002c6	75 16		 jne	 SHORT $_Invalid_parameter$139

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002c8	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  002cc	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  002cf	73 0d		 jae	 SHORT $_Invalid_parameter$139

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  002d1	48 2b c8	 sub	 rcx, rax
  002d4	48 83 e9 08	 sub	 rcx, 8
  002d8	48 83 f9 1f	 cmp	 rcx, 31
  002dc	76 07		 jbe	 SHORT $LN101@main
$_Invalid_parameter$139:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  002e4	cc		 int	 3
$LN101@main:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  002e5	48 8b c8	 mov	 rcx, rax
  002e8	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN98@main:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  002ed	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  002f5	f3 0f 7f 44 24
	70		 movdqu	 XMMWORD PTR typ_zak³adu$[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  002fb	c6 44 24 60 00	 mov	 BYTE PTR typ_zak³adu$[rsp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 106  : 	return 0; //Zwrócenie wartoæ 0, czyli porogram zakoñczy³ siê bez b³êdu

  00300	48 8d 4d 80	 lea	 rcx, QWORD PTR log$[rbp-256]
  00304	e8 00 00 00 00	 call	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00309	90		 npad	 1
  0030a	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-256]
  00311	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00316	33 c0		 xor	 eax, eax

; 107  : }

  00318	48 8b 8d b0 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  0031f	48 33 cc	 xor	 rcx, rsp
  00322	e8 00 00 00 00	 call	 __security_check_cookie
  00327	48 8b 9c 24 d0
	02 00 00	 mov	 rbx, QWORD PTR [rsp+720]
  0032f	48 81 c4 c0 02
	00 00		 add	 rsp, 704		; 000002c0H
  00336	5d		 pop	 rbp
  00337	c3		 ret	 0
$LN136@main:
main	ENDP
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$0 PROC
  00000	48 8d 8a a0 01
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$0 ENDP
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$5 PROC
  0000c	40 55		 push	 rbp
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	48 8b ea	 mov	 rbp, rdx
  00015	8b 45 44	 mov	 eax, DWORD PTR $T1[rbp]
  00018	83 e0 01	 and	 eax, 1
  0001b	85 c0		 test	 eax, eax
  0001d	74 18		 je	 SHORT $LN28@main$dtor$
  0001f	83 65 44 fe	 and	 DWORD PTR $T1[rbp], -2
  00023	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rbp]
  0002a	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN28@main$dtor$:
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5d		 pop	 rbp
  0003c	c3		 ret	 0
main$dtor$5 ENDP
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$6 PROC
  0003d	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rdx]
  00044	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00048	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$6 ENDP
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$8 PROC
  0004f	48 8b 8a 58 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00056	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$8 ENDP
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$1 PROC
  0005d	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rdx]
  00064	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$1 ENDP
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$2 PROC
  00069	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR typ_zak³adu$[rdx]
  00070	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$0 PROC
  00000	48 8d 8a a0 01
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$5 PROC
  0000c	40 55		 push	 rbp
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	48 8b ea	 mov	 rbp, rdx
  00015	8b 45 44	 mov	 eax, DWORD PTR $T1[rbp]
  00018	83 e0 01	 and	 eax, 1
  0001b	85 c0		 test	 eax, eax
  0001d	74 18		 je	 SHORT $LN28@main$dtor$
  0001f	83 65 44 fe	 and	 DWORD PTR $T1[rbp], -2
  00023	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rbp]
  0002a	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN28@main$dtor$:
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5d		 pop	 rbp
  0003c	c3		 ret	 0
main$dtor$5 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$6 PROC
  0003d	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rdx]
  00044	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00048	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$6 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$8 PROC
  0004f	48 8b 8a 58 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00056	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$8 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$1 PROC
  0005d	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rdx]
  00064	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T11 = 80
this$ = 88
hCCI$12 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$2 PROC
  00069	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR typ_zak³adu$[rdx]
  00070	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN19:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8d b9 a8 00
	00 00		 lea	 rdi, QWORD PTR [rcx+168]

; 1132 : 		{	// destroy the object

  0001b	48 8b 87 58 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-168]
  00022	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  0002d	48 89 84 39 58
	ff ff ff	 mov	 QWORD PTR [rcx+rdi-168], rax
  00035	48 8b 87 58 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-168]
  0003c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00040	8d 91 58 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-168]
  00046	89 94 39 54 ff
	ff ff		 mov	 DWORD PTR [rcx+rdi-172], edx

; 1133 : 		}

  0004d	48 8d 9f 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rdi-160]

; 161  : 		{	// destroy the object

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0005b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005e	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00066	74 2f		 je	 SHORT $LN12@vbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00068	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  0006c	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  00070	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00073	75 22		 jne	 SHORT $LN12@vbase

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00075	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007c	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00083	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00086	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0008a	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008d	44 2b c2	 sub	 r8d, edx
  00090	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00094	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN12@vbase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 164  : 		if (_Closef)

  00097	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  0009b	74 09		 je	 SHORT $LN8@vbase

; 165  : 			close();

  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a5	90		 npad	 1
$LN8@vbase:

; 166  : 		}

  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000af	90		 npad	 1

; 1133 : 		}

  000b0	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000bd	90		 npad	 1
  000be	48 8b cf	 mov	 rcx, rdi
  000c1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ca	5f		 pop	 rdi
  000cb	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
classSize$dead$ = 56
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	33 d2		 xor	 edx, edx
  00006	41 b8 08 01 00
	00		 mov	 r8d, 264		; 00000108H
  0000c	e8 00 00 00 00	 call	 memset
  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN19:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8d b9 b8 00
	00 00		 lea	 rdi, QWORD PTR [rcx+184]

; 1352 : 		{	// destroy the object

  0001b	48 8b 87 48 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-184]
  00022	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  0002d	48 89 84 39 48
	ff ff ff	 mov	 QWORD PTR [rcx+rdi-184], rax
  00035	48 8b 87 48 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-184]
  0003c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00040	8d 91 48 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-184]
  00046	89 94 39 44 ff
	ff ff		 mov	 DWORD PTR [rcx+rdi-188], edx

; 1353 : 		}

  0004d	48 8d 9f 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rdi-160]

; 161  : 		{	// destroy the object

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0005b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005e	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00066	74 2f		 je	 SHORT $LN12@vbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00068	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  0006c	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  00070	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00073	75 22		 jne	 SHORT $LN12@vbase

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00075	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007c	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00083	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00086	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0008a	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008d	44 2b c2	 sub	 r8d, edx
  00090	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00094	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN12@vbase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 164  : 		if (_Closef)

  00097	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  0009b	74 09		 je	 SHORT $LN8@vbase

; 165  : 			close();

  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a5	90		 npad	 1
$LN8@vbase:

; 166  : 		}

  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000af	90		 npad	 1

; 1353 : 		}

  000b0	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000bd	90		 npad	 1
  000be	48 8b cf	 mov	 rcx, rdi
  000c1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ca	5f		 pop	 rdi
  000cb	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
classSize$dead$ = 56
?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	33 d2		 xor	 edx, edx
  00006	41 b8 18 01 00
	00		 mov	 r8d, 280		; 00000118H
  0000c	e8 00 00 00 00	 call	 memset
  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = 32
$T295 = 40
__$ReturnUdt$ = 64
?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Obstaw, COMDAT

; 110  : {

$LN2069:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T295[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
  00016	33 c0		 xor	 eax, eax
  00018	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0001c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00020	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00028	88 01		 mov	 BYTE PTR [rcx], al
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 186  : 	return zaklad_typ; //Zwracam typ zak³adu podany przez u¿ytkownika

  0002a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
$LL4@Obstaw:

; 111  : 	string zaklad_typ; //Deklaracja zmiennej typu string przechowywuj¹cej typ zak³adu
; 112  : 
; 113  : 	do { //Pêtla do aby wykona³a siê conajmniej raz
; 114  : 		cout << "Jak¹ opcje chcesz obstawiæ? (zgodnie z poni¿szym opisem) :" << endl; //Zadanie pytania u¿ytkownikowi

  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@POFCNLON@Jak?$LJ?5opcje?5chcesz?5obstawi?f?$DP?5?$CIzgo@
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00040	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00045	48 8b c8	 mov	 rcx, rax
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 115  : 		cout << "p - parzyste" << endl; //Wskazaæ mo¿liw¹ odpowied

  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@
  0005c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00063	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00068	48 8b c8	 mov	 rcx, rax
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 116  : 		cout << "n - nieparzyste" << endl; //Wskazaæ mo¿liw¹ odpowied

  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@
  0007f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00086	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 117  : 		cout << "r - czerwone (red)" << endl; //Wskazaæ mo¿liw¹ odpowied

  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@LEDAOJLK@r?5?9?5czerwone?5?$CIred?$CJ?$AA@
  000a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000a9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 118  : 		cout << "b - czarne (black)" << endl; //Wskazaæ mo¿liw¹ odpowied

  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@EPLAAEJB@b?5?9?5czarne?5?$CIblack?$CJ?$AA@
  000c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000cc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000d1	48 8b c8	 mov	 rcx, rax
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 119  : 		cout << "g - górna po³owa" << endl; //Wskazaæ mo¿liw¹ odpowied

  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@
  000e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000ef	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000f4	48 8b c8	 mov	 rcx, rax
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 120  : 		cout << "d - dolna po³owa" << endl; //Wskazaæ mo¿liw¹ odpowied

  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@
  0010b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00112	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00117	48 8b c8	 mov	 rcx, rax
  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 121  : 		cout << "k1, k2, k3 - kolumna 1, kolumna 2, kolumna 3" << endl; //Wskazaæ mo¿liw¹ odpowied

  00127	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@
  0012e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00135	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0013a	48 8b c8	 mov	 rcx, rax
  0013d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 122  : 		cout << "w1, w2, ... , w12 - wiersz trzech numerów" << endl; //Wskazaæ mo¿liw¹ odpowied

  0014a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@OAIPJBPB@w1?0?5w2?0?5?4?4?4?5?0?5w12?5?9?5wiersz?5trzec@
  00151	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00158	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0015d	48 8b c8	 mov	 rcx, rax
  00160	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 123  : 		cout << "0-36 - pojedyñcze pole o odpowiednim numerze" << endl; //Wskazaæ mo¿liw¹ odpowied

  0016d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@CGIAAFPM@0?936?5?9?5pojedy?qcze?5pole?5o?5odpowie@
  00174	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0017b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00180	48 8b c8	 mov	 rcx, rax
  00183	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  00190	48 8b d3	 mov	 rdx, rbx
  00193	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  0019a	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0019f	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001a2	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  001a6	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  001aa	72 03		 jb	 SHORT $LN1838@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001ac	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1838@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  001af	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001b3	48 83 f8 01	 cmp	 rax, 1
  001b7	75 0f		 jne	 SHORT $LN2067@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001b9	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001bc	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01JBBJJEPG@p?$AA@
  001c2	0f 84 a5 07 00
	00		 je	 $LN5@Obstaw
$LN2067@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001c8	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001cb	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  001cf	72 03		 jb	 SHORT $LN1839@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001d1	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1839@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001d4	48 83 f8 01	 cmp	 rax, 1
  001d8	75 0f		 jne	 SHORT $LN2066@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001da	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001dd	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01EFFIKLCJ@n?$AA@
  001e3	0f 84 84 07 00
	00		 je	 $LN5@Obstaw
$LN2066@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001e9	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001ec	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  001f0	72 03		 jb	 SHORT $LN1840@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001f2	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1840@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001f5	48 83 f8 01	 cmp	 rax, 1
  001f9	75 0f		 jne	 SHORT $LN2065@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001fb	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001fe	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01KDCPPGHE@r?$AA@
  00204	0f 84 63 07 00
	00		 je	 $LN5@Obstaw
$LN2065@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0020a	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0020d	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00211	72 03		 jb	 SHORT $LN1841@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00213	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1841@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00216	48 83 f8 01	 cmp	 rax, 1
  0021a	75 0f		 jne	 SHORT $LN2064@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0021c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0021f	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01OJONOECF@b?$AA@
  00225	0f 84 42 07 00
	00		 je	 $LN5@Obstaw
$LN2064@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0022b	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0022e	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00232	72 03		 jb	 SHORT $LN1842@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00234	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1842@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00237	48 83 f8 01	 cmp	 rax, 1
  0023b	75 0f		 jne	 SHORT $LN2063@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0023d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00240	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01JEJKBAGA@g?$AA@
  00246	0f 84 21 07 00
	00		 je	 $LN5@Obstaw
$LN2063@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0024c	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0024f	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00253	72 03		 jb	 SHORT $LN1843@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00255	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1843@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00258	48 83 f8 01	 cmp	 rax, 1
  0025c	75 0f		 jne	 SHORT $LN2062@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0025e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00261	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01LPLHEDKD@d?$AA@
  00267	0f 84 00 07 00
	00		 je	 $LN5@Obstaw
$LN2062@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0026d	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00270	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00274	72 03		 jb	 SHORT $LN1844@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00276	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1844@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00279	48 83 f8 02	 cmp	 rax, 2
  0027d	75 10		 jne	 SHORT $LN2061@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0027f	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00282	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02ICGBAFJO@k1?$AA@
  00289	0f 84 de 06 00
	00		 je	 $LN5@Obstaw
$LN2061@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0028f	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00292	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00296	72 03		 jb	 SHORT $LN1845@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00298	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1845@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0029b	48 83 f8 02	 cmp	 rax, 2
  0029f	75 10		 jne	 SHORT $LN2060@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002a1	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  002a4	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02KJEMFGFN@k2?$AA@
  002ab	0f 84 bc 06 00
	00		 je	 $LN5@Obstaw
$LN2060@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  002b1	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002b4	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  002b8	72 03		 jb	 SHORT $LN1846@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  002ba	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1846@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002bd	48 83 f8 02	 cmp	 rax, 2
  002c1	75 10		 jne	 SHORT $LN2059@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002c3	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  002c6	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02LAFHGHBM@k3?$AA@
  002cd	0f 84 9a 06 00
	00		 je	 $LN5@Obstaw
$LN2059@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  002d3	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002d6	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  002da	72 03		 jb	 SHORT $LN1847@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  002dc	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1847@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002df	48 83 f8 02	 cmp	 rax, 2
  002e3	75 10		 jne	 SHORT $LN2058@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002e5	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  002e8	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02JHFNFPIK@w1?$AA@
  002ef	0f 84 78 06 00
	00		 je	 $LN5@Obstaw
$LN2058@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  002f5	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002f8	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  002fc	72 03		 jb	 SHORT $LN1848@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  002fe	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1848@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00301	48 83 f8 02	 cmp	 rax, 2
  00305	75 10		 jne	 SHORT $LN2057@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00307	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0030a	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02LMHAAMEJ@w2?$AA@
  00311	0f 84 56 06 00
	00		 je	 $LN5@Obstaw
$LN2057@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00317	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0031a	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0031e	72 03		 jb	 SHORT $LN1849@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00320	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1849@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00323	48 83 f8 02	 cmp	 rax, 2
  00327	75 10		 jne	 SHORT $LN2056@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00329	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0032c	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02KFGLDNAI@w3?$AA@
  00333	0f 84 34 06 00
	00		 je	 $LN5@Obstaw
$LN2056@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00339	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0033c	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00340	72 03		 jb	 SHORT $LN1850@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00342	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1850@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00345	48 83 f8 02	 cmp	 rax, 2
  00349	75 10		 jne	 SHORT $LN2055@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0034b	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0034e	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02OKCKKLMP@w4?$AA@
  00355	0f 84 12 06 00
	00		 je	 $LN5@Obstaw
$LN2055@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0035b	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0035e	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00362	72 03		 jb	 SHORT $LN1851@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00364	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1851@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00367	48 83 f8 02	 cmp	 rax, 2
  0036b	75 10		 jne	 SHORT $LN2054@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0036d	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00370	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02PDDBJKIO@w5?$AA@
  00377	0f 84 f0 05 00
	00		 je	 $LN5@Obstaw
$LN2054@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0037d	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00380	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00384	72 03		 jb	 SHORT $LN1852@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00386	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1852@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00389	48 83 f8 02	 cmp	 rax, 2
  0038d	75 10		 jne	 SHORT $LN2053@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0038f	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00392	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02NIBMMJEN@w6?$AA@
  00399	0f 84 ce 05 00
	00		 je	 $LN5@Obstaw
$LN2053@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0039f	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003a2	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  003a6	72 03		 jb	 SHORT $LN1853@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  003a8	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1853@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  003ab	48 83 f8 02	 cmp	 rax, 2
  003af	75 10		 jne	 SHORT $LN2052@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  003b1	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  003b4	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02MBAHPIAM@w7?$AA@
  003bb	0f 84 ac 05 00
	00		 je	 $LN5@Obstaw
$LN2052@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  003c1	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003c4	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  003c8	72 03		 jb	 SHORT $LN1854@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  003ca	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1854@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  003cd	48 83 f8 02	 cmp	 rax, 2
  003d1	75 10		 jne	 SHORT $LN2051@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  003d3	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  003d6	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02EGJPOEMD@w8?$AA@
  003dd	0f 84 8a 05 00
	00		 je	 $LN5@Obstaw
$LN2051@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  003e3	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003e6	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  003ea	72 03		 jb	 SHORT $LN1855@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  003ec	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1855@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  003ef	48 83 f8 02	 cmp	 rax, 2
  003f3	75 10		 jne	 SHORT $LN2050@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  003f5	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  003f8	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02FPIENFIC@w9?$AA@
  003ff	0f 84 68 05 00
	00		 je	 $LN5@Obstaw
$LN2050@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00405	4c 8b c3	 mov	 r8, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00408	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0040c	72 03		 jb	 SHORT $LN1856@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0040e	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
$LN1856@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00411	48 83 f8 03	 cmp	 rax, 3
  00415	75 1e		 jne	 SHORT $LN2049@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00417	41 0f b7 08	 movzx	 ecx, WORD PTR [r8]
  0041b	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_03NCLMABJC@w10?$AA@
  00422	75 11		 jne	 SHORT $LN2049@Obstaw
  00424	41 0f b6 48 02	 movzx	 ecx, BYTE PTR [r8+2]
  00429	3a 0d 02 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_03NCLMABJC@w10?$AA@+2
  0042f	0f 84 38 05 00
	00		 je	 $LN5@Obstaw
$LN2049@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00435	4c 8b c3	 mov	 r8, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00438	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0043c	72 03		 jb	 SHORT $LN1857@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0043e	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
$LN1857@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00441	48 83 f8 03	 cmp	 rax, 3
  00445	75 1e		 jne	 SHORT $LN2048@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00447	41 0f b7 08	 movzx	 ecx, WORD PTR [r8]
  0044b	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_03MLKHDAND@w11?$AA@
  00452	75 11		 jne	 SHORT $LN2048@Obstaw
  00454	41 0f b6 48 02	 movzx	 ecx, BYTE PTR [r8+2]
  00459	3a 0d 02 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_03MLKHDAND@w11?$AA@+2
  0045f	0f 84 08 05 00
	00		 je	 $LN5@Obstaw
$LN2048@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00465	4c 8b c3	 mov	 r8, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00468	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0046c	72 03		 jb	 SHORT $LN1858@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0046e	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
$LN1858@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00471	48 83 f8 03	 cmp	 rax, 3
  00475	75 1e		 jne	 SHORT $LN2047@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00477	41 0f b7 08	 movzx	 ecx, WORD PTR [r8]
  0047b	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_03OAIKGDBA@w12?$AA@
  00482	75 11		 jne	 SHORT $LN2047@Obstaw
  00484	41 0f b6 48 02	 movzx	 ecx, BYTE PTR [r8+2]
  00489	3a 0d 02 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_03OAIKGDBA@w12?$AA@+2
  0048f	0f 84 d8 04 00
	00		 je	 $LN5@Obstaw
$LN2047@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00495	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00498	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0049c	72 03		 jb	 SHORT $LN1859@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0049e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1859@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  004a1	48 83 f8 01	 cmp	 rax, 1
  004a5	75 0f		 jne	 SHORT $LN2046@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  004a7	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  004aa	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01GBGANLPD@0?$AA@
  004b0	0f 84 b7 04 00
	00		 je	 $LN5@Obstaw
$LN2046@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  004b6	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004b9	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  004bd	72 03		 jb	 SHORT $LN1860@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004bf	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1860@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  004c2	48 83 f8 01	 cmp	 rax, 1
  004c6	75 0f		 jne	 SHORT $LN2045@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  004c8	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  004cb	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01HIHLOKLC@1?$AA@
  004d1	0f 84 96 04 00
	00		 je	 $LN5@Obstaw
$LN2045@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  004d7	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004da	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  004de	72 03		 jb	 SHORT $LN1861@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  004e0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1861@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  004e3	48 83 f8 01	 cmp	 rax, 1
  004e7	75 0f		 jne	 SHORT $LN2044@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  004e9	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  004ec	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01FDFGLJHB@2?$AA@
  004f2	0f 84 75 04 00
	00		 je	 $LN5@Obstaw
$LN2044@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  004f8	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004fb	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  004ff	72 03		 jb	 SHORT $LN1862@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00501	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1862@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00504	48 83 f8 01	 cmp	 rax, 1
  00508	75 0f		 jne	 SHORT $LN2043@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0050a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0050d	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01EKENIIDA@3?$AA@
  00513	0f 84 54 04 00
	00		 je	 $LN5@Obstaw
$LN2043@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00519	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0051c	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00520	72 03		 jb	 SHORT $LN1863@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00522	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1863@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00525	48 83 f8 01	 cmp	 rax, 1
  00529	75 0f		 jne	 SHORT $LN2042@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0052b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0052e	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01FAMBOPH@4?$AA@
  00534	0f 84 33 04 00
	00		 je	 $LN5@Obstaw
$LN2042@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0053a	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0053d	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00541	72 03		 jb	 SHORT $LN1864@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00543	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1864@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00546	48 83 f8 01	 cmp	 rax, 1
  0054a	75 0f		 jne	 SHORT $LN2041@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0054c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0054f	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01BMBHCPLG@5?$AA@
  00555	0f 84 12 04 00
	00		 je	 $LN5@Obstaw
$LN2041@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0055b	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0055e	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00562	72 03		 jb	 SHORT $LN1865@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00564	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1865@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00567	48 83 f8 01	 cmp	 rax, 1
  0056b	75 0f		 jne	 SHORT $LN2040@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0056d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00570	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01DHDKHMHF@6?$AA@
  00576	0f 84 f1 03 00
	00		 je	 $LN5@Obstaw
$LN2040@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0057c	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0057f	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00583	72 03		 jb	 SHORT $LN1866@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00585	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1866@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00588	48 83 f8 01	 cmp	 rax, 1
  0058c	75 0f		 jne	 SHORT $LN2039@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0058e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00591	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01COCBENDE@7?$AA@
  00597	0f 84 d0 03 00
	00		 je	 $LN5@Obstaw
$LN2039@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0059d	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005a0	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  005a4	72 03		 jb	 SHORT $LN1867@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005a6	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1867@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005a9	48 83 f8 01	 cmp	 rax, 1
  005ad	75 0f		 jne	 SHORT $LN2038@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005af	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  005b2	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01KJLJFBPL@8?$AA@
  005b8	0f 84 af 03 00
	00		 je	 $LN5@Obstaw
$LN2038@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  005be	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005c1	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  005c5	72 03		 jb	 SHORT $LN1868@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005c7	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1868@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005ca	48 83 f8 01	 cmp	 rax, 1
  005ce	75 0f		 jne	 SHORT $LN2037@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005d0	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  005d3	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01LAKCGALK@9?$AA@
  005d9	0f 84 8e 03 00
	00		 je	 $LN5@Obstaw
$LN2037@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  005df	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005e2	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  005e6	72 03		 jb	 SHORT $LN1869@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005e8	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1869@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005eb	48 83 f8 02	 cmp	 rax, 2
  005ef	75 10		 jne	 SHORT $LN2036@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005f1	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  005f4	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02PKFBJPLJ@10?$AA@
  005fb	0f 84 6c 03 00
	00		 je	 $LN5@Obstaw
$LN2036@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00601	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00604	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00608	72 03		 jb	 SHORT $LN1870@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0060a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1870@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0060d	48 83 f8 02	 cmp	 rax, 2
  00611	75 10		 jne	 SHORT $LN2035@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00613	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00616	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02ODEKKOPI@11?$AA@
  0061d	0f 84 4a 03 00
	00		 je	 $LN5@Obstaw
$LN2035@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00623	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00626	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0062a	72 03		 jb	 SHORT $LN1871@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0062c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1871@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0062f	48 83 f8 02	 cmp	 rax, 2
  00633	75 10		 jne	 SHORT $LN2034@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00635	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00638	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02MIGHPNDL@12?$AA@
  0063f	0f 84 28 03 00
	00		 je	 $LN5@Obstaw
$LN2034@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00645	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00648	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0064c	72 03		 jb	 SHORT $LN1872@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0064e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1872@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00651	48 83 f8 02	 cmp	 rax, 2
  00655	75 10		 jne	 SHORT $LN2033@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00657	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0065a	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02NBHMMMHK@13?$AA@
  00661	0f 84 06 03 00
	00		 je	 $LN5@Obstaw
$LN2033@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00667	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0066a	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0066e	72 03		 jb	 SHORT $LN1873@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00670	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1873@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00673	48 83 f8 02	 cmp	 rax, 2
  00677	75 10		 jne	 SHORT $LN2032@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00679	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0067c	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02JODNFKLN@14?$AA@
  00683	0f 84 e4 02 00
	00		 je	 $LN5@Obstaw
$LN2032@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00689	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0068c	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00690	72 03		 jb	 SHORT $LN1874@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00692	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1874@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00695	48 83 f8 02	 cmp	 rax, 2
  00699	75 10		 jne	 SHORT $LN2031@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0069b	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0069e	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02IHCGGLPM@15?$AA@
  006a5	0f 84 c2 02 00
	00		 je	 $LN5@Obstaw
$LN2031@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  006ab	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006ae	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  006b2	72 03		 jb	 SHORT $LN1875@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  006b4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1875@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  006b7	48 83 f8 02	 cmp	 rax, 2
  006bb	75 10		 jne	 SHORT $LN2030@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  006bd	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  006c0	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02KMALDIDP@16?$AA@
  006c7	0f 84 a0 02 00
	00		 je	 $LN5@Obstaw
$LN2030@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  006cd	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006d0	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  006d4	72 03		 jb	 SHORT $LN1876@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  006d6	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1876@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  006d9	48 83 f8 02	 cmp	 rax, 2
  006dd	75 10		 jne	 SHORT $LN2029@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  006df	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  006e2	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02LFBAAJHO@17?$AA@
  006e9	0f 84 7e 02 00
	00		 je	 $LN5@Obstaw
$LN2029@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  006ef	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006f2	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  006f6	72 03		 jb	 SHORT $LN1877@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  006f8	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1877@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  006fb	48 83 f8 02	 cmp	 rax, 2
  006ff	75 10		 jne	 SHORT $LN2028@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00701	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00704	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02DCIIBFLB@18?$AA@
  0070b	0f 84 5c 02 00
	00		 je	 $LN5@Obstaw
$LN2028@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00711	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00714	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00718	72 03		 jb	 SHORT $LN1878@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0071a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1878@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0071d	48 83 f8 02	 cmp	 rax, 2
  00721	75 10		 jne	 SHORT $LN2027@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00723	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00726	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02CLJDCEPA@19?$AA@
  0072d	0f 84 3a 02 00
	00		 je	 $LN5@Obstaw
$LN2027@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00733	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00736	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0073a	72 03		 jb	 SHORT $LN1879@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0073c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1879@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0073f	48 83 f8 02	 cmp	 rax, 2
  00743	75 10		 jne	 SHORT $LN2026@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00745	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00748	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02PIBHCBOA@20?$AA@
  0074f	0f 84 18 02 00
	00		 je	 $LN5@Obstaw
$LN2026@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00755	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00758	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0075c	72 03		 jb	 SHORT $LN1880@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0075e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1880@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00761	48 83 f8 02	 cmp	 rax, 2
  00765	75 10		 jne	 SHORT $LN2025@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00767	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0076a	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02OBAMBAKB@21?$AA@
  00771	0f 84 f6 01 00
	00		 je	 $LN5@Obstaw
$LN2025@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00777	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0077a	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0077e	72 03		 jb	 SHORT $LN1881@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00780	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1881@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00783	48 83 f8 02	 cmp	 rax, 2
  00787	75 10		 jne	 SHORT $LN2024@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00789	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0078c	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02MKCBEDGC@22?$AA@
  00793	0f 84 d4 01 00
	00		 je	 $LN5@Obstaw
$LN2024@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00799	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0079c	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  007a0	72 03		 jb	 SHORT $LN1882@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  007a2	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1882@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  007a5	48 83 f8 02	 cmp	 rax, 2
  007a9	75 10		 jne	 SHORT $LN2023@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  007ab	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  007ae	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02NDDKHCCD@23?$AA@
  007b5	0f 84 b2 01 00
	00		 je	 $LN5@Obstaw
$LN2023@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  007bb	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007be	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  007c2	72 03		 jb	 SHORT $LN1883@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  007c4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1883@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  007c7	48 83 f8 02	 cmp	 rax, 2
  007cb	75 10		 jne	 SHORT $LN2022@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  007cd	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  007d0	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02JMHLOEOE@24?$AA@
  007d7	0f 84 90 01 00
	00		 je	 $LN5@Obstaw
$LN2022@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  007dd	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007e0	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  007e4	72 03		 jb	 SHORT $LN1884@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  007e6	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1884@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  007e9	48 83 f8 02	 cmp	 rax, 2
  007ed	75 10		 jne	 SHORT $LN2021@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  007ef	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  007f2	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02IFGANFKF@25?$AA@
  007f9	0f 84 6e 01 00
	00		 je	 $LN5@Obstaw
$LN2021@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  007ff	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00802	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00806	72 03		 jb	 SHORT $LN1885@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00808	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1885@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0080b	48 83 f8 02	 cmp	 rax, 2
  0080f	75 10		 jne	 SHORT $LN2020@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00811	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00814	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02KOENIGGG@26?$AA@
  0081b	0f 84 4c 01 00
	00		 je	 $LN5@Obstaw
$LN2020@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00821	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00824	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00828	72 03		 jb	 SHORT $LN1886@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0082a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1886@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0082d	48 83 f8 02	 cmp	 rax, 2
  00831	75 10		 jne	 SHORT $LN2019@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00833	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00836	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02LHFGLHCH@27?$AA@
  0083d	0f 84 2a 01 00
	00		 je	 $LN5@Obstaw
$LN2019@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00843	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00846	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0084a	72 03		 jb	 SHORT $LN1887@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0084c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1887@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0084f	48 83 f8 02	 cmp	 rax, 2
  00853	75 10		 jne	 SHORT $LN2018@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00855	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00858	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02DAMOKLOI@28?$AA@
  0085f	0f 84 08 01 00
	00		 je	 $LN5@Obstaw
$LN2018@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00865	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00868	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0086c	72 03		 jb	 SHORT $LN1888@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0086e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1888@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00871	48 83 f8 02	 cmp	 rax, 2
  00875	75 10		 jne	 SHORT $LN2017@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00877	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0087a	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02CJNFJKKJ@29?$AA@
  00881	0f 84 e6 00 00
	00		 je	 $LN5@Obstaw
$LN2017@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00887	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0088a	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0088e	72 03		 jb	 SHORT $LN1889@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00890	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1889@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00893	48 83 f8 02	 cmp	 rax, 2
  00897	75 10		 jne	 SHORT $LN2016@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00899	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0089c	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02PJNFELNH@30?$AA@
  008a3	0f 84 c4 00 00
	00		 je	 $LN5@Obstaw
$LN2016@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008a9	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008ac	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  008b0	72 03		 jb	 SHORT $LN1890@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  008b2	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1890@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  008b5	48 83 f8 02	 cmp	 rax, 2
  008b9	75 10		 jne	 SHORT $LN2015@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  008bb	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  008be	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02OAMOHKJG@31?$AA@
  008c5	0f 84 a2 00 00
	00		 je	 $LN5@Obstaw
$LN2015@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008cb	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008ce	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  008d2	72 03		 jb	 SHORT $LN1891@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  008d4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1891@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  008d7	48 83 f8 02	 cmp	 rax, 2
  008db	75 10		 jne	 SHORT $LN2014@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  008dd	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  008e0	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02MLODCJFF@32?$AA@
  008e7	0f 84 80 00 00
	00		 je	 $LN5@Obstaw
$LN2014@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008ed	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008f0	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  008f4	72 03		 jb	 SHORT $LN1892@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  008f6	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1892@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  008f9	48 83 f8 02	 cmp	 rax, 2
  008fd	75 0c		 jne	 SHORT $LN2013@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  008ff	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00902	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02NCPIBIBE@33?$AA@
  00909	74 62		 je	 SHORT $LN5@Obstaw
$LN2013@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0090b	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0090e	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00912	72 03		 jb	 SHORT $LN1893@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00914	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1893@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00917	48 83 f8 02	 cmp	 rax, 2
  0091b	75 0c		 jne	 SHORT $LN2012@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0091d	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00920	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02JNLJIOND@34?$AA@
  00927	74 44		 je	 SHORT $LN5@Obstaw
$LN2012@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00929	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0092c	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00930	72 03		 jb	 SHORT $LN1894@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00932	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1894@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00935	48 83 f8 02	 cmp	 rax, 2
  00939	75 0c		 jne	 SHORT $LN2011@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0093b	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0093e	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ??_C@_02IEKCLPJC@35?$AA@
  00945	74 26		 je	 SHORT $LN5@Obstaw
$LN2011@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00947	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0094a	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0094e	72 03		 jb	 SHORT $LN1837@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00950	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1837@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00953	48 83 f8 02	 cmp	 rax, 2
  00957	0f 85 d5 f6 ff
	ff		 jne	 $LL4@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0095d	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00960	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02KPIPOMFB@36?$AA@
  00967	0f 85 c5 f6 ff
	ff		 jne	 $LL4@Obstaw
$LN5@Obstaw:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 186  : 	return zaklad_typ; //Zwracam typ zak³adu podany przez u¿ytkownika

  0096d	48 8b c3	 mov	 rax, rbx

; 187  : }

  00970	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00974	5b		 pop	 rbx
  00975	c3		 ret	 0
  00976	cc		 int	 3
?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Obstaw
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T295 = 40
__$ReturnUdt$ = 64
?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Obstaw'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN8@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Obstaw'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T295 = 40
__$ReturnUdt$ = 64
?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Obstaw'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN8@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Obstaw'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
_TEXT	SEGMENT
$T17 = 32
kwota_zak³adu_s$ = 40
__$ArrayPad$ = 72
kwota_zak³adu$ = 96
iloæ_pieniêdzy$ = 104
?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z PROC		; Wczytaj_Kwotê_Zak³adu, COMDAT

; 190  : {

$LN181:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T17[rsp], -2
  0000f	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  00014	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00028	48 8b da	 mov	 rbx, rdx
  0002b	48 8b f9	 mov	 rdi, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0002e	33 f6		 xor	 esi, esi
  00030	48 89 74 24 38	 mov	 QWORD PTR kwota_zak³adu_s$[rsp+16], rsi

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00035	48 c7 44 24 40
	0f 00 00 00	 mov	 QWORD PTR kwota_zak³adu_s$[rsp+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0003e	40 88 74 24 28	 mov	 BYTE PTR kwota_zak³adu_s$[rsp], sil
  00043	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL2@Wczytaj_Kw:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 195  : 		cout << "Masz " << iloæ_pieniêdzy << "$, jak¹ kwot¹ chcesz obstawiæ wynik?" << endl; //Podanie akualnego stanu konta i zadanie pytania o kwotê zak³adu

  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05OMMBNPEF@Masz?5?$AA@
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0005e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00063	48 8b c8	 mov	 rcx, rax
  00066	8b 13		 mov	 edx, DWORD PTR [rbx]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0006e	48 8b c8	 mov	 rcx, rax
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@MANFGHNE@$?0?5jak?$LJ?5kwot?$LJ?5chcesz?5obstawi?f?5wy@
  00078	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0007d	48 8b c8	 mov	 rcx, rax
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  0008d	48 8d 54 24 28	 lea	 rdx, QWORD PTR kwota_zak³adu_s$[rsp]
  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  00099	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0009e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR kwota_zak³adu_s$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000a3	48 83 7c 24 40
	10		 cmp	 QWORD PTR kwota_zak³adu_s$[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  000a9	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR kwota_zak³adu_s$[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 197  : 		kwota_zak³adu = atoi(kwota_zak³adu_s.c_str()); //Zmiana stringa na inta i wpisanie do zmiennej kwota_zak³adu

  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  000b5	89 07		 mov	 DWORD PTR [rdi], eax
  000b7	8b 0b		 mov	 ecx, DWORD PTR [rbx]

; 198  : 		if ((kwota_zak³adu > 0) && (kwota_zak³adu <= iloæ_pieniêdzy)) //Sprawdzenie czy kwota zak³¹du jest wiêksza od zeri i mniejsza lub równa dostêpnej gotówce

  000b9	85 c0		 test	 eax, eax
  000bb	7e 0a		 jle	 SHORT $LN179@Wczytaj_Kw
  000bd	3b c1		 cmp	 eax, ecx
  000bf	0f 8e b5 00 00
	00		 jle	 $LN166@Wczytaj_Kw

; 199  : 			break; //Je¿eli tak to zatrzymuje pêtle
; 200  : 		else //W przeciwym wypadku
; 201  : 			if (kwota_zak³adu == 0) //Je¿eli wynikiem zamiany na liczbê jest zero (wynikiem zamiany jest zero kiedy tekst to zero lub kiedy jest b³¹d zamiany) to

  000c5	85 c0		 test	 eax, eax
$LN179@Wczytaj_Kw:
  000c7	75 58		 jne	 SHORT $LN9@Wczytaj_Kw

; 202  : 			{
; 203  : 				bool czy_zero = true; //Utworzenie zmiennej informuj¹cej czy znaleziono zero w tekcie i przypisanie jej wartoci true
; 204  : 				for (unsigned short i = 0; i < (unsigned short)kwota_zak³adu_s.size(); ++i) //Rozpoczêcie pêtli numerowanej przez zmienn¹ i przez wszystkie znaki wczytanego tekst

  000c9	0f b7 c6	 movzx	 eax, si
  000cc	44 0f b7 44 24
	38		 movzx	 r8d, WORD PTR kwota_zak³adu_s$[rsp+16]
  000d2	66 41 3b f0	 cmp	 si, r8w
  000d6	73 37		 jae	 SHORT $LN173@Wczytaj_Kw
  000d8	4c 8b 4c 24 40	 mov	 r9, QWORD PTR kwota_zak³adu_s$[rsp+24]
  000dd	4c 8b 54 24 28	 mov	 r10, QWORD PTR kwota_zak³adu_s$[rsp]
  000e2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL6@Wczytaj_Kw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  000f0	48 8d 54 24 28	 lea	 rdx, QWORD PTR kwota_zak³adu_s$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000f5	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  000f9	49 0f 43 d2	 cmovae	 rdx, r10
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 205  : 					if (kwota_zak³adu_s[i] != '0') //Je¿eli znak na i-tej pozycji

  000fd	0f b7 c8	 movzx	 ecx, ax
  00100	80 3c 11 30	 cmp	 BYTE PTR [rcx+rdx], 48	; 00000030H
  00104	75 12		 jne	 SHORT $LN165@Wczytaj_Kw

; 202  : 			{
; 203  : 				bool czy_zero = true; //Utworzenie zmiennej informuj¹cej czy znaleziono zero w tekcie i przypisanie jej wartoci true
; 204  : 				for (unsigned short i = 0; i < (unsigned short)kwota_zak³adu_s.size(); ++i) //Rozpoczêcie pêtli numerowanej przez zmienn¹ i przez wszystkie znaki wczytanego tekst

  00106	66 ff c0	 inc	 ax
  00109	66 41 3b c0	 cmp	 ax, r8w
  0010d	72 e1		 jb	 SHORT $LL6@Wczytaj_Kw
$LN173@Wczytaj_Kw:

; 213  : 				{
; 214  : 					cout << "Nie mo¿esz obstawiæ zerowego zak³adu" << endl; //Poinformowanie u¿ytkownika, ¿e nie mo¿e obstawiæ zerowego zak³adu

  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@

; 215  : 					if (Ustawienia.stan_dwiêków) cout << '\a'; //Je¿eli stan_dwiêków == 1 to wywo³anie pikniêcia w g³oniku
; 216  : 				}
; 217  : 			}

  00116	eb 25		 jmp	 SHORT $LN178@Wczytaj_Kw
$LN165@Wczytaj_Kw:

; 206  : 					{
; 207  : 						cout << "Wprowadzi³eæ nieprawid³ow¹ wartoæ" << endl; //Poinformowanie u¿ytkownika, ¿e nie mo¿e obstawiæ tekstowego

  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@

; 208  : 						if (Ustawienia.stan_dwiêków) cout << '\a'; //Je¿eli stan_dwiêków == 1 to wywo³anie pikniêcia w g³oniku
; 209  : 						czy_zero = false; //Zmiana wartoci zmiennej czy znaleziono zero w tekcie na false
; 210  : 						break; //Zatrzymanie pêtli
; 211  : 					}
; 212  : 				if (czy_zero) //Sprawdzenie czy znaleziono same zera w tekcie, je¿eli tak to

  0011f	eb 1c		 jmp	 SHORT $LN178@Wczytaj_Kw
$LN9@Wczytaj_Kw:

; 218  : 			else if (kwota_zak³adu > iloæ_pieniêdzy) //Je¿eli u¿ytkownik chce obstawiæ za wiêcej ni¿ ma, to

  00121	3b c1		 cmp	 eax, ecx
  00123	7e 09		 jle	 SHORT $LN15@Wczytaj_Kw

; 219  : 			{
; 220  : 				cout << "Nie masz tyle pieniêdzy" << endl; //Poinformowanie go o tym

  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@

; 221  : 				if (Ustawienia.stan_dwiêków) cout << '\a'; //Je¿eli stan_dwiêków == 1 to wywo³anie pikniêcia w g³oniku
; 222  : 			}

  0012c	eb 0f		 jmp	 SHORT $LN178@Wczytaj_Kw
$LN15@Wczytaj_Kw:

; 223  : 			else if (kwota_zak³adu < 0) //Je¿eli u¿ytkownik chce obstawiæ za ujemn¹ kwotê, to

  0012e	85 c0		 test	 eax, eax
  00130	0f 89 1a ff ff
	ff		 jns	 $LL2@Wczytaj_Kw

; 224  : 			{
; 225  : 				cout << "Nie mo¿esz obstawiæ ujemn¹ kwot¹ zak³adu" << endl; //Poinformowanie go o tym

  00136	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@
$LN178@Wczytaj_Kw:
  0013d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00144	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00149	48 8b c8	 mov	 rcx, rax
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 226  : 				if (Ustawienia.stan_dwiêków) cout << '\a'; //Je¿eli stan_dwiêków == 1 to wywo³anie pikniêcia w g³oniku

  00159	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  00161	0f 84 e9 fe ff
	ff		 je	 $LL2@Wczytaj_Kw
  00167	b2 07		 mov	 dl, 7
  00169	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00170	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 227  : 			}
; 228  : 	}

  00175	e9 d6 fe ff ff	 jmp	 $LL2@Wczytaj_Kw
$LN166@Wczytaj_Kw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0017a	48 8b 54 24 40	 mov	 rdx, QWORD PTR kwota_zak³adu_s$[rsp+24]
  0017f	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00183	72 46		 jb	 SHORT $LN128@Wczytaj_Kw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00185	48 8b 4c 24 28	 mov	 rcx, QWORD PTR kwota_zak³adu_s$[rsp]
  0018a	48 8b c1	 mov	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0018d	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00190	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00197	72 2d		 jb	 SHORT $LN131@Wczytaj_Kw

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00199	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  0019d	4c 3b c2	 cmp	 r8, rdx
  001a0	76 1d		 jbe	 SHORT $_Invalid_parameter$182

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001a2	49 8b d0	 mov	 rdx, r8
  001a5	a8 1f		 test	 al, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001a7	75 16		 jne	 SHORT $_Invalid_parameter$182

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001a9	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  001ad	48 3b c8	 cmp	 rcx, rax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  001b0	73 0d		 jae	 SHORT $_Invalid_parameter$182

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001b2	48 2b c1	 sub	 rax, rcx
  001b5	48 83 e8 08	 sub	 rax, 8
  001b9	48 83 f8 1f	 cmp	 rax, 31
  001bd	76 07		 jbe	 SHORT $LN131@Wczytaj_Kw
$_Invalid_parameter$182:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001c5	cc		 int	 3
$LN131@Wczytaj_Kw:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  001c6	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN128@Wczytaj_Kw:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 229  : }

  001cb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d0	48 33 cc	 xor	 rcx, rsp
  001d3	e8 00 00 00 00	 call	 __security_check_cookie
  001d8	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001dd	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  001e2	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001e6	5f		 pop	 rdi
  001e7	c3		 ret	 0
$LN177@Wczytaj_Kw:
?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z ENDP		; Wczytaj_Kwotê_Zak³adu
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T17 = 32
kwota_zak³adu_s$ = 40
__$ArrayPad$ = 72
kwota_zak³adu$ = 96
iloæ_pieniêdzy$ = 104
?dtor$0@?0??Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z@4HA PROC ; `Wczytaj_Kwotê_Zak³adu'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR kwota_zak³adu_s$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z@4HA ENDP ; `Wczytaj_Kwotê_Zak³adu'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T17 = 32
kwota_zak³adu_s$ = 40
__$ArrayPad$ = 72
kwota_zak³adu$ = 96
iloæ_pieniêdzy$ = 104
?dtor$0@?0??Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z@4HA PROC ; `Wczytaj_Kwotê_Zak³adu'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR kwota_zak³adu_s$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z@4HA ENDP ; `Wczytaj_Kwotê_Zak³adu'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Zakrêæ_Ruletk¹@@YAHXZ
_TEXT	SEGMENT
$T3 = 32
hCCI$17 = 40
hCCI$18 = 40
$T4 = 40
__$ArrayPad$ = 48
?Zakrêæ_Ruletk¹@@YAHXZ PROC				; Zakrêæ_Ruletk¹, COMDAT

; 232  : {

$LN166:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001d	49 89 6b 08	 mov	 QWORD PTR [r11+8], rbp
  00021	49 89 73 10	 mov	 QWORD PTR [r11+16], rsi
  00025	4d 89 6b 18	 mov	 QWORD PTR [r11+24], r13
  00029	4d 89 7b d8	 mov	 QWORD PTR [r11-40], r15
  0002d	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6
  00032	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7
  00037	45 0f 29 43 a8	 movaps	 XMMWORD PTR [r11-88], xmm8

; 233  : 	int iloæ_zakrêceñ = rand() % (Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki + 1) + Ustawienia.iloæ_minimalna_obrotów_ruletki; //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ pseudolosow¹ (o niskiej pseoudolosowoci) iloæ obrotów ruletk¹ ((od 0 do max dodatkowych obrotów ruletki) + minimalna iloæ obrotów ruletki) zanim nastêpi finalny obrót

  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00042	0f bf 0d 02 00
	00 00		 movsx	 ecx, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2
  00049	99		 cdq
  0004a	44 0f bf 3d 00
	00 00 00	 movsx	 r15d, WORD PTR ?Ustawienia@@3US_Ustawienia@@A
  00052	ff c1		 inc	 ecx

; 234  : 	double czas_przeskoku_kulki_szybki_opónienie = Ustawienia.czas_przeskoku_kulki_szybki / (iloæ_zakrêceñ * 37.0); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoæ na kole ruletki powinna byæ szybciej pokazana

  00054	f2 44 0f 10 05
	00 00 00 00	 movsd	 xmm8, QWORD PTR __real@4042800000000000
  0005d	f7 f9		 idiv	 ecx
  0005f	0f bf 05 04 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4

; 387  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00066	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H

; 233  : 	int iloæ_zakrêceñ = rand() % (Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki + 1) + Ustawienia.iloæ_minimalna_obrotów_ruletki; //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ pseudolosow¹ (o niskiej pseoudolosowoci) iloæ obrotów ruletk¹ ((od 0 do max dodatkowych obrotów ruletki) + minimalna iloæ obrotów ruletki) zanim nastêpi finalny obrót

  0006b	44 03 fa	 add	 r15d, edx
  0006e	66 0f 6e f8	 movd	 xmm7, eax
  00072	66 41 0f 6e c7	 movd	 xmm0, r15d

; 234  : 	double czas_przeskoku_kulki_szybki_opónienie = Ustawienia.czas_przeskoku_kulki_szybki / (iloæ_zakrêceñ * 37.0); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoæ na kole ruletki powinna byæ szybciej pokazana

  00077	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0007b	f3 0f e6 ff	 cvtdq2pd xmm7, xmm7
  0007f	f2 41 0f 59 c0	 mulsd	 xmm0, xmm8
  00084	f2 0f 5e f8	 divsd	 xmm7, xmm0

; 387  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 388  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 389  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0008e	48 8b c8	 mov	 rcx, rax
  00091	48 8d 54 24 28	 lea	 rdx, QWORD PTR hCCI$18[rsp]
  00096	48 8b d8	 mov	 rbx, rax
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCursorInfo

; 390  : 	hCCI.bVisible = FALSE; //Zmiena widocznoci kursora na niewidoczny

  0009f	33 ed		 xor	 ebp, ebp

; 391  : 	SetConsoleCursorInfo(hConsoleOut, &hCCI); //Ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  000a1	48 8d 54 24 28	 lea	 rdx, QWORD PTR hCCI$18[rsp]
  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	89 6c 24 2c	 mov	 DWORD PTR hCCI$18[rsp+4], ebp
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCursorInfo

; 235  : 	Hide_Cursor(); //Ukrycie kursora tekstowego w konsoli
; 236  : 	for (int i = 0; i < iloæ_zakrêceñ; ++i) //Wykonanie iloæ_zakrêceñ obrotów ruletk¹

  000b3	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:?Ruletka_ko³o@@3QBGB
  000ba	8b fd		 mov	 edi, ebp
  000bc	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:?Ruletka_plansza_kolor_col@@3QBGB
  000c3	45 85 ff	 test	 r15d, r15d
  000c6	0f 8e da 00 00
	00		 jle	 $LN3@Zakr?
  000cc	4c 89 74 24 78	 mov	 QWORD PTR [rsp+120], r14
$LL4@Zakr?:
  000d1	66 0f 6e f7	 movd	 xmm6, edi

; 237  : 		for (int ii = 0; ii < 37; ++ii) //Przejcie przez wszystkie pozycje ruletki

  000d5	8b f5		 mov	 esi, ebp
  000d7	f3 0f e6 f6	 cvtdq2pd xmm6, xmm6
  000db	4d 8b f4	 mov	 r14, r12
  000de	f2 41 0f 59 f0	 mulsd	 xmm6, xmm8
  000e3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL7@Zakr?:

; 238  : 		{
; 239  : 			Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[ii]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  000f0	41 0f b7 06	 movzx	 eax, WORD PTR [r14]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  000f4	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H

; 238  : 		{
; 239  : 			Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[ii]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  000f9	41 0f b7 5c 45
	00		 movzx	 ebx, WORD PTR [r13+rax*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00105	48 8b c8	 mov	 rcx, rax
  00108	0f b7 d3	 movzx	 edx, bx
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 240  : 			cout << Ruletka_ko³o[ii]; //Wypisanie numeru na kole ruletki na którym znajduje siê pêtla

  00111	41 0f b7 16	 movzx	 edx, WORD PTR [r14]
  00115	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  00122	66 0f 6e c6	 movd	 xmm0, esi

; 241  : 			Sleep((DWORD)(czas_przeskoku_kulki_szybki_opónienie*((double)i*37.0 + (double)ii))); //Przestój który zwiêksza siê co zmianê pozycji pêtli

  00126	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0012a	f2 0f 58 c6	 addsd	 xmm0, xmm6
  0012e	f2 0f 59 c7	 mulsd	 xmm0, xmm7
  00132	f2 48 0f 2c c8	 cvttsd2si rcx, xmm0
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  0013d	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00148	48 8b c8	 mov	 rcx, rax
  0014b	ba 07 00 00 00	 mov	 edx, 7
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 242  : 			Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 243  : 			cout << "\b\b" << "  " << "\b\b"; //Cofniêcie kursora tekstowego do lewej strony konsoli aby zape³niæ podem spacjami czyli niewidocznym znakiem wiersza konsoli aby widaæ przejcie pomiêdzy liczbami na ruletce

  00156	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  00164	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00169	48 8b c8	 mov	 rcx, rax
  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KNHHEEKP@?5?5?$AA@
  00173	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00178	48 8b c8	 mov	 rcx, rax
  0017b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  00182	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00187	ff c6		 inc	 esi
  00189	49 83 c6 02	 add	 r14, 2
  0018d	83 fe 25	 cmp	 esi, 37			; 00000025H
  00190	0f 8c 5a ff ff
	ff		 jl	 $LL7@Zakr?

; 235  : 	Hide_Cursor(); //Ukrycie kursora tekstowego w konsoli
; 236  : 	for (int i = 0; i < iloæ_zakrêceñ; ++i) //Wykonanie iloæ_zakrêceñ obrotów ruletk¹

  00196	ff c7		 inc	 edi
  00198	41 3b ff	 cmp	 edi, r15d
  0019b	0f 8c 30 ff ff
	ff		 jl	 $LL4@Zakr?
  001a1	4c 8b 74 24 78	 mov	 r14, QWORD PTR [rsp+120]
$LN3@Zakr?:

; 244  : 		}
; 245  : 	int wylosowana_pozycja = Wylosuj(0, 36); //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ losow¹ lub pseudolosow¹ liczbê (o wysokiej pseoudolosowoci) pozycjê na ruletce

  001a6	44 0f 28 44 24
	40		 movaps	 xmm8, XMMWORD PTR [rsp+64]
  001ac	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  001b1	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]
  001b6	c7 44 24 20 24
	00 00 00	 mov	 DWORD PTR $T3[rsp], 36	; 00000024H
  001be	89 6c 24 28	 mov	 DWORD PTR $T4[rsp], ebp
$LL89@Zakr?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  001c8	44 8b c0	 mov	 r8d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  001cb	b8 4d 91 cf ba	 mov	 eax, -1160801971	; bacf914dH
  001d0	41 f7 e0	 mul	 r8d
  001d3	41 8b c8	 mov	 ecx, r8d
  001d6	2b ca		 sub	 ecx, edx
  001d8	d1 e9		 shr	 ecx, 1
  001da	03 ca		 add	 ecx, edx
  001dc	c1 e9 05	 shr	 ecx, 5
  001df	81 f9 45 3e eb
	06		 cmp	 ecx, 116080197		; 06eb3e45H
  001e5	73 db		 jae	 SHORT $LL89@Zakr?
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 246  : 	double czas_przeskoku_kulki_wolny_przyspieszenie = (Ustawienia.czas_przeskoku_kulki_wolny - Ustawienia.czas_przeskoku_kulki_szybki) / (double)(wylosowana_pozycja); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoæ na kole ruletki powinna byæ szybciej pokazana

  001e7	0f bf 0d 06 00
	00 00		 movsx	 ecx, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+6
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3960 : 				return (_Ret % _Index);

  001ee	b8 4d 91 cf ba	 mov	 eax, -1160801971	; bacf914dH
  001f3	41 f7 e0	 mul	 r8d
  001f6	41 8b c0	 mov	 eax, r8d
  001f9	2b c2		 sub	 eax, edx
  001fb	d1 e8		 shr	 eax, 1
  001fd	03 c2		 add	 eax, edx
  001ff	c1 e8 05	 shr	 eax, 5
  00202	6b c0 25	 imul	 eax, eax, 37		; 00000025H
  00205	44 2b c0	 sub	 r8d, eax
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 246  : 	double czas_przeskoku_kulki_wolny_przyspieszenie = (Ustawienia.czas_przeskoku_kulki_wolny - Ustawienia.czas_przeskoku_kulki_szybki) / (double)(wylosowana_pozycja); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoæ na kole ruletki powinna byæ szybciej pokazana

  00208	0f bf 05 04 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4
  0020f	2b c8		 sub	 ecx, eax

; 247  : 	for (int i = 0; i < wylosowana_pozycja; ++i) //Przejcie przez pozycje do pozycji o 1 mniejszej od wylosowanej pozyji na ruletce

  00211	49 63 f8	 movsxd	 rdi, r8d
  00214	66 41 0f 6e c0	 movd	 xmm0, r8d
  00219	66 0f 6e f1	 movd	 xmm6, ecx
  0021d	f3 0f e6 f6	 cvtdq2pd xmm6, xmm6
  00221	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00225	f2 0f 5e f0	 divsd	 xmm6, xmm0
  00229	45 85 c0	 test	 r8d, r8d
  0022c	0f 8e c4 00 00
	00		 jle	 $LN9@Zakr?

; 260  : 	Show_Cursor(); //Pokazanie kursora tekstowego w konsoli
; 261  : 
; 262  : 	return Ruletka_ko³o[wylosowana_pozycja]; //Zwracam wartoæ bêd¹c¹ na wylosowanym polu ruletki

  00232	48 8b f5	 mov	 rsi, rbp
  00235	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL10@Zakr?:

; 248  : 	{
; 249  : 		Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[i]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  00240	41 0f b7 04 74	 movzx	 eax, WORD PTR [r12+rsi*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00245	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H

; 248  : 	{
; 249  : 		Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[i]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  0024a	41 0f b7 5c 45
	00		 movzx	 ebx, WORD PTR [r13+rax*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00250	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00256	48 8b c8	 mov	 rcx, rax
  00259	0f b7 d3	 movzx	 edx, bx
  0025c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 250  : 		cout << Ruletka_ko³o[i]; //Wypisanie numeru na kole ruletki na którym znajduje siê pêtla

  00262	41 0f b7 14 74	 movzx	 edx, WORD PTR [r12+rsi*2]
  00267	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z

; 251  : 		Sleep((DWORD)(Ustawienia.czas_przeskoku_kulki_szybki + (czas_przeskoku_kulki_wolny_przyspieszenie*i))); //Przestój który zwiêksza siê co zmianê pozycji pêtli

  00274	0f bf 05 04 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4
  0027b	66 0f 6e cd	 movd	 xmm1, ebp
  0027f	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00283	66 0f 6e c0	 movd	 xmm0, eax
  00287	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0028b	f2 0f 59 ce	 mulsd	 xmm1, xmm6
  0028f	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00293	f2 48 0f 2c c9	 cvttsd2si rcx, xmm1
  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  0029e	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  002a9	48 8b c8	 mov	 rcx, rax
  002ac	ba 07 00 00 00	 mov	 edx, 7
  002b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 252  : 		Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 253  : 		cout << "\b\b" << "  " << "\b\b"; //Cofniêcie kursora tekstowego do lewej strony konsoli aby zape³niæ podem spacjami czyli niewidocznym znakiem wiersza konsoli aby widaæ przejcie pomiêdzy liczbami na ruletce

  002b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  002c5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002ca	48 8b c8	 mov	 rcx, rax
  002cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KNHHEEKP@?5?5?$AA@
  002d4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002d9	48 8b c8	 mov	 rcx, rax
  002dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  002e3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002e8	ff c5		 inc	 ebp
  002ea	48 ff c6	 inc	 rsi
  002ed	48 3b f7	 cmp	 rsi, rdi
  002f0	0f 8c 4a ff ff
	ff		 jl	 $LL10@Zakr?
$LN9@Zakr?:

; 254  : 	}
; 255  : 	cout << "Wylosowano numer "; //Poinformowanie o zakoñczeniu (wywietlania) losowania

  002f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
  00304	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 256  : 	Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[wylosowana_pozycja]]);//Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  00309	41 0f b7 04 7c	 movzx	 eax, WORD PTR [r12+rdi*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  0030e	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H

; 256  : 	Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[wylosowana_pozycja]]);//Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  00313	41 0f b7 5c 45
	00		 movzx	 ebx, WORD PTR [r13+rax*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00319	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0031f	48 8b c8	 mov	 rcx, rax
  00322	0f b7 d3	 movzx	 edx, bx
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 257  : 	cout << Ruletka_ko³o[wylosowana_pozycja]; //Wypisanie liczby na wylosowanej pozycji ruletki

  0032b	41 0f b7 14 7c	 movzx	 edx, WORD PTR [r12+rdi*2]
  00330	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00337	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  0033d	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  00342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00348	48 8b c8	 mov	 rcx, rax
  0034b	ba 07 00 00 00	 mov	 edx, 7
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 258  : 	Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 259  : 	cout << ". "; //Zakoñczenie tekstu kropk¹

  00356	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0035d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KHOJGJKF@?4?5?$AA@
  00364	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 396  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00369	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0036e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 397  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 398  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  00374	48 8b c8	 mov	 rcx, rax
  00377	48 8d 54 24 28	 lea	 rdx, QWORD PTR hCCI$17[rsp]
  0037c	48 8b d8	 mov	 rbx, rax
  0037f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCursorInfo

; 399  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoæ widocznoci kursorsora tekstego w konsoli jest ró¿na od prawdy

  00385	83 7c 24 2c 01	 cmp	 DWORD PTR hCCI$17[rsp+4], 1
  0038a	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  0038f	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR [rsp+176]
  00397	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+168]
  0039f	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR [rsp+160]
  003a7	74 16		 je	 SHORT $LN164@Zakr?

; 400  : 	{
; 401  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoci kursora na widoczny
; 402  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  003a9	48 8d 54 24 28	 lea	 rdx, QWORD PTR hCCI$17[rsp]
  003ae	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR hCCI$17[rsp+4], 1
  003b6	48 8b cb	 mov	 rcx, rbx
  003b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCursorInfo
$LN164@Zakr?:

; 260  : 	Show_Cursor(); //Pokazanie kursora tekstowego w konsoli
; 261  : 
; 262  : 	return Ruletka_ko³o[wylosowana_pozycja]; //Zwracam wartoæ bêd¹c¹ na wylosowanym polu ruletki

  003bf	41 0f b7 04 7c	 movzx	 eax, WORD PTR [r12+rdi*2]

; 263  : }

  003c4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003c9	48 33 cc	 xor	 rcx, rsp
  003cc	e8 00 00 00 00	 call	 __security_check_cookie
  003d1	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  003d8	41 5c		 pop	 r12
  003da	5f		 pop	 rdi
  003db	5b		 pop	 rbx
  003dc	c3		 ret	 0
?Zakrêæ_Ruletk¹@@YAHXZ ENDP				; Zakrêæ_Ruletk¹
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Sprawd_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
kwota$ = 48
typ_zak³adu$ = 56
wylosowana_liczba$ = 64
?Sprawd_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; Sprawd_Zak³ad, COMDAT

; 266  : {

$LN349:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b 19		 mov	 ebx, DWORD PTR [rcx]
  00011	48 8b f1	 mov	 rsi, rcx

; 267  : 	int wygrana = kwota; //Deklaracja zmiennej przechowywuj¹ca kwotê wygran¹ lub zwrócon¹ przy wylosowaniu 0
; 268  : 
; 269  : 	if (wylosowana_liczba == 0) //Warunek sprawdzaj¹cy czy wylosowano 0

  00014	49 63 08	 movsxd	 rcx, DWORD PTR [r8]
  00017	49 8b f8	 mov	 rdi, r8
  0001a	4c 8b 4a 18	 mov	 r9, QWORD PTR [rdx+24]
  0001e	85 c9		 test	 ecx, ecx
  00020	75 46		 jne	 SHORT $LN4@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00022	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  00026	72 03		 jb	 SHORT $LN64@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00028	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN64@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 271  : 		switch (typ_zak³adu[0]) //Switch do obliczenia wygranej lub przegranej

  0002b	0f be 0a	 movsx	 ecx, BYTE PTR [rdx]
  0002e	83 c1 d0	 add	 ecx, -48		; ffffffffffffffd0H
  00031	83 f9 47	 cmp	 ecx, 71			; 00000047H
  00034	0f 87 13 02 00
	00		 ja	 $LN49@Sprawd_Z
  0003a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00041	48 63 c9	 movsxd	 rcx, ecx
  00044	41 0f b6 8c 08
	00 00 00 00	 movzx	 ecx, BYTE PTR $LN344@Sprawd_Z[r8+rcx]
  0004d	41 8b 94 88 00
	00 00 00	 mov	 edx, DWORD PTR $LN345@Sprawd_Z[r8+rcx*4]
  00055	49 03 d0	 add	 rdx, r8
  00058	ff e2		 jmp	 rdx
$LN6@Sprawd_Z:

; 272  : 		{
; 273  : 		case 'p':
; 274  : 		{
; 275  : 			wygrana /= 2; //Je¿eli typ zak³adu by³ p to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  0005a	8b c3		 mov	 eax, ebx
  0005c	99		 cdq
  0005d	2b c2		 sub	 eax, edx
  0005f	d1 f8		 sar	 eax, 1
  00061	8b d8		 mov	 ebx, eax

; 276  : 			break; //Wyjcie z switcha

  00063	e9 e5 01 00 00	 jmp	 $LN49@Sprawd_Z
$LN4@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00068	48 8b c2	 mov	 rax, rdx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0006b	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  0006f	72 03		 jb	 SHORT $LN335@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00071	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN335@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00074	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00078	49 83 f8 01	 cmp	 r8, 1
  0007c	75 1f		 jne	 SHORT $LN16@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0007e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00081	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JBBJJEPG@p?$AA@
  00087	75 14		 jne	 SHORT $LN16@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 325  : 			if (wylosowana_liczba % 2 == 0) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest parzysta, je¿eli tak to wygrana jest 1:1

  00089	8b c3		 mov	 eax, ebx
  0008b	41 84 c8	 test	 cl, r8b

; 326  : 			else wygrana *= 0; //Je¿eli wylosowana liczba nie jest parzysta to przegra³o siê zak³ad
; 327  : 		else if (typ_zak³adu == "n") //Je¿eli typ zak³adu to n

  0008e	bb 00 00 00 00	 mov	 ebx, 0
  00093	0f 45 c3	 cmovne	 eax, ebx
  00096	8b d8		 mov	 ebx, eax
  00098	e9 b0 01 00 00	 jmp	 $LN49@Sprawd_Z
$LN16@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0009d	48 8b c2	 mov	 rax, rdx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000a0	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  000a4	72 03		 jb	 SHORT $LN336@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000a6	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN336@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000a9	49 83 f8 01	 cmp	 r8, 1
  000ad	75 2b		 jne	 SHORT $LN20@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000af	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b2	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01EFFIKLCJ@n?$AA@
  000b8	75 20		 jne	 SHORT $LN20@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 328  : 			if (wylosowana_liczba % 2 == 1) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest nieparzysta, je¿eli tak to wygrana jest 1:1

  000ba	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; ffffffff80000001H
  000c0	7d 07		 jge	 SHORT $LN343@Sprawd_Z
  000c2	ff c9		 dec	 ecx
  000c4	83 c9 fe	 or	 ecx, -2
  000c7	ff c1		 inc	 ecx
$LN343@Sprawd_Z:

; 329  : 			else wygrana *= 0; //Je¿eli obstawiony numer nie jest nieparzysta to przegra³o siê zak³ad
; 330  : 		else if (typ_zak³adu == "r") //Je¿eli typ zak³adu to n

  000c9	8b c3		 mov	 eax, ebx
  000cb	33 db		 xor	 ebx, ebx
  000cd	83 f9 01	 cmp	 ecx, 1
  000d0	0f 45 c3	 cmovne	 eax, ebx
  000d3	8b d8		 mov	 ebx, eax
  000d5	e9 73 01 00 00	 jmp	 $LN49@Sprawd_Z
$LN20@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  000da	48 8b c2	 mov	 rax, rdx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000dd	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  000e1	72 03		 jb	 SHORT $LN337@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000e3	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN337@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000e6	49 83 f8 01	 cmp	 r8, 1
  000ea	75 29		 jne	 SHORT $LN24@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000ec	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ef	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01KDCPPGHE@r?$AA@
  000f5	75 1e		 jne	 SHORT $LN24@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 331  : 			if (Ruletka_plansza_kolor[wylosowana_liczba] == 'r') wygrana *= 1; //To sprawdzam czy wylosowana liczba jest czerwona, je¿eli tak to wygrana jest 1:1

  000f7	8b c3		 mov	 eax, ebx
  000f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase

; 332  : 			else wygrana *= 0; //Je¿eli wylosowana liczba nie jest czerwony to przegra³o siê zak³ad
; 333  : 		else if (typ_zak³adu == "b") //Je¿eli typ zak³adu to n

  00100	33 db		 xor	 ebx, ebx
  00102	42 80 bc 01 00
	00 00 00 72	 cmp	 BYTE PTR ?Ruletka_plansza_kolor@@3QBDB[rcx+r8], 114 ; 00000072H
  0010b	0f 45 c3	 cmovne	 eax, ebx
  0010e	8b d8		 mov	 ebx, eax
  00110	e9 38 01 00 00	 jmp	 $LN49@Sprawd_Z
$LN24@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00115	48 8b c2	 mov	 rax, rdx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00118	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  0011c	72 03		 jb	 SHORT $LN338@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0011e	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN338@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00121	49 83 f8 01	 cmp	 r8, 1
  00125	75 29		 jne	 SHORT $LN28@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00127	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012a	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01OJONOECF@b?$AA@
  00130	75 1e		 jne	 SHORT $LN28@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 334  : 			if (Ruletka_plansza_kolor[wylosowana_liczba] == 'b') wygrana *= 1; //To sprawdzam czy wylosowana liczba jest czarna, je¿eli tak to wygrana jest 1:1

  00132	8b c3		 mov	 eax, ebx
  00134	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase

; 335  : 			else wygrana *= 0; //Je¿eli wylosowana liczba nie jest czarny to przegra³o siê zak³ad
; 336  : 		else if (typ_zak³adu == "g") //Je¿eli typ zak³adu to g

  0013b	33 db		 xor	 ebx, ebx
  0013d	42 80 bc 01 00
	00 00 00 62	 cmp	 BYTE PTR ?Ruletka_plansza_kolor@@3QBDB[rcx+r8], 98 ; 00000062H
  00146	0f 45 c3	 cmovne	 eax, ebx
  00149	8b d8		 mov	 ebx, eax
  0014b	e9 fd 00 00 00	 jmp	 $LN49@Sprawd_Z
$LN28@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00150	48 8b c2	 mov	 rax, rdx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00153	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  00157	72 03		 jb	 SHORT $LN339@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00159	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN339@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0015c	49 83 f8 01	 cmp	 r8, 1
  00160	75 1c		 jne	 SHORT $LN32@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00162	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00165	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JEJKBAGA@g?$AA@
  0016b	75 11		 jne	 SHORT $LN32@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 339  : 		else if (typ_zak³adu == "d") //Je¿eli typ zak³adu to d

  0016d	8b c3		 mov	 eax, ebx
  0016f	33 db		 xor	 ebx, ebx
  00171	83 f9 13	 cmp	 ecx, 19
  00174	0f 4d c3	 cmovge	 eax, ebx
  00177	8b d8		 mov	 ebx, eax
  00179	e9 cf 00 00 00	 jmp	 $LN49@Sprawd_Z
$LN32@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0017e	48 8b c2	 mov	 rax, rdx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00181	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  00185	72 03		 jb	 SHORT $LN340@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00187	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN340@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0018a	49 83 f8 01	 cmp	 r8, 1
  0018e	75 1c		 jne	 SHORT $LN36@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00190	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00193	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01LPLHEDKD@d?$AA@
  00199	75 11		 jne	 SHORT $LN36@Sprawd_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 342  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  0019b	8b c3		 mov	 eax, ebx
  0019d	33 db		 xor	 ebx, ebx
  0019f	83 f9 12	 cmp	 ecx, 18
  001a2	0f 4e c3	 cmovle	 eax, ebx
  001a5	8b d8		 mov	 ebx, eax
  001a7	e9 a1 00 00 00	 jmp	 $LN49@Sprawd_Z
$LN36@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001ac	48 8b c2	 mov	 rax, rdx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001af	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  001b3	72 03		 jb	 SHORT $LN341@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001b5	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN341@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 342  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  001b8	80 38 6b	 cmp	 BYTE PTR [rax], 107	; 0000006bH
  001bb	75 36		 jne	 SHORT $LN40@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001bd	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  001c1	72 03		 jb	 SHORT $LN268@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001c3	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN268@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 343  : 			if ((wylosowana_liczba - 1) % 3 == typ_zak³adu[1] - 49) wygrana *= 2; //To sprawdzam czy wylosowana liczba jest z obstawionej kolumny, je¿eli tak to wygrana jest 2:1

  001c6	44 0f be 42 01	 movsx	 r8d, BYTE PTR [rdx+1]
  001cb	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001d0	41 83 e8 31	 sub	 r8d, 49			; 00000031H
  001d4	ff c9		 dec	 ecx
  001d6	f7 e9		 imul	 ecx
  001d8	8b c2		 mov	 eax, edx
  001da	c1 e8 1f	 shr	 eax, 31
  001dd	03 d0		 add	 edx, eax
  001df	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001e2	2b c8		 sub	 ecx, eax

; 345  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  001e4	8d 04 1b	 lea	 eax, DWORD PTR [rbx+rbx]
  001e7	33 db		 xor	 ebx, ebx
  001e9	41 3b c8	 cmp	 ecx, r8d
  001ec	0f 45 c3	 cmovne	 eax, ebx
  001ef	8b d8		 mov	 ebx, eax
  001f1	eb 5a		 jmp	 SHORT $LN49@Sprawd_Z
$LN40@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001f3	48 8b c2	 mov	 rax, rdx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001f6	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  001fa	72 03		 jb	 SHORT $LN342@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001fc	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN342@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 345  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  001ff	80 38 77	 cmp	 BYTE PTR [rax], 119	; 00000077H
  00202	75 2c		 jne	 SHORT $LN44@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00204	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  00208	72 03		 jb	 SHORT $LN298@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0020a	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN298@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 346  : 			if (((wylosowana_liczba - 1) / 3 + 1) == typ_zak³adu[1] - 48) wygrana *= 11; //To sprawdzam czy wylosowana liczba jest z obstawionego wiersza, je¿eli tak to wygrana jest 11:1

  0020d	44 0f be 42 01	 movsx	 r8d, BYTE PTR [rdx+1]
  00212	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00217	41 83 e8 31	 sub	 r8d, 49			; 00000031H
  0021b	ff c9		 dec	 ecx
  0021d	f7 e9		 imul	 ecx
  0021f	8b c2		 mov	 eax, edx
  00221	c1 e8 1f	 shr	 eax, 31
  00224	03 d0		 add	 edx, eax
  00226	41 3b d0	 cmp	 edx, r8d
  00229	75 20		 jne	 SHORT $LN48@Sprawd_Z
  0022b	6b db 0b	 imul	 ebx, ebx, 11

; 348  : 		else if (wylosowana_liczba == atoi(typ_zak³adu.c_str())) wygrana *= 35; //Je¿eli typ zak³adu to liczba, to sprawdzam czy wylosowana liczba jest równa obstawionej liczbie, je¿eli tak to wygrana jest 35:1

  0022e	eb 1d		 jmp	 SHORT $LN49@Sprawd_Z
$LN44@Sprawd_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00230	49 83 f9 10	 cmp	 r9, 16

; 1594 : 		if (_Large_string_engaged())

  00234	72 03		 jb	 SHORT $LN314@Sprawd_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00236	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN314@Sprawd_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 348  : 		else if (wylosowana_liczba == atoi(typ_zak³adu.c_str())) wygrana *= 35; //Je¿eli typ zak³adu to liczba, to sprawdzam czy wylosowana liczba jest równa obstawionej liczbie, je¿eli tak to wygrana jest 35:1

  00239	48 8b ca	 mov	 rcx, rdx
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00242	39 07		 cmp	 DWORD PTR [rdi], eax
  00244	75 05		 jne	 SHORT $LN48@Sprawd_Z
$LN14@Sprawd_Z:
  00246	6b db 23	 imul	 ebx, ebx, 35		; 00000023H
  00249	eb 02		 jmp	 SHORT $LN49@Sprawd_Z
$LN48@Sprawd_Z:

; 349  : 		else wygrana *= 0; //Je¿eli wylosowana liczba nie jest równa obstawionej liczbie to przegra³o siê zak³ad

  0024b	33 db		 xor	 ebx, ebx
$LN49@Sprawd_Z:

; 350  : 	}
; 351  : 
; 352  : 	if (wygrana >= kwota) cout << "Obstawi³e poprawnie, wygrywasz " << wygrana << "$." << endl; //Je¿eli wygrana jest wiêksza lub równa obstawionej kwocie to informujê o tym, ¿e wygra³

  0024d	8b 3e		 mov	 edi, DWORD PTR [rsi]
  0024f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00256	3b df		 cmp	 ebx, edi
  00258	7c 10		 jl	 SHORT $LN50@Sprawd_Z
  0025a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@GINPHDN@Obstawi?$LDe?$JM?5poprawnie?0?5wygrywasz?5@
  00261	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00266	8b d3		 mov	 edx, ebx
  00268	eb 29		 jmp	 SHORT $LN347@Sprawd_Z
$LN50@Sprawd_Z:

; 353  : 	else if (wygrana == kwota / 2) cout << "Obstawi³e niepoprawnie lecz uda³o Ci siê, dostajesz po³owê zak³adu " << wygrana << "$." << endl; //Je¿eli wygrana jest równa po³owie obstawionej kwocie to informujê o tym, ¿e przegra³ po³owe stawki

  0026a	8b c7		 mov	 eax, edi
  0026c	99		 cdq
  0026d	2b c2		 sub	 eax, edx
  0026f	d1 f8		 sar	 eax, 1
  00271	3b d8		 cmp	 ebx, eax
  00273	75 10		 jne	 SHORT $LN52@Sprawd_Z
  00275	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@MDKBMGPE@Obstawi?$LDe?$JM?5niepoprawnie?5lecz?5uda@
  0027c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00281	8b d3		 mov	 edx, ebx
  00283	eb 0e		 jmp	 SHORT $LN347@Sprawd_Z
$LN52@Sprawd_Z:

; 354  : 	else cout << "Obstawi³e niepoprawnie, przegra³e " << kwota << "$." << endl; //Je¿eli wygrana jest równa zero to informujê o tym, ¿e przegra³

  00285	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@BAJKLKHM@Obstawi?$LDe?$JM?5niepoprawnie?0?5przegra@
  0028c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00291	8b d7		 mov	 edx, edi
$LN347@Sprawd_Z:
  00293	48 8b c8	 mov	 rcx, rax
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0029c	48 8b c8	 mov	 rcx, rax
  0029f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DEPNMBPN@$?4?$AA@
  002a6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  002b2	48 8b c8	 mov	 rcx, rax
  002b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 355  : 
; 356  : 	return wygrana; //Zwracam warto wygranej lub zwrotu
; 357  : }

  002bb	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  002c0	8b c3		 mov	 eax, ebx
  002c2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  002c7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002cb	5f		 pop	 rdi
  002cc	c3		 ret	 0
  002cd	0f 1f 00	 npad	 3
$LN345@Sprawd_Z:
  002d0	00 00 00 00	 DD	 $LN14@Sprawd_Z
  002d4	00 00 00 00	 DD	 $LN6@Sprawd_Z
  002d8	00 00 00 00	 DD	 $LN48@Sprawd_Z
  002dc	00 00 00 00	 DD	 $LN49@Sprawd_Z
$LN344@Sprawd_Z:
  002e0	00		 DB	 0
  002e1	03		 DB	 3
  002e2	03		 DB	 3
  002e3	03		 DB	 3
  002e4	03		 DB	 3
  002e5	03		 DB	 3
  002e6	03		 DB	 3
  002e7	03		 DB	 3
  002e8	03		 DB	 3
  002e9	03		 DB	 3
  002ea	03		 DB	 3
  002eb	03		 DB	 3
  002ec	03		 DB	 3
  002ed	03		 DB	 3
  002ee	03		 DB	 3
  002ef	03		 DB	 3
  002f0	03		 DB	 3
  002f1	03		 DB	 3
  002f2	03		 DB	 3
  002f3	03		 DB	 3
  002f4	03		 DB	 3
  002f5	03		 DB	 3
  002f6	03		 DB	 3
  002f7	03		 DB	 3
  002f8	03		 DB	 3
  002f9	03		 DB	 3
  002fa	03		 DB	 3
  002fb	03		 DB	 3
  002fc	03		 DB	 3
  002fd	03		 DB	 3
  002fe	03		 DB	 3
  002ff	03		 DB	 3
  00300	03		 DB	 3
  00301	03		 DB	 3
  00302	03		 DB	 3
  00303	03		 DB	 3
  00304	03		 DB	 3
  00305	03		 DB	 3
  00306	03		 DB	 3
  00307	03		 DB	 3
  00308	03		 DB	 3
  00309	03		 DB	 3
  0030a	03		 DB	 3
  0030b	03		 DB	 3
  0030c	03		 DB	 3
  0030d	03		 DB	 3
  0030e	03		 DB	 3
  0030f	03		 DB	 3
  00310	03		 DB	 3
  00311	03		 DB	 3
  00312	01		 DB	 1
  00313	03		 DB	 3
  00314	01		 DB	 1
  00315	03		 DB	 3
  00316	03		 DB	 3
  00317	01		 DB	 1
  00318	03		 DB	 3
  00319	03		 DB	 3
  0031a	03		 DB	 3
  0031b	02		 DB	 2
  0031c	03		 DB	 3
  0031d	03		 DB	 3
  0031e	01		 DB	 1
  0031f	03		 DB	 3
  00320	01		 DB	 1
  00321	03		 DB	 3
  00322	01		 DB	 1
  00323	03		 DB	 3
  00324	03		 DB	 3
  00325	03		 DB	 3
  00326	03		 DB	 3
  00327	02		 DB	 2
?Sprawd_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; Sprawd_Zak³ad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Czy_Kontynuowaæ@@YA_NAEBH@Z
_TEXT	SEGMENT
$T73 = 32
tak_nie$ = 40
__$ArrayPad$ = 72
iloæ_pieniêdzy$ = 96
?Czy_Kontynuowaæ@@YA_NAEBH@Z PROC			; Czy_Kontynuowaæ, COMDAT

; 360  : {

$LN635:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T73[rsp], -2
  0000f	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00023	48 8b f9	 mov	 rdi, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00026	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tak_nie$[rsp+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0002f	bb 0f 00 00 00	 mov	 ebx, 15
  00034	48 89 5c 24 40	 mov	 QWORD PTR tak_nie$[rsp+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00039	c6 44 24 28 00	 mov	 BYTE PTR tak_nie$[rsp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 363  : 	if (iloæ_pieniêdzy == 0) //Je¿eli posiadana iloæ gotówki jest róna 0

  0003e	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00041	75 3d		 jne	 SHORT $LL2@Czy_Kontyn

; 364  : 	{
; 365  : 		cout << "Nie mo¿esz kontynuowaæ, przegra³e wszystko" << endl; //Poinformowanie u¿ytkownika, ¿e jest bankrutem

  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00051	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00056	48 8b c8	 mov	 rcx, rax
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  00066	40 32 ff	 xor	 dil, dil
  00069	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tak_nie$[rsp]
  0006e	e9 9e 02 00 00	 jmp	 $LN12@Czy_Kontyn
  00073	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL2@Czy_Kontyn:
$_Invalid_parameter$636:

; 366  : 		return false; //Zwrot wartoci false, co oznacza, ¿e kolejna runda siê nie odbêdzie
; 367  : 	}
; 368  : 
; 369  : 	while (true) //Rozpoczêcie pêtli nieskoñczonej
; 370  : 	{
; 371  : 		cout << "Na koncie masz " << iloæ_pieniêdzy << "$, czy chcesz grac dalej ('t'-tak, 'n'-nie) ?" << endl; //Pointormowanie o stanie konta i zapytanie o to czy gra dalej

  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0008e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00093	48 8b c8	 mov	 rcx, rax
  00096	8b 17		 mov	 edx, DWORD PTR [rdi]
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0009e	48 8b c8	 mov	 rcx, rax
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@DOCNGCMI@$?0?5czy?5chcesz?5grac?5dalej?5?$CI?8t?8?9ta@
  000a8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  000bd	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]
  000c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  000c9	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  000ce	48 8d 44 24 28	 lea	 rax, QWORD PTR tak_nie$[rsp]

; 1594 : 		if (_Large_string_engaged())

  000d3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tak_nie$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000d8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR tak_nie$[rsp+24]
  000dd	48 83 fb 10	 cmp	 rbx, 16

; 1594 : 		if (_Large_string_engaged())

  000e1	48 0f 43 c1	 cmovae	 rax, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000e5	4c 8b 44 24 38	 mov	 r8, QWORD PTR tak_nie$[rsp+16]
  000ea	49 83 f8 01	 cmp	 r8, 1
  000ee	75 1c		 jne	 SHORT $LN137@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000f0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f3	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01PFHFFBPC@t?$AA@
  000f9	75 04		 jne	 SHORT $LN629@Czy_Kontyn
  000fb	33 c0		 xor	 eax, eax
  000fd	eb 05		 jmp	 SHORT $LN630@Czy_Kontyn
$LN629@Czy_Kontyn:
  000ff	1b c0		 sbb	 eax, eax
  00101	83 c8 01	 or	 eax, 1
$LN630@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00104	85 c0		 test	 eax, eax
  00106	0f 84 d9 01 00
	00		 je	 $LN610@Czy_Kontyn
$LN137@Czy_Kontyn:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0010c	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00111	48 83 fb 10	 cmp	 rbx, 16

; 1594 : 		if (_Large_string_engaged())

  00115	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00119	49 83 f8 03	 cmp	 r8, 3
  0011d	75 34		 jne	 SHORT $LN166@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0011f	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00122	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PFPKAEFD@tak?$AA@
  00128	75 1c		 jne	 SHORT $LN627@Czy_Kontyn
  0012a	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  0012e	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PFPKAEFD@tak?$AA@+1
  00134	75 10		 jne	 SHORT $LN627@Czy_Kontyn
  00136	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  0013a	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PFPKAEFD@tak?$AA@+2
  00140	75 04		 jne	 SHORT $LN627@Czy_Kontyn
  00142	33 c0		 xor	 eax, eax
  00144	eb 05		 jmp	 SHORT $LN628@Czy_Kontyn
$LN627@Czy_Kontyn:
  00146	1b c0		 sbb	 eax, eax
  00148	83 c8 01	 or	 eax, 1
$LN628@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0014b	85 c0		 test	 eax, eax
  0014d	0f 84 92 01 00
	00		 je	 $LN610@Czy_Kontyn
$LN166@Czy_Kontyn:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00153	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00158	48 83 fb 10	 cmp	 rbx, 16

; 1594 : 		if (_Large_string_engaged())

  0015c	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00160	49 83 f8 03	 cmp	 r8, 3
  00164	75 34		 jne	 SHORT $LN195@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00166	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00169	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FFMIKLGN@Tak?$AA@
  0016f	75 1c		 jne	 SHORT $LN625@Czy_Kontyn
  00171	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  00175	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FFMIKLGN@Tak?$AA@+1
  0017b	75 10		 jne	 SHORT $LN625@Czy_Kontyn
  0017d	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  00181	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FFMIKLGN@Tak?$AA@+2
  00187	75 04		 jne	 SHORT $LN625@Czy_Kontyn
  00189	33 c0		 xor	 eax, eax
  0018b	eb 05		 jmp	 SHORT $LN626@Czy_Kontyn
$LN625@Czy_Kontyn:
  0018d	1b c0		 sbb	 eax, eax
  0018f	83 c8 01	 or	 eax, 1
$LN626@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00192	85 c0		 test	 eax, eax
  00194	0f 84 4b 01 00
	00		 je	 $LN610@Czy_Kontyn
$LN195@Czy_Kontyn:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0019a	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0019f	48 83 fb 10	 cmp	 rbx, 16

; 1594 : 		if (_Large_string_engaged())

  001a3	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001a7	49 83 f8 03	 cmp	 r8, 3
  001ab	75 34		 jne	 SHORT $LN224@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001ad	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  001b0	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PIABMJCP@TAK?$AA@
  001b6	75 1c		 jne	 SHORT $LN623@Czy_Kontyn
  001b8	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  001bc	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PIABMJCP@TAK?$AA@+1
  001c2	75 10		 jne	 SHORT $LN623@Czy_Kontyn
  001c4	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  001c8	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PIABMJCP@TAK?$AA@+2
  001ce	75 04		 jne	 SHORT $LN623@Czy_Kontyn
  001d0	33 c0		 xor	 eax, eax
  001d2	eb 05		 jmp	 SHORT $LN624@Czy_Kontyn
$LN623@Czy_Kontyn:
  001d4	1b c0		 sbb	 eax, eax
  001d6	83 c8 01	 or	 eax, 1
$LN624@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001d9	85 c0		 test	 eax, eax
  001db	0f 84 04 01 00
	00		 je	 $LN610@Czy_Kontyn
$LN224@Czy_Kontyn:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001e1	48 8d 44 24 28	 lea	 rax, QWORD PTR tak_nie$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001e6	48 83 fb 10	 cmp	 rbx, 16

; 1594 : 		if (_Large_string_engaged())

  001ea	48 0f 43 c1	 cmovae	 rax, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001ee	49 83 f8 01	 cmp	 r8, 1
  001f2	75 1c		 jne	 SHORT $LN253@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001f4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f7	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01EFFIKLCJ@n?$AA@
  001fd	75 04		 jne	 SHORT $LN621@Czy_Kontyn
  001ff	33 c0		 xor	 eax, eax
  00201	eb 05		 jmp	 SHORT $LN622@Czy_Kontyn
$LN621@Czy_Kontyn:
  00203	1b c0		 sbb	 eax, eax
  00205	83 c8 01	 or	 eax, 1
$LN622@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00208	85 c0		 test	 eax, eax
  0020a	0f 84 d5 00 00
	00		 je	 $LN610@Czy_Kontyn
$LN253@Czy_Kontyn:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00210	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00215	48 83 fb 10	 cmp	 rbx, 16

; 1594 : 		if (_Large_string_engaged())

  00219	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0021d	49 83 f8 03	 cmp	 r8, 3
  00221	75 34		 jne	 SHORT $LN282@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00223	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00226	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FKMOMPJO@nie?$AA@
  0022c	75 1c		 jne	 SHORT $LN619@Czy_Kontyn
  0022e	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  00232	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FKMOMPJO@nie?$AA@+1
  00238	75 10		 jne	 SHORT $LN619@Czy_Kontyn
  0023a	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  0023e	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FKMOMPJO@nie?$AA@+2
  00244	75 04		 jne	 SHORT $LN619@Czy_Kontyn
  00246	33 c0		 xor	 eax, eax
  00248	eb 05		 jmp	 SHORT $LN620@Czy_Kontyn
$LN619@Czy_Kontyn:
  0024a	1b c0		 sbb	 eax, eax
  0024c	83 c8 01	 or	 eax, 1
$LN620@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0024f	85 c0		 test	 eax, eax
  00251	0f 84 8e 00 00
	00		 je	 $LN610@Czy_Kontyn
$LN282@Czy_Kontyn:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00257	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0025c	48 83 fb 10	 cmp	 rbx, 16

; 1594 : 		if (_Large_string_engaged())

  00260	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00264	49 83 f8 03	 cmp	 r8, 3
  00268	75 30		 jne	 SHORT $LN311@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0026a	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0026d	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PKPMGAKA@Nie?$AA@
  00273	75 1c		 jne	 SHORT $LN617@Czy_Kontyn
  00275	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  00279	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PKPMGAKA@Nie?$AA@+1
  0027f	75 10		 jne	 SHORT $LN617@Czy_Kontyn
  00281	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  00285	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PKPMGAKA@Nie?$AA@+2
  0028b	75 04		 jne	 SHORT $LN617@Czy_Kontyn
  0028d	33 c0		 xor	 eax, eax
  0028f	eb 05		 jmp	 SHORT $LN618@Czy_Kontyn
$LN617@Czy_Kontyn:
  00291	1b c0		 sbb	 eax, eax
  00293	83 c8 01	 or	 eax, 1
$LN618@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00296	85 c0		 test	 eax, eax
  00298	74 4b		 je	 SHORT $LN610@Czy_Kontyn
$LN311@Czy_Kontyn:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0029a	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0029f	48 83 fb 10	 cmp	 rbx, 16

; 1594 : 		if (_Large_string_engaged())

  002a3	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002a7	49 83 f8 03	 cmp	 r8, 3
  002ab	0f 85 cf fd ff
	ff		 jne	 $LL2@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002b1	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  002b4	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FHDFACOC@NIE?$AA@
  002ba	75 1c		 jne	 SHORT $LN615@Czy_Kontyn
  002bc	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  002c0	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FHDFACOC@NIE?$AA@+1
  002c6	75 10		 jne	 SHORT $LN615@Czy_Kontyn
  002c8	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  002cc	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FHDFACOC@NIE?$AA@+2
  002d2	75 04		 jne	 SHORT $LN615@Czy_Kontyn
  002d4	33 c0		 xor	 eax, eax
  002d6	eb 05		 jmp	 SHORT $LN616@Czy_Kontyn
$LN615@Czy_Kontyn:
  002d8	1b c0		 sbb	 eax, eax
  002da	83 c8 01	 or	 eax, 1
$LN616@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002dd	85 c0		 test	 eax, eax
  002df	0f 85 9b fd ff
	ff		 jne	 $LL2@Czy_Kontyn
$LN610@Czy_Kontyn:

; 1582 : 		value_type * _Result = _Bx._Buf;

  002e5	48 8d 44 24 28	 lea	 rax, QWORD PTR tak_nie$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002ea	48 83 fb 10	 cmp	 rbx, 16

; 1583 : 		if (_Large_string_engaged())

  002ee	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 374  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoæ true

  002f2	80 38 74	 cmp	 BYTE PTR [rax], 116	; 00000074H
  002f5	74 17		 je	 SHORT $LN9@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  002f7	48 8d 44 24 28	 lea	 rax, QWORD PTR tak_nie$[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002fc	48 83 fb 10	 cmp	 rbx, 16

; 1583 : 		if (_Large_string_engaged())

  00300	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 374  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoæ true

  00304	80 38 54	 cmp	 BYTE PTR [rax], 84	; 00000054H
  00307	74 05		 je	 SHORT $LN9@Czy_Kontyn
$_Invalid_parameter$637:

; 375  : 			else return false; //W przeciwym wypadku zwracam wartoæ false

  00309	40 32 ff	 xor	 dil, dil
  0030c	eb 03		 jmp	 SHORT $LN12@Czy_Kontyn
$LN9@Czy_Kontyn:

; 374  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoæ true

  0030e	40 b7 01	 mov	 dil, 1
$LN12@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00311	48 83 fb 10	 cmp	 rbx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00315	72 42		 jb	 SHORT $LN485@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00317	48 8b c1	 mov	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0031a	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0031e	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00325	72 2d		 jb	 SHORT $LN488@Czy_Kontyn

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00327	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  0032b	4c 3b c2	 cmp	 r8, rdx
  0032e	76 1d		 jbe	 SHORT $_Invalid_parameter$638

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00330	49 8b d0	 mov	 rdx, r8
  00333	a8 1f		 test	 al, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00335	75 16		 jne	 SHORT $_Invalid_parameter$638

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00337	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0033b	48 3b c8	 cmp	 rcx, rax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0033e	73 0d		 jae	 SHORT $_Invalid_parameter$638

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00340	48 2b c1	 sub	 rax, rcx
  00343	48 83 e8 08	 sub	 rax, 8
  00347	48 83 f8 1f	 cmp	 rax, 31
  0034b	76 07		 jbe	 SHORT $LN488@Czy_Kontyn
$_Invalid_parameter$638:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0034d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00353	cc		 int	 3
$LN488@Czy_Kontyn:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00354	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN485@Czy_Kontyn:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 375  : 			else return false; //W przeciwym wypadku zwracam wartoæ false

  00359	40 0f b6 c7	 movzx	 eax, dil

; 376  : 	}
; 377  : }

  0035d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00362	48 33 cc	 xor	 rcx, rsp
  00365	e8 00 00 00 00	 call	 __security_check_cookie
  0036a	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0036f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00373	5f		 pop	 rdi
  00374	c3		 ret	 0
$LN633@Czy_Kontyn:
?Czy_Kontynuowaæ@@YA_NAEBH@Z ENDP			; Czy_Kontynuowaæ
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T73 = 32
tak_nie$ = 40
__$ArrayPad$ = 72
iloæ_pieniêdzy$ = 96
?dtor$0@?0??Czy_Kontynuowaæ@@YA_NAEBH@Z@4HA PROC	; `Czy_Kontynuowaæ'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR tak_nie$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Czy_Kontynuowaæ@@YA_NAEBH@Z@4HA ENDP	; `Czy_Kontynuowaæ'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T73 = 32
tak_nie$ = 40
__$ArrayPad$ = 72
iloæ_pieniêdzy$ = 96
?dtor$0@?0??Czy_Kontynuowaæ@@YA_NAEBH@Z@4HA PROC	; `Czy_Kontynuowaæ'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR tak_nie$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Czy_Kontynuowaæ@@YA_NAEBH@Z@4HA ENDP	; `Czy_Kontynuowaæ'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Change_Col@@YAXAEBH@Z
_TEXT	SEGMENT
num_of_col$ = 48
?Change_Col@@YAXAEBH@Z PROC				; Change_Col, COMDAT

; 380  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00009	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00014	0f b7 13	 movzx	 edx, WORD PTR [rbx]
  00017	48 8b c8	 mov	 rcx, rax

; 383  : }

  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0001f	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_SetConsoleTextAttribute
?Change_Col@@YAXAEBH@Z ENDP				; Change_Col
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Hide_Cursor@@YAXXZ
_TEXT	SEGMENT
hCCI$ = 32
__$ArrayPad$ = 40
?Hide_Cursor@@YAXXZ PROC				; Hide_Cursor, COMDAT

; 386  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 387  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00015	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 388  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 389  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  00020	48 8b c8	 mov	 rcx, rax
  00023	48 8d 54 24 20	 lea	 rdx, QWORD PTR hCCI$[rsp]
  00028	48 8b d8	 mov	 rbx, rax
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCursorInfo

; 390  : 	hCCI.bVisible = FALSE; //Zmiena widocznoci kursora na niewidoczny
; 391  : 	SetConsoleCursorInfo(hConsoleOut, &hCCI); //Ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  00031	48 8d 54 24 20	 lea	 rdx, QWORD PTR hCCI$[rsp]
  00036	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR hCCI$[rsp+4], 0
  0003e	48 8b cb	 mov	 rcx, rbx
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCursorInfo

; 392  : }

  00047	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004c	48 33 cc	 xor	 rcx, rsp
  0004f	e8 00 00 00 00	 call	 __security_check_cookie
  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
?Hide_Cursor@@YAXXZ ENDP				; Hide_Cursor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Show_Cursor@@YAXXZ
_TEXT	SEGMENT
hCCI$ = 32
__$ArrayPad$ = 40
?Show_Cursor@@YAXXZ PROC				; Show_Cursor, COMDAT

; 395  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 396  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00015	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 397  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 398  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  00020	48 8b c8	 mov	 rcx, rax
  00023	48 8d 54 24 20	 lea	 rdx, QWORD PTR hCCI$[rsp]
  00028	48 8b d8	 mov	 rbx, rax
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCursorInfo

; 399  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoæ widocznoci kursorsora tekstego w konsoli jest ró¿na od prawdy

  00031	83 7c 24 24 01	 cmp	 DWORD PTR hCCI$[rsp+4], 1
  00036	74 16		 je	 SHORT $LN2@Show_Curso

; 400  : 	{
; 401  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoci kursora na widoczny
; 402  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoci kursora zgodnie z poprzedni¹ zmienn¹

  00038	48 8d 54 24 20	 lea	 rdx, QWORD PTR hCCI$[rsp]
  0003d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR hCCI$[rsp+4], 1
  00045	48 8b cb	 mov	 rcx, rbx
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCursorInfo
$LN2@Show_Curso:

; 403  : 	}
; 404  : }

  0004e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00053	48 33 cc	 xor	 rcx, rsp
  00056	e8 00 00 00 00	 call	 __security_check_cookie
  0005b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005f	5b		 pop	 rbx
  00060	c3		 ret	 0
?Show_Cursor@@YAXXZ ENDP				; Show_Cursor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wylosuj@@YAHAEBH0@Z
_TEXT	SEGMENT
od_liczby$ = 48
do_liczby$ = 56
?Wylosuj@@YAHAEBH0@Z PROC				; Wylosuj, COMDAT

; 407  : {

$LN130:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 408  : 	if (od_liczby > do_liczby) //Je¿eli od jest wiêksze ni¿ do to

  0000a	8b 39		 mov	 edi, DWORD PTR [rcx]
  0000c	8b 1a		 mov	 ebx, DWORD PTR [rdx]
  0000e	3b fb		 cmp	 edi, ebx
  00010	7e 11		 jle	 SHORT $LN2@Wylosuj
$LL96@Wylosuj:

; 409  : 	{
; 410  : 		return Wylosuj(do_liczby, od_liczby); //Wywo³ujemy funkcje z przeciwn¹ kolejnoci¹ argumentów

  00012	48 8b c1	 mov	 rax, rcx
  00015	48 8b ca	 mov	 rcx, rdx
  00018	48 8b d0	 mov	 rdx, rax
  0001b	8b 39		 mov	 edi, DWORD PTR [rcx]
  0001d	8b 18		 mov	 ebx, DWORD PTR [rax]
  0001f	3b fb		 cmp	 edi, ebx
  00021	7f ef		 jg	 SHORT $LL96@Wylosuj
$LN2@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2328 : 		if (_Umax - _Umin == _Uty(-1))

  00023	2b df		 sub	 ebx, edi
  00025	83 fb ff	 cmp	 ebx, -1			; ffffffffH
  00028	75 13		 jne	 SHORT $LN32@Wylosuj

; 6410 : 		return (_Random_device());

  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  00030	03 c7		 add	 eax, edi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 426  : }

  00032	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
$LN32@Wylosuj:
  0003d	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2331 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  00042	8d 73 01	 lea	 esi, DWORD PTR [rbx+1]
$LL72@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3944 : 			_Udiff _Ret = 0;	// random bits

  00045	45 33 c0	 xor	 r8d, r8d

; 3945 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00048	33 c0		 xor	 eax, eax

; 3946 : 
; 3947 : 			while (_Mask < _Udiff(_Index - 1))

  0004a	85 db		 test	 ebx, ebx
  0004c	74 0c		 je	 SHORT $LN76@Wylosuj
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  00054	44 8b c0	 mov	 r8d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3954 : 				_Mask |= _Bmask;

  00057	83 c8 ff	 or	 eax, -1			; ffffffffH
$LN76@Wylosuj:

; 3955 : 				}
; 3956 : 
; 3957 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3958 : 			if (_Ret / _Index < _Mask / _Index
; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  0005a	33 d2		 xor	 edx, edx
  0005c	f7 f6		 div	 esi
  0005e	8b c8		 mov	 ecx, eax
  00060	44 8b ca	 mov	 r9d, edx
  00063	33 d2		 xor	 edx, edx
  00065	41 8b c0	 mov	 eax, r8d
  00068	f7 f6		 div	 esi
  0006a	3b c1		 cmp	 eax, ecx
  0006c	72 05		 jb	 SHORT $LN109@Wylosuj
  0006e	44 3b cb	 cmp	 r9d, ebx
  00071	75 d2		 jne	 SHORT $LL72@Wylosuj
$LN109@Wylosuj:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 426  : }

  00073	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3960 : 				return (_Ret % _Index);

  00078	33 d2		 xor	 edx, edx
  0007a	41 8b c0	 mov	 eax, r8d
  0007d	f7 f6		 div	 esi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 425  : 	return distribution(generator); //Zwraca wygenerowan¹ liczbê

  0007f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  00084	8d 04 17	 lea	 eax, DWORD PTR [rdi+rdx]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 426  : }

  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
?Wylosuj@@YAHAEBH0@Z ENDP				; Wylosuj
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Odczytaj_liczbê, COMDAT

; 428  : void Odczytaj_liczbê(const int & wylosowana_liczba, const string & typ_zak³adu) {

$LN2536:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d a8 08 fe
	ff ff		 lea	 rbp, QWORD PTR [rax-504]
  00013	48 81 ec d0 02
	00 00		 sub	 rsp, 720		; 000002d0H
  0001a	48 c7 45 90 fe
	ff ff ff	 mov	 QWORD PTR $T353[rbp-256], -2
  00022	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00026	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0002a	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c4	 xor	 rax, rsp
  00038	48 89 85 c0 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  0003f	48 8b da	 mov	 rbx, rdx
  00042	48 8b f1	 mov	 rsi, rcx
  00045	45 33 f6	 xor	 r14d, r14d
  00048	44 89 74 24 20	 mov	 DWORD PTR $T1[rsp], r14d

; 429  : 	if ((Ustawienia.g³os_odczytu_numeru == 0) || (!G³osyKompletne)) return; //Je¿eli ustawienia wy³¹czaj¹ g³os lub brak plików g³osu to wyjd z funkcji

  0004d	66 44 39 35 14
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, r14w
  00055	0f 84 64 04 00
	00		 je	 $LN3@Odczytaj_l
  0005b	44 38 35 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, r14b ; G³osyKompletne
  00062	0f 84 57 04 00
	00		 je	 $LN3@Odczytaj_l
  00068	33 d2		 xor	 edx, edx
  0006a	41 b8 f8 00 00
	00		 mov	 r8d, 248		; 000000f8H
  00070	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-256]
  00077	e8 00 00 00 00	 call	 memset
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 590  : 		{	// construct empty character buffer

  0007c	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:__ImageBase
  00083	49 8d 87 00 00
	00 00		 lea	 rax, QWORD PTR ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@[r15]
  0008a	48 89 85 c0 00
	00 00		 mov	 QWORD PTR numers$[rbp-256], rax
  00091	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00098	4c 89 a5 d0 00
	00 00		 mov	 QWORD PTR numers$[rbp-240], r12
  0009f	48 8d 8d 58 01
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-104]
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  000ac	90		 npad	 1
  000ad	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	typedef typename allocator_traits<allocator_type>::pointer _Ptrty;
; 350  : 
; 351  : 	enum
; 352  : 		{	// constant for minimum buffer size
; 353  : 		_MINSIZE = 32};
; 354  : 
; 355  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 356  : 		{	// convert open mode to stream state bits
; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);
; 367  : 		}
; 368  : 
; 369  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 370  : 	_Strstate _Mystate;	// the stream state
; 371  : 	allocator_type _Al;	// the allocator object
; 372  : 	};
; 373  : 
; 374  : template<class _Elem,
; 375  : 	class _Traits,
; 376  : 	class _Alloc> inline
; 377  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 378  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 379  : 	{	// swap _Left and _Right basic_stringbufs
; 380  : 	_Left.swap(_Right);
; 381  : 	}
; 382  : 
; 383  : 		// CLASS TEMPLATE basic_istringstream
; 384  : template<class _Elem,
; 385  : 	class _Traits,
; 386  : 	class _Alloc>
; 387  : 	class basic_istringstream
; 388  : 		: public basic_istream<_Elem, _Traits>
; 389  : 	{	// input stream associated with a character array
; 390  : public:
; 391  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 392  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 393  : 	typedef _Alloc allocator_type;
; 394  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 395  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 396  : 
; 397  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 398  : 		: _Mybase(&_Stringbuffer),
; 399  : 			_Stringbuffer(_Mode | ios_base::in)
; 400  : 		{	// construct empty readable character buffer
; 401  : 		}
; 402  : 
; 403  : 	explicit basic_istringstream(const _Mystr& _Str,
; 404  : 		ios_base::openmode _Mode = ios_base::in)
; 405  : 		: _Mybase(&_Stringbuffer),
; 406  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 407  : 		{	// construct readable character buffer from NTCS
; 408  : 		}
; 409  : 
; 410  : 	basic_istringstream(_Myt&& _Right)
; 411  : 		: _Mybase(&_Stringbuffer)
; 412  : 		{	// construct by moving _Right
; 413  : 		_Assign_rv(_STD move(_Right));
; 414  : 		}
; 415  : 
; 416  : 	_Myt& operator=(_Myt&& _Right)
; 417  : 		{	// move from _Right
; 418  : 		_Assign_rv(_STD move(_Right));
; 419  : 		return (*this);
; 420  : 		}
; 421  : 
; 422  : 	void _Assign_rv(_Myt&& _Right)
; 423  : 		{	// assign by moving _Right
; 424  : 		if (this != _STD addressof(_Right))
; 425  : 			{	// different, worth moving
; 426  : 			_Stringbuffer.str(_Mystr());
; 427  : 			this->swap(_Right);
; 428  : 			}
; 429  : 		}
; 430  : 
; 431  : 	void swap(_Myt& _Right)
; 432  : 		{	// swap with _Right
; 433  : 		if (this != _STD addressof(_Right))
; 434  : 			{	// different, swap base and buffer
; 435  : 			_Mybase::swap(_Right);
; 436  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 437  : 			}
; 438  : 		}
; 439  : 
; 440  : 	basic_istringstream(const _Myt&) = delete;
; 441  : 	_Myt& operator=(const _Myt&) = delete;
; 442  : 
; 443  : 	virtual ~basic_istringstream() _NOEXCEPT
; 444  : 		{	// destroy the object
; 445  : 		}
; 446  : 
; 447  : 	_Mysb *rdbuf() const
; 448  : 		{	// return pointer to file buffer
; 449  : 		return ((_Mysb *)&_Stringbuffer);
; 450  : 		}
; 451  : 
; 452  : 	_Mystr str() const
; 453  : 		{	// return string copy of character array
; 454  : 		return (_Stringbuffer.str());
; 455  : 		}
; 456  : 
; 457  : 	void str(const _Mystr& _Newstr)
; 458  : 		{	// replace character array from string
; 459  : 		_Stringbuffer.str(_Newstr);
; 460  : 		}
; 461  : 
; 462  : private:
; 463  : 	_Mysb _Stringbuffer;	// the string buffer
; 464  : 	};
; 465  : 
; 466  : template<class _Elem,
; 467  : 	class _Traits,
; 468  : 	class _Alloc> inline
; 469  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 470  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 471  : 	{	// swap _Left and _Right basic_istringstreams
; 472  : 	_Left.swap(_Right);
; 473  : 	}
; 474  : 
; 475  : 		// CLASS TEMPLATE basic_ostringstream
; 476  : template<class _Elem,
; 477  : 	class _Traits,
; 478  : 	class _Alloc>
; 479  : 	class basic_ostringstream
; 480  : 		: public basic_ostream<_Elem, _Traits>
; 481  : 	{	// output stream associated with a character array
; 482  : public:
; 483  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 484  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 485  : 	typedef _Alloc allocator_type;
; 486  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 487  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 488  : 
; 489  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 490  : 		: _Mybase(&_Stringbuffer),
; 491  : 			_Stringbuffer(_Mode | ios_base::out)
; 492  : 		{	// construct empty writable character buffer
; 493  : 		}
; 494  : 
; 495  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 496  : 		ios_base::openmode _Mode = ios_base::out)
; 497  : 		: _Mybase(&_Stringbuffer),
; 498  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 499  : 		{	// construct writable character buffer from NTCS
; 500  : 		}
; 501  : 
; 502  : 	basic_ostringstream(_Myt&& _Right)
; 503  : 		: _Mybase(&_Stringbuffer)
; 504  : 		{	// construct by moving _Right
; 505  : 		_Assign_rv(_STD move(_Right));
; 506  : 		}
; 507  : 
; 508  : 	_Myt& operator=(_Myt&& _Right)
; 509  : 		{	// move from _Right
; 510  : 		_Assign_rv(_STD move(_Right));
; 511  : 		return (*this);
; 512  : 		}
; 513  : 
; 514  : 	void _Assign_rv(_Myt&& _Right)
; 515  : 		{	// assign by moving _Right
; 516  : 		if (this != _STD addressof(_Right))
; 517  : 			{	// different, worth moving
; 518  : 			_Stringbuffer.str(_Mystr());
; 519  : 			this->swap(_Right);
; 520  : 			}
; 521  : 		}
; 522  : 
; 523  : 	void swap(_Myt& _Right)
; 524  : 		{	// swap with _Right
; 525  : 		if (this != _STD addressof(_Right))
; 526  : 			{	// different, swap base and buffer
; 527  : 			_Mybase::swap(_Right);
; 528  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 529  : 			}
; 530  : 		}
; 531  : 
; 532  : 	basic_ostringstream(const _Myt&) = delete;
; 533  : 	_Myt& operator=(const _Myt&) = delete;
; 534  : 
; 535  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 536  : 		{	// destroy the object
; 537  : 		}
; 538  : 
; 539  : 	_Mysb *rdbuf() const
; 540  : 		{	// return pointer to buffer
; 541  : 		return ((_Mysb *)&_Stringbuffer);
; 542  : 		}
; 543  : 
; 544  : 	_Mystr str() const
; 545  : 		{	// return string copy of character array
; 546  : 		return (_Stringbuffer.str());
; 547  : 		}
; 548  : 
; 549  : 	void str(const _Mystr& _Newstr)
; 550  : 		{	// replace character array from string
; 551  : 		_Stringbuffer.str(_Newstr);
; 552  : 		}
; 553  : 
; 554  : private:
; 555  : 	_Mysb _Stringbuffer;	// the string buffer
; 556  : 	};
; 557  : 
; 558  : template<class _Elem,
; 559  : 	class _Traits,
; 560  : 	class _Alloc> inline
; 561  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 562  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 563  : 	{	// swap _Left and _Right basic_ostringstreams
; 564  : 	_Left.swap(_Right);
; 565  : 	}
; 566  : 
; 567  : 		// CLASS TEMPLATE basic_stringstream
; 568  : template<class _Elem,
; 569  : 	class _Traits,
; 570  : 	class _Alloc>
; 571  : 	class basic_stringstream
; 572  : 		: public basic_iostream<_Elem, _Traits>
; 573  : 	{	// input/output stream associated with a character array
; 574  : public:
; 575  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 576  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 577  : 	typedef _Elem char_type;
; 578  : 	typedef _Traits traits_type;
; 579  : 	typedef _Alloc allocator_type;
; 580  : 	typedef typename _Traits::int_type int_type;
; 581  : 	typedef typename _Traits::pos_type pos_type;
; 582  : 	typedef typename _Traits::off_type off_type;
; 583  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 584  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 585  : 
; 586  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 587  : 		ios_base::in | ios_base::out)
; 588  : 		: _Mybase(&_Stringbuffer),

  000b5	45 33 c0	 xor	 r8d, r8d
  000b8	48 8d 95 d8 00
	00 00		 lea	 rdx, QWORD PTR numers$[rbp-232]
  000bf	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-256]
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  000cc	90		 npad	 1

; 590  : 		{	// construct empty character buffer

  000cd	48 8b 85 c0 00
	00 00		 mov	 rax, QWORD PTR numers$[rbp-256]
  000d4	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  000df	48 89 84 0d c0
	00 00 00	 mov	 QWORD PTR numers$[rbp+rcx-256], rax
  000e7	48 8b 85 c0 00
	00 00		 mov	 rax, QWORD PTR numers$[rbp-256]
  000ee	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000f2	8d 91 68 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-152]
  000f8	89 94 0d bc 00
	00 00		 mov	 DWORD PTR numers$[rbp+rcx-260], edx

; 589  : 			_Stringbuffer(_Mode)

  000ff	48 8d 85 d8 00
	00 00		 lea	 rax, QWORD PTR numers$[rbp-232]
  00106	48 89 45 88	 mov	 QWORD PTR this$[rbp-256], rax

; 30   : 		{	// construct empty character buffer from mode

  0010a	48 8d 8d d8 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-232]
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00117	90		 npad	 1
  00118	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0011f	4c 89 ad d8 00
	00 00		 mov	 QWORD PTR numers$[rbp-232], r13

; 311  : 		_Seekhigh = 0;

  00126	4c 89 b5 40 01
	00 00		 mov	 QWORD PTR numers$[rbp-128], r14

; 312  : 		_Mystate = _State;

  0012d	44 89 b5 48 01
	00 00		 mov	 DWORD PTR numers$[rbp-120], r14d
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 432  : 	numers << wylosowana_liczba; //Wpisanie to typu wylosowanej liczby

  00134	8b 16		 mov	 edx, DWORD PTR [rsi]
  00136	48 8d 8d d0 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-240]
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z

; 433  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  00143	48 8d 54 24 68	 lea	 rdx, QWORD PTR $T7[rsp]
  00148	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-256]
  0014f	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  00154	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3805 : 	return (_STD move(_Right.insert(0, _Left)));

  00155	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0015c	4c 8b c7	 mov	 r8, rdi
  0015f	48 8b c8	 mov	 rcx, rax
  00162	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00167	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  0016a	f3 0f 7f 44 24
	58		 movdqu	 XMMWORD PTR $T14[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00170	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00173	0f 11 44 24 48	 movups	 XMMWORD PTR $T14[rsp], xmm0
  00178	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0017c	0f 11 4c 24 58	 movups	 XMMWORD PTR $T14[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00181	4c 89 70 10	 mov	 QWORD PTR [rax+16], r14

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00185	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0018d	44 88 30	 mov	 BYTE PTR [rax], r14b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00190	45 8d 46 04	 lea	 r8d, QWORD PTR [r14+4]
  00194	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  0019b	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T14[rsp]
  001a0	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  001a5	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  001a8	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T30[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  001ae	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  001b1	0f 11 44 24 28	 movups	 XMMWORD PTR $T30[rsp], xmm0
  001b6	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  001ba	0f 11 4c 24 38	 movups	 XMMWORD PTR $T30[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  001bf	4c 89 70 10	 mov	 QWORD PTR [rax+16], r14

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001c3	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  001cb	44 88 30	 mov	 BYTE PTR [rax], r14b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001ce	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T30[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001d3	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T30[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  001d9	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T30[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 433  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  001df	45 33 c0	 xor	 r8d, r8d
  001e2	33 d2		 xor	 edx, edx
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001ea	48 8b 54 24 40	 mov	 rdx, QWORD PTR $T30[rsp+24]
  001ef	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  001f3	72 4a		 jb	 SHORT $LN294@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001f5	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001f8	48 8b 44 24 28	 mov	 rax, QWORD PTR $T30[rsp]
  001fd	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00200	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00207	72 2e		 jb	 SHORT $LN297@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00209	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  0020d	4c 3b c2	 cmp	 r8, rdx
  00210	76 1e		 jbe	 SHORT $_Invalid_parameter$2537

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00212	49 8b d0	 mov	 rdx, r8
  00215	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00218	75 16		 jne	 SHORT $_Invalid_parameter$2537

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0021a	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0021e	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00221	73 0d		 jae	 SHORT $_Invalid_parameter$2537

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00223	48 2b c8	 sub	 rcx, rax
  00226	48 83 e9 08	 sub	 rcx, 8
  0022a	48 83 f9 1f	 cmp	 rcx, 31
  0022e	76 07		 jbe	 SHORT $LN297@Odczytaj_l
$_Invalid_parameter$2537:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00236	cc		 int	 3
$LN297@Odczytaj_l:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00237	48 8b c8	 mov	 rcx, rax
  0023a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN294@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  0023f	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00247	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T30[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0024d	c6 44 24 28 00	 mov	 BYTE PTR $T30[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00252	48 8b 54 24 60	 mov	 rdx, QWORD PTR $T14[rsp+24]
  00257	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  0025b	72 4a		 jb	 SHORT $LN365@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0025d	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00260	48 8b 44 24 48	 mov	 rax, QWORD PTR $T14[rsp]
  00265	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00268	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0026f	72 2e		 jb	 SHORT $LN368@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00271	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00275	4c 3b c2	 cmp	 r8, rdx
  00278	76 1e		 jbe	 SHORT $_Invalid_parameter$2538

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0027a	49 8b d0	 mov	 rdx, r8
  0027d	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00280	75 16		 jne	 SHORT $_Invalid_parameter$2538

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00282	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00286	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00289	73 0d		 jae	 SHORT $_Invalid_parameter$2538

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0028b	48 2b c8	 sub	 rcx, rax
  0028e	48 83 e9 08	 sub	 rcx, 8
  00292	48 83 f9 1f	 cmp	 rcx, 31
  00296	76 07		 jbe	 SHORT $LN368@Odczytaj_l
$_Invalid_parameter$2538:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0029e	cc		 int	 3
$LN368@Odczytaj_l:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0029f	48 8b c8	 mov	 rcx, rax
  002a2	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN365@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  002a7	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  002af	f3 0f 7f 44 24
	58		 movdqu	 XMMWORD PTR $T14[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  002b5	c6 44 24 48 00	 mov	 BYTE PTR $T14[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002ba	48 8b 55 80	 mov	 rdx, QWORD PTR $T7[rbp-232]
  002be	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  002c2	72 4a		 jb	 SHORT $LN436@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002c4	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002c7	48 8b 44 24 68	 mov	 rax, QWORD PTR $T7[rsp]
  002cc	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  002cf	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  002d6	72 2e		 jb	 SHORT $LN439@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  002d8	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  002dc	4c 3b c2	 cmp	 r8, rdx
  002df	76 1e		 jbe	 SHORT $_Invalid_parameter$2539

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  002e1	49 8b d0	 mov	 rdx, r8
  002e4	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  002e7	75 16		 jne	 SHORT $_Invalid_parameter$2539

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002e9	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  002ed	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  002f0	73 0d		 jae	 SHORT $_Invalid_parameter$2539

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  002f2	48 2b c8	 sub	 rcx, rax
  002f5	48 83 e9 08	 sub	 rcx, 8
  002f9	48 83 f9 1f	 cmp	 rcx, 31
  002fd	76 07		 jbe	 SHORT $LN439@Odczytaj_l
$_Invalid_parameter$2539:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00305	cc		 int	 3
$LN439@Odczytaj_l:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00306	48 8b c8	 mov	 rcx, rax
  00309	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN436@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 434  : 	if (wylosowana_liczba != 0)

  0030e	4c 63 06	 movsxd	 r8, DWORD PTR [rsi]
  00311	45 85 c0	 test	 r8d, r8d
  00314	0f 84 4d 01 00
	00		 je	 $LN2531@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0031a	48 8b c3	 mov	 rax, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0031d	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00321	48 83 f9 10	 cmp	 rcx, 16

; 1594 : 		if (_Large_string_engaged())

  00325	72 03		 jb	 SHORT $LN2491@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00327	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN2491@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  0032a	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0032e	48 83 fa 01	 cmp	 rdx, 1
  00332	75 19		 jne	 SHORT $LN492@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00334	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00337	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JBBJJEPG@p?$AA@
  0033d	75 05		 jne	 SHORT $LN2521@Odczytaj_l
  0033f	41 8b c6	 mov	 eax, r14d
  00342	eb 05		 jmp	 SHORT $LN2522@Odczytaj_l
$LN2521@Odczytaj_l:
  00344	1b c0		 sbb	 eax, eax
  00346	83 c8 01	 or	 eax, 1
$LN2522@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00349	85 c0		 test	 eax, eax
  0034b	74 33		 je	 SHORT $LN7@Odczytaj_l
$LN492@Odczytaj_l:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0034d	48 8b c3	 mov	 rax, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00350	48 83 f9 10	 cmp	 rcx, 16

; 1594 : 		if (_Large_string_engaged())

  00354	72 03		 jb	 SHORT $LN2492@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00356	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN2492@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00359	48 83 fa 01	 cmp	 rdx, 1
  0035d	0f 85 6d 02 00
	00		 jne	 $LN521@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00363	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00366	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01EFFIKLCJ@n?$AA@
  0036c	75 05		 jne	 SHORT $LN2519@Odczytaj_l
  0036e	41 8b c6	 mov	 eax, r14d
  00371	eb 05		 jmp	 SHORT $LN2520@Odczytaj_l
$LN2519@Odczytaj_l:
  00373	1b c0		 sbb	 eax, eax
  00375	83 c8 01	 or	 eax, 1
$LN2520@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00378	85 c0		 test	 eax, eax
  0037a	0f 85 50 02 00
	00		 jne	 $LN521@Odczytaj_l
$LN7@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 436  : 			if (wylosowana_liczba % 2 == 0) //Je¿eli wylosowana liczba modulo 2 jest 0 to

  00380	41 f6 c0 01	 test	 r8b, 1
  00384	0f 85 65 01 00
	00		 jne	 $LN8@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0038a	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00392	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T70[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00398	c6 44 24 28 00	 mov	 BYTE PTR $T70[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  0039d	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T1[rsp], 15

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());
; 3733 : 	_Ans += _Left;
; 3734 : 	_Ans += _Right;
; 3735 : 	return (_Ans);
; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
; 3749 : 	_Ans += _Left;
; 3750 : 	_Ans += _Right;
; 3751 : 	return (_Ans);
; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  003a5	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  003ac	48 83 c2 05	 add	 rdx, 5
  003b0	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T70[rsp]
  003b5	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003ba	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  003c2	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  003ca	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  003d1	48 8b d7	 mov	 rdx, rdi
  003d4	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T70[rsp]
  003d9	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003de	41 b8 05 00 00
	00		 mov	 r8d, 5
  003e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNHGCFLK@p?4wav?$AA@
  003eb	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T70[rsp]
  003f0	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  003f5	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T70[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003fa	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T70[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  00400	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T70[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 437  : 				PlaySound((G³os + "p.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana licza jest parzysta

  00406	45 33 c0	 xor	 r8d, r8d
  00409	33 d2		 xor	 edx, edx
  0040b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  00411	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00412	48 8b 54 24 40	 mov	 rdx, QWORD PTR $T70[rsp+24]
  00417	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  0041b	72 4a		 jb	 SHORT $LN2531@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0041d	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00420	48 8b 44 24 28	 mov	 rax, QWORD PTR $T70[rsp]
  00425	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00428	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0042f	72 2e		 jb	 SHORT $LN651@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00431	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00435	4c 3b c2	 cmp	 r8, rdx
  00438	76 1e		 jbe	 SHORT $_Invalid_parameter$2540

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0043a	49 8b d0	 mov	 rdx, r8
  0043d	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00440	75 16		 jne	 SHORT $_Invalid_parameter$2540

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00442	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00446	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00449	73 0d		 jae	 SHORT $_Invalid_parameter$2540

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0044b	48 2b c8	 sub	 rcx, rax
  0044e	48 83 e9 08	 sub	 rcx, 8
  00452	48 83 f9 1f	 cmp	 rcx, 31
  00456	76 07		 jbe	 SHORT $LN651@Odczytaj_l
$_Invalid_parameter$2540:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0045e	cc		 int	 3
$LN651@Odczytaj_l:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0045f	48 8b c8	 mov	 rcx, rax
  00462	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2531@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3694 : 		if (_My_data._Large_string_engaged())

  00467	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
$LN802@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 634  : 		{	// destroy the object

  0046e	48 8b 85 c0 00
	00 00		 mov	 rax, QWORD PTR numers$[rbp-256]
  00475	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00479	4c 89 bc 0d c0
	00 00 00	 mov	 QWORD PTR numers$[rbp+rcx-256], r15
  00481	48 8b 85 c0 00
	00 00		 mov	 rax, QWORD PTR numers$[rbp-256]
  00488	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0048c	8d 91 68 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-152]
  00492	89 94 0d bc 00
	00 00		 mov	 DWORD PTR numers$[rbp+rcx-260], edx

; 635  : 		}

  00499	48 8d 8d d8 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-232]
  004a0	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  004a5	48 8d 8d e0 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-224]
  004ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  004b2	48 8d 8d 58 01
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-104]
  004b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN3@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 458  : }

  004bf	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  004c6	48 33 cc	 xor	 rcx, rsp
  004c9	e8 00 00 00 00	 call	 __security_check_cookie
  004ce	4c 8d 9c 24 d0
	02 00 00	 lea	 r11, QWORD PTR [rsp+720]
  004d6	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  004da	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  004de	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  004e2	49 8b e3	 mov	 rsp, r11
  004e5	41 5f		 pop	 r15
  004e7	41 5e		 pop	 r14
  004e9	41 5d		 pop	 r13
  004eb	41 5c		 pop	 r12
  004ed	5d		 pop	 rbp
  004ee	c3		 ret	 0
$LN8@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  004ef	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  004f7	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T89[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  004fd	c6 44 24 28 00	 mov	 BYTE PTR $T89[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  00502	c7 44 24 20 17
	00 00 00	 mov	 DWORD PTR $T1[rsp], 23

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());
; 3733 : 	_Ans += _Left;
; 3734 : 	_Ans += _Right;
; 3735 : 	return (_Ans);
; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
; 3749 : 	_Ans += _Left;
; 3750 : 	_Ans += _Right;
; 3751 : 	return (_Ans);
; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  0050a	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00511	48 83 c2 05	 add	 rdx, 5
  00515	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T89[rsp]
  0051a	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0051f	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  00527	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0052f	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00536	48 8b d7	 mov	 rdx, rdi
  00539	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T89[rsp]
  0053e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00543	41 b8 05 00 00
	00		 mov	 r8d, 5
  00549	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05MEKKEGFB@n?4wav?$AA@
  00550	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T89[rsp]
  00555	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0055a	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T89[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0055f	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T89[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  00565	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T89[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 439  : 				PlaySound((G³os + "n.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana licza jest nieparzysta

  0056b	45 33 c0	 xor	 r8d, r8d
  0056e	33 d2		 xor	 edx, edx
  00570	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  00576	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00577	48 8b 54 24 40	 mov	 rdx, QWORD PTR $T89[rsp+24]
  0057c	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00580	0f 82 e1 fe ff
	ff		 jb	 $LN2531@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00586	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00589	48 8b 44 24 28	 mov	 rax, QWORD PTR $T89[rsp]
  0058e	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00591	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00598	0f 82 c1 fe ff
	ff		 jb	 $LN651@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0059e	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  005a2	4c 3b c2	 cmp	 r8, rdx
  005a5	76 22		 jbe	 SHORT $_Invalid_parameter$2541

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  005a7	49 8b d0	 mov	 rdx, r8
  005aa	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  005ad	75 1a		 jne	 SHORT $_Invalid_parameter$2541

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  005af	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  005b3	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  005b6	73 11		 jae	 SHORT $_Invalid_parameter$2541

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  005b8	48 2b c8	 sub	 rcx, rax
  005bb	48 83 e9 08	 sub	 rcx, 8
  005bf	48 83 f9 1f	 cmp	 rcx, 31
  005c3	0f 86 96 fe ff
	ff		 jbe	 $LN651@Odczytaj_l
$_Invalid_parameter$2541:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  005c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  005cf	cc		 int	 3
$LN521@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  005d0	48 8b c3	 mov	 rax, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005d3	48 83 f9 10	 cmp	 rcx, 16

; 1594 : 		if (_Large_string_engaged())

  005d7	72 03		 jb	 SHORT $LN2493@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005d9	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN2493@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005dc	48 83 fa 01	 cmp	 rdx, 1
  005e0	75 19		 jne	 SHORT $LN858@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005e2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005e5	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01KDCPPGHE@r?$AA@
  005eb	75 05		 jne	 SHORT $LN2517@Odczytaj_l
  005ed	41 8b c6	 mov	 eax, r14d
  005f0	eb 05		 jmp	 SHORT $LN2518@Odczytaj_l
$LN2517@Odczytaj_l:
  005f2	1b c0		 sbb	 eax, eax
  005f4	83 c8 01	 or	 eax, 1
$LN2518@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005f7	85 c0		 test	 eax, eax
  005f9	74 33		 je	 SHORT $LN12@Odczytaj_l
$LN858@Odczytaj_l:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  005fb	48 8b c3	 mov	 rax, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005fe	48 83 f9 10	 cmp	 rcx, 16

; 1594 : 		if (_Large_string_engaged())

  00602	72 03		 jb	 SHORT $LN2494@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00604	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN2494@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00607	48 83 fa 01	 cmp	 rdx, 1
  0060b	0f 85 ee 01 00
	00		 jne	 $LN887@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00611	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00614	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01OJONOECF@b?$AA@
  0061a	75 05		 jne	 SHORT $LN2515@Odczytaj_l
  0061c	41 8b c6	 mov	 eax, r14d
  0061f	eb 05		 jmp	 SHORT $LN2516@Odczytaj_l
$LN2515@Odczytaj_l:
  00621	1b c0		 sbb	 eax, eax
  00623	83 c8 01	 or	 eax, 1
$LN2516@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00626	85 c0		 test	 eax, eax
  00628	0f 85 d1 01 00
	00		 jne	 $LN887@Odczytaj_l
$LN12@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 441  : 			if (Ruletka_plansza_kolor[wylosowana_liczba] == 'r') //Je¿eli kolor wylosowanej liczby to czerwony

  0062e	43 80 bc 38 00
	00 00 00 72	 cmp	 BYTE PTR ?Ruletka_plansza_kolor@@3QBDB[r8+r15], 114 ; 00000072H
  00637	0f 85 e1 00 00
	00		 jne	 $LN13@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0063d	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00645	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T118[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0064b	c6 44 24 28 00	 mov	 BYTE PTR $T118[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  00650	c7 44 24 20 27
	00 00 00	 mov	 DWORD PTR $T1[rsp], 39	; 00000027H

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());
; 3733 : 	_Ans += _Left;
; 3734 : 	_Ans += _Right;
; 3735 : 	return (_Ans);
; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
; 3749 : 	_Ans += _Left;
; 3750 : 	_Ans += _Right;
; 3751 : 	return (_Ans);
; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00658	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0065f	48 83 c2 05	 add	 rdx, 5
  00663	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T118[rsp]
  00668	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0066d	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  00675	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0067d	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00684	48 8b d7	 mov	 rdx, rdi
  00687	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T118[rsp]
  0068c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00691	41 b8 05 00 00
	00		 mov	 r8d, 5
  00697	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LALOIELB@r?4wav?$AA@
  0069e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T118[rsp]
  006a3	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  006a8	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T118[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006ad	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T118[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  006b3	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T118[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 442  : 				PlaySound((G³os + "r.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest koloru czerwonego

  006b9	45 33 c0	 xor	 r8d, r8d
  006bc	33 d2		 xor	 edx, edx
  006be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  006c4	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006c5	48 8b 54 24 40	 mov	 rdx, QWORD PTR $T118[rsp+24]
  006ca	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  006ce	0f 82 93 fd ff
	ff		 jb	 $LN2531@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  006d4	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  006d7	48 8b 44 24 28	 mov	 rax, QWORD PTR $T118[rsp]
  006dc	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  006df	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  006e6	0f 82 73 fd ff
	ff		 jb	 $LN651@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  006ec	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  006f0	4c 3b c2	 cmp	 r8, rdx
  006f3	76 22		 jbe	 SHORT $_Invalid_parameter$2542

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  006f5	49 8b d0	 mov	 rdx, r8
  006f8	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  006fb	75 1a		 jne	 SHORT $_Invalid_parameter$2542

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  006fd	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00701	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00704	73 11		 jae	 SHORT $_Invalid_parameter$2542

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00706	48 2b c8	 sub	 rcx, rax
  00709	48 83 e9 08	 sub	 rcx, 8
  0070d	48 83 f9 1f	 cmp	 rcx, 31
  00711	0f 86 48 fd ff
	ff		 jbe	 $LN651@Odczytaj_l
$_Invalid_parameter$2542:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00717	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0071d	90		 npad	 1
$LN13@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0071e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00726	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T137[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0072c	c6 44 24 28 00	 mov	 BYTE PTR $T137[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  00731	c7 44 24 20 47
	00 00 00	 mov	 DWORD PTR $T1[rsp], 71	; 00000047H

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());
; 3733 : 	_Ans += _Left;
; 3734 : 	_Ans += _Right;
; 3735 : 	return (_Ans);
; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
; 3749 : 	_Ans += _Left;
; 3750 : 	_Ans += _Right;
; 3751 : 	return (_Ans);
; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00739	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00740	48 83 c2 05	 add	 rdx, 5
  00744	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T137[rsp]
  00749	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0074e	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  00756	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0075e	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00765	48 8b d7	 mov	 rdx, rdi
  00768	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T137[rsp]
  0076d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00772	41 b8 05 00 00
	00		 mov	 r8d, 5
  00778	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LDGIIGCK@b?4wav?$AA@
  0077f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T137[rsp]
  00784	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00789	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T137[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0078e	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T137[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  00794	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T137[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 444  : 				PlaySound((G³os + "b.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e liczba jest koloru czarnego

  0079a	45 33 c0	 xor	 r8d, r8d
  0079d	33 d2		 xor	 edx, edx
  0079f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  007a5	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007a6	48 8b 54 24 40	 mov	 rdx, QWORD PTR $T137[rsp+24]
  007ab	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  007af	0f 82 b2 fc ff
	ff		 jb	 $LN2531@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  007b5	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  007b8	48 8b 44 24 28	 mov	 rax, QWORD PTR $T137[rsp]
  007bd	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  007c0	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  007c7	0f 82 92 fc ff
	ff		 jb	 $LN651@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  007cd	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  007d1	4c 3b c2	 cmp	 r8, rdx
  007d4	76 22		 jbe	 SHORT $_Invalid_parameter$2543

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  007d6	49 8b d0	 mov	 rdx, r8
  007d9	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  007dc	75 1a		 jne	 SHORT $_Invalid_parameter$2543

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  007de	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  007e2	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  007e5	73 11		 jae	 SHORT $_Invalid_parameter$2543

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  007e7	48 2b c8	 sub	 rcx, rax
  007ea	48 83 e9 08	 sub	 rcx, 8
  007ee	48 83 f9 1f	 cmp	 rcx, 31
  007f2	0f 86 67 fc ff
	ff		 jbe	 $LN651@Odczytaj_l
$_Invalid_parameter$2543:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  007f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  007fe	cc		 int	 3
$LN887@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  007ff	48 8b c3	 mov	 rax, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00802	48 83 f9 10	 cmp	 rcx, 16

; 1594 : 		if (_Large_string_engaged())

  00806	72 03		 jb	 SHORT $LN2495@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00808	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN2495@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0080b	48 83 fa 01	 cmp	 rdx, 1
  0080f	75 19		 jne	 SHORT $LN1224@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00811	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00814	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JEJKBAGA@g?$AA@
  0081a	75 05		 jne	 SHORT $LN2513@Odczytaj_l
  0081c	41 8b c6	 mov	 eax, r14d
  0081f	eb 05		 jmp	 SHORT $LN2514@Odczytaj_l
$LN2513@Odczytaj_l:
  00821	1b c0		 sbb	 eax, eax
  00823	83 c8 01	 or	 eax, 1
$LN2514@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00826	85 c0		 test	 eax, eax
  00828	74 33		 je	 SHORT $LN17@Odczytaj_l
$LN1224@Odczytaj_l:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0082a	48 8b c3	 mov	 rax, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0082d	48 83 f9 10	 cmp	 rcx, 16

; 1594 : 		if (_Large_string_engaged())

  00831	72 03		 jb	 SHORT $LN2496@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00833	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN2496@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00836	48 83 fa 01	 cmp	 rdx, 1
  0083a	0f 85 e9 01 00
	00		 jne	 $LN1253@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00840	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00843	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01LPLHEDKD@d?$AA@
  00849	75 05		 jne	 SHORT $LN2511@Odczytaj_l
  0084b	41 8b c6	 mov	 eax, r14d
  0084e	eb 05		 jmp	 SHORT $LN2512@Odczytaj_l
$LN2511@Odczytaj_l:
  00850	1b c0		 sbb	 eax, eax
  00852	83 c8 01	 or	 eax, 1
$LN2512@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00855	85 c0		 test	 eax, eax
  00857	0f 85 cc 01 00
	00		 jne	 $LN1253@Odczytaj_l
$LN17@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 446  : 			if (wylosowana_liczba < 19) //Je¿eli wylosowa liczba jest mniejsza ni¿ 19

  0085d	41 83 f8 13	 cmp	 r8d, 19
  00861	0f 8d e1 00 00
	00		 jge	 $LN18@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00867	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  0086f	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T166[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00875	c6 44 24 28 00	 mov	 BYTE PTR $T166[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  0087a	c7 44 24 20 87
	00 00 00	 mov	 DWORD PTR $T1[rsp], 135	; 00000087H

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());
; 3733 : 	_Ans += _Left;
; 3734 : 	_Ans += _Right;
; 3735 : 	return (_Ans);
; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
; 3749 : 	_Ans += _Left;
; 3750 : 	_Ans += _Right;
; 3751 : 	return (_Ans);
; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00882	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00889	48 83 c2 05	 add	 rdx, 5
  0088d	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T166[rsp]
  00892	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00897	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  0089f	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  008a7	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  008ae	48 8b d7	 mov	 rdx, rdi
  008b1	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T166[rsp]
  008b6	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  008bb	41 b8 05 00 00
	00		 mov	 r8d, 5
  008c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05ODKFBHJJ@g?4wav?$AA@
  008c8	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T166[rsp]
  008cd	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008d2	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T166[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008d7	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T166[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  008dd	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T166[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 447  : 				PlaySound((G³os + "g.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest z górnej po³ówki

  008e3	45 33 c0	 xor	 r8d, r8d
  008e6	33 d2		 xor	 edx, edx
  008e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  008ee	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008ef	48 8b 54 24 40	 mov	 rdx, QWORD PTR $T166[rsp+24]
  008f4	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  008f8	0f 82 69 fb ff
	ff		 jb	 $LN2531@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  008fe	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00901	48 8b 44 24 28	 mov	 rax, QWORD PTR $T166[rsp]
  00906	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00909	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00910	0f 82 49 fb ff
	ff		 jb	 $LN651@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00916	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  0091a	4c 3b c2	 cmp	 r8, rdx
  0091d	76 22		 jbe	 SHORT $_Invalid_parameter$2544

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0091f	49 8b d0	 mov	 rdx, r8
  00922	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00925	75 1a		 jne	 SHORT $_Invalid_parameter$2544

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00927	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0092b	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0092e	73 11		 jae	 SHORT $_Invalid_parameter$2544

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00930	48 2b c8	 sub	 rcx, rax
  00933	48 83 e9 08	 sub	 rcx, 8
  00937	48 83 f9 1f	 cmp	 rcx, 31
  0093b	0f 86 1e fb ff
	ff		 jbe	 $LN651@Odczytaj_l
$_Invalid_parameter$2544:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00941	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00947	90		 npad	 1
$LN18@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00948	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00950	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T185[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00956	c6 44 24 28 00	 mov	 BYTE PTR $T185[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  0095b	c7 44 24 20 07
	01 00 00	 mov	 DWORD PTR $T1[rsp], 263	; 00000107H

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());
; 3733 : 	_Ans += _Left;
; 3734 : 	_Ans += _Right;
; 3735 : 	return (_Ans);
; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
; 3749 : 	_Ans += _Left;
; 3750 : 	_Ans += _Right;
; 3751 : 	return (_Ans);
; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00963	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0096a	48 83 c2 05	 add	 rdx, 5
  0096e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T185[rsp]
  00973	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00978	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  00980	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00988	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0098f	48 8b d7	 mov	 rdx, rdi
  00992	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T185[rsp]
  00997	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0099c	41 b8 05 00 00
	00		 mov	 r8d, 5
  009a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05GFDBGFDH@d?4wav?$AA@
  009a9	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T185[rsp]
  009ae	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  009b3	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T185[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009b8	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T185[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  009be	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T185[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 449  : 				PlaySound((G³os + "d.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana liczba jest z dolnej po³ówki

  009c4	45 33 c0	 xor	 r8d, r8d
  009c7	33 d2		 xor	 edx, edx
  009c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  009cf	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009d0	48 8b 54 24 40	 mov	 rdx, QWORD PTR $T185[rsp+24]
  009d5	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  009d9	0f 82 88 fa ff
	ff		 jb	 $LN2531@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  009df	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  009e2	48 8b 44 24 28	 mov	 rax, QWORD PTR $T185[rsp]
  009e7	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  009ea	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  009f1	0f 82 68 fa ff
	ff		 jb	 $LN651@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  009f7	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  009fb	4c 3b c2	 cmp	 r8, rdx
  009fe	76 22		 jbe	 SHORT $_Invalid_parameter$2545

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00a00	49 8b d0	 mov	 rdx, r8
  00a03	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00a06	75 1a		 jne	 SHORT $_Invalid_parameter$2545

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00a08	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00a0c	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00a0f	73 11		 jae	 SHORT $_Invalid_parameter$2545

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00a11	48 2b c8	 sub	 rcx, rax
  00a14	48 83 e9 08	 sub	 rcx, 8
  00a18	48 83 f9 1f	 cmp	 rcx, 31
  00a1c	0f 86 3d fa ff
	ff		 jbe	 $LN651@Odczytaj_l
$_Invalid_parameter$2545:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00a22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00a28	cc		 int	 3
$LN1253@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00a29	48 8b c3	 mov	 rax, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a2c	48 83 f9 10	 cmp	 rcx, 16

; 1594 : 		if (_Large_string_engaged())

  00a30	72 03		 jb	 SHORT $LN2497@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a32	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN2497@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 450  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  00a35	80 38 6b	 cmp	 BYTE PTR [rax], 107	; 0000006bH
  00a38	0f 85 76 02 00
	00		 jne	 $LN20@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00a3e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00a46	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T205[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00a4c	c6 44 24 28 00	 mov	 BYTE PTR $T205[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  00a51	c7 44 24 20 07
	02 00 00	 mov	 DWORD PTR $T1[rsp], 519	; 00000207H

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());
; 3733 : 	_Ans += _Left;
; 3734 : 	_Ans += _Right;
; 3735 : 	return (_Ans);
; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
; 3749 : 	_Ans += _Left;
; 3750 : 	_Ans += _Right;
; 3751 : 	return (_Ans);
; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00a59	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00a60	48 ff c2	 inc	 rdx
  00a63	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T205[rsp]
  00a68	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a6d	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  00a75	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00a7d	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00a84	48 8b d7	 mov	 rdx, rdi
  00a87	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T205[rsp]
  00a8c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00a91	41 b8 01 00 00
	00		 mov	 r8d, 1
  00a97	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01DICPFPGM@k?$AA@
  00a9e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T205[rsp]
  00aa3	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 451  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  00aa8	8b 0e		 mov	 ecx, DWORD PTR [rsi]
  00aaa	ff c9		 dec	 ecx
  00aac	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00ab1	f7 e9		 imul	 ecx
  00ab3	8b c2		 mov	 eax, edx
  00ab5	c1 e8 1f	 shr	 eax, 31
  00ab8	03 d0		 add	 edx, eax
  00aba	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00abd	2b c8		 sub	 ecx, eax
  00abf	80 c1 31	 add	 cl, 49			; 00000031H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  00ac2	48 8b 54 24 38	 mov	 rdx, QWORD PTR $T205[rsp+16]
  00ac7	4c 8b 44 24 40	 mov	 r8, QWORD PTR $T205[rsp+24]
  00acc	49 3b d0	 cmp	 rdx, r8

; 2977 : 		if (_Old_size < _My_data._Myres)

  00acf	73 22		 jae	 SHORT $LN1654@Odczytaj_l

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  00ad1	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00ad5	48 89 44 24 38	 mov	 QWORD PTR $T205[rsp+16], rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00ada	48 8d 44 24 28	 lea	 rax, QWORD PTR $T205[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00adf	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  00ae3	48 0f 43 44 24
	28		 cmovae	 rax, QWORD PTR $T205[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00ae9	88 0c 10	 mov	 BYTE PTR [rax+rdx], cl
  00aec	c6 44 10 01 00	 mov	 BYTE PTR [rax+rdx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  00af1	eb 0e		 jmp	 SHORT $LN1653@Odczytaj_l
$LN1654@Odczytaj_l:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  00af3	44 0f b6 c9	 movzx	 r9d, cl
  00af7	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T205[rsp]
  00afc	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN1653@Odczytaj_l:

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00b01	0f 10 44 24 28	 movups	 xmm0, XMMWORD PTR $T205[rsp]
  00b06	0f 11 44 24 68	 movups	 XMMWORD PTR $T223[rsp], xmm0
  00b0b	0f 10 4c 24 38	 movups	 xmm1, XMMWORD PTR $T205[rsp+16]
  00b10	0f 11 4c 24 78	 movups	 XMMWORD PTR $T223[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00b15	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00b1d	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T205[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00b23	c6 44 24 28 00	 mov	 BYTE PTR $T205[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3871 : 	return (_STD move(_Left));

  00b28	c7 44 24 20 07
	06 00 00	 mov	 DWORD PTR $T1[rsp], 1543 ; 00000607H

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00b30	41 b8 04 00 00
	00		 mov	 r8d, 4
  00b36	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  00b3d	48 8d 4c 24 68	 lea	 rcx, QWORD PTR $T223[rsp]
  00b42	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00b47	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  00b4a	f3 0f 7f 44 24
	58		 movdqu	 XMMWORD PTR $T239[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00b50	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00b53	0f 11 44 24 48	 movups	 XMMWORD PTR $T239[rsp], xmm0
  00b58	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00b5c	0f 11 4c 24 58	 movups	 XMMWORD PTR $T239[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00b61	4c 89 70 10	 mov	 QWORD PTR [rax+16], r14

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00b65	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00b6d	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00b70	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T239[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b75	48 83 7c 24 60
	10		 cmp	 QWORD PTR $T239[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  00b7b	48 0f 43 4c 24
	48		 cmovae	 rcx, QWORD PTR $T239[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 451  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  00b81	45 33 c0	 xor	 r8d, r8d
  00b84	33 d2		 xor	 edx, edx
  00b86	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b8c	48 8b 54 24 60	 mov	 rdx, QWORD PTR $T239[rsp+24]
  00b91	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00b95	72 4a		 jb	 SHORT $LN1862@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00b97	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00b9a	48 8b 44 24 48	 mov	 rax, QWORD PTR $T239[rsp]
  00b9f	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00ba2	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00ba9	72 2e		 jb	 SHORT $LN1865@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00bab	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00baf	4c 3b c2	 cmp	 r8, rdx
  00bb2	76 1e		 jbe	 SHORT $_Invalid_parameter$2546

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00bb4	49 8b d0	 mov	 rdx, r8
  00bb7	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00bba	75 16		 jne	 SHORT $_Invalid_parameter$2546

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00bbc	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00bc0	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00bc3	73 0d		 jae	 SHORT $_Invalid_parameter$2546

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00bc5	48 2b c8	 sub	 rcx, rax
  00bc8	48 83 e9 08	 sub	 rcx, 8
  00bcc	48 83 f9 1f	 cmp	 rcx, 31
  00bd0	76 07		 jbe	 SHORT $LN1865@Odczytaj_l
$_Invalid_parameter$2546:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00bd2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00bd8	cc		 int	 3
$LN1865@Odczytaj_l:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00bd9	48 8b c8	 mov	 rcx, rax
  00bdc	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1862@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00be1	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00be9	f3 0f 7f 44 24
	58		 movdqu	 XMMWORD PTR $T239[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00bef	c6 44 24 48 00	 mov	 BYTE PTR $T239[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00bf4	48 8b 55 80	 mov	 rdx, QWORD PTR $T223[rbp-232]
  00bf8	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00bfc	72 4a		 jb	 SHORT $LN1933@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00bfe	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00c01	48 8b 44 24 68	 mov	 rax, QWORD PTR $T223[rsp]
  00c06	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00c09	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00c10	72 2e		 jb	 SHORT $LN1936@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00c12	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00c16	4c 3b c2	 cmp	 r8, rdx
  00c19	76 1e		 jbe	 SHORT $_Invalid_parameter$2547

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00c1b	49 8b d0	 mov	 rdx, r8
  00c1e	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00c21	75 16		 jne	 SHORT $_Invalid_parameter$2547

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00c23	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00c27	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00c2a	73 0d		 jae	 SHORT $_Invalid_parameter$2547

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00c2c	48 2b c8	 sub	 rcx, rax
  00c2f	48 83 e9 08	 sub	 rcx, 8
  00c33	48 83 f9 1f	 cmp	 rcx, 31
  00c37	76 07		 jbe	 SHORT $LN1936@Odczytaj_l
$_Invalid_parameter$2547:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00c39	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00c3f	cc		 int	 3
$LN1936@Odczytaj_l:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00c40	48 8b c8	 mov	 rcx, rax
  00c43	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1933@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00c48	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00c50	f3 0f 7f 44 24
	78		 movdqu	 XMMWORD PTR $T223[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00c56	c6 44 24 68 00	 mov	 BYTE PTR $T223[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c5b	48 8b 54 24 40	 mov	 rdx, QWORD PTR $T205[rsp+24]
  00c60	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00c64	0f 82 fd f7 ff
	ff		 jb	 $LN2531@Odczytaj_l

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00c6a	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00c6d	48 8b 44 24 28	 mov	 rax, QWORD PTR $T205[rsp]
  00c72	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00c75	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00c7c	0f 82 dd f7 ff
	ff		 jb	 $LN651@Odczytaj_l

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00c82	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00c86	4c 3b c2	 cmp	 r8, rdx
  00c89	76 22		 jbe	 SHORT $_Invalid_parameter$2548

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00c8b	49 8b d0	 mov	 rdx, r8
  00c8e	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00c91	75 1a		 jne	 SHORT $_Invalid_parameter$2548

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00c93	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00c97	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00c9a	73 11		 jae	 SHORT $_Invalid_parameter$2548

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00c9c	48 2b c8	 sub	 rcx, rax
  00c9f	48 83 e9 08	 sub	 rcx, 8
  00ca3	48 83 f9 1f	 cmp	 rcx, 31
  00ca7	0f 86 b2 f7 ff
	ff		 jbe	 $LN651@Odczytaj_l
$_Invalid_parameter$2548:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00cad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00cb3	cc		 int	 3
$LN20@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00cb4	48 83 f9 10	 cmp	 rcx, 16

; 1594 : 		if (_Large_string_engaged())

  00cb8	72 03		 jb	 SHORT $LN2046@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00cba	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN2046@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 452  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  00cbd	80 3b 77	 cmp	 BYTE PTR [rbx], 119	; 00000077H
  00cc0	0f 85 a1 f7 ff
	ff		 jne	 $LN2531@Odczytaj_l
  00cc6	33 d2		 xor	 edx, edx
  00cc8	41 b8 f8 00 00
	00		 mov	 r8d, 248		; 000000f8H
  00cce	48 8d 4d c0	 lea	 rcx, QWORD PTR numers$354[rbp-256]
  00cd2	e8 00 00 00 00	 call	 memset
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 590  : 		{	// construct empty character buffer

  00cd7	49 8d 87 00 00
	00 00		 lea	 rax, QWORD PTR ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@[r15]
  00cde	48 89 45 c0	 mov	 QWORD PTR numers$354[rbp-256], rax
  00ce2	4c 89 65 d0	 mov	 QWORD PTR numers$354[rbp-240], r12
  00ce6	48 8d 4d 58	 lea	 rcx, QWORD PTR numers$354[rbp-104]
  00cea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00cf0	90		 npad	 1
  00cf1	c7 44 24 20 07
	10 00 00	 mov	 DWORD PTR $T1[rsp], 4103 ; 00001007H

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	typedef typename allocator_traits<allocator_type>::pointer _Ptrty;
; 350  : 
; 351  : 	enum
; 352  : 		{	// constant for minimum buffer size
; 353  : 		_MINSIZE = 32};
; 354  : 
; 355  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 356  : 		{	// convert open mode to stream state bits
; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);
; 367  : 		}
; 368  : 
; 369  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 370  : 	_Strstate _Mystate;	// the stream state
; 371  : 	allocator_type _Al;	// the allocator object
; 372  : 	};
; 373  : 
; 374  : template<class _Elem,
; 375  : 	class _Traits,
; 376  : 	class _Alloc> inline
; 377  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 378  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 379  : 	{	// swap _Left and _Right basic_stringbufs
; 380  : 	_Left.swap(_Right);
; 381  : 	}
; 382  : 
; 383  : 		// CLASS TEMPLATE basic_istringstream
; 384  : template<class _Elem,
; 385  : 	class _Traits,
; 386  : 	class _Alloc>
; 387  : 	class basic_istringstream
; 388  : 		: public basic_istream<_Elem, _Traits>
; 389  : 	{	// input stream associated with a character array
; 390  : public:
; 391  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 392  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 393  : 	typedef _Alloc allocator_type;
; 394  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 395  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 396  : 
; 397  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 398  : 		: _Mybase(&_Stringbuffer),
; 399  : 			_Stringbuffer(_Mode | ios_base::in)
; 400  : 		{	// construct empty readable character buffer
; 401  : 		}
; 402  : 
; 403  : 	explicit basic_istringstream(const _Mystr& _Str,
; 404  : 		ios_base::openmode _Mode = ios_base::in)
; 405  : 		: _Mybase(&_Stringbuffer),
; 406  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 407  : 		{	// construct readable character buffer from NTCS
; 408  : 		}
; 409  : 
; 410  : 	basic_istringstream(_Myt&& _Right)
; 411  : 		: _Mybase(&_Stringbuffer)
; 412  : 		{	// construct by moving _Right
; 413  : 		_Assign_rv(_STD move(_Right));
; 414  : 		}
; 415  : 
; 416  : 	_Myt& operator=(_Myt&& _Right)
; 417  : 		{	// move from _Right
; 418  : 		_Assign_rv(_STD move(_Right));
; 419  : 		return (*this);
; 420  : 		}
; 421  : 
; 422  : 	void _Assign_rv(_Myt&& _Right)
; 423  : 		{	// assign by moving _Right
; 424  : 		if (this != _STD addressof(_Right))
; 425  : 			{	// different, worth moving
; 426  : 			_Stringbuffer.str(_Mystr());
; 427  : 			this->swap(_Right);
; 428  : 			}
; 429  : 		}
; 430  : 
; 431  : 	void swap(_Myt& _Right)
; 432  : 		{	// swap with _Right
; 433  : 		if (this != _STD addressof(_Right))
; 434  : 			{	// different, swap base and buffer
; 435  : 			_Mybase::swap(_Right);
; 436  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 437  : 			}
; 438  : 		}
; 439  : 
; 440  : 	basic_istringstream(const _Myt&) = delete;
; 441  : 	_Myt& operator=(const _Myt&) = delete;
; 442  : 
; 443  : 	virtual ~basic_istringstream() _NOEXCEPT
; 444  : 		{	// destroy the object
; 445  : 		}
; 446  : 
; 447  : 	_Mysb *rdbuf() const
; 448  : 		{	// return pointer to file buffer
; 449  : 		return ((_Mysb *)&_Stringbuffer);
; 450  : 		}
; 451  : 
; 452  : 	_Mystr str() const
; 453  : 		{	// return string copy of character array
; 454  : 		return (_Stringbuffer.str());
; 455  : 		}
; 456  : 
; 457  : 	void str(const _Mystr& _Newstr)
; 458  : 		{	// replace character array from string
; 459  : 		_Stringbuffer.str(_Newstr);
; 460  : 		}
; 461  : 
; 462  : private:
; 463  : 	_Mysb _Stringbuffer;	// the string buffer
; 464  : 	};
; 465  : 
; 466  : template<class _Elem,
; 467  : 	class _Traits,
; 468  : 	class _Alloc> inline
; 469  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 470  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 471  : 	{	// swap _Left and _Right basic_istringstreams
; 472  : 	_Left.swap(_Right);
; 473  : 	}
; 474  : 
; 475  : 		// CLASS TEMPLATE basic_ostringstream
; 476  : template<class _Elem,
; 477  : 	class _Traits,
; 478  : 	class _Alloc>
; 479  : 	class basic_ostringstream
; 480  : 		: public basic_ostream<_Elem, _Traits>
; 481  : 	{	// output stream associated with a character array
; 482  : public:
; 483  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 484  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 485  : 	typedef _Alloc allocator_type;
; 486  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 487  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 488  : 
; 489  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 490  : 		: _Mybase(&_Stringbuffer),
; 491  : 			_Stringbuffer(_Mode | ios_base::out)
; 492  : 		{	// construct empty writable character buffer
; 493  : 		}
; 494  : 
; 495  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 496  : 		ios_base::openmode _Mode = ios_base::out)
; 497  : 		: _Mybase(&_Stringbuffer),
; 498  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 499  : 		{	// construct writable character buffer from NTCS
; 500  : 		}
; 501  : 
; 502  : 	basic_ostringstream(_Myt&& _Right)
; 503  : 		: _Mybase(&_Stringbuffer)
; 504  : 		{	// construct by moving _Right
; 505  : 		_Assign_rv(_STD move(_Right));
; 506  : 		}
; 507  : 
; 508  : 	_Myt& operator=(_Myt&& _Right)
; 509  : 		{	// move from _Right
; 510  : 		_Assign_rv(_STD move(_Right));
; 511  : 		return (*this);
; 512  : 		}
; 513  : 
; 514  : 	void _Assign_rv(_Myt&& _Right)
; 515  : 		{	// assign by moving _Right
; 516  : 		if (this != _STD addressof(_Right))
; 517  : 			{	// different, worth moving
; 518  : 			_Stringbuffer.str(_Mystr());
; 519  : 			this->swap(_Right);
; 520  : 			}
; 521  : 		}
; 522  : 
; 523  : 	void swap(_Myt& _Right)
; 524  : 		{	// swap with _Right
; 525  : 		if (this != _STD addressof(_Right))
; 526  : 			{	// different, swap base and buffer
; 527  : 			_Mybase::swap(_Right);
; 528  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 529  : 			}
; 530  : 		}
; 531  : 
; 532  : 	basic_ostringstream(const _Myt&) = delete;
; 533  : 	_Myt& operator=(const _Myt&) = delete;
; 534  : 
; 535  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 536  : 		{	// destroy the object
; 537  : 		}
; 538  : 
; 539  : 	_Mysb *rdbuf() const
; 540  : 		{	// return pointer to buffer
; 541  : 		return ((_Mysb *)&_Stringbuffer);
; 542  : 		}
; 543  : 
; 544  : 	_Mystr str() const
; 545  : 		{	// return string copy of character array
; 546  : 		return (_Stringbuffer.str());
; 547  : 		}
; 548  : 
; 549  : 	void str(const _Mystr& _Newstr)
; 550  : 		{	// replace character array from string
; 551  : 		_Stringbuffer.str(_Newstr);
; 552  : 		}
; 553  : 
; 554  : private:
; 555  : 	_Mysb _Stringbuffer;	// the string buffer
; 556  : 	};
; 557  : 
; 558  : template<class _Elem,
; 559  : 	class _Traits,
; 560  : 	class _Alloc> inline
; 561  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 562  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 563  : 	{	// swap _Left and _Right basic_ostringstreams
; 564  : 	_Left.swap(_Right);
; 565  : 	}
; 566  : 
; 567  : 		// CLASS TEMPLATE basic_stringstream
; 568  : template<class _Elem,
; 569  : 	class _Traits,
; 570  : 	class _Alloc>
; 571  : 	class basic_stringstream
; 572  : 		: public basic_iostream<_Elem, _Traits>
; 573  : 	{	// input/output stream associated with a character array
; 574  : public:
; 575  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 576  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 577  : 	typedef _Elem char_type;
; 578  : 	typedef _Traits traits_type;
; 579  : 	typedef _Alloc allocator_type;
; 580  : 	typedef typename _Traits::int_type int_type;
; 581  : 	typedef typename _Traits::pos_type pos_type;
; 582  : 	typedef typename _Traits::off_type off_type;
; 583  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 584  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 585  : 
; 586  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 587  : 		ios_base::in | ios_base::out)
; 588  : 		: _Mybase(&_Stringbuffer),

  00cf9	45 33 c0	 xor	 r8d, r8d
  00cfc	48 8d 55 d8	 lea	 rdx, QWORD PTR numers$354[rbp-232]
  00d00	48 8d 4d c0	 lea	 rcx, QWORD PTR numers$354[rbp-256]
  00d04	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00d0a	90		 npad	 1

; 590  : 		{	// construct empty character buffer

  00d0b	48 8b 45 c0	 mov	 rax, QWORD PTR numers$354[rbp-256]
  00d0f	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00d13	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00d1a	4c 89 7c 0d c0	 mov	 QWORD PTR numers$354[rbp+rcx-256], r15
  00d1f	48 8b 45 c0	 mov	 rax, QWORD PTR numers$354[rbp-256]
  00d23	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00d27	8d 91 68 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-152]
  00d2d	89 54 0d bc	 mov	 DWORD PTR numers$354[rbp+rcx-260], edx

; 589  : 			_Stringbuffer(_Mode)

  00d31	48 8d 45 d8	 lea	 rax, QWORD PTR numers$354[rbp-232]
  00d35	48 89 45 88	 mov	 QWORD PTR this$[rbp-256], rax

; 30   : 		{	// construct empty character buffer from mode

  00d39	48 8d 4d d8	 lea	 rcx, QWORD PTR numers$354[rbp-232]
  00d3d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00d43	90		 npad	 1
  00d44	4c 89 6d d8	 mov	 QWORD PTR numers$354[rbp-232], r13

; 311  : 		_Seekhigh = 0;

  00d48	4c 89 75 40	 mov	 QWORD PTR numers$354[rbp-128], r14

; 312  : 		_Mystate = _State;

  00d4c	44 89 75 48	 mov	 DWORD PTR numers$354[rbp-120], r14d
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 455  : 			numers << ((wylosowana_liczba - 1) / 3 + 1); //Wpisanie do typu obliczonego wiersza wylosowanej liczby

  00d50	8b 0e		 mov	 ecx, DWORD PTR [rsi]
  00d52	ff c9		 dec	 ecx
  00d54	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00d59	f7 e9		 imul	 ecx
  00d5b	8b c2		 mov	 eax, edx
  00d5d	c1 e8 1f	 shr	 eax, 31
  00d60	ff c2		 inc	 edx
  00d62	03 d0		 add	 edx, eax
  00d64	48 8d 4d d0	 lea	 rcx, QWORD PTR numers$354[rbp-240]
  00d68	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z

; 456  : 			PlaySound((G³os + "w" + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiego wiersza jest wylosowana liczba

  00d6e	48 8d 55 98	 lea	 rdx, QWORD PTR $T275[rbp-256]
  00d72	48 8d 4d c0	 lea	 rcx, QWORD PTR numers$354[rbp-256]
  00d76	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  00d7b	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00d7e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00d86	f3 0f 7f 44 24
	58		 movdqu	 XMMWORD PTR $T277[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00d8c	c6 44 24 48 00	 mov	 BYTE PTR $T277[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  00d91	c7 44 24 20 07
	30 00 00	 mov	 DWORD PTR $T1[rsp], 12295 ; 00003007H

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());
; 3733 : 	_Ans += _Left;
; 3734 : 	_Ans += _Right;
; 3735 : 	return (_Ans);
; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
; 3749 : 	_Ans += _Left;
; 3750 : 	_Ans += _Right;
; 3751 : 	return (_Ans);
; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00d99	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00da0	48 ff c2	 inc	 rdx
  00da3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T277[rsp]
  00da8	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00dad	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  00db5	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00dbd	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00dc4	48 8b d7	 mov	 rdx, rdi
  00dc7	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T277[rsp]
  00dcc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00dd1	41 b8 01 00 00
	00		 mov	 r8d, 1
  00dd7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
  00dde	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T277[rsp]
  00de3	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3047 : 		return (this->_Get_data()._Mysize);

  00de8	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]

; 3826 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  00dec	48 8b 44 24 60	 mov	 rax, QWORD PTR $T277[rsp+24]
  00df1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T277[rsp+16]
  00df6	48 2b c1	 sub	 rax, rcx
  00df9	4c 3b c0	 cmp	 r8, rax
  00dfc	76 1b		 jbe	 SHORT $LN2498@Odczytaj_l

; 3077 : 		return (this->_Get_data()._Myres);

  00dfe	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 3826 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  00e02	49 2b c0	 sub	 rax, r8
  00e05	48 3b c1	 cmp	 rax, rcx
  00e08	72 0f		 jb	 SHORT $LN2498@Odczytaj_l

; 3828 : 	else
; 3829 : 		return (_STD move(_Right.insert(0, _Left)));

  00e0a	4c 8d 44 24 48	 lea	 r8, QWORD PTR $T277[rsp]
  00e0f	48 8b cb	 mov	 rcx, rbx
  00e12	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00e17	eb 17		 jmp	 SHORT $LN2533@Odczytaj_l
$LN2498@Odczytaj_l:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00e19	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1594 : 		if (_Large_string_engaged())

  00e1e	72 03		 jb	 SHORT $LN2249@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00e20	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN2249@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00e23	48 8b d3	 mov	 rdx, rbx
  00e26	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T277[rsp]
  00e2b	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2533@Odczytaj_l:
  00e30	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  00e33	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T312[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00e39	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00e3c	0f 11 44 24 28	 movups	 XMMWORD PTR $T312[rsp], xmm0
  00e41	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00e45	0f 11 4c 24 38	 movups	 XMMWORD PTR $T312[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00e4a	4c 89 70 10	 mov	 QWORD PTR [rax+16], r14

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00e4e	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 3827 : 		return (_STD move(_Left.append(_Right)));

  00e56	c7 44 24 20 07
	70 00 00	 mov	 DWORD PTR $T1[rsp], 28679 ; 00007007H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00e5e	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00e61	41 b8 04 00 00
	00		 mov	 r8d, 4
  00e67	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  00e6e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T312[rsp]
  00e73	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00e78	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  00e7b	f3 0f 7f 44 24
	78		 movdqu	 XMMWORD PTR $T341[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00e81	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00e84	0f 11 44 24 68	 movups	 XMMWORD PTR $T341[rsp], xmm0
  00e89	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00e8d	0f 11 4c 24 78	 movups	 XMMWORD PTR $T341[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00e92	4c 89 70 10	 mov	 QWORD PTR [rax+16], r14

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00e96	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00e9e	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00ea1	48 8d 4c 24 68	 lea	 rcx, QWORD PTR $T341[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ea6	48 83 7d 80 10	 cmp	 QWORD PTR $T341[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  00eab	48 0f 43 4c 24
	68		 cmovae	 rcx, QWORD PTR $T341[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 456  : 			PlaySound((G³os + "w" + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiego wiersza jest wylosowana liczba

  00eb1	45 33 c0	 xor	 r8d, r8d
  00eb4	33 d2		 xor	 edx, edx
  00eb6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  00ebc	48 8d 4c 24 68	 lea	 rcx, QWORD PTR $T341[rsp]
  00ec1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ec6	90		 npad	 1
  00ec7	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T312[rsp]
  00ecc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ed1	90		 npad	 1
  00ed2	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T277[rsp]
  00ed7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00edc	90		 npad	 1
  00edd	48 8d 4d 98	 lea	 rcx, QWORD PTR $T275[rbp-256]
  00ee1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ee6	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 634  : 		{	// destroy the object

  00ee7	48 8b 45 c0	 mov	 rax, QWORD PTR numers$354[rbp-256]
  00eeb	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00eef	4c 89 7c 0d c0	 mov	 QWORD PTR numers$354[rbp+rcx-256], r15
  00ef4	48 8b 45 c0	 mov	 rax, QWORD PTR numers$354[rbp-256]
  00ef8	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00efc	8d 91 68 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-152]
  00f02	89 54 0d bc	 mov	 DWORD PTR numers$354[rbp+rcx-260], edx

; 635  : 		}

  00f06	48 8d 4d d8	 lea	 rcx, QWORD PTR numers$354[rbp-232]
  00f0a	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00f0f	48 8d 4d e0	 lea	 rcx, QWORD PTR numers$354[rbp-224]
  00f13	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00f19	48 8d 4d 58	 lea	 rcx, QWORD PTR numers$354[rbp-104]
  00f1d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3694 : 		if (_My_data._Large_string_engaged())

  00f23	e9 46 f5 ff ff	 jmp	 $LN802@Odczytaj_l
  00f28	cc		 int	 3
$LN2532@Odczytaj_l:
?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Odczytaj_liczbê
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$19
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 18		 je	 SHORT $LN49@dtor$19
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 8d c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rbp]
  0001e	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN49@dtor$19:
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5d		 pop	 rbp
  00030	c3		 ret	 0
?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$19
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$20@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$20
  00031	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rdx]
  00038	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0003c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$20@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$20
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$22@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$22
  00043	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  0004a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$22@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$22
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$0@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$0
  00051	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rdx]
  00058	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$0@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$0
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$1@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$1
  0005d	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR $T7[rdx]
  00064	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$1
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$2@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$2
  00069	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR $T14[rdx]
  00070	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$2
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$119@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$119
  00075	40 55		 push	 rbp
  00077	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0007b	48 8b ea	 mov	 rbp, rdx
  0007e	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00081	83 e0 08	 and	 eax, 8
  00084	85 c0		 test	 eax, eax
  00086	74 0d		 je	 SHORT $LN530@dtor$119
  00088	83 65 20 f7	 and	 DWORD PTR $T1[rbp], -9
  0008c	48 8d 4d 28	 lea	 rcx, QWORD PTR $T70[rbp]
  00090	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN530@dtor$119:
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5d		 pop	 rbp
  0009a	c3		 ret	 0
?dtor$119@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$119
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$149@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$149
  0009b	40 55		 push	 rbp
  0009d	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000a1	48 8b ea	 mov	 rbp, rdx
  000a4	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000a7	83 e0 10	 and	 eax, 16
  000aa	85 c0		 test	 eax, eax
  000ac	74 0d		 je	 SHORT $LN684@dtor$149
  000ae	83 65 20 ef	 and	 DWORD PTR $T1[rbp], -17
  000b2	48 8d 4d 28	 lea	 rcx, QWORD PTR $T89[rbp]
  000b6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN684@dtor$149:
  000bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?dtor$149@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$149
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$191@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$191
  000c1	40 55		 push	 rbp
  000c3	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000c7	48 8b ea	 mov	 rbp, rdx
  000ca	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000cd	83 e0 20	 and	 eax, 32			; 00000020H
  000d0	85 c0		 test	 eax, eax
  000d2	74 0d		 je	 SHORT $LN896@dtor$191
  000d4	83 65 20 df	 and	 DWORD PTR $T1[rbp], -33	; ffffffffffffffdfH
  000d8	48 8d 4d 28	 lea	 rcx, QWORD PTR $T118[rbp]
  000dc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN896@dtor$191:
  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	5d		 pop	 rbp
  000e6	c3		 ret	 0
?dtor$191@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$191
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$221@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$221
  000e7	40 55		 push	 rbp
  000e9	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000ed	48 8b ea	 mov	 rbp, rdx
  000f0	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000f3	83 e0 40	 and	 eax, 64			; 00000040H
  000f6	85 c0		 test	 eax, eax
  000f8	74 0d		 je	 SHORT $LN1050@dtor$221
  000fa	83 65 20 bf	 and	 DWORD PTR $T1[rbp], -65	; ffffffffffffffbfH
  000fe	48 8d 4d 28	 lea	 rcx, QWORD PTR $T137[rbp]
  00102	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1050@dtor$221:
  00107	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010b	5d		 pop	 rbp
  0010c	c3		 ret	 0
?dtor$221@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$221
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$263@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$263
  0010d	40 55		 push	 rbp
  0010f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00113	48 8b ea	 mov	 rbp, rdx
  00116	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00119	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0011e	85 c0		 test	 eax, eax
  00120	74 10		 je	 SHORT $LN1262@dtor$263
  00122	81 65 20 7f ff
	ff ff		 and	 DWORD PTR $T1[rbp], -129 ; ffffffffffffff7fH
  00129	48 8d 4d 28	 lea	 rcx, QWORD PTR $T166[rbp]
  0012d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1262@dtor$263:
  00132	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00136	5d		 pop	 rbp
  00137	c3		 ret	 0
?dtor$263@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$263
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$293@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$293
  00138	40 55		 push	 rbp
  0013a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0013e	48 8b ea	 mov	 rbp, rdx
  00141	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00144	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00149	85 c0		 test	 eax, eax
  0014b	74 10		 je	 SHORT $LN1416@dtor$293
  0014d	81 65 20 ff fe
	ff ff		 and	 DWORD PTR $T1[rbp], -257 ; fffffffffffffeffH
  00154	48 8d 4d 28	 lea	 rcx, QWORD PTR $T185[rbp]
  00158	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1416@dtor$293:
  0015d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00161	5d		 pop	 rbp
  00162	c3		 ret	 0
?dtor$293@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$293
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$325@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$325
  00163	40 55		 push	 rbp
  00165	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00169	48 8b ea	 mov	 rbp, rdx
  0016c	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0016f	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00174	85 c0		 test	 eax, eax
  00176	74 10		 je	 SHORT $LN1585@dtor$325
  00178	81 65 20 ff fd
	ff ff		 and	 DWORD PTR $T1[rbp], -513 ; fffffffffffffdffH
  0017f	48 8d 4d 28	 lea	 rcx, QWORD PTR $T205[rbp]
  00183	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1585@dtor$325:
  00188	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0018c	5d		 pop	 rbp
  0018d	c3		 ret	 0
?dtor$325@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$325
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$11@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$11
  0018e	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR $T223[rdx]
  00195	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$11
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$427@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$427
  0019a	40 55		 push	 rbp
  0019c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  001a0	48 8b ea	 mov	 rbp, rdx
  001a3	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  001a6	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  001ab	85 c0		 test	 eax, eax
  001ad	74 1b		 je	 SHORT $LN2059@dtor$427
  001af	81 65 20 ff ef
	ff ff		 and	 DWORD PTR $T1[rbp], -4097 ; ffffffffffffefffH
  001b6	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$354[rbp]
  001bd	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN2059@dtor$427:
  001ca	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ce	5d		 pop	 rbp
  001cf	c3		 ret	 0
?dtor$427@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$427
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$428@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$428
  001d0	48 8d 8a c0 00
	00 00		 lea	 rcx, QWORD PTR numers$354[rdx]
  001d7	48 83 c1 20	 add	 rcx, 32			; 00000020H
  001db	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$428@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$428
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$430@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$430
  001e2	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  001e9	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$430@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$430
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$13@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$13
  001f0	48 8d 8a c0 00
	00 00		 lea	 rcx, QWORD PTR numers$354[rdx]
  001f7	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$13@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$13
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$14@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$14
  001fc	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T275[rdx]
  00203	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$14@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$14
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$433@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$433
  00208	40 55		 push	 rbp
  0020a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0020e	48 8b ea	 mov	 rbp, rdx
  00211	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00214	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00219	85 c0		 test	 eax, eax
  0021b	74 10		 je	 SHORT $LN2115@dtor$433
  0021d	81 65 20 ff df
	ff ff		 and	 DWORD PTR $T1[rbp], -8193 ; ffffffffffffdfffH
  00224	48 8d 4d 48	 lea	 rcx, QWORD PTR $T277[rbp]
  00228	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2115@dtor$433:
  0022d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00231	5d		 pop	 rbp
  00232	c3		 ret	 0
?dtor$433@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$433
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$16@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$16
  00233	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T312[rdx]
  0023a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$19
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 18		 je	 SHORT $LN49@dtor$19
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 8d c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rbp]
  0001e	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN49@dtor$19:
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5d		 pop	 rbp
  00030	c3		 ret	 0
?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$20@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$20
  00031	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rdx]
  00038	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0003c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$20@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$22@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$22
  00043	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  0004a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$22@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$0@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$0
  00051	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rdx]
  00058	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$0@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$1@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$1
  0005d	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR $T7[rdx]
  00064	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$2@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$2
  00069	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR $T14[rdx]
  00070	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$119@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$119
  00075	40 55		 push	 rbp
  00077	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0007b	48 8b ea	 mov	 rbp, rdx
  0007e	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00081	83 e0 08	 and	 eax, 8
  00084	85 c0		 test	 eax, eax
  00086	74 0d		 je	 SHORT $LN530@dtor$119
  00088	83 65 20 f7	 and	 DWORD PTR $T1[rbp], -9
  0008c	48 8d 4d 28	 lea	 rcx, QWORD PTR $T70[rbp]
  00090	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN530@dtor$119:
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5d		 pop	 rbp
  0009a	c3		 ret	 0
?dtor$119@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$119
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$149@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$149
  0009b	40 55		 push	 rbp
  0009d	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000a1	48 8b ea	 mov	 rbp, rdx
  000a4	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000a7	83 e0 10	 and	 eax, 16
  000aa	85 c0		 test	 eax, eax
  000ac	74 0d		 je	 SHORT $LN684@dtor$149
  000ae	83 65 20 ef	 and	 DWORD PTR $T1[rbp], -17
  000b2	48 8d 4d 28	 lea	 rcx, QWORD PTR $T89[rbp]
  000b6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN684@dtor$149:
  000bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?dtor$149@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$149
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$191@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$191
  000c1	40 55		 push	 rbp
  000c3	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000c7	48 8b ea	 mov	 rbp, rdx
  000ca	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000cd	83 e0 20	 and	 eax, 32			; 00000020H
  000d0	85 c0		 test	 eax, eax
  000d2	74 0d		 je	 SHORT $LN896@dtor$191
  000d4	83 65 20 df	 and	 DWORD PTR $T1[rbp], -33	; ffffffffffffffdfH
  000d8	48 8d 4d 28	 lea	 rcx, QWORD PTR $T118[rbp]
  000dc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN896@dtor$191:
  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	5d		 pop	 rbp
  000e6	c3		 ret	 0
?dtor$191@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$191
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$221@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$221
  000e7	40 55		 push	 rbp
  000e9	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000ed	48 8b ea	 mov	 rbp, rdx
  000f0	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000f3	83 e0 40	 and	 eax, 64			; 00000040H
  000f6	85 c0		 test	 eax, eax
  000f8	74 0d		 je	 SHORT $LN1050@dtor$221
  000fa	83 65 20 bf	 and	 DWORD PTR $T1[rbp], -65	; ffffffffffffffbfH
  000fe	48 8d 4d 28	 lea	 rcx, QWORD PTR $T137[rbp]
  00102	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1050@dtor$221:
  00107	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010b	5d		 pop	 rbp
  0010c	c3		 ret	 0
?dtor$221@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$221
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$263@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$263
  0010d	40 55		 push	 rbp
  0010f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00113	48 8b ea	 mov	 rbp, rdx
  00116	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00119	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0011e	85 c0		 test	 eax, eax
  00120	74 10		 je	 SHORT $LN1262@dtor$263
  00122	81 65 20 7f ff
	ff ff		 and	 DWORD PTR $T1[rbp], -129 ; ffffffffffffff7fH
  00129	48 8d 4d 28	 lea	 rcx, QWORD PTR $T166[rbp]
  0012d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1262@dtor$263:
  00132	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00136	5d		 pop	 rbp
  00137	c3		 ret	 0
?dtor$263@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$263
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$293@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$293
  00138	40 55		 push	 rbp
  0013a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0013e	48 8b ea	 mov	 rbp, rdx
  00141	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00144	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00149	85 c0		 test	 eax, eax
  0014b	74 10		 je	 SHORT $LN1416@dtor$293
  0014d	81 65 20 ff fe
	ff ff		 and	 DWORD PTR $T1[rbp], -257 ; fffffffffffffeffH
  00154	48 8d 4d 28	 lea	 rcx, QWORD PTR $T185[rbp]
  00158	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1416@dtor$293:
  0015d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00161	5d		 pop	 rbp
  00162	c3		 ret	 0
?dtor$293@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$293
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$325@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$325
  00163	40 55		 push	 rbp
  00165	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00169	48 8b ea	 mov	 rbp, rdx
  0016c	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0016f	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00174	85 c0		 test	 eax, eax
  00176	74 10		 je	 SHORT $LN1585@dtor$325
  00178	81 65 20 ff fd
	ff ff		 and	 DWORD PTR $T1[rbp], -513 ; fffffffffffffdffH
  0017f	48 8d 4d 28	 lea	 rcx, QWORD PTR $T205[rbp]
  00183	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1585@dtor$325:
  00188	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0018c	5d		 pop	 rbp
  0018d	c3		 ret	 0
?dtor$325@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$325
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$11@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$11
  0018e	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR $T223[rdx]
  00195	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$427@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$427
  0019a	40 55		 push	 rbp
  0019c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  001a0	48 8b ea	 mov	 rbp, rdx
  001a3	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  001a6	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  001ab	85 c0		 test	 eax, eax
  001ad	74 1b		 je	 SHORT $LN2059@dtor$427
  001af	81 65 20 ff ef
	ff ff		 and	 DWORD PTR $T1[rbp], -4097 ; ffffffffffffefffH
  001b6	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$354[rbp]
  001bd	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN2059@dtor$427:
  001ca	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ce	5d		 pop	 rbp
  001cf	c3		 ret	 0
?dtor$427@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$427
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$428@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$428
  001d0	48 8d 8a c0 00
	00 00		 lea	 rcx, QWORD PTR numers$354[rdx]
  001d7	48 83 c1 20	 add	 rcx, 32			; 00000020H
  001db	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$428@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$428
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$430@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$430
  001e2	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  001e9	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$430@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$430
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$13@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$13
  001f0	48 8d 8a c0 00
	00 00		 lea	 rcx, QWORD PTR numers$354[rdx]
  001f7	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$13@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$14@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$14
  001fc	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T275[rdx]
  00203	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$14@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$433@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$433
  00208	40 55		 push	 rbp
  0020a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0020e	48 8b ea	 mov	 rbp, rdx
  00211	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00214	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00219	85 c0		 test	 eax, eax
  0021b	74 10		 je	 SHORT $LN2115@dtor$433
  0021d	81 65 20 ff df
	ff ff		 and	 DWORD PTR $T1[rbp], -8193 ; ffffffffffffdfffH
  00224	48 8d 4d 48	 lea	 rcx, QWORD PTR $T277[rbp]
  00228	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2115@dtor$433:
  0022d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00231	5d		 pop	 rbp
  00232	c3		 ret	 0
?dtor$433@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$433
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T312 = 40
$T205 = 40
$T185 = 40
$T166 = 40
$T137 = 40
$T118 = 40
$T89 = 40
$T70 = 40
$T30 = 40
$T277 = 72
$T239 = 72
$T14 = 72
$T341 = 104
$T223 = 104
$T7 = 104
this$ = 136
this$ = 136
$T353 = 144
$T275 = 152
numers$354 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$16@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$16
  00233	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T312[rdx]
  0023a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 634  : 		{	// destroy the object

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8d 99 98 00
	00 00		 lea	 rbx, QWORD PTR [rcx+152]

; 635  : 		}

  00010	48 8d 4b 80	 lea	 rcx, QWORD PTR [rbx-128]
  00014	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0001f	48 89 84 1a 68
	ff ff ff	 mov	 QWORD PTR [rdx+rbx-152], rax
  00027	48 8b 83 68 ff
	ff ff		 mov	 rax, QWORD PTR [rbx-152]
  0002e	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00032	44 8d 82 68 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-152]
  00039	44 89 84 1a 64
	ff ff ff	 mov	 DWORD PTR [rdx+rbx-156], r8d
  00041	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00046	48 8d 4b 88	 lea	 rcx, QWORD PTR [rbx-120]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00050	48 8b cb	 mov	 rcx, rbx
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5b		 pop	 rbx
  00058	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
classSize$dead$ = 56
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2, COMDAT
$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	33 d2		 xor	 edx, edx
  00006	41 b8 f8 00 00
	00		 mov	 r8d, 248		; 000000f8H
  0000c	e8 00 00 00 00	 call	 memset
  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; Wczytaj_z_pliku, COMDAT

; 461  : {

$LN3061:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 8d 6c 24 f9	 lea	 rbp, QWORD PTR [rsp-7]
  00012	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00019	48 c7 45 87 fe
	ff ff ff	 mov	 QWORD PTR $T411[rbp-177], -2
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c4	 xor	 rax, rsp
  0002b	48 89 45 ef	 mov	 QWORD PTR __$ArrayPad$[rbp-177], rax
  0002f	4c 89 4c 24 20	 mov	 QWORD PTR iloæ_pieniêdzy$GSCopy$1$[rsp], r9
  00034	4d 8b f8	 mov	 r15, r8
  00037	4c 8b f2	 mov	 r14, rdx
  0003a	48 8b d9	 mov	 rbx, rcx
  0003d	48 8b 45 6f	 mov	 rax, QWORD PTR kwota_zak³adu$[rbp-177]
  00041	48 89 44 24 30	 mov	 QWORD PTR kwota_zak³adu$GSCopy$1$[rsp], rax
  00046	4c 8b 65 77	 mov	 r12, QWORD PTR wylosowana_liczba$[rbp-177]
  0004a	4c 8b 6d 7f	 mov	 r13, QWORD PTR typ_zak³adu$[rbp-177]

; 462  : 	if (!Ustawienia.czy_kontynuowaæ_grê) //Je¿eli czy_kontynuowaæ_grê == 0

  0004e	66 83 3d 12 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, 0
  00056	75 50		 jne	 SHORT $LN31@Wczytaj_z_

; 463  : 		if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  00058	33 d2		 xor	 edx, edx
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00067	85 c0		 test	 eax, eax
  00069	75 3d		 jne	 SHORT $LN31@Wczytaj_z_

; 464  : 		{
; 465  : 			co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  0006b	41 c6 07 6e	 mov	 BYTE PTR [r15], 110	; 0000006eH

; 466  : 			remove("log_aktualny.txt"); //Usuniêcie pliku log aktualny poniewa¿ rozpoczyna siê now¹ grê

  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_remove

; 467  : 			log_ogólny << '\n' << "Uruchomiono ponownie grê z wy³¹czon¹ opcj¹ kontynuowania" << '\n'; //Wpisanie do buforu logu ogólnego informacje o rozpoczêciu nowej gry spowodowane ustawieniem gry

  0007c	b2 0a		 mov	 dl, 10
  0007e	48 8b cb	 mov	 rcx, rbx
  00081	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
  00086	48 8b c8	 mov	 rcx, rax
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@
  00090	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00095	48 8b c8	 mov	 rcx, rax
  00098	b2 0a		 mov	 dl, 10
  0009a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 468  : 			log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN31@Wczytaj_z_:

; 471  : 	if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000a8	33 d2		 xor	 edx, edx
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000be	49 8d 4e 18	 lea	 rcx, QWORD PTR [r14+24]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 471  : 	if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000c2	85 c0		 test	 eax, eax
  000c4	0f 85 d5 14 00
	00		 jne	 $LN32@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000ca	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  000ce	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  000d3	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  000d6	48 63 51 04	 movsxd	 rdx, DWORD PTR [rcx+4]

; 1370 : 			_Myios::setstate(ios_base::failbit);

  000da	49 8d 0c 16	 lea	 rcx, QWORD PTR [r14+rdx]
  000de	45 33 c0	 xor	 r8d, r8d

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000e1	48 85 c0	 test	 rax, rax
  000e4	75 0b		 jne	 SHORT $LN74@Wczytaj_z_

; 1370 : 			_Myios::setstate(ios_base::failbit);

  000e6	8d 50 02	 lea	 edx, QWORD PTR [rax+2]
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1371 : 		else

  000ef	eb 08		 jmp	 SHORT $LN75@Wczytaj_z_
$LN74@Wczytaj_z_:

; 1372 : 			_Myios::clear();	// added with C++11

  000f1	33 d2		 xor	 edx, edx
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN75@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  000f9	33 c0		 xor	 eax, eax
  000fb	48 89 45 bf	 mov	 QWORD PTR buf$416[rbp-161], rax

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000ff	48 c7 45 c7 0f
	00 00 00	 mov	 QWORD PTR buf$416[rbp-153], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00107	88 45 af	 mov	 BYTE PTR buf$416[rbp-177], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0010a	48 89 45 df	 mov	 QWORD PTR bufor2$417[rbp-161], rax

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0010e	48 c7 45 e7 0f
	00 00 00	 mov	 QWORD PTR bufor2$417[rbp-153], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00116	88 45 cf	 mov	 BYTE PTR bufor2$417[rbp-177], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00119	49 8b 06	 mov	 rax, QWORD PTR [r14]
  0011c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00120	49 03 ce	 add	 rcx, r14
  00123	b2 0a		 mov	 dl, 10
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  0012b	44 0f b6 c0	 movzx	 r8d, al
  0012f	48 8d 55 af	 lea	 rdx, QWORD PTR buf$416[rbp-177]
  00133	49 8b ce	 mov	 rcx, r14
  00136	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 476  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  0013b	49 8b 06	 mov	 rax, QWORD PTR [r14]
  0013e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 343  : 		return ((int)rdstate() & (int)eofbit);

  00142	42 f6 44 31 10
	01		 test	 BYTE PTR [rcx+r14+16], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 476  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  00148	0f 85 8f 00 00
	00		 jne	 $LN3@Wczytaj_z_
  0014e	66 90		 npad	 2
$LL2@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1594 : 		if (_Large_string_engaged())

  00150	48 8b 4d af	 mov	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00154	48 8b 55 c7	 mov	 rdx, QWORD PTR buf$416[rbp-153]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00158	48 8b 7d bf	 mov	 rdi, QWORD PTR buf$416[rbp-161]
  0015c	48 85 ff	 test	 rdi, rdi
  0015f	74 47		 je	 SHORT $LN203@Wczytaj_z_

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00161	4c 8d 4d af	 lea	 r9, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00165	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00169	4c 0f 43 c9	 cmovae	 r9, rcx

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0016d	48 8b 45 e7	 mov	 rax, QWORD PTR bufor2$417[rbp-153]
  00171	48 3b f8	 cmp	 rdi, rax

; 2420 : 		if (_Count <= _My_data._Myres)

  00174	77 26		 ja	 SHORT $LN204@Wczytaj_z_

; 1582 : 		value_type * _Result = _Bx._Buf;

  00176	48 8d 5d cf	 lea	 rbx, QWORD PTR bufor2$417[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0017a	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  0017e	48 0f 43 5d cf	 cmovae	 rbx, QWORD PTR bufor2$417[rbp-177]

; 2423 : 			_My_data._Mysize = _Count;

  00183	48 89 7d df	 mov	 QWORD PTR bufor2$417[rbp-161], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00187	4c 8b c7	 mov	 r8, rdi
  0018a	49 8b d1	 mov	 rdx, r9
  0018d	48 8b cb	 mov	 rcx, rbx
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00196	c6 04 3b 00	 mov	 BYTE PTR [rbx+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  0019a	eb 0c		 jmp	 SHORT $LN203@Wczytaj_z_
$LN204@Wczytaj_z_:

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0019c	48 8b d7	 mov	 rdx, rdi
  0019f	48 8d 4d cf	 lea	 rcx, QWORD PTR bufor2$417[rbp-177]
  001a3	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN203@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  001a8	49 8b 06	 mov	 rax, QWORD PTR [r14]
  001ab	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  001af	49 03 ce	 add	 rcx, r14
  001b2	b2 0a		 mov	 dl, 10
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  001ba	44 0f b6 c0	 movzx	 r8d, al
  001be	48 8d 55 af	 lea	 rdx, QWORD PTR buf$416[rbp-177]
  001c2	49 8b ce	 mov	 rcx, r14
  001c5	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 476  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  001ca	49 8b 06	 mov	 rax, QWORD PTR [r14]
  001cd	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 343  : 		return ((int)rdstate() & (int)eofbit);

  001d1	42 f6 44 31 10
	01		 test	 BYTE PTR [rcx+r14+16], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 476  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  001d7	0f 84 73 ff ff
	ff		 je	 $LL2@Wczytaj_z_
$LN3@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1594 : 		if (_Large_string_engaged())

  001dd	48 8b 55 af	 mov	 rdx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001e1	48 8b 4d c7	 mov	 rcx, QWORD PTR buf$416[rbp-153]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001e5	48 8b 45 bf	 mov	 rax, QWORD PTR buf$416[rbp-161]
  001e9	48 85 c0	 test	 rax, rax
  001ec	75 4c		 jne	 SHORT $LN299@Wczytaj_z_

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001ee	4c 8d 4d cf	 lea	 r9, QWORD PTR bufor2$417[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001f2	48 83 7d e7 10	 cmp	 QWORD PTR bufor2$417[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  001f7	4c 0f 43 4d cf	 cmovae	 r9, QWORD PTR bufor2$417[rbp-177]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  001fc	48 8b 7d df	 mov	 rdi, QWORD PTR bufor2$417[rbp-161]
  00200	48 3b f9	 cmp	 rdi, rcx

; 2420 : 		if (_Count <= _My_data._Myres)

  00203	77 25		 ja	 SHORT $LN300@Wczytaj_z_

; 1582 : 		value_type * _Result = _Bx._Buf;

  00205	48 8d 5d af	 lea	 rbx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00209	48 83 f9 10	 cmp	 rcx, 16

; 1583 : 		if (_Large_string_engaged())

  0020d	48 0f 43 da	 cmovae	 rbx, rdx

; 2423 : 			_My_data._Mysize = _Count;

  00211	48 89 7d bf	 mov	 QWORD PTR buf$416[rbp-161], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00215	4c 8b c7	 mov	 r8, rdi
  00218	49 8b d1	 mov	 rdx, r9
  0021b	48 8b cb	 mov	 rcx, rbx
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00224	c6 04 3b 00	 mov	 BYTE PTR [rbx+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  00228	eb 0c		 jmp	 SHORT $LN3045@Wczytaj_z_
$LN300@Wczytaj_z_:

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0022a	48 8b d7	 mov	 rdx, rdi
  0022d	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]
  00231	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN3045@Wczytaj_z_:
  00236	48 8b 45 bf	 mov	 rax, QWORD PTR buf$416[rbp-161]
$LN299@Wczytaj_z_:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0023a	48 8d 7d af	 lea	 rdi, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0023e	48 83 7d c7 10	 cmp	 QWORD PTR buf$416[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  00243	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$416[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00248	48 83 f8 09	 cmp	 rax, 9
  0024c	72 63		 jb	 SHORT $LN36@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0024e	48 8d 34 07	 lea	 rsi, QWORD PTR [rdi+rax]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00252	4c 8d 46 f8	 lea	 r8, QWORD PTR [rsi-8]
  00256	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00259	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0025e	48 8b cf	 mov	 rcx, rdi
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00267	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  0026a	48 85 c0	 test	 rax, rax
  0026d	74 3e		 je	 SHORT $LN3023@Wczytaj_z_
  0026f	90		 npad	 1
$LL343@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00270	41 b8 09 00 00
	00		 mov	 r8d, 9
  00276	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LFKNBKJA@Posiadasz?$AA@
  0027d	48 8b cb	 mov	 rcx, rbx
  00280	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00285	85 c0		 test	 eax, eax
  00287	0f 84 25 02 00
	00		 je	 $LN2863@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  0028d	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00290	4c 8d 46 f8	 lea	 r8, QWORD PTR [rsi-8]
  00294	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00297	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0029c	48 8b cb	 mov	 rcx, rbx
  0029f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  002a5	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  002a8	48 85 c0	 test	 rax, rax
  002ab	75 c3		 jne	 SHORT $LL343@Wczytaj_z_
$LN3023@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 482  : 		if (buf.find("Posiadasz") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o skoñczeniu rundy

  002ad	48 8b 45 bf	 mov	 rax, QWORD PTR buf$416[rbp-161]
$LN36@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  002b1	48 8d 7d af	 lea	 rdi, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002b5	48 83 7d c7 10	 cmp	 QWORD PTR buf$416[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  002ba	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$416[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  002bf	48 83 f8 0a	 cmp	 rax, 10
  002c3	72 6c		 jb	 SHORT $LN38@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  002c5	48 8d 34 07	 lea	 rsi, QWORD PTR [rdi+rax]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  002c9	4c 8d 46 f7	 lea	 r8, QWORD PTR [rsi-9]
  002cd	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  002d0	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  002d5	48 8b cf	 mov	 rcx, rdi
  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  002de	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  002e1	48 85 c0	 test	 rax, rax
  002e4	74 47		 je	 SHORT $LN3024@Wczytaj_z_
  002e6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL664@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002f0	41 b8 0a 00 00
	00		 mov	 r8d, 10
  002f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@DAFLKCID@Wylosowano?$AA@
  002fd	48 8b cb	 mov	 rcx, rbx
  00300	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00305	85 c0		 test	 eax, eax
  00307	0f 84 83 03 00
	00		 je	 $LN2865@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  0030d	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00310	4c 8d 46 f7	 lea	 r8, QWORD PTR [rsi-9]
  00314	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00317	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  0031c	48 8b cb	 mov	 rcx, rbx
  0031f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00325	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00328	48 85 c0	 test	 rax, rax
  0032b	75 c3		 jne	 SHORT $LL664@Wczytaj_z_
$LN3024@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 493  : 		else if (buf.find("Wylosowano") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o wylosowaniu liczby

  0032d	48 8b 45 bf	 mov	 rax, QWORD PTR buf$416[rbp-161]
$LN38@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00331	48 8d 7d af	 lea	 rdi, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00335	48 83 7d c7 10	 cmp	 QWORD PTR buf$416[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  0033a	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$416[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0033f	48 83 f8 11	 cmp	 rax, 17
  00343	72 6b		 jb	 SHORT $LN42@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00345	48 8d 77 f0	 lea	 rsi, QWORD PTR [rdi-16]
  00349	48 03 f0	 add	 rsi, rax

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0034c	4c 8b c6	 mov	 r8, rsi
  0034f	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00352	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00357	48 8b cf	 mov	 rcx, rdi
  0035a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00360	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00363	48 85 c0	 test	 rax, rax
  00366	74 44		 je	 SHORT $LN3025@Wczytaj_z_
  00368	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL1615@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00370	41 b8 11 00 00
	00		 mov	 r8d, 17
  00376	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  0037d	48 8b cb	 mov	 rcx, rbx
  00380	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00385	85 c0		 test	 eax, eax
  00387	0f 84 b4 09 00
	00		 je	 $LN2871@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  0038d	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00390	4c 8b c6	 mov	 r8, rsi
  00393	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00396	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  0039b	48 8b cb	 mov	 rcx, rbx
  0039e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  003a4	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  003a7	48 85 c0	 test	 rax, rax
  003aa	75 c4		 jne	 SHORT $LL1615@Wczytaj_z_
$LN3025@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 531  : 		else if (buf.find("Obstawiono zaklad") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o typie obstawionego zak³adu

  003ac	48 8b 45 bf	 mov	 rax, QWORD PTR buf$416[rbp-161]
$LN42@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  003b0	48 8d 7d af	 lea	 rdi, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003b4	48 83 7d c7 10	 cmp	 QWORD PTR buf$416[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  003b9	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$416[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  003be	48 83 f8 0d	 cmp	 rax, 13
  003c2	72 6d		 jb	 SHORT $LN46@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  003c4	48 8d 34 38	 lea	 rsi, QWORD PTR [rax+rdi]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  003c8	4c 8d 46 f4	 lea	 r8, QWORD PTR [rsi-12]
  003cc	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  003cf	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  003d4	48 8b cf	 mov	 rcx, rdi
  003d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  003dd	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  003e0	48 85 c0	 test	 rax, rax
  003e3	74 48		 je	 SHORT $LN3026@Wczytaj_z_
  003e5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL2264@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  003f0	41 b8 0d 00 00
	00		 mov	 r8d, 13
  003f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@
  003fd	48 8b cb	 mov	 rcx, rbx
  00400	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00405	85 c0		 test	 eax, eax
  00407	0f 84 bf 0d 00
	00		 je	 $LN2875@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  0040d	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00410	4c 8d 46 f4	 lea	 r8, QWORD PTR [rsi-12]
  00414	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00417	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  0041c	48 8b cb	 mov	 rcx, rbx
  0041f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00425	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00428	48 85 c0	 test	 rax, rax
  0042b	75 c3		 jne	 SHORT $LL2264@Wczytaj_z_
$LN3026@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 562  : 		else if (buf.find("Obstawiono za") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o kwocie obstawionego zak³adu

  0042d	48 8b 45 bf	 mov	 rax, QWORD PTR buf$416[rbp-161]
$LN46@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00431	48 8d 7d af	 lea	 rdi, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00435	48 83 7d c7 10	 cmp	 QWORD PTR buf$416[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  0043a	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$416[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0043f	48 83 f8 13	 cmp	 rax, 19
  00443	0f 82 32 10 00
	00		 jb	 $LN50@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00449	48 8d 34 38	 lea	 rsi, QWORD PTR [rax+rdi]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0044d	4c 8d 46 ee	 lea	 r8, QWORD PTR [rsi-18]
  00451	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00454	ba 47 00 00 00	 mov	 edx, 71			; 00000047H
  00459	48 8b cf	 mov	 rcx, rdi
  0045c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00462	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00465	48 85 c0	 test	 rax, rax
  00468	0f 84 0d 10 00
	00		 je	 $LN50@Wczytaj_z_
  0046e	66 90		 npad	 2
$LL2673@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00470	41 b8 13 00 00
	00		 mov	 r8d, 19
  00476	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@
  0047d	48 8b cb	 mov	 rcx, rbx
  00480	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00485	85 c0		 test	 eax, eax
  00487	0f 84 eb 0f 00
	00		 je	 $LN2877@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  0048d	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00490	4c 8d 46 ee	 lea	 r8, QWORD PTR [rsi-18]
  00494	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00497	ba 47 00 00 00	 mov	 edx, 71			; 00000047H
  0049c	48 8b cb	 mov	 rcx, rbx
  0049f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  004a5	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  004a8	48 85 c0	 test	 rax, rax
  004ab	75 c3		 jne	 SHORT $LL2673@Wczytaj_z_

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  004ad	e9 c9 0f 00 00	 jmp	 $LN50@Wczytaj_z_
$LN2863@Wczytaj_z_:

; 85   : 			return (_Match_try - _Haystack);

  004b2	48 2b df	 sub	 rbx, rdi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 482  : 		if (buf.find("Posiadasz") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o skoñczeniu rundy

  004b5	48 83 fb ff	 cmp	 rbx, -1
  004b9	0f 84 ee fd ff
	ff		 je	 $LN3023@Wczytaj_z_

; 483  : 		{
; 484  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku

  004bf	41 c6 07 6e	 mov	 BYTE PTR [r15], 110	; 0000006eH

; 485  : 			auto pocz¹tek = (unsigned short)buf.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst pozycji ostatniego znaku tekstu o kwocie pieniêdzy któr¹ posiada jeszcze gracz, typ zmiennej auto wsazuje, ¿e kompilator sam wybierze typ zmiennej

  004c3	0f b7 5d bf	 movzx	 ebx, WORD PTR buf$416[rbp-161]
  004c7	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  004cc	4c 8b 45 c7	 mov	 r8, QWORD PTR buf$416[rbp-153]
  004d0	4c 8b 4d af	 mov	 r9, QWORD PTR buf$416[rbp-177]
  004d4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  004e0	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  004e4	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  004e8	49 0f 43 c9	 cmovae	 rcx, r9
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 486  : 			while (buf[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  004ec	0f b7 c3	 movzx	 eax, bx
  004ef	80 3c 08 20	 cmp	 BYTE PTR [rax+rcx], 32	; 00000020H
  004f3	74 0a		 je	 SHORT $LN5@Wczytaj_z_
  004f5	66 85 db	 test	 bx, bx
  004f8	74 05		 je	 SHORT $LN5@Wczytaj_z_
  004fa	66 03 da	 add	 bx, dx
  004fd	eb e1		 jmp	 SHORT $LL4@Wczytaj_z_
$LN5@Wczytaj_z_:

; 487  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  004ff	66 ff c3	 inc	 bx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1563 : 		_Mysize(0),

  00502	45 33 e4	 xor	 r12d, r12d
  00505	4c 89 65 9f	 mov	 QWORD PTR buf2$415[rbp-161], r12

; 1564 : 		_Myres(0)

  00509	4c 89 65 a7	 mov	 QWORD PTR buf2$415[rbp-153], r12

; 2171 : 		const size_type _Right_size = _Right_data._Mysize;

  0050d	48 8b 75 bf	 mov	 rsi, QWORD PTR buf$416[rbp-161]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00511	4c 8d 7d af	 lea	 r15, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00515	49 83 f8 10	 cmp	 r8, 16

; 1594 : 		if (_Large_string_engaged())

  00519	4d 0f 43 f9	 cmovae	 r15, r9

; 2173 : 		if (_Right_size < this->_BUF_SIZE)

  0051d	48 83 fe 10	 cmp	 rsi, 16
  00521	73 0f		 jae	 SHORT $LN404@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00523	41 0f 10 07	 movups	 xmm0, XMMWORD PTR [r15]
  00527	0f 11 45 8f	 movups	 XMMWORD PTR buf2$415[rbp-177], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2177 : 			_My_data._Myres = this->_BUF_SIZE - 1;

  0052b	41 8d 7c 24 0f	 lea	 edi, QWORD PTR [r12+15]

; 2178 : 			return;

  00530	eb 6a		 jmp	 SHORT $LN3046@Wczytaj_z_
$LN404@Wczytaj_z_:

; 2179 : 			}
; 2180 : 
; 2181 : 		auto& _Al = this->_Getal();
; 2182 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  00532	48 8b fe	 mov	 rdi, rsi
  00535	48 83 cf 0f	 or	 rdi, 15
  00539	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00543	48 3b f8	 cmp	 rdi, rax
  00546	48 0f 47 f8	 cmova	 rdi, rax

; 2183 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  0054a	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0054e	48 85 c9	 test	 rcx, rcx
  00551	75 05		 jne	 SHORT $LN462@Wczytaj_z_

; 79   : 		{
; 80   : 		return (nullptr);

  00553	49 8b cc	 mov	 rcx, r12
  00556	eb 34		 jmp	 SHORT $LN460@Wczytaj_z_
$LN462@Wczytaj_z_:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00558	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0055f	72 23		 jb	 SHORT $LN463@Wczytaj_z_

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00561	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  00565	48 3b c1	 cmp	 rax, rcx
  00568	0f 86 d9 12 00
	00		 jbe	 $LN3049@Wczytaj_z_

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0056e	48 8b c8	 mov	 rcx, rax
  00571	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00576	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  0057a	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0057e	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00582	eb 08		 jmp	 SHORT $LN460@Wczytaj_z_
$LN463@Wczytaj_z_:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00584	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00589	48 8b c8	 mov	 rcx, rax
$LN460@Wczytaj_z_:

; 944  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0058c	48 89 4d 8f	 mov	 QWORD PTR buf2$415[rbp-177], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2185 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  00590	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00594	49 8b d7	 mov	 rdx, r15
  00597	e8 00 00 00 00	 call	 memcpy
$LN3046@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2187 : 		_My_data._Myres = _New_capacity;

  0059c	48 89 7d a7	 mov	 QWORD PTR buf2$415[rbp-153], rdi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 489  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  005a0	0f b7 c3	 movzx	 eax, bx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  005a3	48 3b f0	 cmp	 rsi, rax
  005a6	48 0f 42 c6	 cmovb	 rax, rsi

; 1582 : 		value_type * _Result = _Bx._Buf;

  005aa	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$415[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005ae	48 83 ff 10	 cmp	 rdi, 16

; 1583 : 		if (_Large_string_engaged())

  005b2	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$415[rbp-177]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  005b7	48 2b f0	 sub	 rsi, rax

; 2607 : 		_My_data._Mysize = _New_size;

  005ba	48 89 75 9f	 mov	 QWORD PTR buf2$415[rbp-161], rsi

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  005be	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
  005c2	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  005c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 490  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  005cc	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$415[rbp-161]
  005d0	49 8d 50 ff	 lea	 rdx, QWORD PTR [r8-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  005d4	4c 3b c2	 cmp	 r8, rdx
  005d7	0f 82 70 12 00
	00		 jb	 $LN3050@Wczytaj_z_

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  005dd	49 8b c0	 mov	 rax, r8
  005e0	48 2b c2	 sub	 rax, rdx
  005e3	48 83 f8 01	 cmp	 rax, 1
  005e7	41 b9 01 00 00
	00		 mov	 r9d, 1
  005ed	4c 0f 42 c8	 cmovb	 r9, rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  005f1	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$415[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005f5	48 83 7d a7 10	 cmp	 QWORD PTR buf2$415[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  005fa	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$415[rbp-177]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  005ff	48 03 ca	 add	 rcx, rdx

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00602	4d 2b c1	 sub	 r8, r9

; 2607 : 		_My_data._Mysize = _New_size;

  00605	4c 89 45 9f	 mov	 QWORD PTR buf2$415[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00609	4c 2b c2	 sub	 r8, rdx
  0060c	49 ff c0	 inc	 r8
  0060f	4a 8d 14 09	 lea	 rdx, QWORD PTR [rcx+r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00613	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00619	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$415[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0061d	48 83 7d a7 10	 cmp	 QWORD PTR buf2$415[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  00622	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$415[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 491  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00627	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0062d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iloæ_pieniêdzy$GSCopy$1$[rsp]
  00632	89 01		 mov	 DWORD PTR [rcx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00634	48 8b 55 a7	 mov	 rdx, QWORD PTR buf2$415[rbp-153]
  00638	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  0063c	0f 82 40 0e 00
	00		 jb	 $LN51@Wczytaj_z_

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00642	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00645	48 8b 45 8f	 mov	 rax, QWORD PTR buf2$415[rbp-177]
  00649	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0064c	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00653	72 2e		 jb	 SHORT $LN612@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00655	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00659	4c 3b c2	 cmp	 r8, rdx
  0065c	76 1e		 jbe	 SHORT $_Invalid_parameter$3062

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0065e	49 8b d0	 mov	 rdx, r8
  00661	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00664	75 16		 jne	 SHORT $_Invalid_parameter$3062

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00666	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0066a	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0066d	73 0d		 jae	 SHORT $_Invalid_parameter$3062

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0066f	48 2b c8	 sub	 rcx, rax
  00672	48 83 e9 08	 sub	 rcx, 8
  00676	48 83 f9 1f	 cmp	 rcx, 31
  0067a	76 07		 jbe	 SHORT $LN612@Wczytaj_z_
$_Invalid_parameter$3062:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0067c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00682	cc		 int	 3
$LN612@Wczytaj_z_:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00683	48 8b c8	 mov	 rcx, rax
  00686	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 493  : 		else if (buf.find("Wylosowano") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o wylosowaniu liczby

  0068b	e9 f2 0d 00 00	 jmp	 $LN51@Wczytaj_z_
$LN2865@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  00690	48 2b df	 sub	 rbx, rdi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 493  : 		else if (buf.find("Wylosowano") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o wylosowaniu liczby

  00693	48 83 fb ff	 cmp	 rbx, -1
  00697	0f 84 90 fc ff
	ff		 je	 $LN3024@Wczytaj_z_

; 494  : 		{
; 495  : 			co_kontynuowaæ = 'w'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od sprawdzenia wygranej

  0069d	41 c6 07 77	 mov	 BYTE PTR [r15], 119	; 00000077H

; 496  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o wylosowanej liczbie

  006a1	45 33 d2	 xor	 r10d, r10d
  006a4	41 0f b7 da	 movzx	 ebx, r10w
  006a8	48 8b 55 c7	 mov	 rdx, QWORD PTR buf$416[rbp-153]
  006ac	44 8b 4d bf	 mov	 r9d, DWORD PTR buf$416[rbp-161]
  006b0	4c 8b 45 af	 mov	 r8, QWORD PTR buf$416[rbp-177]
  006b4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL6@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  006c0	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006c4	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  006c8	49 0f 43 c8	 cmovae	 rcx, r8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 497  : 			while (buf[pocz¹tek] != 'y' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukiwanie od pocz¹tku litery y która wystêpuje w wyrazie po którym jest wylosowana liczba

  006cc	0f b7 c3	 movzx	 eax, bx
  006cf	80 3c 08 79	 cmp	 BYTE PTR [rax+rcx], 121	; 00000079H
  006d3	74 0d		 je	 SHORT $LN7@Wczytaj_z_
  006d5	0f b7 c3	 movzx	 eax, bx
  006d8	41 3b c1	 cmp	 eax, r9d
  006db	7d 05		 jge	 SHORT $LN7@Wczytaj_z_
  006dd	66 ff c3	 inc	 bx
  006e0	eb de		 jmp	 SHORT $LL6@Wczytaj_z_
$LN7@Wczytaj_z_:

; 498  : 			pocz¹tek += 10; //Przesuniêcie o +10 pozycji pocz¹tku tekstu o po której jest wylosowana liczba

  006e2	66 83 c3 0a	 add	 bx, 10
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1563 : 		_Mysize(0),

  006e6	4c 89 55 9f	 mov	 QWORD PTR buf2$414[rbp-161], r10

; 1564 : 		_Myres(0)

  006ea	4c 89 55 a7	 mov	 QWORD PTR buf2$414[rbp-153], r10

; 2171 : 		const size_type _Right_size = _Right_data._Mysize;

  006ee	48 8b 75 bf	 mov	 rsi, QWORD PTR buf$416[rbp-161]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  006f2	4c 8d 7d af	 lea	 r15, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006f6	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  006fa	4d 0f 43 f8	 cmovae	 r15, r8

; 2173 : 		if (_Right_size < this->_BUF_SIZE)

  006fe	48 83 fe 10	 cmp	 rsi, 16
  00702	73 0f		 jae	 SHORT $LN725@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00704	41 0f 10 07	 movups	 xmm0, XMMWORD PTR [r15]
  00708	0f 11 45 8f	 movups	 XMMWORD PTR buf2$414[rbp-177], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2177 : 			_My_data._Myres = this->_BUF_SIZE - 1;

  0070c	bf 0f 00 00 00	 mov	 edi, 15

; 2178 : 			return;

  00711	eb 6a		 jmp	 SHORT $LN3047@Wczytaj_z_
$LN725@Wczytaj_z_:

; 2179 : 			}
; 2180 : 
; 2181 : 		auto& _Al = this->_Getal();
; 2182 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  00713	48 8b fe	 mov	 rdi, rsi
  00716	48 83 cf 0f	 or	 rdi, 15
  0071a	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00724	48 3b f8	 cmp	 rdi, rax
  00727	48 0f 47 f8	 cmova	 rdi, rax

; 2183 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  0072b	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0072f	48 85 c9	 test	 rcx, rcx
  00732	75 05		 jne	 SHORT $LN783@Wczytaj_z_

; 79   : 		{
; 80   : 		return (nullptr);

  00734	49 8b ca	 mov	 rcx, r10
  00737	eb 34		 jmp	 SHORT $LN781@Wczytaj_z_
$LN783@Wczytaj_z_:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00739	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00740	72 23		 jb	 SHORT $LN784@Wczytaj_z_

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00742	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  00746	48 3b c1	 cmp	 rax, rcx
  00749	0f 86 04 11 00
	00		 jbe	 $LN3051@Wczytaj_z_

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0074f	48 8b c8	 mov	 rcx, rax
  00752	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00757	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  0075b	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0075f	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00763	eb 08		 jmp	 SHORT $LN781@Wczytaj_z_
$LN784@Wczytaj_z_:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00765	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0076a	48 8b c8	 mov	 rcx, rax
$LN781@Wczytaj_z_:

; 944  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0076d	48 89 4d 8f	 mov	 QWORD PTR buf2$414[rbp-177], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2185 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  00771	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00775	49 8b d7	 mov	 rdx, r15
  00778	e8 00 00 00 00	 call	 memcpy
$LN3047@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2187 : 		_My_data._Myres = _New_capacity;

  0077d	48 89 7d a7	 mov	 QWORD PTR buf2$414[rbp-153], rdi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 500  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00781	0f b7 c3	 movzx	 eax, bx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00784	48 3b f0	 cmp	 rsi, rax
  00787	48 0f 42 c6	 cmovb	 rax, rsi

; 1582 : 		value_type * _Result = _Bx._Buf;

  0078b	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0078f	48 83 ff 10	 cmp	 rdi, 16

; 1583 : 		if (_Large_string_engaged())

  00793	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00798	48 2b f0	 sub	 rsi, rax

; 2607 : 		_My_data._Mysize = _New_size;

  0079b	48 89 75 9f	 mov	 QWORD PTR buf2$414[rbp-161], rsi

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0079f	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
  007a3	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  007a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  007ad	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007b1	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  007b6	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 501  : 			wylosowana_liczba = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  007bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  007c1	41 89 04 24	 mov	 DWORD PTR [r12], eax

; 502  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o typie zak³adu

  007c5	45 33 ff	 xor	 r15d, r15d
  007c8	41 0f b7 ff	 movzx	 edi, r15w
  007cc	48 8b 55 c7	 mov	 rdx, QWORD PTR buf$416[rbp-153]
  007d0	44 8b 4d bf	 mov	 r9d, DWORD PTR buf$416[rbp-161]
  007d4	4c 8b 45 af	 mov	 r8, QWORD PTR buf$416[rbp-177]
  007d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL8@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  007e0	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007e4	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  007e8	49 0f 43 c8	 cmovae	 rcx, r8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 503  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (int)buf.size()) ++pocz¹tek;

  007ec	0f b7 c7	 movzx	 eax, di
  007ef	80 3c 08 64	 cmp	 BYTE PTR [rax+rcx], 100	; 00000064H
  007f3	74 0d		 je	 SHORT $LN9@Wczytaj_z_
  007f5	0f b7 c7	 movzx	 eax, di
  007f8	41 3b c1	 cmp	 eax, r9d
  007fb	7d 05		 jge	 SHORT $LN9@Wczytaj_z_
  007fd	66 ff c7	 inc	 di
  00800	eb de		 jmp	 SHORT $LL8@Wczytaj_z_
$LN9@Wczytaj_z_:

; 504  : 			pocz¹tek += 2;  //Przesuniêcie o +2 pozycji pocz¹tku tekstu o po której jest typ zak³adu

  00802	66 83 c7 02	 add	 di, 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00806	4c 8d 4d af	 lea	 r9, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0080a	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0080e	4d 0f 43 c8	 cmovae	 r9, r8

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00812	48 8b 75 bf	 mov	 rsi, QWORD PTR buf$416[rbp-161]
  00816	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$414[rbp-153]
  0081a	48 3b f0	 cmp	 rsi, rax

; 2420 : 		if (_Count <= _My_data._Myres)

  0081d	77 26		 ja	 SHORT $LN919@Wczytaj_z_

; 1582 : 		value_type * _Result = _Bx._Buf;

  0081f	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00823	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00827	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$414[rbp-177]

; 2423 : 			_My_data._Mysize = _Count;

  0082c	48 89 75 9f	 mov	 QWORD PTR buf2$414[rbp-161], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00830	4c 8b c6	 mov	 r8, rsi
  00833	49 8b d1	 mov	 rdx, r9
  00836	48 8b cb	 mov	 rcx, rbx
  00839	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  0083f	44 88 3c 33	 mov	 BYTE PTR [rbx+rsi], r15b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  00843	eb 0c		 jmp	 SHORT $LN918@Wczytaj_z_
$LN919@Wczytaj_z_:

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00845	48 8b d6	 mov	 rdx, rsi
  00848	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]
  0084c	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN918@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 506  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00851	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00854	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$414[rbp-161]
  00858	4c 3b c0	 cmp	 r8, rax
  0085b	49 0f 42 c0	 cmovb	 rax, r8

; 1582 : 		value_type * _Result = _Bx._Buf;

  0085f	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00863	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  00868	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  0086d	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;

  00870	4c 89 45 9f	 mov	 QWORD PTR buf2$414[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00874	49 ff c0	 inc	 r8
  00877	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0087b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00881	48 8d 7d 8f	 lea	 rdi, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00885	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  0088a	48 0f 43 7d 8f	 cmovae	 rdi, QWORD PTR buf2$414[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0088f	49 83 cc ff	 or	 r12, -1
  00893	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$414[rbp-161]
  00897	49 83 f8 0b	 cmp	 r8, 11
  0089b	72 60		 jb	 SHORT $LN992@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0089d	49 8d 34 38	 lea	 rsi, QWORD PTR [r8+rdi]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  008a1	4c 8d 46 f6	 lea	 r8, QWORD PTR [rsi-10]
  008a5	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  008a8	41 8d 54 24 21	 lea	 edx, QWORD PTR [r12+33]
  008ad	48 8b cf	 mov	 rcx, rdi
  008b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  008b6	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  008b9	48 85 c0	 test	 rax, rax
  008bc	74 3b		 je	 SHORT $LN2866@Wczytaj_z_
  008be	66 90		 npad	 2
$LL990@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  008c0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  008c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
  008cd	48 8b cb	 mov	 rcx, rbx
  008d0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  008d5	85 c0		 test	 eax, eax
  008d7	74 32		 je	 SHORT $LN2867@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  008d9	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  008dc	4c 8d 46 f6	 lea	 r8, QWORD PTR [rsi-10]
  008e0	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  008e3	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  008e8	48 8b cb	 mov	 rcx, rbx
  008eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  008f1	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  008f4	48 85 c0	 test	 rax, rax
  008f7	75 c7		 jne	 SHORT $LL990@Wczytaj_z_
$LN2866@Wczytaj_z_:

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  008f9	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$414[rbp-161]
$LN992@Wczytaj_z_:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

  008fd	49 8b dc	 mov	 rbx, r12
$LN989@Wczytaj_z_:

; 1609 : 		if (_Mysize < _Off)

  00900	4c 3b c3	 cmp	 r8, rbx
  00903	0f 82 50 0f 00
	00		 jb	 $LN3052@Wczytaj_z_
  00909	eb 09		 jmp	 SHORT $LN1013@Wczytaj_z_
$LN2867@Wczytaj_z_:

; 85   : 			return (_Match_try - _Haystack);

  0090b	48 2b df	 sub	 rbx, rdi
  0090e	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$414[rbp-161]
  00912	eb ec		 jmp	 SHORT $LN989@Wczytaj_z_
$LN1013@Wczytaj_z_:

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00914	49 8b c0	 mov	 rax, r8
  00917	48 2b c3	 sub	 rax, rbx
  0091a	49 8b d4	 mov	 rdx, r12
  0091d	48 83 f8 ff	 cmp	 rax, -1
  00921	48 0f 42 d0	 cmovb	 rdx, rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00925	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00929	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  0092e	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00933	48 03 cb	 add	 rcx, rbx

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00936	4c 2b c2	 sub	 r8, rdx

; 2607 : 		_My_data._Mysize = _New_size;

  00939	4c 89 45 9f	 mov	 QWORD PTR buf2$414[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0093d	4c 2b c3	 sub	 r8, rbx
  00940	49 ff c0	 inc	 r8
  00943	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00946	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2238 : 		if (this != _STD addressof(_Right))

  0094c	48 8d 45 8f	 lea	 rax, QWORD PTR buf2$414[rbp-177]
  00950	4c 3b e8	 cmp	 r13, rax
  00953	74 4c		 je	 SHORT $LN1072@Wczytaj_z_

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00955	4c 8d 4d 8f	 lea	 r9, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00959	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  0095e	4c 0f 43 4d 8f	 cmovae	 r9, QWORD PTR buf2$414[rbp-177]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00963	48 8b 5d 9f	 mov	 rbx, QWORD PTR buf2$414[rbp-161]

; 2420 : 		if (_Count <= _My_data._Myres)

  00967	49 8b 45 18	 mov	 rax, QWORD PTR [r13+24]
  0096b	48 3b d8	 cmp	 rbx, rax
  0096e	77 26		 ja	 SHORT $LN1073@Wczytaj_z_

; 1582 : 		value_type * _Result = _Bx._Buf;

  00970	49 8b fd	 mov	 rdi, r13

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00973	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00977	72 04		 jb	 SHORT $LN1082@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00979	49 8b 7d 00	 mov	 rdi, QWORD PTR [r13]
$LN1082@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  0097d	49 89 5d 10	 mov	 QWORD PTR [r13+16], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00981	4c 8b c3	 mov	 r8, rbx
  00984	49 8b d1	 mov	 rdx, r9
  00987	48 8b cf	 mov	 rcx, rdi
  0098a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00990	44 88 3c 1f	 mov	 BYTE PTR [rdi+rbx], r15b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  00994	eb 0b		 jmp	 SHORT $LN1072@Wczytaj_z_
$LN1073@Wczytaj_z_:

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00996	48 8b d3	 mov	 rdx, rbx
  00999	49 8b cd	 mov	 rcx, r13
  0099c	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN1072@Wczytaj_z_:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  009a1	48 8d 7d af	 lea	 rdi, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009a5	48 83 7d c7 10	 cmp	 QWORD PTR buf$416[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  009aa	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$416[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  009af	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$416[rbp-161]
  009b3	49 83 f8 11	 cmp	 r8, 17
  009b7	72 64		 jb	 SHORT $LN1118@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  009b9	49 8d 34 38	 lea	 rsi, QWORD PTR [r8+rdi]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  009bd	4c 8d 46 f0	 lea	 r8, QWORD PTR [rsi-16]
  009c1	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  009c4	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  009c9	48 8b cf	 mov	 rcx, rdi
  009cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  009d2	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  009d5	48 85 c0	 test	 rax, rax
  009d8	74 3f		 je	 SHORT $LN2868@Wczytaj_z_
  009da	66 0f 1f 44 00
	00		 npad	 6
$LL1116@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  009e0	41 b8 11 00 00
	00		 mov	 r8d, 17
  009e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  009ed	48 8b cb	 mov	 rcx, rbx
  009f0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  009f5	85 c0		 test	 eax, eax
  009f7	74 32		 je	 SHORT $LN2869@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  009f9	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  009fc	4c 8d 46 f0	 lea	 r8, QWORD PTR [rsi-16]
  00a00	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00a03	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00a08	48 8b cb	 mov	 rcx, rbx
  00a0b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00a11	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00a14	48 85 c0	 test	 rax, rax
  00a17	75 c7		 jne	 SHORT $LL1116@Wczytaj_z_
$LN2868@Wczytaj_z_:

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  00a19	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$416[rbp-161]
$LN1118@Wczytaj_z_:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

  00a1d	49 8b dc	 mov	 rbx, r12
$LN1115@Wczytaj_z_:

; 1609 : 		if (_Mysize < _Off)

  00a20	4c 3b c3	 cmp	 r8, rbx
  00a23	0f 82 36 0e 00
	00		 jb	 $LN3053@Wczytaj_z_
  00a29	eb 09		 jmp	 SHORT $LN1139@Wczytaj_z_
$LN2869@Wczytaj_z_:

; 85   : 			return (_Match_try - _Haystack);

  00a2b	48 2b df	 sub	 rbx, rdi
  00a2e	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$416[rbp-161]
  00a32	eb ec		 jmp	 SHORT $LN1115@Wczytaj_z_
$LN1139@Wczytaj_z_:

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00a34	49 8b c0	 mov	 rax, r8
  00a37	48 2b c3	 sub	 rax, rbx
  00a3a	49 8b d4	 mov	 rdx, r12
  00a3d	48 83 f8 ff	 cmp	 rax, -1
  00a41	48 0f 42 d0	 cmovb	 rdx, rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00a45	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a49	48 83 7d c7 10	 cmp	 QWORD PTR buf$416[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  00a4e	48 0f 43 4d af	 cmovae	 rcx, QWORD PTR buf$416[rbp-177]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00a53	48 03 cb	 add	 rcx, rbx

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00a56	4c 2b c2	 sub	 r8, rdx

; 2607 : 		_My_data._Mysize = _New_size;

  00a59	4c 89 45 bf	 mov	 QWORD PTR buf$416[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00a5d	4c 2b c3	 sub	 r8, rbx
  00a60	49 ff c0	 inc	 r8
  00a63	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00a66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 510  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie zak³adu

  00a6c	41 0f b7 ff	 movzx	 edi, r15w
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00a70	48 8d 45 af	 lea	 rax, QWORD PTR buf$416[rbp-177]

; 1583 : 		if (_Large_string_engaged())

  00a74	48 8b 55 af	 mov	 rdx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a78	4c 8b 45 c7	 mov	 r8, QWORD PTR buf$416[rbp-153]
  00a7c	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  00a80	48 0f 43 c2	 cmovae	 rax, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 511  : 			if (buf[12] == 'a') { pocz¹tek = 14; } //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a wiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  00a84	44 0f b7 4d bf	 movzx	 r9d, WORD PTR buf$416[rbp-161]
  00a89	80 78 0c 61	 cmp	 BYTE PTR [rax+12], 97	; 00000061H
  00a8d	75 11		 jne	 SHORT $LL10@Wczytaj_z_
  00a8f	bf 0e 00 00 00	 mov	 edi, 14

; 512  : 			else //Je¿eli nie to

  00a94	eb 2e		 jmp	 SHORT $LN41@Wczytaj_z_
  00a96	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL10@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00aa0	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00aa4	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  00aa8	48 0f 43 ca	 cmovae	 rcx, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 514  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  00aac	0f b7 c7	 movzx	 eax, di
  00aaf	80 3c 08 7a	 cmp	 BYTE PTR [rax+rcx], 122	; 0000007aH
  00ab3	74 0b		 je	 SHORT $LN11@Wczytaj_z_
  00ab5	66 41 3b f9	 cmp	 di, r9w
  00ab9	73 05		 jae	 SHORT $LN11@Wczytaj_z_
  00abb	66 ff c7	 inc	 di
  00abe	eb e0		 jmp	 SHORT $LL10@Wczytaj_z_
$LN11@Wczytaj_z_:

; 515  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  00ac0	66 83 c7 03	 add	 di, 3
$LN41@Wczytaj_z_:

; 516  : 			}
; 517  : 			int koniec = pocz¹tek + 1; //Przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  00ac4	0f b7 f7	 movzx	 esi, di
  00ac7	ff c6		 inc	 esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3047 : 		return (this->_Get_data()._Mysize);

  00ac9	8b ce		 mov	 ecx, esi
  00acb	0f 1f 44 00 00	 npad	 5
$LL12@Wczytaj_z_:

; 1582 : 		value_type * _Result = _Bx._Buf;

  00ad0	48 8d 45 af	 lea	 rax, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ad4	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  00ad8	48 0f 43 c2	 cmovae	 rax, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 518  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Poszukujemy znaku dolara przed którym jest kwota zak³adu

  00adc	80 3c 01 24	 cmp	 BYTE PTR [rcx+rax], 36	; 00000024H
  00ae0	74 0f		 je	 SHORT $LN13@Wczytaj_z_
  00ae2	41 0f b7 c1	 movzx	 eax, r9w
  00ae6	3b f0		 cmp	 esi, eax
  00ae8	7d 07		 jge	 SHORT $LN13@Wczytaj_z_
  00aea	ff c6		 inc	 esi
  00aec	48 ff c1	 inc	 rcx
  00aef	eb df		 jmp	 SHORT $LL12@Wczytaj_z_
$LN13@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00af1	4c 8d 4d af	 lea	 r9, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00af5	49 83 f8 10	 cmp	 r8, 16

; 1594 : 		if (_Large_string_engaged())

  00af9	4c 0f 43 ca	 cmovae	 r9, rdx

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00afd	4c 8b 7d bf	 mov	 r15, QWORD PTR buf$416[rbp-161]
  00b01	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$414[rbp-153]
  00b05	4c 3b f8	 cmp	 r15, rax

; 2420 : 		if (_Count <= _My_data._Myres)

  00b08	77 27		 ja	 SHORT $LN1262@Wczytaj_z_

; 1582 : 		value_type * _Result = _Bx._Buf;

  00b0a	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b0e	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00b12	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$414[rbp-177]

; 2423 : 			_My_data._Mysize = _Count;

  00b17	4c 89 7d 9f	 mov	 QWORD PTR buf2$414[rbp-161], r15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00b1b	4d 8b c7	 mov	 r8, r15
  00b1e	49 8b d1	 mov	 rdx, r9
  00b21	48 8b cb	 mov	 rcx, rbx
  00b24	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00b2a	42 c6 04 3b 00	 mov	 BYTE PTR [rbx+r15], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  00b2f	eb 0c		 jmp	 SHORT $LN1261@Wczytaj_z_
$LN1262@Wczytaj_z_:

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00b31	49 8b d7	 mov	 rdx, r15
  00b34	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]
  00b38	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN1261@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 520  : 			buf2.erase(koniec, string::npos); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  00b3d	48 63 d6	 movsxd	 rdx, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00b40	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$414[rbp-161]
  00b44	4c 3b c2	 cmp	 r8, rdx
  00b47	0f 82 18 0d 00
	00		 jb	 $LN3054@Wczytaj_z_

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00b4d	49 8b c0	 mov	 rax, r8
  00b50	48 2b c2	 sub	 rax, rdx
  00b53	48 83 f8 ff	 cmp	 rax, -1
  00b57	4c 0f 42 e0	 cmovb	 r12, rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00b5b	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b5f	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  00b64	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00b69	48 03 ca	 add	 rcx, rdx

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00b6c	4d 2b c4	 sub	 r8, r12

; 2607 : 		_My_data._Mysize = _New_size;

  00b6f	4c 89 45 9f	 mov	 QWORD PTR buf2$414[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00b73	4c 2b c2	 sub	 r8, rdx
  00b76	49 ff c0	 inc	 r8
  00b79	4a 8d 14 21	 lea	 rdx, QWORD PTR [rcx+r12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00b7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 521  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00b83	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00b86	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$414[rbp-161]
  00b8a	4c 3b c0	 cmp	 r8, rax
  00b8d	49 0f 42 c0	 cmovb	 rax, r8

; 1582 : 		value_type * _Result = _Bx._Buf;

  00b91	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b95	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  00b9a	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00b9f	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;

  00ba2	4c 89 45 9f	 mov	 QWORD PTR buf2$414[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00ba6	49 ff c0	 inc	 r8
  00ba9	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00bad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00bb3	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00bb7	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  00bbc	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 522  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00bc1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00bc7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR kwota_zak³adu$GSCopy$1$[rsp]
  00bcc	89 01		 mov	 DWORD PTR [rcx], eax

; 523  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  00bce	0f b7 7d df	 movzx	 edi, WORD PTR bufor2$417[rbp-161]
  00bd2	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00bd7	4c 8b 45 e7	 mov	 r8, QWORD PTR bufor2$417[rbp-153]
  00bdb	4c 8b 55 cf	 mov	 r10, QWORD PTR bufor2$417[rbp-177]
  00bdf	90		 npad	 1
$LL14@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00be0	48 8d 4d cf	 lea	 rcx, QWORD PTR bufor2$417[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00be4	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  00be8	49 0f 43 ca	 cmovae	 rcx, r10
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 524  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  00bec	0f b7 c7	 movzx	 eax, di
  00bef	80 3c 08 20	 cmp	 BYTE PTR [rax+rcx], 32	; 00000020H
  00bf3	74 0a		 je	 SHORT $LN15@Wczytaj_z_
  00bf5	66 85 ff	 test	 di, di
  00bf8	74 05		 je	 SHORT $LN15@Wczytaj_z_
  00bfa	66 03 fa	 add	 di, dx
  00bfd	eb e1		 jmp	 SHORT $LL14@Wczytaj_z_
$LN15@Wczytaj_z_:

; 525  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  00bff	66 ff c7	 inc	 di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00c02	4c 8d 4d cf	 lea	 r9, QWORD PTR bufor2$417[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c06	49 83 f8 10	 cmp	 r8, 16

; 1594 : 		if (_Large_string_engaged())

  00c0a	4d 0f 43 ca	 cmovae	 r9, r10

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00c0e	48 8b 75 df	 mov	 rsi, QWORD PTR bufor2$417[rbp-161]
  00c12	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$414[rbp-153]
  00c16	48 3b f0	 cmp	 rsi, rax

; 2420 : 		if (_Count <= _My_data._Myres)

  00c19	77 26		 ja	 SHORT $LN1420@Wczytaj_z_

; 1582 : 		value_type * _Result = _Bx._Buf;

  00c1b	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c1f	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00c23	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$414[rbp-177]

; 2423 : 			_My_data._Mysize = _Count;

  00c28	48 89 75 9f	 mov	 QWORD PTR buf2$414[rbp-161], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00c2c	4c 8b c6	 mov	 r8, rsi
  00c2f	49 8b d1	 mov	 rdx, r9
  00c32	48 8b cb	 mov	 rcx, rbx
  00c35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00c3b	c6 04 33 00	 mov	 BYTE PTR [rbx+rsi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  00c3f	eb 0c		 jmp	 SHORT $LN1419@Wczytaj_z_
$LN1420@Wczytaj_z_:

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00c41	48 8b d6	 mov	 rdx, rsi
  00c44	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]
  00c48	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN1419@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 527  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00c4d	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00c50	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$414[rbp-161]
  00c54	4c 3b c0	 cmp	 r8, rax
  00c57	49 0f 42 c0	 cmovb	 rax, r8

; 1582 : 		value_type * _Result = _Bx._Buf;

  00c5b	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c5f	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  00c64	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00c69	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;

  00c6c	4c 89 45 9f	 mov	 QWORD PTR buf2$414[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00c70	49 ff c0	 inc	 r8
  00c73	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00c77	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 528  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00c7d	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$414[rbp-161]
  00c81	49 8d 50 ff	 lea	 rdx, QWORD PTR [r8-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00c85	4c 3b c2	 cmp	 r8, rdx
  00c88	0f 82 dd 0b 00
	00		 jb	 $LN3055@Wczytaj_z_

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00c8e	49 8b c0	 mov	 rax, r8
  00c91	48 2b c2	 sub	 rax, rdx
  00c94	48 83 f8 01	 cmp	 rax, 1
  00c98	41 b9 01 00 00
	00		 mov	 r9d, 1
  00c9e	4c 0f 42 c8	 cmovb	 r9, rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00ca2	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ca6	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  00cab	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00cb0	48 03 ca	 add	 rcx, rdx

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00cb3	4d 2b c1	 sub	 r8, r9

; 2607 : 		_My_data._Mysize = _New_size;

  00cb6	4c 89 45 9f	 mov	 QWORD PTR buf2$414[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00cba	4c 2b c2	 sub	 r8, rdx
  00cbd	49 ff c0	 inc	 r8
  00cc0	4a 8d 14 09	 lea	 rdx, QWORD PTR [rcx+r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00cc4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00cca	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00cce	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  00cd3	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 529  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  00cd8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00cde	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iloæ_pieniêdzy$GSCopy$1$[rsp]
  00ce3	89 01		 mov	 DWORD PTR [rcx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ce5	48 8b 55 a7	 mov	 rdx, QWORD PTR buf2$414[rbp-153]
  00ce9	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00ced	0f 82 8c 07 00
	00		 jb	 $LN3043@Wczytaj_z_

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00cf3	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00cf6	48 8b 45 8f	 mov	 rax, QWORD PTR buf2$414[rbp-177]
  00cfa	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00cfd	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00d04	72 2e		 jb	 SHORT $LN1563@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00d06	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00d0a	4c 3b c2	 cmp	 r8, rdx
  00d0d	76 1e		 jbe	 SHORT $_Invalid_parameter$3063

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00d0f	49 8b d0	 mov	 rdx, r8
  00d12	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00d15	75 16		 jne	 SHORT $_Invalid_parameter$3063

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00d17	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00d1b	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00d1e	73 0d		 jae	 SHORT $_Invalid_parameter$3063

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00d20	48 2b c8	 sub	 rcx, rax
  00d23	48 83 e9 08	 sub	 rcx, 8
  00d27	48 83 f9 1f	 cmp	 rcx, 31
  00d2b	76 07		 jbe	 SHORT $LN1563@Wczytaj_z_
$_Invalid_parameter$3063:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00d2d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00d33	cc		 int	 3
$LN1563@Wczytaj_z_:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00d34	48 8b c8	 mov	 rcx, rax
  00d37	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 531  : 		else if (buf.find("Obstawiono zaklad") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o typie obstawionego zak³adu

  00d3c	e9 3e 07 00 00	 jmp	 $LN3043@Wczytaj_z_
$LN2871@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  00d41	48 2b df	 sub	 rbx, rdi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 531  : 		else if (buf.find("Obstawiono zaklad") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o typie obstawionego zak³adu

  00d44	48 83 fb ff	 cmp	 rbx, -1
  00d48	0f 84 5e f6 ff
	ff		 je	 $LN3025@Wczytaj_z_

; 532  : 		{
; 533  : 			co_kontynuowaæ = 't'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od wylosowania liczby

  00d4e	41 c6 07 74	 mov	 BYTE PTR [r15], 116	; 00000074H

; 534  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o typie zak³adu

  00d52	45 33 ff	 xor	 r15d, r15d
  00d55	41 0f b7 df	 movzx	 ebx, r15w
  00d59	4c 8b 45 c7	 mov	 r8, QWORD PTR buf$416[rbp-153]
  00d5d	0f b7 55 bf	 movzx	 edx, WORD PTR buf$416[rbp-161]
  00d61	4c 8b 4d af	 mov	 r9, QWORD PTR buf$416[rbp-177]
  00d65	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL16@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00d70	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d74	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  00d78	49 0f 43 c9	 cmovae	 rcx, r9
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 535  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek;

  00d7c	0f b7 c3	 movzx	 eax, bx
  00d7f	80 3c 08 64	 cmp	 BYTE PTR [rax+rcx], 100	; 00000064H
  00d83	74 0a		 je	 SHORT $LN17@Wczytaj_z_
  00d85	66 3b da	 cmp	 bx, dx
  00d88	73 05		 jae	 SHORT $LN17@Wczytaj_z_
  00d8a	66 ff c3	 inc	 bx
  00d8d	eb e1		 jmp	 SHORT $LL16@Wczytaj_z_
$LN17@Wczytaj_z_:

; 536  : 			pocz¹tek += 2; //Przesuniêcie pozycji pocz¹tku tekstu o 2 po której jest typ zak³adu

  00d8f	66 83 c3 02	 add	 bx, 2

; 537  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeniej odczytanego tekstu

  00d93	48 8d 55 af	 lea	 rdx, QWORD PTR buf$416[rbp-177]
  00d97	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]
  00d9b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00da0	90		 npad	 1

; 538  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00da1	0f b7 c3	 movzx	 eax, bx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00da4	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  00da8	4c 3b c0	 cmp	 r8, rax
  00dab	49 0f 42 c0	 cmovb	 rax, r8

; 1582 : 		value_type * _Result = _Bx._Buf;

  00daf	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00db3	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  00db8	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00dbd	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;

  00dc0	4c 89 45 9f	 mov	 QWORD PTR buf2$413[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00dc4	49 ff c0	 inc	 r8
  00dc7	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00dcb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2238 : 		if (this != _STD addressof(_Right))

  00dd1	48 8d 45 8f	 lea	 rax, QWORD PTR buf2$413[rbp-177]
  00dd5	4c 3b e8	 cmp	 r13, rax
  00dd8	74 4c		 je	 SHORT $LN1721@Wczytaj_z_

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00dda	4c 8d 4d 8f	 lea	 r9, QWORD PTR buf2$413[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00dde	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  00de3	4c 0f 43 4d 8f	 cmovae	 r9, QWORD PTR buf2$413[rbp-177]

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00de8	48 8b 5d 9f	 mov	 rbx, QWORD PTR buf2$413[rbp-161]

; 2420 : 		if (_Count <= _My_data._Myres)

  00dec	49 8b 45 18	 mov	 rax, QWORD PTR [r13+24]
  00df0	48 3b d8	 cmp	 rbx, rax
  00df3	77 26		 ja	 SHORT $LN1722@Wczytaj_z_

; 1582 : 		value_type * _Result = _Bx._Buf;

  00df5	49 8b fd	 mov	 rdi, r13

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00df8	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00dfc	72 04		 jb	 SHORT $LN1731@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00dfe	49 8b 7d 00	 mov	 rdi, QWORD PTR [r13]
$LN1731@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  00e02	49 89 5d 10	 mov	 QWORD PTR [r13+16], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00e06	4c 8b c3	 mov	 r8, rbx
  00e09	49 8b d1	 mov	 rdx, r9
  00e0c	48 8b cf	 mov	 rcx, rdi
  00e0f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00e15	c6 04 1f 00	 mov	 BYTE PTR [rdi+rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  00e19	eb 0b		 jmp	 SHORT $LN1721@Wczytaj_z_
$LN1722@Wczytaj_z_:

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00e1b	48 8b d3	 mov	 rdx, rbx
  00e1e	49 8b cd	 mov	 rcx, r13
  00e21	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN1721@Wczytaj_z_:

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00e26	48 8d 7d af	 lea	 rdi, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00e2a	48 83 7d c7 10	 cmp	 QWORD PTR buf$416[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  00e2f	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$416[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00e34	49 83 cc ff	 or	 r12, -1
  00e38	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$416[rbp-161]
  00e3c	49 83 f8 11	 cmp	 r8, 17
  00e40	72 6a		 jb	 SHORT $LN1767@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00e42	49 8d 70 f0	 lea	 rsi, QWORD PTR [r8-16]
  00e46	48 03 f7	 add	 rsi, rdi

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00e49	4c 8b c6	 mov	 r8, rsi
  00e4c	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00e4f	41 8d 54 24 50	 lea	 edx, QWORD PTR [r12+80]
  00e54	48 8b cf	 mov	 rcx, rdi
  00e57	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00e5d	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00e60	48 85 c0	 test	 rax, rax
  00e63	74 43		 je	 SHORT $LN2872@Wczytaj_z_
  00e65	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL1765@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00e70	41 b8 11 00 00
	00		 mov	 r8d, 17
  00e76	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  00e7d	48 8b cb	 mov	 rcx, rbx
  00e80	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00e85	85 c0		 test	 eax, eax
  00e87	74 31		 je	 SHORT $LN2873@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  00e89	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00e8c	4c 8b c6	 mov	 r8, rsi
  00e8f	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00e92	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00e97	48 8b cb	 mov	 rcx, rbx
  00e9a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00ea0	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00ea3	48 85 c0	 test	 rax, rax
  00ea6	75 c8		 jne	 SHORT $LL1765@Wczytaj_z_
$LN2872@Wczytaj_z_:

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  00ea8	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$416[rbp-161]
$LN1767@Wczytaj_z_:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

  00eac	49 8b dc	 mov	 rbx, r12
$LN1764@Wczytaj_z_:

; 1609 : 		if (_Mysize < _Off)

  00eaf	4c 3b c3	 cmp	 r8, rbx
  00eb2	0f 82 b9 09 00
	00		 jb	 $LN3056@Wczytaj_z_
  00eb8	eb 09		 jmp	 SHORT $LN1788@Wczytaj_z_
$LN2873@Wczytaj_z_:

; 85   : 			return (_Match_try - _Haystack);

  00eba	48 2b df	 sub	 rbx, rdi
  00ebd	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$416[rbp-161]
  00ec1	eb ec		 jmp	 SHORT $LN1764@Wczytaj_z_
$LN1788@Wczytaj_z_:

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00ec3	49 8b c0	 mov	 rax, r8
  00ec6	48 2b c3	 sub	 rax, rbx
  00ec9	49 8b d4	 mov	 rdx, r12
  00ecc	48 83 f8 ff	 cmp	 rax, -1
  00ed0	48 0f 42 d0	 cmovb	 rdx, rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00ed4	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ed8	48 83 7d c7 10	 cmp	 QWORD PTR buf$416[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  00edd	48 0f 43 4d af	 cmovae	 rcx, QWORD PTR buf$416[rbp-177]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00ee2	48 03 cb	 add	 rcx, rbx

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00ee5	4c 2b c2	 sub	 r8, rdx

; 2607 : 		_My_data._Mysize = _New_size;

  00ee8	4c 89 45 bf	 mov	 QWORD PTR buf$416[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00eec	4c 2b c3	 sub	 r8, rbx
  00eef	49 ff c0	 inc	 r8
  00ef2	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00ef5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 541  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie zak³adu

  00efb	41 0f b7 ff	 movzx	 edi, r15w
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00eff	48 8d 45 af	 lea	 rax, QWORD PTR buf$416[rbp-177]

; 1583 : 		if (_Large_string_engaged())

  00f03	48 8b 55 af	 mov	 rdx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00f07	4c 8b 45 c7	 mov	 r8, QWORD PTR buf$416[rbp-153]
  00f0b	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  00f0f	48 0f 43 c2	 cmovae	 rax, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 542  : 			if (buf[12] == 'a') pocz¹tek = 14; //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a wiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  00f13	80 78 0c 61	 cmp	 BYTE PTR [rax+12], 97	; 00000061H
  00f17	75 07		 jne	 SHORT $LN3015@Wczytaj_z_
  00f19	bf 0e 00 00 00	 mov	 edi, 14

; 543  : 			else //Je¿eli nie to

  00f1e	eb 36		 jmp	 SHORT $LN45@Wczytaj_z_
$LN3015@Wczytaj_z_:
  00f20	44 8b 4d bf	 mov	 r9d, DWORD PTR buf$416[rbp-161]
  00f24	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL18@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00f30	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00f34	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  00f38	48 0f 43 ca	 cmovae	 rcx, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 545  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  00f3c	0f b7 c7	 movzx	 eax, di
  00f3f	80 3c 08 7a	 cmp	 BYTE PTR [rax+rcx], 122	; 0000007aH
  00f43	74 0d		 je	 SHORT $LN19@Wczytaj_z_
  00f45	0f b7 c7	 movzx	 eax, di
  00f48	41 3b c1	 cmp	 eax, r9d
  00f4b	7d 05		 jge	 SHORT $LN19@Wczytaj_z_
  00f4d	66 ff c7	 inc	 di
  00f50	eb de		 jmp	 SHORT $LL18@Wczytaj_z_
$LN19@Wczytaj_z_:

; 546  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  00f52	66 83 c7 03	 add	 di, 3
$LN45@Wczytaj_z_:

; 547  : 			}
; 548  : 			unsigned short koniec = pocz¹tek + 1; //Przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  00f56	8d 77 01	 lea	 esi, DWORD PTR [rdi+1]
  00f59	44 0f b7 4d bf	 movzx	 r9d, WORD PTR buf$416[rbp-161]
  00f5e	66 90		 npad	 2
$LL20@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00f60	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00f64	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  00f68	48 0f 43 ca	 cmovae	 rcx, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 549  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Pêtla poszukuj¹ca znaku dolara, pêtla koñczy siê znalezieniem znaku dolara

  00f6c	0f b7 c6	 movzx	 eax, si
  00f6f	80 3c 08 24	 cmp	 BYTE PTR [rax+rcx], 36	; 00000024H
  00f73	74 0b		 je	 SHORT $LN21@Wczytaj_z_
  00f75	66 41 3b f1	 cmp	 si, r9w
  00f79	73 05		 jae	 SHORT $LN21@Wczytaj_z_
  00f7b	66 ff c6	 inc	 si
  00f7e	eb e0		 jmp	 SHORT $LL20@Wczytaj_z_
$LN21@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00f80	4c 8d 4d af	 lea	 r9, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00f84	49 83 f8 10	 cmp	 r8, 16

; 1594 : 		if (_Large_string_engaged())

  00f88	4c 0f 43 ca	 cmovae	 r9, rdx

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00f8c	4c 8b 7d bf	 mov	 r15, QWORD PTR buf$416[rbp-161]
  00f90	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$413[rbp-153]
  00f94	4c 3b f8	 cmp	 r15, rax

; 2420 : 		if (_Count <= _My_data._Myres)

  00f97	77 27		 ja	 SHORT $LN1911@Wczytaj_z_

; 1582 : 		value_type * _Result = _Bx._Buf;

  00f99	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$413[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00f9d	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00fa1	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$413[rbp-177]

; 2423 : 			_My_data._Mysize = _Count;

  00fa6	4c 89 7d 9f	 mov	 QWORD PTR buf2$413[rbp-161], r15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00faa	4d 8b c7	 mov	 r8, r15
  00fad	49 8b d1	 mov	 rdx, r9
  00fb0	48 8b cb	 mov	 rcx, rbx
  00fb3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00fb9	42 c6 04 3b 00	 mov	 BYTE PTR [rbx+r15], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  00fbe	eb 0c		 jmp	 SHORT $LN1910@Wczytaj_z_
$LN1911@Wczytaj_z_:

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00fc0	49 8b d7	 mov	 rdx, r15
  00fc3	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]
  00fc7	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN1910@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 551  : 			buf2.erase(koniec, string::npos); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  00fcc	0f b7 d6	 movzx	 edx, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00fcf	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  00fd3	4c 3b c2	 cmp	 r8, rdx
  00fd6	0f 82 9b 08 00
	00		 jb	 $LN3057@Wczytaj_z_

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00fdc	49 8b c0	 mov	 rax, r8
  00fdf	48 2b c2	 sub	 rax, rdx
  00fe2	48 83 f8 ff	 cmp	 rax, -1
  00fe6	4c 0f 42 e0	 cmovb	 r12, rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00fea	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00fee	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  00ff3	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00ff8	48 03 ca	 add	 rcx, rdx

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00ffb	4d 2b c4	 sub	 r8, r12

; 2607 : 		_My_data._Mysize = _New_size;

  00ffe	4c 89 45 9f	 mov	 QWORD PTR buf2$413[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  01002	4c 2b c2	 sub	 r8, rdx
  01005	49 ff c0	 inc	 r8
  01008	4a 8d 14 21	 lea	 rdx, QWORD PTR [rcx+r12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0100c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 552  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  01012	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  01015	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  01019	4c 3b c0	 cmp	 r8, rax
  0101c	49 0f 42 c0	 cmovb	 rax, r8

; 1582 : 		value_type * _Result = _Bx._Buf;

  01020	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01024	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  01029	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  0102e	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;

  01031	4c 89 45 9f	 mov	 QWORD PTR buf2$413[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  01035	49 ff c0	 inc	 r8
  01038	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0103c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01042	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01046	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  0104b	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 553  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  01050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  01056	48 8b 4c 24 30	 mov	 rcx, QWORD PTR kwota_zak³adu$GSCopy$1$[rsp]
  0105b	89 01		 mov	 DWORD PTR [rcx], eax

; 554  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  0105d	0f b7 7d df	 movzx	 edi, WORD PTR bufor2$417[rbp-161]
  01061	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  01066	4c 8b 45 e7	 mov	 r8, QWORD PTR bufor2$417[rbp-153]
  0106a	4c 8b 55 cf	 mov	 r10, QWORD PTR bufor2$417[rbp-177]
  0106e	66 90		 npad	 2
$LL22@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  01070	48 8d 4d cf	 lea	 rcx, QWORD PTR bufor2$417[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01074	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  01078	49 0f 43 ca	 cmovae	 rcx, r10
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 555  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  0107c	0f b7 c7	 movzx	 eax, di
  0107f	80 3c 08 20	 cmp	 BYTE PTR [rax+rcx], 32	; 00000020H
  01083	74 0a		 je	 SHORT $LN23@Wczytaj_z_
  01085	66 85 ff	 test	 di, di
  01088	74 05		 je	 SHORT $LN23@Wczytaj_z_
  0108a	66 03 fa	 add	 di, dx
  0108d	eb e1		 jmp	 SHORT $LL22@Wczytaj_z_
$LN23@Wczytaj_z_:

; 556  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  0108f	66 ff c7	 inc	 di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01092	4c 8d 4d cf	 lea	 r9, QWORD PTR bufor2$417[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01096	49 83 f8 10	 cmp	 r8, 16

; 1594 : 		if (_Large_string_engaged())

  0109a	4d 0f 43 ca	 cmovae	 r9, r10

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0109e	48 8b 75 df	 mov	 rsi, QWORD PTR bufor2$417[rbp-161]
  010a2	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$413[rbp-153]
  010a6	48 3b f0	 cmp	 rsi, rax

; 2420 : 		if (_Count <= _My_data._Myres)

  010a9	77 26		 ja	 SHORT $LN2069@Wczytaj_z_

; 1582 : 		value_type * _Result = _Bx._Buf;

  010ab	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$413[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  010af	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  010b3	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$413[rbp-177]

; 2423 : 			_My_data._Mysize = _Count;

  010b8	48 89 75 9f	 mov	 QWORD PTR buf2$413[rbp-161], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  010bc	4c 8b c6	 mov	 r8, rsi
  010bf	49 8b d1	 mov	 rdx, r9
  010c2	48 8b cb	 mov	 rcx, rbx
  010c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  010cb	c6 04 33 00	 mov	 BYTE PTR [rbx+rsi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  010cf	eb 0c		 jmp	 SHORT $LN2068@Wczytaj_z_
$LN2069@Wczytaj_z_:

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  010d1	48 8b d6	 mov	 rdx, rsi
  010d4	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]
  010d8	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN2068@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 558  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  010dd	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  010e0	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  010e4	4c 3b c0	 cmp	 r8, rax
  010e7	49 0f 42 c0	 cmovb	 rax, r8

; 1582 : 		value_type * _Result = _Bx._Buf;

  010eb	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  010ef	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  010f4	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  010f9	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;

  010fc	4c 89 45 9f	 mov	 QWORD PTR buf2$413[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  01100	49 ff c0	 inc	 r8
  01103	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 559  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  0110d	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  01111	49 8d 50 ff	 lea	 rdx, QWORD PTR [r8-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  01115	4c 3b c2	 cmp	 r8, rdx
  01118	0f 82 5f 07 00
	00		 jb	 $LN3058@Wczytaj_z_

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  0111e	49 8b c0	 mov	 rax, r8
  01121	48 2b c2	 sub	 rax, rdx
  01124	48 83 f8 01	 cmp	 rax, 1
  01128	41 b9 01 00 00
	00		 mov	 r9d, 1
  0112e	4c 0f 42 c8	 cmovb	 r9, rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  01132	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01136	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  0113b	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  01140	48 03 ca	 add	 rcx, rdx

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  01143	4d 2b c1	 sub	 r8, r9

; 2607 : 		_My_data._Mysize = _New_size;

  01146	4c 89 45 9f	 mov	 QWORD PTR buf2$413[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0114a	4c 2b c2	 sub	 r8, rdx
  0114d	49 ff c0	 inc	 r8
  01150	4a 8d 14 09	 lea	 rdx, QWORD PTR [rcx+r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0115a	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0115e	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  01163	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 560  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  01168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0116e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iloæ_pieniêdzy$GSCopy$1$[rsp]
  01173	89 01		 mov	 DWORD PTR [rcx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01175	48 8b 55 a7	 mov	 rdx, QWORD PTR buf2$413[rbp-153]
  01179	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  0117d	0f 82 fc 02 00
	00		 jb	 $LN3043@Wczytaj_z_

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01183	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01186	48 8b 45 8f	 mov	 rax, QWORD PTR buf2$413[rbp-177]
  0118a	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0118d	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  01194	0f 82 9a fb ff
	ff		 jb	 $LN1563@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0119a	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  0119e	4c 3b c2	 cmp	 r8, rdx
  011a1	76 22		 jbe	 SHORT $_Invalid_parameter$3064

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  011a3	49 8b d0	 mov	 rdx, r8
  011a6	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  011a9	75 1a		 jne	 SHORT $_Invalid_parameter$3064

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  011ab	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  011af	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  011b2	73 11		 jae	 SHORT $_Invalid_parameter$3064

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  011b4	48 2b c8	 sub	 rcx, rax
  011b7	48 83 e9 08	 sub	 rcx, 8
  011bb	48 83 f9 1f	 cmp	 rcx, 31
  011bf	0f 86 6f fb ff
	ff		 jbe	 $LN1563@Wczytaj_z_
$_Invalid_parameter$3064:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  011c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  011cb	cc		 int	 3
$LN2875@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  011cc	48 2b df	 sub	 rbx, rdi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 562  : 		else if (buf.find("Obstawiono za") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa wiadcz¹ce o kwocie obstawionego zak³adu

  011cf	48 83 fb ff	 cmp	 rbx, -1
  011d3	0f 84 54 f2 ff
	ff		 je	 $LN3026@Wczytaj_z_

; 563  : 		{
; 564  : 			co_kontynuowaæ = 'k';  //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od zapytania o typ zak³adu

  011d9	41 c6 07 6b	 mov	 BYTE PTR [r15], 107	; 0000006bH

; 565  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  011dd	45 33 ff	 xor	 r15d, r15d
  011e0	41 0f b7 ff	 movzx	 edi, r15w
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  011e4	48 8d 45 af	 lea	 rax, QWORD PTR buf$416[rbp-177]

; 1583 : 		if (_Large_string_engaged())

  011e8	48 8b 55 af	 mov	 rdx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  011ec	4c 8b 45 c7	 mov	 r8, QWORD PTR buf$416[rbp-153]
  011f0	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  011f4	48 0f 43 c2	 cmovae	 rax, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 566  : 			if (buf[12] == 'a') { pocz¹tek = 14; } //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a wiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  011f8	80 78 0c 61	 cmp	 BYTE PTR [rax+12], 97	; 00000061H
  011fc	75 06		 jne	 SHORT $LN3019@Wczytaj_z_
  011fe	41 8d 7f 0e	 lea	 edi, QWORD PTR [r15+14]

; 567  : 			else //Je¿eli nie to

  01202	eb 30		 jmp	 SHORT $LN49@Wczytaj_z_
$LN3019@Wczytaj_z_:
  01204	44 0f b7 4d bf	 movzx	 r9d, WORD PTR buf$416[rbp-161]
  01209	0f 1f 80 00 00
	00 00		 npad	 7
$LL24@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  01210	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01214	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  01218	48 0f 43 ca	 cmovae	 rcx, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 569  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z wiadcz¹cej o wyrazie po którym jest kwota zak³adu

  0121c	0f b7 c7	 movzx	 eax, di
  0121f	80 3c 08 7a	 cmp	 BYTE PTR [rax+rcx], 122	; 0000007aH
  01223	74 0b		 je	 SHORT $LN25@Wczytaj_z_
  01225	66 41 3b f9	 cmp	 di, r9w
  01229	73 05		 jae	 SHORT $LN25@Wczytaj_z_
  0122b	66 ff c7	 inc	 di
  0122e	eb e0		 jmp	 SHORT $LL24@Wczytaj_z_
$LN25@Wczytaj_z_:

; 570  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  01230	66 83 c7 03	 add	 di, 3
$LN49@Wczytaj_z_:

; 571  : 			}
; 572  : 			unsigned short koniec = pocz¹tek + 1; //Utworzenie i przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  01234	8d 5f 01	 lea	 ebx, DWORD PTR [rdi+1]
  01237	44 8b 4d bf	 mov	 r9d, DWORD PTR buf$416[rbp-161]
  0123b	0f 1f 44 00 00	 npad	 5
$LL26@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  01240	48 8d 4d af	 lea	 rcx, QWORD PTR buf$416[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01244	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  01248	48 0f 43 ca	 cmovae	 rcx, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 573  : 			while (buf[koniec] != '$' && koniec < (int)buf.size()) ++koniec; //Pêtla szukaj¹ca znaku dolara

  0124c	0f b7 c3	 movzx	 eax, bx
  0124f	80 3c 08 24	 cmp	 BYTE PTR [rax+rcx], 36	; 00000024H
  01253	74 0d		 je	 SHORT $LN27@Wczytaj_z_
  01255	0f b7 c3	 movzx	 eax, bx
  01258	41 3b c1	 cmp	 eax, r9d
  0125b	7d 05		 jge	 SHORT $LN27@Wczytaj_z_
  0125d	66 ff c3	 inc	 bx
  01260	eb de		 jmp	 SHORT $LL26@Wczytaj_z_
$LN27@Wczytaj_z_:

; 574  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeniej odczytanego tekstu

  01262	48 8d 55 af	 lea	 rdx, QWORD PTR buf$416[rbp-177]
  01266	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]
  0126a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0126f	90		 npad	 1

; 575  : 			buf2.erase(koniec, string::npos); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  01270	0f b7 d3	 movzx	 edx, bx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  01273	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$412[rbp-161]
  01277	4c 3b c2	 cmp	 r8, rdx
  0127a	0f 82 03 06 00
	00		 jb	 $LN3059@Wczytaj_z_

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  01280	49 8b c0	 mov	 rax, r8
  01283	48 2b c2	 sub	 rax, rdx
  01286	49 83 cc ff	 or	 r12, -1
  0128a	49 3b c4	 cmp	 rax, r12
  0128d	4c 0f 42 e0	 cmovb	 r12, rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  01291	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01295	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  0129a	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  0129f	48 03 ca	 add	 rcx, rdx

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  012a2	4d 2b c4	 sub	 r8, r12

; 2607 : 		_My_data._Mysize = _New_size;

  012a5	4c 89 45 9f	 mov	 QWORD PTR buf2$412[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  012a9	4c 2b c2	 sub	 r8, rdx
  012ac	49 ff c0	 inc	 r8
  012af	4a 8d 14 21	 lea	 rdx, QWORD PTR [rcx+r12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  012b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 576  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  012b9	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  012bc	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$412[rbp-161]
  012c0	4c 3b c0	 cmp	 r8, rax
  012c3	49 0f 42 c0	 cmovb	 rax, r8

; 1582 : 		value_type * _Result = _Bx._Buf;

  012c7	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  012cb	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  012d0	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  012d5	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;

  012d8	4c 89 45 9f	 mov	 QWORD PTR buf2$412[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  012dc	49 ff c0	 inc	 r8
  012df	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  012e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  012e9	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  012ed	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  012f2	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 577  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  012f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  012fd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR kwota_zak³adu$GSCopy$1$[rsp]
  01302	89 01		 mov	 DWORD PTR [rcx], eax

; 578  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  01304	0f b7 7d df	 movzx	 edi, WORD PTR bufor2$417[rbp-161]
  01308	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0130d	4c 8b 45 e7	 mov	 r8, QWORD PTR bufor2$417[rbp-153]
  01311	4c 8b 55 cf	 mov	 r10, QWORD PTR bufor2$417[rbp-177]
  01315	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL28@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  01320	48 8d 4d cf	 lea	 rcx, QWORD PTR bufor2$417[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01324	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  01328	49 0f 43 ca	 cmovae	 rcx, r10
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 579  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  0132c	0f b7 c7	 movzx	 eax, di
  0132f	80 3c 08 20	 cmp	 BYTE PTR [rax+rcx], 32	; 00000020H
  01333	74 0a		 je	 SHORT $LN29@Wczytaj_z_
  01335	66 85 ff	 test	 di, di
  01338	74 05		 je	 SHORT $LN29@Wczytaj_z_
  0133a	66 03 fa	 add	 di, dx
  0133d	eb e1		 jmp	 SHORT $LL28@Wczytaj_z_
$LN29@Wczytaj_z_:

; 580  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  0133f	66 ff c7	 inc	 di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01342	4c 8d 4d cf	 lea	 r9, QWORD PTR bufor2$417[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01346	49 83 f8 10	 cmp	 r8, 16

; 1594 : 		if (_Large_string_engaged())

  0134a	4d 0f 43 ca	 cmovae	 r9, r10

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0134e	48 8b 75 df	 mov	 rsi, QWORD PTR bufor2$417[rbp-161]
  01352	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$412[rbp-153]
  01356	48 3b f0	 cmp	 rsi, rax

; 2420 : 		if (_Count <= _My_data._Myres)

  01359	77 26		 ja	 SHORT $LN2478@Wczytaj_z_

; 1582 : 		value_type * _Result = _Bx._Buf;

  0135b	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$412[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0135f	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  01363	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$412[rbp-177]

; 2423 : 			_My_data._Mysize = _Count;

  01368	48 89 75 9f	 mov	 QWORD PTR buf2$412[rbp-161], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0136c	4c 8b c6	 mov	 r8, rsi
  0136f	49 8b d1	 mov	 rdx, r9
  01372	48 8b cb	 mov	 rcx, rbx
  01375	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  0137b	c6 04 33 00	 mov	 BYTE PTR [rbx+rsi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  0137f	eb 0c		 jmp	 SHORT $LN2477@Wczytaj_z_
$LN2478@Wczytaj_z_:

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  01381	48 8b d6	 mov	 rdx, rsi
  01384	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]
  01388	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN2477@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 582  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  0138d	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  01390	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$412[rbp-161]
  01394	4c 3b c0	 cmp	 r8, rax
  01397	49 0f 42 c0	 cmovb	 rax, r8

; 1582 : 		value_type * _Result = _Bx._Buf;

  0139b	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0139f	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  013a4	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  013a9	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;

  013ac	4c 89 45 9f	 mov	 QWORD PTR buf2$412[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  013b0	49 ff c0	 inc	 r8
  013b3	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  013b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 583  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  013bd	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$412[rbp-161]
  013c1	49 8d 50 ff	 lea	 rdx, QWORD PTR [r8-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  013c5	4c 3b c2	 cmp	 r8, rdx
  013c8	0f 82 bb 04 00
	00		 jb	 $LN3060@Wczytaj_z_

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  013ce	49 8b c0	 mov	 rax, r8
  013d1	48 2b c2	 sub	 rax, rdx
  013d4	48 83 f8 01	 cmp	 rax, 1
  013d8	41 b9 01 00 00
	00		 mov	 r9d, 1
  013de	4c 0f 42 c8	 cmovb	 r9, rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  013e2	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  013e6	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1583 : 		if (_Large_string_engaged())

  013eb	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]

; 2605 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  013f0	48 03 ca	 add	 rcx, rdx

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  013f3	4d 2b c1	 sub	 r8, r9

; 2607 : 		_My_data._Mysize = _New_size;

  013f6	4c 89 45 9f	 mov	 QWORD PTR buf2$412[rbp-161], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  013fa	4c 2b c2	 sub	 r8, rdx
  013fd	49 ff c0	 inc	 r8
  01400	4a 8d 14 09	 lea	 rdx, QWORD PTR [rcx+r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  01404	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0140a	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0140e	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1594 : 		if (_Large_string_engaged())

  01413	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 584  : 			iloæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekcie na wartoæ w zmiennnej liczbowej

  01418	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0141e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iloæ_pieniêdzy$GSCopy$1$[rsp]
  01423	89 01		 mov	 DWORD PTR [rcx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01425	48 8b 55 a7	 mov	 rdx, QWORD PTR buf2$412[rbp-153]
  01429	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  0142d	72 50		 jb	 SHORT $LN3043@Wczytaj_z_

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0142f	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01432	48 8b 45 8f	 mov	 rax, QWORD PTR buf2$412[rbp-177]
  01436	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01439	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  01440	0f 82 ee f8 ff
	ff		 jb	 $LN1563@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01446	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  0144a	4c 3b c2	 cmp	 r8, rdx
  0144d	76 22		 jbe	 SHORT $_Invalid_parameter$3065

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0144f	49 8b d0	 mov	 rdx, r8
  01452	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01455	75 1a		 jne	 SHORT $_Invalid_parameter$3065

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01457	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0145b	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0145e	73 11		 jae	 SHORT $_Invalid_parameter$3065

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01460	48 2b c8	 sub	 rcx, rax
  01463	48 83 e9 08	 sub	 rcx, 8
  01467	48 83 f9 1f	 cmp	 rcx, 31
  0146b	0f 86 c3 f8 ff
	ff		 jbe	 $LN1563@Wczytaj_z_
$_Invalid_parameter$3065:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  01471	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01477	cc		 int	 3
$LN2877@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  01478	48 2b df	 sub	 rbx, rdi
$LN50@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 592  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku

  0147b	41 c6 07 6e	 mov	 BYTE PTR [r15], 110	; 0000006eH
$LN3043@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3694 : 		if (_My_data._Large_string_engaged())

  0147f	45 33 e4	 xor	 r12d, r12d
$LN51@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1391 : 		if (_Filebuffer.close() == 0)

  01482	49 8d 4e 18	 lea	 rcx, QWORD PTR [r14+24]
  01486	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  0148b	48 85 c0	 test	 rax, rax
  0148e	75 17		 jne	 SHORT $LN2688@Wczytaj_z_

; 1392 : 			_Myios::setstate(ios_base::failbit);

  01490	49 8b 06	 mov	 rax, QWORD PTR [r14]
  01493	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  01497	49 03 ce	 add	 rcx, r14
  0149a	45 33 c0	 xor	 r8d, r8d
  0149d	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  014a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2688@Wczytaj_z_:

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  014a7	41 b8 0a 00 00
	00		 mov	 r8d, 10
  014ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  014b4	49 8d 4e 18	 lea	 rcx, QWORD PTR [r14+24]
  014b8	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  014bd	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  014c0	4c 63 41 04	 movsxd	 r8, DWORD PTR [rcx+4]

; 1370 : 			_Myios::setstate(ios_base::failbit);

  014c4	4b 8d 0c 06	 lea	 rcx, QWORD PTR [r14+r8]
  014c8	45 33 c0	 xor	 r8d, r8d

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  014cb	48 85 c0	 test	 rax, rax
  014ce	75 0b		 jne	 SHORT $LN2691@Wczytaj_z_

; 1370 : 			_Myios::setstate(ios_base::failbit);

  014d0	8d 50 02	 lea	 edx, QWORD PTR [rax+2]
  014d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1371 : 		else

  014d9	eb 09		 jmp	 SHORT $LN2692@Wczytaj_z_
$LN2691@Wczytaj_z_:

; 1372 : 			_Myios::clear();	// added with C++11

  014db	33 d2		 xor	 edx, edx
  014dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  014e3	90		 npad	 1
$LN2692@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  014e4	48 8b 55 e7	 mov	 rdx, QWORD PTR bufor2$417[rbp-153]
  014e8	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  014ec	72 49		 jb	 SHORT $LN2732@Wczytaj_z_

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  014ee	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  014f1	48 8b 45 cf	 mov	 rax, QWORD PTR bufor2$417[rbp-177]
  014f5	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  014f8	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  014ff	72 2e		 jb	 SHORT $LN2735@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01501	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  01505	4c 3b c2	 cmp	 r8, rdx
  01508	76 1e		 jbe	 SHORT $_Invalid_parameter$3066

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0150a	49 8b d0	 mov	 rdx, r8
  0150d	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01510	75 16		 jne	 SHORT $_Invalid_parameter$3066

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01512	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01516	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01519	73 0d		 jae	 SHORT $_Invalid_parameter$3066

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0151b	48 2b c8	 sub	 rcx, rax
  0151e	48 83 e9 08	 sub	 rcx, 8
  01522	48 83 f9 1f	 cmp	 rcx, 31
  01526	76 07		 jbe	 SHORT $LN2735@Wczytaj_z_
$_Invalid_parameter$3066:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  01528	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0152e	cc		 int	 3
$LN2735@Wczytaj_z_:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0152f	48 8b c8	 mov	 rcx, rax
  01532	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2732@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  01537	4c 89 65 df	 mov	 QWORD PTR bufor2$417[rbp-161], r12

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0153b	48 c7 45 e7 0f
	00 00 00	 mov	 QWORD PTR bufor2$417[rbp-153], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01543	c6 45 cf 00	 mov	 BYTE PTR bufor2$417[rbp-177], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01547	48 8b 55 c7	 mov	 rdx, QWORD PTR buf$416[rbp-153]
  0154b	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  0154f	0f 82 d2 02 00
	00		 jb	 $LN33@Wczytaj_z_

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01555	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01558	48 8b 4d af	 mov	 rcx, QWORD PTR buf$416[rbp-177]
  0155c	48 8b c1	 mov	 rax, rcx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0155f	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  01566	72 2d		 jb	 SHORT $LN2806@Wczytaj_z_

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01568	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  0156c	4c 3b c2	 cmp	 r8, rdx
  0156f	76 1d		 jbe	 SHORT $_Invalid_parameter$3067

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01571	49 8b d0	 mov	 rdx, r8
  01574	a8 1f		 test	 al, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01576	75 16		 jne	 SHORT $_Invalid_parameter$3067

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01578	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0157c	48 3b c8	 cmp	 rcx, rax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0157f	73 0d		 jae	 SHORT $_Invalid_parameter$3067

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01581	48 2b c1	 sub	 rax, rcx
  01584	48 83 e8 08	 sub	 rax, 8
  01588	48 83 f8 1f	 cmp	 rax, 31
  0158c	76 07		 jbe	 SHORT $LN2806@Wczytaj_z_
$_Invalid_parameter$3067:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0158e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01594	cc		 int	 3
$LN2806@Wczytaj_z_:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01595	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 597  : 	else

  0159a	e9 88 02 00 00	 jmp	 $LN33@Wczytaj_z_
$LN32@Wczytaj_z_:

; 598  : 	{
; 599  : 		co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  0159f	41 c6 07 6e	 mov	 BYTE PTR [r15], 110	; 0000006eH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  015a3	41 b8 02 00 00
	00		 mov	 r8d, 2
  015a9	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  015ae	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  015b1	48 63 51 04	 movsxd	 rdx, DWORD PTR [rcx+4]

; 1370 : 			_Myios::setstate(ios_base::failbit);

  015b5	49 8d 0c 16	 lea	 rcx, QWORD PTR [r14+rdx]
  015b9	45 33 c0	 xor	 r8d, r8d

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  015bc	48 85 c0	 test	 rax, rax
  015bf	75 0b		 jne	 SHORT $LN2837@Wczytaj_z_

; 1370 : 			_Myios::setstate(ios_base::failbit);

  015c1	8d 50 02	 lea	 edx, QWORD PTR [rax+2]
  015c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1371 : 		else

  015ca	eb 08		 jmp	 SHORT $LN2838@Wczytaj_z_
$LN2837@Wczytaj_z_:

; 1372 : 			_Myios::clear();	// added with C++11

  015cc	33 d2		 xor	 edx, edx
  015ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2838@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 601  : 		GetSystemTime(&Czas); //Pobieranie aktualnej daty i czasu z zegara systemowego

  015d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Czas@@3U_SYSTEMTIME@@A ; Czas
  015db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemTime

; 602  : 		log << "Gra rozpoczeta dnia " << Czas.wDay << "." << Czas.wMonth << "." << Czas.wYear << " o godzinie "; //Wpisanie do bufora zapisu danych o dniu,miesi¹cu i roku do pliku log_aktualny.txt

  015e1	49 83 c6 10	 add	 r14, 16
  015e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@
  015ec	49 8b ce	 mov	 rcx, r14
  015ef	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  015f4	48 8b c8	 mov	 rcx, rax
  015f7	0f b7 15 06 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+6
  015fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  01604	48 8b c8	 mov	 rcx, rax
  01607	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LFCBOECM@?4?$AA@
  0160e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01613	48 8b c8	 mov	 rcx, rax
  01616	0f b7 15 02 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+2
  0161d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  01623	48 8b c8	 mov	 rcx, rax
  01626	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LFCBOECM@?4?$AA@
  0162d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01632	48 8b c8	 mov	 rcx, rax
  01635	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A
  0163c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  01642	48 8b c8	 mov	 rcx, rax
  01645	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
  0164c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 603  : 		if (Czas.wHour < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania godzinny je¿eli godzina jest minejsza ni¿ 10 do pliku log_aktualny.txt

  01651	0f b7 15 08 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
  01658	66 83 fa 0a	 cmp	 dx, 10
  0165c	73 16		 jae	 SHORT $LN52@Wczytaj_z_
  0165e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  01665	49 8b ce	 mov	 rcx, r14
  01668	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0166d	0f b7 15 08 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
$LN52@Wczytaj_z_:

; 604  : 		log << Czas.wHour << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia godzin od minut do pliku log_aktualny.txt

  01674	49 8b ce	 mov	 rcx, r14
  01677	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  0167d	48 8b c8	 mov	 rcx, rax
  01680	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  01687	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 605  : 		if (Czas.wMinute < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania minut je¿eli minuty jest minejsze ni¿ 10 do pliku log_aktualny.txt

  0168c	0f b7 15 0a 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
  01693	66 83 fa 0a	 cmp	 dx, 10
  01697	73 16		 jae	 SHORT $LN53@Wczytaj_z_
  01699	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  016a0	49 8b ce	 mov	 rcx, r14
  016a3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  016a8	0f b7 15 0a 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
$LN53@Wczytaj_z_:

; 606  : 		log << Czas.wMinute << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia minut od sekund do pliku log_aktualny.txt

  016af	49 8b ce	 mov	 rcx, r14
  016b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  016b8	48 8b c8	 mov	 rcx, rax
  016bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  016c2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 607  : 		if (Czas.wSecond < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania sekund je¿eli sekundy jest minejsza ni¿ 10 do pliku log_aktualny.txt

  016c7	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
  016ce	66 83 fa 0a	 cmp	 dx, 10
  016d2	73 16		 jae	 SHORT $LN54@Wczytaj_z_
  016d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  016db	49 8b ce	 mov	 rcx, r14
  016de	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  016e3	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
$LN54@Wczytaj_z_:

; 608  : 		log << Czas.wSecond << '\n'; // Wpisanie do bufora zapisu danych o sekundzie do pliku log_aktualny.txt

  016ea	49 8b ce	 mov	 rcx, r14
  016ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  016f3	48 8b c8	 mov	 rcx, rax
  016f6	b2 0a		 mov	 dl, 10
  016f8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 609  : 		log_ogólny << "Nowa gra rozpoczeta dnia " << Czas.wDay << "." << Czas.wMonth << "." << Czas.wYear << " o godzinie "; //Wpisanie do bufora zapisu danych o dniu,miesi¹cu i roku do pliku log_ogólny.txt

  016fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@
  01704	48 8b cb	 mov	 rcx, rbx
  01707	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0170c	48 8b c8	 mov	 rcx, rax
  0170f	0f b7 15 06 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+6
  01716	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  0171c	48 8b c8	 mov	 rcx, rax
  0171f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LFCBOECM@?4?$AA@
  01726	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0172b	48 8b c8	 mov	 rcx, rax
  0172e	0f b7 15 02 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+2
  01735	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  0173b	48 8b c8	 mov	 rcx, rax
  0173e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LFCBOECM@?4?$AA@
  01745	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0174a	48 8b c8	 mov	 rcx, rax
  0174d	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A
  01754	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  0175a	48 8b c8	 mov	 rcx, rax
  0175d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
  01764	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 610  : 		if (Czas.wHour < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania godzinny je¿eli godzina jest minejsza ni¿ 10 do pliku log_ogólny.txt

  01769	0f b7 15 08 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
  01770	66 83 fa 0a	 cmp	 dx, 10
  01774	73 16		 jae	 SHORT $LN55@Wczytaj_z_
  01776	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  0177d	48 8b cb	 mov	 rcx, rbx
  01780	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01785	0f b7 15 08 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
$LN55@Wczytaj_z_:

; 611  : 		log_ogólny << Czas.wHour << ":";//Wpisanie do bufora zapisu znaku : dla rozdzielenia godzin od minut do pliku log_aktualny.txt

  0178c	48 8b cb	 mov	 rcx, rbx
  0178f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  01795	48 8b c8	 mov	 rcx, rax
  01798	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  0179f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 612  : 		if (Czas.wMinute < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania minut je¿eli minuty jest minejsza ni¿ 10 do pliku log_ogólny.txt

  017a4	0f b7 15 0a 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
  017ab	66 83 fa 0a	 cmp	 dx, 10
  017af	73 16		 jae	 SHORT $LN56@Wczytaj_z_
  017b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  017b8	48 8b cb	 mov	 rcx, rbx
  017bb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  017c0	0f b7 15 0a 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
$LN56@Wczytaj_z_:

; 613  : 		log_ogólny << Czas.wMinute << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia minut od sekund do pliku log_ogólny.txt

  017c7	48 8b cb	 mov	 rcx, rbx
  017ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  017d0	48 8b c8	 mov	 rcx, rax
  017d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  017da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 614  : 		if (Czas.wSecond < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania sekund je¿eli sekundy jest minejsza ni¿ 10 do pliku log_ogólny.txt

  017df	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
  017e6	66 83 fa 0a	 cmp	 dx, 10
  017ea	73 16		 jae	 SHORT $LN57@Wczytaj_z_
  017ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  017f3	48 8b cb	 mov	 rcx, rbx
  017f6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  017fb	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
$LN57@Wczytaj_z_:

; 615  : 		log_ogólny << Czas.wSecond << '\n'; // Wpisanie do bufora zapisu danych o sekundzie do pliku log_ogólny.txt

  01802	48 8b cb	 mov	 rcx, rbx
  01805	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  0180b	48 8b c8	 mov	 rcx, rax
  0180e	b2 0a		 mov	 dl, 10
  01810	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 616  : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  01815	49 8b ce	 mov	 rcx, r14
  01818	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 617  : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  0181e	48 8b cb	 mov	 rcx, rbx
  01821	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN33@Wczytaj_z_:

; 619  : }

  01827	48 8b 4d ef	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-177]
  0182b	48 33 cc	 xor	 rcx, rsp
  0182e	e8 00 00 00 00	 call	 __security_check_cookie
  01833	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0183a	41 5f		 pop	 r15
  0183c	41 5e		 pop	 r14
  0183e	41 5d		 pop	 r13
  01840	41 5c		 pop	 r12
  01842	5f		 pop	 rdi
  01843	5e		 pop	 rsi
  01844	5b		 pop	 rbx
  01845	5d		 pop	 rbp
  01846	c3		 ret	 0
$LN3049@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  01847	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  0184c	90		 npad	 1
$LN3050@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1611 : 			_Xran();

  0184d	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  01852	90		 npad	 1
$LN3051@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  01853	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  01858	90		 npad	 1
$LN3052@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1611 : 			_Xran();

  01859	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  0185e	cc		 int	 3
$LN3053@Wczytaj_z_:
  0185f	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  01864	cc		 int	 3
$LN3054@Wczytaj_z_:
  01865	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  0186a	cc		 int	 3
$LN3055@Wczytaj_z_:
  0186b	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  01870	90		 npad	 1
$LN3056@Wczytaj_z_:
  01871	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  01876	cc		 int	 3
$LN3057@Wczytaj_z_:
  01877	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  0187c	cc		 int	 3
$LN3058@Wczytaj_z_:
  0187d	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  01882	90		 npad	 1
$LN3059@Wczytaj_z_:
  01883	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  01888	cc		 int	 3
$LN3060@Wczytaj_z_:
  01889	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  0188e	cc		 int	 3
$LN3044@Wczytaj_z_:
?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; Wczytaj_z_pliku
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$0@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR buf$416[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$0
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$1@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$1
  0000c	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR bufor2$417[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$1
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$2@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$2
  00018	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$415[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$2
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$3@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$3
  00024	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$414[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$3
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$4@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$4
  00030	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$413[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$4
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$5@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$5
  0003c	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$412[rdx]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$0@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR buf$416[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$1@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$1
  0000c	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR bufor2$417[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$2@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$2
  00018	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$415[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$3@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$3
  00024	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$414[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$4@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$4
  00030	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$413[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T411 = 56
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf2$415 = 64
buf$416 = 96
bufor2$417 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$5@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$5
  0003c	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$412[rdx]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Sprawd_Pliki@@YAXXZ
_TEXT	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?Sprawd_Pliki@@YAXXZ PROC				; Sprawd_Pliki, COMDAT

; 622  : {

$LN4777:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d a8 08 fe
	ff ff		 lea	 rbp, QWORD PTR [rax-504]
  00013	48 81 ec d0 02
	00 00		 sub	 rsp, 720		; 000002d0H
  0001a	48 c7 45 78 fe
	ff ff ff	 mov	 QWORD PTR $T641[rbp-256], -2
  00022	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00026	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0002a	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c4	 xor	 rax, rsp
  00038	48 89 85 c0 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  0003f	45 33 ed	 xor	 r13d, r13d
  00042	44 89 6c 24 30	 mov	 DWORD PTR $T1[rsp], r13d

; 623  : 	if (Ustawienia.efekty_dwiêkowe == 1) //Je¿eli w³¹czono efekty dwiêkowe

  00047	66 83 3d 18 00
	00 00 01	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, 1
  0004f	0f 85 29 02 00
	00		 jne	 $LN34@Sprawd_P

; 624  : 	{
; 625  : 		if ((_access("Efekty_dwiêkowe", 0))) //Sprawd czy nie ma folderu Efekty dwiêkowe

  00055	33 d2		 xor	 edx, edx
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00064	85 c0		 test	 eax, eax
  00066	74 0f		 je	 SHORT $LN14@Sprawd_P

; 626  : 		{
; 627  : 			CreateDirectoryA("Efekty_dwiêkowe", nullptr); //Je¿eli nie ma to utwórz go

  00068	33 d2		 xor	 edx, edx
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateDirectoryA
$LN14@Sprawd_P:

; 628  : 		}
; 629  : 
; 630  : 		bool czy_pobierano = false; //Utworzenie zmiennej informuj¹c¹ czy rozpoczêto pobieranie plików

  00077	32 db		 xor	 bl, bl

; 631  : 		bool czy_pobrano = true; //Utworzenie zmiennej informuj¹c¹ czy ostatnie pobieranie zakoñczy³o siê sukesem

  00079	40 b7 01	 mov	 dil, 1

; 632  : 
; 633  : 		if ((_access("Efekty_dwiêkowe/bankrut.wav", 0))) //Sprawdzenie czy plik nie istnieje

  0007c	33 d2		 xor	 edx, edx
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  0008b	85 c0		 test	 eax, eax
  0008d	74 78		 je	 SHORT $LN4731@Sprawd_P

; 634  : 		{
; 635  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o
; 636  : 			{
; 637  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0009d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000a2	48 8b c8	 mov	 rcx, rax
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 638  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  000b2	40 0f b6 df	 movzx	 ebx, dil

; 639  : 			}
; 640  : 			auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/bankrut.wav", "Efekty_dwiêkowe/bankrut.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  000b6	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  000bb	45 33 c9	 xor	 r9d, r9d
  000be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@
  000cc	33 c9		 xor	 ecx, ecx
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA

; 641  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  000d4	85 c0		 test	 eax, eax
  000d6	74 2f		 je	 SHORT $LN4731@Sprawd_P

; 642  : 				if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 643  : 				{
; 644  : 					czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false
; 645  : 					cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  000d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  000df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000e6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000eb	48 8b c8	 mov	 rcx, rax
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 646  : 					EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio

  000fb	44 88 2d 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, r13b ; EfektyKompletne

; 647  : 				}
; 648  : 		}
; 649  : 
; 650  : 		if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo

  00102	e9 77 01 00 00	 jmp	 $LN34@Sprawd_P
$LN4731@Sprawd_P:

; 651  : 			if ((_access("Efekty_dwiêkowe/wygrana1.wav", 0))) //Sprawdzenie czy plik nie istnieje

  00107	33 d2		 xor	 edx, edx
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00116	85 c0		 test	 eax, eax
  00118	74 4f		 je	 SHORT $LN4735@Sprawd_P

; 652  : 			{
; 653  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  0011a	84 db		 test	 bl, bl
  0011c	75 25		 jne	 SHORT $LN21@Sprawd_P

; 654  : 				{
; 655  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00125	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0012c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00131	48 8b c8	 mov	 rcx, rax
  00134	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 656  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00141	b3 01		 mov	 bl, 1
$LN21@Sprawd_P:

; 657  : 				}
; 658  : 				auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/wygrana1.wav", "Efekty_dwiêkowe/wygrana1.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  00143	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00148	45 33 c9	 xor	 r9d, r9d
  0014b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@
  00159	33 c9		 xor	 ecx, ecx
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA

; 659  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00161	85 c0		 test	 eax, eax
  00163	0f 85 bc 00 00
	00		 jne	 $LN4770@Sprawd_P
$LN4735@Sprawd_P:

; 660  : 					if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 661  : 					{
; 662  : 						czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false
; 663  : 						cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 664  : 						EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 665  : 					}
; 666  : 			}
; 667  : 
; 668  : 		if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 669  : 			if ((_access("Efekty_dwiêkowe/wygrana2.wav", 0))) //Sprawdzenie czy plik nie istnieje

  00169	33 d2		 xor	 edx, edx
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00178	85 c0		 test	 eax, eax
  0017a	74 4b		 je	 SHORT $LN4737@Sprawd_P

; 670  : 			{
; 671  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  0017c	84 db		 test	 bl, bl
  0017e	75 25		 jne	 SHORT $LN26@Sprawd_P

; 672  : 				{
; 673  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00180	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00187	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0018e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00193	48 8b c8	 mov	 rcx, rax
  00196	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 674  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  001a3	b3 01		 mov	 bl, 1
$LN26@Sprawd_P:

; 675  : 				}
; 676  : 				auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/wygrana2.wav", "Efekty_dwiêkowe/wygrana2.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  001a5	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  001aa	45 33 c9	 xor	 r9d, r9d
  001ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
  001b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@
  001bb	33 c9		 xor	 ecx, ecx
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA

; 677  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  001c3	85 c0		 test	 eax, eax
  001c5	75 5e		 jne	 SHORT $LN4770@Sprawd_P
$LN4737@Sprawd_P:

; 678  : 					if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 679  : 					{
; 680  : 						czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false
; 681  : 						cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 682  : 						EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 683  : 					}
; 684  : 			}
; 685  : 
; 686  : 		if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 687  : 			if ((_access("Efekty_dwiêkowe/zwielokrotnenie.wav", 0))) //Sprawdzenie czy plik nie istnieje

  001c7	33 d2		 xor	 edx, edx
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  001d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  001d6	85 c0		 test	 eax, eax
  001d8	74 78		 je	 SHORT $LN33@Sprawd_P

; 688  : 			{
; 689  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  001da	84 db		 test	 bl, bl
  001dc	75 25		 jne	 SHORT $LN31@Sprawd_P

; 690  : 				{
; 691  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  001de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  001e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001ec	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  001f1	48 8b c8	 mov	 rcx, rax
  001f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 692  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00201	b3 01		 mov	 bl, 1
$LN31@Sprawd_P:

; 693  : 				}
; 694  : 				auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/zwielokrotnenie.wav", "Efekty_dwiêkowe/zwielokrotnenie.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  00203	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00208	45 33 c9	 xor	 r9d, r9d
  0020b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  00212	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@
  00219	33 c9		 xor	 ecx, ecx
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA

; 695  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00221	85 c0		 test	 eax, eax
  00223	74 2d		 je	 SHORT $LN33@Sprawd_P
$LN4770@Sprawd_P:

; 696  : 					if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 697  : 					{
; 698  : 						czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoæ false

  00225	40 32 ff	 xor	 dil, dil

; 699  : 						cout << "Brak plików dla efektów dwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  00228	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  0022f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00236	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0023b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00242	48 8b c8	 mov	 rcx, rax
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 700  : 						EfektyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio

  0024b	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, dil ; EfektyKompletne
$LN33@Sprawd_P:

; 701  : 					}
; 702  : 			}
; 703  : 
; 704  : 		if (czy_pobierano && czy_pobrano) cout << "Pobrano brakuj¹ce pliki efektów" << endl; //Poinformowanie o ukoñczonu pobierania plików

  00252	84 db		 test	 bl, bl
  00254	74 28		 je	 SHORT $LN34@Sprawd_P
  00256	40 84 ff	 test	 dil, dil
  00259	74 23		 je	 SHORT $LN34@Sprawd_P
  0025b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@
  00262	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00269	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0026e	48 8b c8	 mov	 rcx, rax
  00271	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00278	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
$LN34@Sprawd_P:

; 705  : 	}
; 706  : 
; 707  : 	if (Ustawienia.g³os_odczytu_numeru > 0) //Je¿eli w³¹czono odczyt g³osowy

  0027e	66 44 39 2d 14
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, r13w
  00286	0f 8e 5d 20 00
	00		 jle	 $LN35@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2420 : 		if (_Count <= _My_data._Myres)

  0028c	48 8b 05 18 00
	00 00		 mov	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24

; 1582 : 		value_type * _Result = _Bx._Buf;

  00293	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2420 : 		if (_Count <= _My_data._Myres)

  0029a	48 83 f8 05	 cmp	 rax, 5
  0029e	72 36		 jb	 SHORT $LN167@Sprawd_P

; 1583 : 		if (_Large_string_engaged())

  002a0	48 8b df	 mov	 rbx, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  002a3	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  002a7	48 0f 43 1d 00
	00 00 00	 cmovae	 rbx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2423 : 			_My_data._Mysize = _Count;

  002af	48 c7 05 10 00
	00 00 05 00 00
	00		 mov	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 5
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  002ba	41 b8 05 00 00
	00		 mov	 r8d, 5
  002c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  002c7	48 8b cb	 mov	 rcx, rbx
  002ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  002d0	44 88 6b 05	 mov	 BYTE PTR [rbx+5], r13b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  002d4	eb 14		 jmp	 SHORT $LN166@Sprawd_P
$LN167@Sprawd_P:

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  002d6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  002dd	ba 05 00 00 00	 mov	 edx, 5
  002e2	48 8b cf	 mov	 rcx, rdi
  002e5	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN166@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 711  : 		switch (Ustawienia.g³os_odczytu_numeru) //U¿ycie warunku wielokrotnego wyboru do wpisania odpowiedniej nazwy g³osu do zmiennej g³os_nazwa

  002ea	0f bf 05 14 00
	00 00		 movsx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20
  002f1	ff c8		 dec	 eax
  002f3	83 f8 08	 cmp	 eax, 8
  002f6	0f 87 96 00 00
	00		 ja	 $LN45@Sprawd_P
  002fc	48 98		 cdqe
  002fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00305	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN4768@Sprawd_P[rdx+rax*4]
  0030c	48 03 ca	 add	 rcx, rdx
  0030f	ff e1		 jmp	 rcx
$LN36@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00311	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KFCKMKOB@Jacek?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 716  : 			break; //Wyjcie z instrukcji case //Wyjcie z instrukcji case

  00318	eb 6a		 jmp	 SHORT $LN4771@Sprawd_P
$LN37@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0031a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00320	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03FPCJKMNP@Ewa?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 721  : 			break; //Wyjcie z instrukcji case

  00327	eb 61		 jmp	 SHORT $LN4772@Sprawd_P
$LN38@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00329	41 b8 04 00 00
	00		 mov	 r8d, 4
  0032f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04CDICBAGM@Maja?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 726  : 			break; //Wyjcie z instrukcji case

  00336	eb 52		 jmp	 SHORT $LN4772@Sprawd_P
$LN39@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00338	41 b8 03 00 00
	00		 mov	 r8d, 3
  0033e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JIHJHPIE@Jan?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 731  : 			break; //Wyjcie z instrukcji case

  00345	eb 43		 jmp	 SHORT $LN4772@Sprawd_P
$LN40@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00347	41 b8 06 00 00
	00		 mov	 r8d, 6
  0034d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06DKNIKMFF@Jacek2?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 736  : 			break; //Wyjcie z instrukcji case

  00354	eb 34		 jmp	 SHORT $LN4772@Sprawd_P
$LN41@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00356	41 b8 04 00 00
	00		 mov	 r8d, 4
  0035c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04PLEDLCJI@Ewa2?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 742  : 			break; //Wyjcie z instrukcji case

  00363	eb 25		 jmp	 SHORT $LN4772@Sprawd_P
$LN42@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00365	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KJFHPLBC@Maja2?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 747  : 			break; //Wyjcie z instrukcji case

  0036c	eb 16		 jmp	 SHORT $LN4771@Sprawd_P
$LN43@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0036e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00374	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04HDNGKDH@Jan2?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 752  : 			break; //Wyjcie z instrukcji case

  0037b	eb 0d		 jmp	 SHORT $LN4772@Sprawd_P
$LN44@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0037d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05NKPCGME@Agata?$AA@
$LN4771@Sprawd_P:
  00384	41 b8 05 00 00
	00		 mov	 r8d, 5
$LN4772@Sprawd_P:
  0038a	48 8b cf	 mov	 rcx, rdi
  0038d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN45@Sprawd_P:
  00392	41 bf 01 00 00
	00		 mov	 r15d, 1
  00398	45 8b c7	 mov	 r8d, r15d
  0039b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01IDAFKMJL@_?$AA@
  003a2	48 8b cf	 mov	 rcx, rdi
  003a5	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 764  : 		G³os += '0' + Ustawienia.g³os_szybkoæ_odczytu_numeru; //Dodanie do zmiennej szybkoci mowy

  003aa	44 0f b6 0d 16
	00 00 00	 movzx	 r9d, BYTE PTR ?Ustawienia@@3US_Ustawienia@@A+22
  003b2	41 80 c1 30	 add	 r9b, 48			; 00000030H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  003b6	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 2977 : 		if (_Old_size < _My_data._Myres)

  003bd	48 8b 15 18 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24
  003c4	48 3b ca	 cmp	 rcx, rdx
  003c7	73 25		 jae	 SHORT $LN281@Sprawd_P

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  003c9	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  003cd	48 89 05 10 00
	00 00		 mov	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, rax

; 1583 : 		if (_Large_string_engaged())

  003d4	48 8b c7	 mov	 rax, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  003d7	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  003db	48 0f 43 05 00
	00 00 00	 cmovae	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  003e3	44 88 0c 08	 mov	 BYTE PTR [rax+rcx], r9b
  003e7	44 88 6c 08 01	 mov	 BYTE PTR [rax+rcx+1], r13b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  003ec	eb 08		 jmp	 SHORT $LN280@Sprawd_P
$LN281@Sprawd_P:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  003ee	48 8b cf	 mov	 rcx, rdi
  003f1	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN280@Sprawd_P:

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003f6	4d 8b c7	 mov	 r8, r15
  003f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KMDKNFGN@?1?$AA@
  00400	48 8b cf	 mov	 rcx, rdi
  00403	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3683 : 		_My_data._Mysize = 0;

  00408	4c 89 ad b0 00
	00 00		 mov	 QWORD PTR link$643[rbp-240], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0040f	48 c7 85 b8 00
	00 00 0f 00 00
	00		 mov	 QWORD PTR link$643[rbp-232], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0041a	44 88 ad a0 00
	00 00		 mov	 BYTE PTR link$643[rbp-256], r13b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00421	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
  00428	ba 42 00 00 00	 mov	 edx, 66			; 00000042H
  0042d	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR link$643[rbp-256]
  00434	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
  00439	90		 npad	 1

; 3683 : 		_My_data._Mysize = 0;

  0043a	4c 89 ad 90 00
	00 00		 mov	 QWORD PTR g³os2$642[rbp-240], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00441	48 c7 85 98 00
	00 00 0f 00 00
	00		 mov	 QWORD PTR g³os2$642[rbp-232], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0044c	c6 85 80 00 00
	00 00		 mov	 BYTE PTR g³os2$642[rbp-256], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00453	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0045a	48 83 f8 05	 cmp	 rax, 5
  0045e	0f 82 57 1f 00
	00		 jb	 $LN4776@Sprawd_P

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00464	48 83 c0 fb	 add	 rax, -5
  00468	48 83 cb ff	 or	 rbx, -1
  0046c	48 3b c3	 cmp	 rax, rbx
  0046f	48 0f 42 d8	 cmovb	 rbx, rax

; 1594 : 		if (_Large_string_engaged())

  00473	4c 8b cf	 mov	 r9, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00476	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  0047e	4c 0f 43 0d 00
	00 00 00	 cmovae	 r9, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00486	49 83 c1 05	 add	 r9, 5
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0048a	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR g³os2$642[rbp-256]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2420 : 		if (_Count <= _My_data._Myres)

  00491	48 83 fb 0f	 cmp	 rbx, 15
  00495	77 1d		 ja	 SHORT $LN426@Sprawd_P

; 2421 : 			{
; 2422 : 			_Elem * const _Old_ptr = _My_data._Myptr();
; 2423 : 			_My_data._Mysize = _Count;

  00497	48 89 9d 90 00
	00 00		 mov	 QWORD PTR g³os2$642[rbp-240], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0049e	4c 8b c3	 mov	 r8, rbx
  004a1	49 8b d1	 mov	 rdx, r9
  004a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  004aa	c6 84 1d 80 00
	00 00 00	 mov	 BYTE PTR g³os2$642[rbp+rbx-256], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  004b2	eb 09		 jmp	 SHORT $LN425@Sprawd_P
$LN426@Sprawd_P:

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  004b4	48 8b d3	 mov	 rdx, rbx
  004b7	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
  004bc	90		 npad	 1
$LN425@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 771  : 		if ((_access("G³os", 0))) //Sprawd czy nie ma folderu G³os

  004bd	33 d2		 xor	 edx, edx
  004bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04JLFAMLOH@G?$LDos?$AA@
  004c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  004cc	85 c0		 test	 eax, eax
  004ce	74 10		 je	 SHORT $LN46@Sprawd_P

; 772  : 		{
; 773  : 			CreateDirectoryA("G³os", nullptr); //Je¿eli nie ma to utwórz go

  004d0	33 d2		 xor	 edx, edx
  004d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04JLFAMLOH@G?$LDos?$AA@
  004d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateDirectoryA
  004df	90		 npad	 1
$LN46@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  004e0	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  004e8	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T43[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  004ee	c6 44 24 58 00	 mov	 BYTE PTR $T43[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3751 : 	return (_Ans);

  004f3	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR $T1[rsp], 3

; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  004fb	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR g³os2$642[rbp-240]
  00502	48 83 c2 05	 add	 rdx, 5
  00506	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T43[rsp]
  0050b	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00510	41 b8 05 00 00
	00		 mov	 r8d, 5
  00516	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  0051d	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T43[rsp]
  00522	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00527	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0052e	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  00536	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0053e	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  00545	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T43[rsp]
  0054a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0054f	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T43[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00554	48 83 7c 24 70
	10		 cmp	 QWORD PTR $T43[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  0055a	48 0f 43 4c 24
	58		 cmovae	 rcx, QWORD PTR $T43[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 775  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //Sprawd czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoci¹ g³osu

  00560	33 d2		 xor	 edx, edx
  00562	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00568	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0056a	48 8b 54 24 70	 mov	 rdx, QWORD PTR $T43[rsp+24]
  0056f	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00573	72 4a		 jb	 SHORT $LN571@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00575	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00578	4c 8b 44 24 58	 mov	 r8, QWORD PTR $T43[rsp]
  0057d	49 8b c8	 mov	 rcx, r8

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00580	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00587	72 2e		 jb	 SHORT $LN574@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00589	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  0058d	48 3b c2	 cmp	 rax, rdx
  00590	76 1e		 jbe	 SHORT $_Invalid_parameter$4778

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00592	48 8b d0	 mov	 rdx, rax
  00595	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00598	75 16		 jne	 SHORT $_Invalid_parameter$4778

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0059a	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  0059e	4c 3b c1	 cmp	 r8, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  005a1	73 0d		 jae	 SHORT $_Invalid_parameter$4778

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  005a3	49 2b c8	 sub	 rcx, r8
  005a6	48 83 e9 08	 sub	 rcx, 8
  005aa	48 83 f9 1f	 cmp	 rcx, 31
  005ae	76 07		 jbe	 SHORT $LN574@Sprawd_P
$_Invalid_parameter$4778:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  005b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  005b6	cc		 int	 3
$LN574@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  005b7	49 8b c8	 mov	 rcx, r8
  005ba	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN571@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 775  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //Sprawd czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoci¹ g³osu

  005bf	85 db		 test	 ebx, ebx
  005c1	0f 84 de 00 00
	00		 je	 $LN725@Sprawd_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  005c7	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  005cf	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T63[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  005d5	c6 44 24 58 00	 mov	 BYTE PTR $T63[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3751 : 	return (_Ans);

  005da	c7 44 24 30 05
	00 00 00	 mov	 DWORD PTR $T1[rsp], 5

; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  005e2	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR g³os2$642[rbp-240]
  005e9	48 83 c2 05	 add	 rdx, 5
  005ed	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T63[rsp]
  005f2	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  005f7	41 b8 05 00 00
	00		 mov	 r8d, 5
  005fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  00604	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T63[rsp]
  00609	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0060e	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00615	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  0061d	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00625	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  0062c	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T63[rsp]
  00631	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00636	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T63[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0063b	48 83 7c 24 70
	10		 cmp	 QWORD PTR $T63[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  00641	48 0f 43 4c 24
	58		 cmovae	 rcx, QWORD PTR $T63[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 777  : 			CreateDirectoryA(("G³os/" + g³os2).c_str(), nullptr); //Je¿eli nie ma to utwórz go

  00647	33 d2		 xor	 edx, edx
  00649	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateDirectoryA
  0064f	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00650	48 8b 54 24 70	 mov	 rdx, QWORD PTR $T63[rsp+24]
  00655	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00659	72 4a		 jb	 SHORT $LN725@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0065b	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0065e	48 8b 44 24 58	 mov	 rax, QWORD PTR $T63[rsp]
  00663	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00666	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0066d	72 2e		 jb	 SHORT $LN728@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0066f	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00673	4c 3b c2	 cmp	 r8, rdx
  00676	76 1e		 jbe	 SHORT $_Invalid_parameter$4779

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00678	49 8b d0	 mov	 rdx, r8
  0067b	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0067e	75 16		 jne	 SHORT $_Invalid_parameter$4779

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00680	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00684	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00687	73 0d		 jae	 SHORT $_Invalid_parameter$4779

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00689	48 2b c8	 sub	 rcx, rax
  0068c	48 83 e9 08	 sub	 rcx, 8
  00690	48 83 f9 1f	 cmp	 rcx, 31
  00694	76 07		 jbe	 SHORT $LN728@Sprawd_P
$_Invalid_parameter$4779:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00696	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0069c	cc		 int	 3
$LN728@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0069d	48 8b c8	 mov	 rcx, rax
  006a0	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN725@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 780  : 		bool czy_pobierano = false; //Utworzenie zmiennej logicznej informuj¹cej czy jakie pobieranie siê rozpocze³o

  006a5	40 32 f6	 xor	 sil, sil
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  006a8	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  006b0	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T82[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  006b6	40 88 74 24 58	 mov	 BYTE PTR $T82[rsp], sil
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  006bb	c7 44 24 30 09
	00 00 00	 mov	 DWORD PTR $T1[rsp], 9

; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  006c3	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  006ca	48 83 c2 05	 add	 rdx, 5
  006ce	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T82[rsp]
  006d3	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1594 : 		if (_Large_string_engaged())

  006d8	48 8b d7	 mov	 rdx, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006db	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  006e3	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  006eb	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  006f2	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T82[rsp]
  006f7	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  006fc	41 b8 05 00 00
	00		 mov	 r8d, 5
  00702	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNHGCFLK@p?4wav?$AA@
  00709	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T82[rsp]
  0070e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00713	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T82[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00718	48 83 7c 24 70
	10		 cmp	 QWORD PTR $T82[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  0071e	48 0f 43 4c 24
	58		 cmovae	 rcx, QWORD PTR $T82[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 782  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00724	33 d2		 xor	 edx, edx
  00726	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  0072c	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0072e	48 8b 54 24 70	 mov	 rdx, QWORD PTR $T82[rsp+24]
  00733	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00737	72 4a		 jb	 SHORT $LN879@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00739	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0073c	4c 8b 44 24 58	 mov	 r8, QWORD PTR $T82[rsp]
  00741	49 8b c8	 mov	 rcx, r8

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00744	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0074b	72 2e		 jb	 SHORT $LN882@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0074d	4c 8d 4a 27	 lea	 r9, QWORD PTR [rdx+39]
  00751	4c 3b ca	 cmp	 r9, rdx
  00754	76 1e		 jbe	 SHORT $_Invalid_parameter$4780

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00756	49 8b d1	 mov	 rdx, r9
  00759	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0075c	75 16		 jne	 SHORT $_Invalid_parameter$4780

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0075e	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  00762	4c 3b c1	 cmp	 r8, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00765	73 0d		 jae	 SHORT $_Invalid_parameter$4780

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00767	49 2b c8	 sub	 rcx, r8
  0076a	48 83 e9 08	 sub	 rcx, 8
  0076e	48 83 f9 1f	 cmp	 rcx, 31
  00772	76 07		 jbe	 SHORT $LN882@Sprawd_P
$_Invalid_parameter$4780:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00774	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0077a	cc		 int	 3
$LN882@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0077b	49 8b c8	 mov	 rcx, r8
  0077e	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN879@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00783	41 8b c7	 mov	 eax, r15d
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 782  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00786	85 db		 test	 ebx, ebx
  00788	0f 84 5b 03 00
	00		 je	 $LN50@Sprawd_P

; 783  : 		{
; 784  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o
; 785  : 			{
; 786  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0078e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00795	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0079c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  007a1	48 8b c8	 mov	 rcx, rax
  007a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  007ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 787  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  007b1	40 b6 01	 mov	 sil, 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  007b4	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  007bc	f3 0f 7f 45 a8	 movdqu	 XMMWORD PTR $T102[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  007c1	c6 45 98 00	 mov	 BYTE PTR $T102[rbp-256], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3751 : 	return (_Ans);

  007c5	c7 44 24 30 11
	00 00 00	 mov	 DWORD PTR $T1[rsp], 17

; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  007cd	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR g³os2$642[rbp-240]
  007d4	48 83 c2 05	 add	 rdx, 5
  007d8	48 8d 4d 98	 lea	 rcx, QWORD PTR $T102[rbp-256]
  007dc	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  007e1	41 b8 05 00 00
	00		 mov	 r8d, 5
  007e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  007ee	48 8d 4d 98	 lea	 rcx, QWORD PTR $T102[rbp-256]
  007f2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  007f7	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007fe	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  00806	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0080e	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  00815	48 8d 4d 98	 lea	 rcx, QWORD PTR $T102[rbp-256]
  00819	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0081e	41 b8 05 00 00
	00		 mov	 r8d, 5
  00824	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNHGCFLK@p?4wav?$AA@
  0082b	48 8d 4d 98	 lea	 rcx, QWORD PTR $T102[rbp-256]
  0082f	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00834	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  00837	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T119[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0083d	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00840	0f 11 44 24 38	 movups	 XMMWORD PTR $T119[rsp], xmm0
  00845	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00849	0f 11 4c 24 48	 movups	 XMMWORD PTR $T119[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  0084e	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00852	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0085a	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0085d	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00865	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T128[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0086a	c6 44 24 78 00	 mov	 BYTE PTR $T128[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3735 : 	return (_Ans);

  0086f	c7 44 24 30 71
	00 00 00	 mov	 DWORD PTR $T1[rsp], 113	; 00000071H

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());

  00877	48 8b 95 b0 00
	00 00		 mov	 rdx, QWORD PTR link$643[rbp-240]
  0087e	48 03 95 90 00
	00 00		 add	 rdx, QWORD PTR g³os2$642[rbp-240]
  00885	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T128[rsp]
  0088a	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0088f	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$643[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00896	48 83 bd b8 00
	00 00 10	 cmp	 QWORD PTR link$643[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  0089e	48 0f 43 95 a0
	00 00 00	 cmovae	 rdx, QWORD PTR link$643[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  008a6	4c 8b 85 b0 00
	00 00		 mov	 r8, QWORD PTR link$643[rbp-240]
  008ad	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T128[rsp]
  008b2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  008b7	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008be	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  008c6	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  008ce	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  008d5	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T128[rsp]
  008da	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  008df	41 b8 05 00 00
	00		 mov	 r8d, 5
  008e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNHGCFLK@p?4wav?$AA@
  008ec	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T128[rsp]
  008f1	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  008f6	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  008f9	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T147[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  008ff	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00902	0f 11 44 24 58	 movups	 XMMWORD PTR $T147[rsp], xmm0
  00907	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0090b	0f 11 4c 24 68	 movups	 XMMWORD PTR $T147[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00910	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00914	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0091c	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0091f	4c 8d 44 24 38	 lea	 r8, QWORD PTR $T119[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00924	48 83 7c 24 50
	10		 cmp	 QWORD PTR $T119[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  0092a	4c 0f 43 44 24
	38		 cmovae	 r8, QWORD PTR $T119[rsp]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00930	48 8d 54 24 58	 lea	 rdx, QWORD PTR $T147[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00935	48 83 7c 24 70
	10		 cmp	 QWORD PTR $T147[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  0093b	48 0f 43 54 24
	58		 cmovae	 rdx, QWORD PTR $T147[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 789  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00941	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00946	45 33 c9	 xor	 r9d, r9d
  00949	33 c9		 xor	 ecx, ecx
  0094b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  00951	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00953	48 8b 54 24 70	 mov	 rdx, QWORD PTR $T147[rsp+24]
  00958	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  0095c	72 4a		 jb	 SHORT $LN1272@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0095e	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00961	4c 8b 44 24 58	 mov	 r8, QWORD PTR $T147[rsp]
  00966	49 8b c8	 mov	 rcx, r8

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00969	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00970	72 2e		 jb	 SHORT $LN1275@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00972	4c 8d 4a 27	 lea	 r9, QWORD PTR [rdx+39]
  00976	4c 3b ca	 cmp	 r9, rdx
  00979	76 1e		 jbe	 SHORT $_Invalid_parameter$4781

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0097b	49 8b d1	 mov	 rdx, r9
  0097e	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00981	75 16		 jne	 SHORT $_Invalid_parameter$4781

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00983	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  00987	4c 3b c1	 cmp	 r8, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0098a	73 0d		 jae	 SHORT $_Invalid_parameter$4781

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0098c	49 2b c8	 sub	 rcx, r8
  0098f	48 83 e9 08	 sub	 rcx, 8
  00993	48 83 f9 1f	 cmp	 rcx, 31
  00997	76 07		 jbe	 SHORT $LN1275@Sprawd_P
$_Invalid_parameter$4781:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00999	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0099f	cc		 int	 3
$LN1275@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  009a0	49 8b c8	 mov	 rcx, r8
  009a3	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1272@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  009a8	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  009b0	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T147[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  009b6	c6 44 24 58 00	 mov	 BYTE PTR $T147[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009bb	48 8b 55 90	 mov	 rdx, QWORD PTR $T128[rbp-232]
  009bf	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  009c3	72 4a		 jb	 SHORT $LN1343@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  009c5	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  009c8	48 8b 44 24 78	 mov	 rax, QWORD PTR $T128[rsp]
  009cd	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  009d0	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  009d7	72 2e		 jb	 SHORT $LN1346@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  009d9	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  009dd	4c 3b c2	 cmp	 r8, rdx
  009e0	76 1e		 jbe	 SHORT $_Invalid_parameter$4782

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  009e2	49 8b d0	 mov	 rdx, r8
  009e5	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  009e8	75 16		 jne	 SHORT $_Invalid_parameter$4782

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  009ea	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  009ee	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  009f1	73 0d		 jae	 SHORT $_Invalid_parameter$4782

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  009f3	48 2b c8	 sub	 rcx, rax
  009f6	48 83 e9 08	 sub	 rcx, 8
  009fa	48 83 f9 1f	 cmp	 rcx, 31
  009fe	76 07		 jbe	 SHORT $LN1346@Sprawd_P
$_Invalid_parameter$4782:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00a00	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00a06	cc		 int	 3
$LN1346@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00a07	48 8b c8	 mov	 rcx, rax
  00a0a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1343@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00a0f	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00a17	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T128[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00a1c	c6 44 24 78 00	 mov	 BYTE PTR $T128[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a21	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T119[rsp+24]
  00a26	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00a2a	72 4a		 jb	 SHORT $LN1414@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00a2c	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00a2f	48 8b 44 24 38	 mov	 rax, QWORD PTR $T119[rsp]
  00a34	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00a37	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00a3e	72 2e		 jb	 SHORT $LN1417@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00a40	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00a44	4c 3b c2	 cmp	 r8, rdx
  00a47	76 1e		 jbe	 SHORT $_Invalid_parameter$4783

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00a49	49 8b d0	 mov	 rdx, r8
  00a4c	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00a4f	75 16		 jne	 SHORT $_Invalid_parameter$4783

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00a51	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00a55	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00a58	73 0d		 jae	 SHORT $_Invalid_parameter$4783

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00a5a	48 2b c8	 sub	 rcx, rax
  00a5d	48 83 e9 08	 sub	 rcx, 8
  00a61	48 83 f9 1f	 cmp	 rcx, 31
  00a65	76 07		 jbe	 SHORT $LN1417@Sprawd_P
$_Invalid_parameter$4783:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00a67	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00a6d	cc		 int	 3
$LN1417@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00a6e	48 8b c8	 mov	 rcx, rax
  00a71	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1414@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00a76	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00a7e	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T119[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00a84	c6 44 24 38 00	 mov	 BYTE PTR $T119[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a89	48 8b 55 b0	 mov	 rdx, QWORD PTR $T102[rbp-232]
  00a8d	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00a91	72 49		 jb	 SHORT $LN1485@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00a93	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00a96	48 8b 45 98	 mov	 rax, QWORD PTR $T102[rbp-256]
  00a9a	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00a9d	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00aa4	72 2e		 jb	 SHORT $LN1488@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00aa6	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00aaa	4c 3b c2	 cmp	 r8, rdx
  00aad	76 1e		 jbe	 SHORT $_Invalid_parameter$4784

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00aaf	49 8b d0	 mov	 rdx, r8
  00ab2	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00ab5	75 16		 jne	 SHORT $_Invalid_parameter$4784

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00ab7	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00abb	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00abe	73 0d		 jae	 SHORT $_Invalid_parameter$4784

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00ac0	48 2b c8	 sub	 rcx, rax
  00ac3	48 83 e9 08	 sub	 rcx, 8
  00ac7	48 83 f9 1f	 cmp	 rcx, 31
  00acb	76 07		 jbe	 SHORT $LN1488@Sprawd_P
$_Invalid_parameter$4784:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00acd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00ad3	cc		 int	 3
$LN1488@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00ad4	48 8b c8	 mov	 rcx, rax
  00ad7	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1485@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00adc	b8 a1 00 00 00	 mov	 eax, 161		; 000000a1H
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 790  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00ae1	85 db		 test	 ebx, ebx
  00ae3	0f 85 b1 08 00
	00		 jne	 $LN4773@Sprawd_P
$LN50@Sprawd_P:

; 798  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00ae9	8b d8		 mov	 ebx, eax
$_Invalid_parameter$4785:
$_Invalid_parameter$4786:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00aeb	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00af3	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T198[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00af9	c6 44 24 38 00	 mov	 BYTE PTR $T198[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  00afe	0f ba e8 08	 bts	 eax, 8
  00b02	89 44 24 30	 mov	 DWORD PTR $T1[rsp], eax

; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00b06	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00b0d	48 83 c2 05	 add	 rdx, 5
  00b11	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T198[rsp]
  00b16	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1594 : 		if (_Large_string_engaged())

  00b1b	48 8b d7	 mov	 rdx, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b1e	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  00b26	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00b2e	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00b35	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T198[rsp]
  00b3a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00b3f	41 b8 05 00 00
	00		 mov	 r8d, 5
  00b45	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05MEKKEGFB@n?4wav?$AA@
  00b4c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T198[rsp]
  00b51	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00b56	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T198[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b5b	48 83 7c 24 50
	10		 cmp	 QWORD PTR $T198[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  00b61	48 0f 43 4c 24
	38		 cmovae	 rcx, QWORD PTR $T198[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 798  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00b67	33 d2		 xor	 edx, edx
  00b69	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00b6f	44 8b f0	 mov	 r14d, eax
  00b72	44 8b e3	 mov	 r12d, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b75	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T198[rsp+24]
  00b7a	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00b7e	72 4a		 jb	 SHORT $LN1781@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00b80	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00b83	4c 8b 44 24 38	 mov	 r8, QWORD PTR $T198[rsp]
  00b88	49 8b c8	 mov	 rcx, r8

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00b8b	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00b92	72 2e		 jb	 SHORT $LN1784@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00b94	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00b98	48 3b c2	 cmp	 rax, rdx
  00b9b	76 1e		 jbe	 SHORT $_Invalid_parameter$4787

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00b9d	48 8b d0	 mov	 rdx, rax
  00ba0	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00ba3	75 16		 jne	 SHORT $_Invalid_parameter$4787

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00ba5	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  00ba9	4c 3b c1	 cmp	 r8, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00bac	73 0d		 jae	 SHORT $_Invalid_parameter$4787

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00bae	49 2b c8	 sub	 rcx, r8
  00bb1	48 83 e9 08	 sub	 rcx, 8
  00bb5	48 83 f9 1f	 cmp	 rcx, 31
  00bb9	76 07		 jbe	 SHORT $LN1784@Sprawd_P
$_Invalid_parameter$4787:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00bbb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00bc1	cc		 int	 3
$LN1784@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00bc2	49 8b c8	 mov	 rcx, r8
  00bc5	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1781@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 798  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00bca	45 85 f6	 test	 r14d, r14d
  00bcd	0f 84 70 03 00
	00		 je	 $LN53@Sprawd_P

; 799  : 		{
; 800  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  00bd3	40 84 f6	 test	 sil, sil
  00bd6	75 26		 jne	 SHORT $LN52@Sprawd_P

; 801  : 			{
; 802  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00bd8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00bdf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00be6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00beb	48 8b c8	 mov	 rcx, rax
  00bee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00bf5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 803  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00bfb	40 b6 01	 mov	 sil, 1
$LN52@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00bfe	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00c06	f3 0f 7f 45 a8	 movdqu	 XMMWORD PTR $T218[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00c0b	c6 45 98 00	 mov	 BYTE PTR $T218[rbp-256], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3751 : 	return (_Ans);

  00c0f	0f ba eb 09	 bts	 ebx, 9
  00c13	89 5c 24 30	 mov	 DWORD PTR $T1[rsp], ebx

; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  00c17	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR g³os2$642[rbp-240]
  00c1e	48 83 c2 05	 add	 rdx, 5
  00c22	48 8d 4d 98	 lea	 rcx, QWORD PTR $T218[rbp-256]
  00c26	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00c2b	41 b8 05 00 00
	00		 mov	 r8d, 5
  00c31	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  00c38	48 8d 4d 98	 lea	 rcx, QWORD PTR $T218[rbp-256]
  00c3c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00c41	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c48	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  00c50	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00c58	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  00c5f	48 8d 4d 98	 lea	 rcx, QWORD PTR $T218[rbp-256]
  00c63	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00c68	41 b8 05 00 00
	00		 mov	 r8d, 5
  00c6e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05MEKKEGFB@n?4wav?$AA@
  00c75	48 8d 4d 98	 lea	 rcx, QWORD PTR $T218[rbp-256]
  00c79	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00c7e	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  00c81	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T235[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00c87	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00c8a	0f 11 44 24 58	 movups	 XMMWORD PTR $T235[rsp], xmm0
  00c8f	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00c93	0f 11 4c 24 68	 movups	 XMMWORD PTR $T235[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00c98	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00c9c	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00ca4	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00ca7	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00caf	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T244[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00cb4	c6 44 24 78 00	 mov	 BYTE PTR $T244[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3735 : 	return (_Ans);

  00cb9	41 8b c4	 mov	 eax, r12d
  00cbc	0d 00 0e 00 00	 or	 eax, 3584		; 00000e00H
  00cc1	89 44 24 30	 mov	 DWORD PTR $T1[rsp], eax

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());

  00cc5	48 8b 95 b0 00
	00 00		 mov	 rdx, QWORD PTR link$643[rbp-240]
  00ccc	48 03 95 90 00
	00 00		 add	 rdx, QWORD PTR g³os2$642[rbp-240]
  00cd3	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T244[rsp]
  00cd8	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00cdd	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$643[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ce4	48 83 bd b8 00
	00 00 10	 cmp	 QWORD PTR link$643[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  00cec	48 0f 43 95 a0
	00 00 00	 cmovae	 rdx, QWORD PTR link$643[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00cf4	4c 8b 85 b0 00
	00 00		 mov	 r8, QWORD PTR link$643[rbp-240]
  00cfb	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T244[rsp]
  00d00	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00d05	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d0c	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  00d14	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00d1c	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  00d23	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T244[rsp]
  00d28	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00d2d	41 b8 05 00 00
	00		 mov	 r8d, 5
  00d33	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05MEKKEGFB@n?4wav?$AA@
  00d3a	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T244[rsp]
  00d3f	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00d44	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  00d47	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T263[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00d4d	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00d50	0f 11 44 24 38	 movups	 XMMWORD PTR $T263[rsp], xmm0
  00d55	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00d59	0f 11 4c 24 48	 movups	 XMMWORD PTR $T263[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00d5e	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00d62	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00d6a	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3860 : 	return (_STD move(_Left.append(_Right)));

  00d6d	41 8b dc	 mov	 ebx, r12d
  00d70	81 cb 00 1e 00
	00		 or	 ebx, 7680		; 00001e00H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00d76	4c 8d 44 24 58	 lea	 r8, QWORD PTR $T235[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d7b	48 83 7c 24 70
	10		 cmp	 QWORD PTR $T235[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  00d81	4c 0f 43 44 24
	58		 cmovae	 r8, QWORD PTR $T235[rsp]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00d87	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T263[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00d8c	48 83 7c 24 50
	10		 cmp	 QWORD PTR $T263[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  00d92	48 0f 43 54 24
	38		 cmovae	 rdx, QWORD PTR $T263[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 805  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00d98	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00d9d	45 33 c9	 xor	 r9d, r9d
  00da0	33 c9		 xor	 ecx, ecx
  00da2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  00da8	44 8b f0	 mov	 r14d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00dab	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T263[rsp+24]
  00db0	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00db4	72 4a		 jb	 SHORT $LN2174@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00db6	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00db9	4c 8b 44 24 38	 mov	 r8, QWORD PTR $T263[rsp]
  00dbe	49 8b c8	 mov	 rcx, r8

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00dc1	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00dc8	72 2e		 jb	 SHORT $LN2177@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00dca	4c 8d 4a 27	 lea	 r9, QWORD PTR [rdx+39]
  00dce	4c 3b ca	 cmp	 r9, rdx
  00dd1	76 1e		 jbe	 SHORT $_Invalid_parameter$4788

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00dd3	49 8b d1	 mov	 rdx, r9
  00dd6	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00dd9	75 16		 jne	 SHORT $_Invalid_parameter$4788

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00ddb	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  00ddf	4c 3b c1	 cmp	 r8, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00de2	73 0d		 jae	 SHORT $_Invalid_parameter$4788

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00de4	49 2b c8	 sub	 rcx, r8
  00de7	48 83 e9 08	 sub	 rcx, 8
  00deb	48 83 f9 1f	 cmp	 rcx, 31
  00def	76 07		 jbe	 SHORT $LN2177@Sprawd_P
$_Invalid_parameter$4788:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00df1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00df7	cc		 int	 3
$LN2177@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00df8	49 8b c8	 mov	 rcx, r8
  00dfb	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2174@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00e00	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00e08	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T263[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00e0e	c6 44 24 38 00	 mov	 BYTE PTR $T263[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00e13	48 8b 55 90	 mov	 rdx, QWORD PTR $T244[rbp-232]
  00e17	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00e1b	72 4a		 jb	 SHORT $LN2245@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00e1d	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00e20	48 8b 44 24 78	 mov	 rax, QWORD PTR $T244[rsp]
  00e25	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00e28	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00e2f	72 2e		 jb	 SHORT $LN2248@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00e31	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00e35	4c 3b c2	 cmp	 r8, rdx
  00e38	76 1e		 jbe	 SHORT $_Invalid_parameter$4789

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00e3a	49 8b d0	 mov	 rdx, r8
  00e3d	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00e40	75 16		 jne	 SHORT $_Invalid_parameter$4789

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00e42	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00e46	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00e49	73 0d		 jae	 SHORT $_Invalid_parameter$4789

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00e4b	48 2b c8	 sub	 rcx, rax
  00e4e	48 83 e9 08	 sub	 rcx, 8
  00e52	48 83 f9 1f	 cmp	 rcx, 31
  00e56	76 07		 jbe	 SHORT $LN2248@Sprawd_P
$_Invalid_parameter$4789:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00e58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00e5e	cc		 int	 3
$LN2248@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00e5f	48 8b c8	 mov	 rcx, rax
  00e62	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2245@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00e67	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00e6f	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T244[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00e74	c6 44 24 78 00	 mov	 BYTE PTR $T244[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00e79	48 8b 54 24 70	 mov	 rdx, QWORD PTR $T235[rsp+24]
  00e7e	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00e82	72 4a		 jb	 SHORT $LN2316@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00e84	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00e87	48 8b 44 24 58	 mov	 rax, QWORD PTR $T235[rsp]
  00e8c	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00e8f	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00e96	72 2e		 jb	 SHORT $LN2319@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00e98	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00e9c	4c 3b c2	 cmp	 r8, rdx
  00e9f	76 1e		 jbe	 SHORT $_Invalid_parameter$4790

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00ea1	49 8b d0	 mov	 rdx, r8
  00ea4	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00ea7	75 16		 jne	 SHORT $_Invalid_parameter$4790

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00ea9	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00ead	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00eb0	73 0d		 jae	 SHORT $_Invalid_parameter$4790

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00eb2	48 2b c8	 sub	 rcx, rax
  00eb5	48 83 e9 08	 sub	 rcx, 8
  00eb9	48 83 f9 1f	 cmp	 rcx, 31
  00ebd	76 07		 jbe	 SHORT $LN2319@Sprawd_P
$_Invalid_parameter$4790:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00ebf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00ec5	cc		 int	 3
$LN2319@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00ec6	48 8b c8	 mov	 rcx, rax
  00ec9	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2316@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00ece	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00ed6	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T235[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00edc	c6 44 24 58 00	 mov	 BYTE PTR $T235[rsp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 805  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00ee1	81 e3 ff f5 ff
	ff		 and	 ebx, -2561		; fffffffffffff5ffH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ee7	48 8b 55 b0	 mov	 rdx, QWORD PTR $T218[rbp-232]
  00eeb	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00eef	72 49		 jb	 SHORT $LN2387@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00ef1	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00ef4	48 8b 45 98	 mov	 rax, QWORD PTR $T218[rbp-256]
  00ef8	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00efb	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00f02	72 2e		 jb	 SHORT $LN2390@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00f04	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00f08	4c 3b c2	 cmp	 r8, rdx
  00f0b	76 1e		 jbe	 SHORT $_Invalid_parameter$4791

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00f0d	49 8b d0	 mov	 rdx, r8
  00f10	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00f13	75 16		 jne	 SHORT $_Invalid_parameter$4791

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00f15	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00f19	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00f1c	73 0d		 jae	 SHORT $_Invalid_parameter$4791

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00f1e	48 2b c8	 sub	 rcx, rax
  00f21	48 83 e9 08	 sub	 rcx, 8
  00f25	48 83 f9 1f	 cmp	 rcx, 31
  00f29	76 07		 jbe	 SHORT $LN2390@Sprawd_P
$_Invalid_parameter$4791:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00f2b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00f31	cc		 int	 3
$LN2390@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00f32	48 8b c8	 mov	 rcx, rax
  00f35	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2387@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 806  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00f3a	45 85 f6	 test	 r14d, r14d
  00f3d	0f 85 57 04 00
	00		 jne	 $LN4773@Sprawd_P
$LN53@Sprawd_P:

; 814  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00f43	44 8b f3	 mov	 r14d, ebx
$_Invalid_parameter$4792:
$_Invalid_parameter$4793:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00f46	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00f4e	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T310[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00f54	c6 44 24 38 00	 mov	 BYTE PTR $T310[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  00f59	0f ba eb 0d	 bts	 ebx, 13
  00f5d	89 5c 24 30	 mov	 DWORD PTR $T1[rsp], ebx

; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00f61	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00f68	48 83 c2 05	 add	 rdx, 5
  00f6c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T310[rsp]
  00f71	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1594 : 		if (_Large_string_engaged())

  00f76	48 8b d7	 mov	 rdx, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00f79	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  00f81	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00f89	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00f90	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T310[rsp]
  00f95	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00f9a	41 b8 05 00 00
	00		 mov	 r8d, 5
  00fa0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LALOIELB@r?4wav?$AA@
  00fa7	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T310[rsp]
  00fac	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00fb1	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T310[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00fb6	48 83 7c 24 50
	10		 cmp	 QWORD PTR $T310[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  00fbc	48 0f 43 4c 24
	38		 cmovae	 rcx, QWORD PTR $T310[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 814  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00fc2	33 d2		 xor	 edx, edx
  00fc4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00fca	8b d8		 mov	 ebx, eax
  00fcc	45 8b e6	 mov	 r12d, r14d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00fcf	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T310[rsp+24]
  00fd4	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00fd8	72 4a		 jb	 SHORT $LN2650@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00fda	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00fdd	4c 8b 44 24 38	 mov	 r8, QWORD PTR $T310[rsp]
  00fe2	49 8b c8	 mov	 rcx, r8

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00fe5	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00fec	72 2e		 jb	 SHORT $LN2653@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00fee	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00ff2	48 3b c2	 cmp	 rax, rdx
  00ff5	76 1e		 jbe	 SHORT $_Invalid_parameter$4794

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00ff7	48 8b d0	 mov	 rdx, rax
  00ffa	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00ffd	75 16		 jne	 SHORT $_Invalid_parameter$4794

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00fff	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  01003	4c 3b c1	 cmp	 r8, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01006	73 0d		 jae	 SHORT $_Invalid_parameter$4794

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01008	49 2b c8	 sub	 rcx, r8
  0100b	48 83 e9 08	 sub	 rcx, 8
  0100f	48 83 f9 1f	 cmp	 rcx, 31
  01013	76 07		 jbe	 SHORT $LN2653@Sprawd_P
$_Invalid_parameter$4794:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  01015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0101b	cc		 int	 3
$LN2653@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0101c	49 8b c8	 mov	 rcx, r8
  0101f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2650@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 814  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01024	85 db		 test	 ebx, ebx
  01026	0f 84 9d 03 00
	00		 je	 $LN56@Sprawd_P

; 815  : 		{
; 816  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  0102c	40 84 f6	 test	 sil, sil
  0102f	75 26		 jne	 SHORT $LN55@Sprawd_P

; 817  : 			{
; 818  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01038	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0103f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01044	48 8b c8	 mov	 rcx, rax
  01047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0104e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 819  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01054	40 b6 01	 mov	 sil, 1
$LN55@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  01057	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  0105f	f3 0f 7f 45 a8	 movdqu	 XMMWORD PTR $T328[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01064	c6 45 98 00	 mov	 BYTE PTR $T328[rbp-256], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3751 : 	return (_Ans);

  01068	41 0f ba ee 0e	 bts	 r14d, 14
  0106d	44 89 74 24 30	 mov	 DWORD PTR $T1[rsp], r14d

; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  01072	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR g³os2$642[rbp-240]
  01079	48 83 c2 05	 add	 rdx, 5
  0107d	48 8d 4d 98	 lea	 rcx, QWORD PTR $T328[rbp-256]
  01081	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01086	41 b8 05 00 00
	00		 mov	 r8d, 5
  0108c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  01093	48 8d 4d 98	 lea	 rcx, QWORD PTR $T328[rbp-256]
  01097	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0109c	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  010a3	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  010ab	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  010b3	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  010ba	48 8d 4d 98	 lea	 rcx, QWORD PTR $T328[rbp-256]
  010be	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  010c3	41 b8 05 00 00
	00		 mov	 r8d, 5
  010c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LALOIELB@r?4wav?$AA@
  010d0	48 8d 4d 98	 lea	 rcx, QWORD PTR $T328[rbp-256]
  010d4	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  010d9	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  010dc	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T345[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  010e2	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  010e5	0f 11 44 24 58	 movups	 XMMWORD PTR $T345[rsp], xmm0
  010ea	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  010ee	0f 11 4c 24 68	 movups	 XMMWORD PTR $T345[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  010f3	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  010f7	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  010ff	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  01102	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  0110a	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T354[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0110f	c6 44 24 78 00	 mov	 BYTE PTR $T354[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3735 : 	return (_Ans);

  01114	41 8b c4	 mov	 eax, r12d
  01117	0d 00 c0 01 00	 or	 eax, 114688		; 0001c000H
  0111c	89 44 24 30	 mov	 DWORD PTR $T1[rsp], eax

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());

  01120	48 8b 95 b0 00
	00 00		 mov	 rdx, QWORD PTR link$643[rbp-240]
  01127	48 03 95 90 00
	00 00		 add	 rdx, QWORD PTR g³os2$642[rbp-240]
  0112e	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T354[rsp]
  01133	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01138	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$643[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0113f	48 83 bd b8 00
	00 00 10	 cmp	 QWORD PTR link$643[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  01147	48 0f 43 95 a0
	00 00 00	 cmovae	 rdx, QWORD PTR link$643[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0114f	4c 8b 85 b0 00
	00 00		 mov	 r8, QWORD PTR link$643[rbp-240]
  01156	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T354[rsp]
  0115b	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01160	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01167	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  0116f	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  01177	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  0117e	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T354[rsp]
  01183	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01188	41 b8 05 00 00
	00		 mov	 r8d, 5
  0118e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LALOIELB@r?4wav?$AA@
  01195	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T354[rsp]
  0119a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0119f	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  011a2	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T373[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  011a8	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  011ab	0f 11 44 24 38	 movups	 XMMWORD PTR $T373[rsp], xmm0
  011b0	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  011b4	0f 11 4c 24 48	 movups	 XMMWORD PTR $T373[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  011b9	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  011bd	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  011c5	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3860 : 	return (_STD move(_Left.append(_Right)));

  011c8	45 8b f4	 mov	 r14d, r12d
  011cb	41 81 ce 00 c0
	03 00		 or	 r14d, 245760		; 0003c000H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  011d2	4c 8d 44 24 58	 lea	 r8, QWORD PTR $T345[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  011d7	48 83 7c 24 70
	10		 cmp	 QWORD PTR $T345[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  011dd	4c 0f 43 44 24
	58		 cmovae	 r8, QWORD PTR $T345[rsp]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  011e3	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T373[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  011e8	48 83 7c 24 50
	10		 cmp	 QWORD PTR $T373[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  011ee	48 0f 43 54 24
	38		 cmovae	 rdx, QWORD PTR $T373[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 821  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  011f4	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  011f9	45 33 c9	 xor	 r9d, r9d
  011fc	33 c9		 xor	 ecx, ecx
  011fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  01204	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01206	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T373[rsp+24]
  0120b	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  0120f	72 4a		 jb	 SHORT $LN3032@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01211	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01214	4c 8b 44 24 38	 mov	 r8, QWORD PTR $T373[rsp]
  01219	49 8b c8	 mov	 rcx, r8

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0121c	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  01223	72 2e		 jb	 SHORT $LN3035@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01225	4c 8d 4a 27	 lea	 r9, QWORD PTR [rdx+39]
  01229	4c 3b ca	 cmp	 r9, rdx
  0122c	76 1e		 jbe	 SHORT $_Invalid_parameter$4795

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0122e	49 8b d1	 mov	 rdx, r9
  01231	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01234	75 16		 jne	 SHORT $_Invalid_parameter$4795

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01236	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  0123a	4c 3b c1	 cmp	 r8, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0123d	73 0d		 jae	 SHORT $_Invalid_parameter$4795

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0123f	49 2b c8	 sub	 rcx, r8
  01242	48 83 e9 08	 sub	 rcx, 8
  01246	48 83 f9 1f	 cmp	 rcx, 31
  0124a	76 07		 jbe	 SHORT $LN3035@Sprawd_P
$_Invalid_parameter$4795:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0124c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01252	cc		 int	 3
$LN3035@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01253	49 8b c8	 mov	 rcx, r8
  01256	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN3032@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  0125b	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01263	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T373[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01269	c6 44 24 38 00	 mov	 BYTE PTR $T373[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0126e	48 8b 55 90	 mov	 rdx, QWORD PTR $T354[rbp-232]
  01272	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  01276	72 4a		 jb	 SHORT $LN3092@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01278	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0127b	48 8b 44 24 78	 mov	 rax, QWORD PTR $T354[rsp]
  01280	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01283	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0128a	72 2e		 jb	 SHORT $LN3095@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0128c	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  01290	4c 3b c2	 cmp	 r8, rdx
  01293	76 1e		 jbe	 SHORT $_Invalid_parameter$4796

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01295	49 8b d0	 mov	 rdx, r8
  01298	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0129b	75 16		 jne	 SHORT $_Invalid_parameter$4796

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0129d	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  012a1	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  012a4	73 0d		 jae	 SHORT $_Invalid_parameter$4796

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  012a6	48 2b c8	 sub	 rcx, rax
  012a9	48 83 e9 08	 sub	 rcx, 8
  012ad	48 83 f9 1f	 cmp	 rcx, 31
  012b1	76 07		 jbe	 SHORT $LN3095@Sprawd_P
$_Invalid_parameter$4796:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  012b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  012b9	cc		 int	 3
$LN3095@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  012ba	48 8b c8	 mov	 rcx, rax
  012bd	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN3092@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  012c2	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  012ca	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T354[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  012cf	c6 44 24 78 00	 mov	 BYTE PTR $T354[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  012d4	48 8b 54 24 70	 mov	 rdx, QWORD PTR $T345[rsp+24]
  012d9	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  012dd	72 4a		 jb	 SHORT $LN3152@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  012df	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  012e2	48 8b 44 24 58	 mov	 rax, QWORD PTR $T345[rsp]
  012e7	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  012ea	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  012f1	72 2e		 jb	 SHORT $LN3155@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  012f3	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  012f7	4c 3b c2	 cmp	 r8, rdx
  012fa	76 1e		 jbe	 SHORT $_Invalid_parameter$4797

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  012fc	49 8b d0	 mov	 rdx, r8
  012ff	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01302	75 16		 jne	 SHORT $_Invalid_parameter$4797

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01304	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01308	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0130b	73 0d		 jae	 SHORT $_Invalid_parameter$4797

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0130d	48 2b c8	 sub	 rcx, rax
  01310	48 83 e9 08	 sub	 rcx, 8
  01314	48 83 f9 1f	 cmp	 rcx, 31
  01318	76 07		 jbe	 SHORT $LN3155@Sprawd_P
$_Invalid_parameter$4797:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0131a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01320	cc		 int	 3
$LN3155@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01321	48 8b c8	 mov	 rcx, rax
  01324	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN3152@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  01329	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01331	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T345[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01337	c6 44 24 58 00	 mov	 BYTE PTR $T345[rsp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 821  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0133c	41 81 e6 ff bf
	fe ff		 and	 r14d, -81921		; fffffffffffebfffH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01343	48 8b 55 b0	 mov	 rdx, QWORD PTR $T328[rbp-232]
  01347	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  0134b	72 49		 jb	 SHORT $LN3212@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0134d	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01350	48 8b 45 98	 mov	 rax, QWORD PTR $T328[rbp-256]
  01354	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01357	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0135e	72 2e		 jb	 SHORT $LN3215@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01360	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  01364	4c 3b c2	 cmp	 r8, rdx
  01367	76 1e		 jbe	 SHORT $_Invalid_parameter$4798

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01369	49 8b d0	 mov	 rdx, r8
  0136c	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0136f	75 16		 jne	 SHORT $_Invalid_parameter$4798

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01371	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01375	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01378	73 0d		 jae	 SHORT $_Invalid_parameter$4798

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0137a	48 2b c8	 sub	 rcx, rax
  0137d	48 83 e9 08	 sub	 rcx, 8
  01381	48 83 f9 1f	 cmp	 rcx, 31
  01385	76 07		 jbe	 SHORT $LN3215@Sprawd_P
$_Invalid_parameter$4798:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  01387	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0138d	cc		 int	 3
$LN3215@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0138e	48 8b c8	 mov	 rcx, rax
  01391	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN3212@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 822  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01396	85 db		 test	 ebx, ebx
  01398	74 2f		 je	 SHORT $LN56@Sprawd_P
$LN4773@Sprawd_P:

; 823  : 			{
; 824  : 				cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  0139a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  013a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  013a8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  013ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  013b4	48 8b c8	 mov	 rcx, rax
  013b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  013bd	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  013c4	e9 07 0f 00 00	 jmp	 $LN75@Sprawd_P
$LN56@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 830  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  013c9	41 8b de	 mov	 ebx, r14d
$_Invalid_parameter$4799:
$_Invalid_parameter$4800:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  013cc	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  013d4	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T412[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  013da	c6 44 24 38 00	 mov	 BYTE PTR $T412[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  013df	41 0f ba ee 12	 bts	 r14d, 18
  013e4	44 89 74 24 30	 mov	 DWORD PTR $T1[rsp], r14d

; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  013e9	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  013f0	48 83 c2 05	 add	 rdx, 5
  013f4	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T412[rsp]
  013f9	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1594 : 		if (_Large_string_engaged())

  013fe	48 8b d7	 mov	 rdx, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01401	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  01409	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  01411	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  01418	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T412[rsp]
  0141d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01422	41 b8 05 00 00
	00		 mov	 r8d, 5
  01428	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LDGIIGCK@b?4wav?$AA@
  0142f	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T412[rsp]
  01434	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01439	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T412[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0143e	48 83 7c 24 50
	10		 cmp	 QWORD PTR $T412[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  01444	48 0f 43 4c 24
	38		 cmovae	 rcx, QWORD PTR $T412[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 830  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0144a	33 d2		 xor	 edx, edx
  0144c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  01452	44 8b f0	 mov	 r14d, eax
  01455	44 8b e3	 mov	 r12d, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01458	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T412[rsp+24]
  0145d	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  01461	72 4a		 jb	 SHORT $LN3475@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01463	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01466	4c 8b 44 24 38	 mov	 r8, QWORD PTR $T412[rsp]
  0146b	49 8b c8	 mov	 rcx, r8

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0146e	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  01475	72 2e		 jb	 SHORT $LN3478@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01477	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  0147b	48 3b c2	 cmp	 rax, rdx
  0147e	76 1e		 jbe	 SHORT $_Invalid_parameter$4801

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01480	48 8b d0	 mov	 rdx, rax
  01483	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01486	75 16		 jne	 SHORT $_Invalid_parameter$4801

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01488	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  0148c	4c 3b c1	 cmp	 r8, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0148f	73 0d		 jae	 SHORT $_Invalid_parameter$4801

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01491	49 2b c8	 sub	 rcx, r8
  01494	48 83 e9 08	 sub	 rcx, 8
  01498	48 83 f9 1f	 cmp	 rcx, 31
  0149c	76 07		 jbe	 SHORT $LN3478@Sprawd_P
$_Invalid_parameter$4801:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0149e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  014a4	cc		 int	 3
$LN3478@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  014a5	49 8b c8	 mov	 rcx, r8
  014a8	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN3475@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 830  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  014ad	45 85 f6	 test	 r14d, r14d
  014b0	0f 84 70 03 00
	00		 je	 $LN59@Sprawd_P

; 831  : 		{
; 832  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  014b6	40 84 f6	 test	 sil, sil
  014b9	75 26		 jne	 SHORT $LN58@Sprawd_P

; 833  : 			{
; 834  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  014bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  014c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  014c9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  014ce	48 8b c8	 mov	 rcx, rax
  014d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  014d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 835  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  014de	40 b6 01	 mov	 sil, 1
$LN58@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  014e1	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  014e9	f3 0f 7f 45 a8	 movdqu	 XMMWORD PTR $T430[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  014ee	c6 45 98 00	 mov	 BYTE PTR $T430[rbp-256], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3751 : 	return (_Ans);

  014f2	0f ba eb 13	 bts	 ebx, 19
  014f6	89 5c 24 30	 mov	 DWORD PTR $T1[rsp], ebx

; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  014fa	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR g³os2$642[rbp-240]
  01501	48 83 c2 05	 add	 rdx, 5
  01505	48 8d 4d 98	 lea	 rcx, QWORD PTR $T430[rbp-256]
  01509	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0150e	41 b8 05 00 00
	00		 mov	 r8d, 5
  01514	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  0151b	48 8d 4d 98	 lea	 rcx, QWORD PTR $T430[rbp-256]
  0151f	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01524	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0152b	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  01533	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0153b	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  01542	48 8d 4d 98	 lea	 rcx, QWORD PTR $T430[rbp-256]
  01546	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0154b	41 b8 05 00 00
	00		 mov	 r8d, 5
  01551	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LDGIIGCK@b?4wav?$AA@
  01558	48 8d 4d 98	 lea	 rcx, QWORD PTR $T430[rbp-256]
  0155c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  01561	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  01564	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T447[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0156a	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0156d	0f 11 44 24 58	 movups	 XMMWORD PTR $T447[rsp], xmm0
  01572	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  01576	0f 11 4c 24 68	 movups	 XMMWORD PTR $T447[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  0157b	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0157f	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01587	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0158a	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01592	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T456[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01597	c6 44 24 78 00	 mov	 BYTE PTR $T456[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3735 : 	return (_Ans);

  0159c	41 8b c4	 mov	 eax, r12d
  0159f	0d 00 00 38 00	 or	 eax, 3670016		; 00380000H
  015a4	89 44 24 30	 mov	 DWORD PTR $T1[rsp], eax

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());

  015a8	48 8b 95 b0 00
	00 00		 mov	 rdx, QWORD PTR link$643[rbp-240]
  015af	48 03 95 90 00
	00 00		 add	 rdx, QWORD PTR g³os2$642[rbp-240]
  015b6	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T456[rsp]
  015bb	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1593 : 		const value_type * _Result = _Bx._Buf;

  015c0	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$643[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  015c7	48 83 bd b8 00
	00 00 10	 cmp	 QWORD PTR link$643[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  015cf	48 0f 43 95 a0
	00 00 00	 cmovae	 rdx, QWORD PTR link$643[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  015d7	4c 8b 85 b0 00
	00 00		 mov	 r8, QWORD PTR link$643[rbp-240]
  015de	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T456[rsp]
  015e3	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  015e8	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  015ef	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  015f7	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  015ff	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  01606	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T456[rsp]
  0160b	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01610	41 b8 05 00 00
	00		 mov	 r8d, 5
  01616	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LDGIIGCK@b?4wav?$AA@
  0161d	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T456[rsp]
  01622	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  01627	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  0162a	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T475[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01630	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  01633	0f 11 44 24 38	 movups	 XMMWORD PTR $T475[rsp], xmm0
  01638	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0163c	0f 11 4c 24 48	 movups	 XMMWORD PTR $T475[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  01641	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01645	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0164d	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3860 : 	return (_STD move(_Left.append(_Right)));

  01650	41 8b dc	 mov	 ebx, r12d
  01653	81 cb 00 00 78
	00		 or	 ebx, 7864320		; 00780000H

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01659	4c 8d 44 24 58	 lea	 r8, QWORD PTR $T447[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0165e	48 83 7c 24 70
	10		 cmp	 QWORD PTR $T447[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  01664	4c 0f 43 44 24
	58		 cmovae	 r8, QWORD PTR $T447[rsp]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0166a	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T475[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0166f	48 83 7c 24 50
	10		 cmp	 QWORD PTR $T475[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  01675	48 0f 43 54 24
	38		 cmovae	 rdx, QWORD PTR $T475[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 837  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "b.wav").c_str(), ("G³os/" + g³os2 + "b.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0167b	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  01680	45 33 c9	 xor	 r9d, r9d
  01683	33 c9		 xor	 ecx, ecx
  01685	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  0168b	44 8b f0	 mov	 r14d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0168e	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T475[rsp+24]
  01693	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  01697	72 4a		 jb	 SHORT $LN3857@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01699	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0169c	4c 8b 44 24 38	 mov	 r8, QWORD PTR $T475[rsp]
  016a1	49 8b c8	 mov	 rcx, r8

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  016a4	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  016ab	72 2e		 jb	 SHORT $LN3860@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  016ad	4c 8d 4a 27	 lea	 r9, QWORD PTR [rdx+39]
  016b1	4c 3b ca	 cmp	 r9, rdx
  016b4	76 1e		 jbe	 SHORT $_Invalid_parameter$4802

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  016b6	49 8b d1	 mov	 rdx, r9
  016b9	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  016bc	75 16		 jne	 SHORT $_Invalid_parameter$4802

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  016be	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  016c2	4c 3b c1	 cmp	 r8, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  016c5	73 0d		 jae	 SHORT $_Invalid_parameter$4802

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  016c7	49 2b c8	 sub	 rcx, r8
  016ca	48 83 e9 08	 sub	 rcx, 8
  016ce	48 83 f9 1f	 cmp	 rcx, 31
  016d2	76 07		 jbe	 SHORT $LN3860@Sprawd_P
$_Invalid_parameter$4802:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  016d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  016da	cc		 int	 3
$LN3860@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  016db	49 8b c8	 mov	 rcx, r8
  016de	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN3857@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  016e3	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  016eb	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T475[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  016f1	c6 44 24 38 00	 mov	 BYTE PTR $T475[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  016f6	48 8b 55 90	 mov	 rdx, QWORD PTR $T456[rbp-232]
  016fa	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  016fe	72 4a		 jb	 SHORT $LN3917@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01700	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01703	48 8b 44 24 78	 mov	 rax, QWORD PTR $T456[rsp]
  01708	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0170b	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  01712	72 2e		 jb	 SHORT $LN3920@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01714	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  01718	4c 3b c2	 cmp	 r8, rdx
  0171b	76 1e		 jbe	 SHORT $_Invalid_parameter$4803

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0171d	49 8b d0	 mov	 rdx, r8
  01720	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01723	75 16		 jne	 SHORT $_Invalid_parameter$4803

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01725	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01729	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0172c	73 0d		 jae	 SHORT $_Invalid_parameter$4803

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0172e	48 2b c8	 sub	 rcx, rax
  01731	48 83 e9 08	 sub	 rcx, 8
  01735	48 83 f9 1f	 cmp	 rcx, 31
  01739	76 07		 jbe	 SHORT $LN3920@Sprawd_P
$_Invalid_parameter$4803:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0173b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01741	cc		 int	 3
$LN3920@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01742	48 8b c8	 mov	 rcx, rax
  01745	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN3917@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  0174a	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01752	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T456[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01757	c6 44 24 78 00	 mov	 BYTE PTR $T456[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0175c	48 8b 54 24 70	 mov	 rdx, QWORD PTR $T447[rsp+24]
  01761	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  01765	72 4a		 jb	 SHORT $LN3977@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01767	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0176a	48 8b 44 24 58	 mov	 rax, QWORD PTR $T447[rsp]
  0176f	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01772	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  01779	72 2e		 jb	 SHORT $LN3980@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0177b	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  0177f	4c 3b c2	 cmp	 r8, rdx
  01782	76 1e		 jbe	 SHORT $_Invalid_parameter$4804

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01784	49 8b d0	 mov	 rdx, r8
  01787	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0178a	75 16		 jne	 SHORT $_Invalid_parameter$4804

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0178c	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01790	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01793	73 0d		 jae	 SHORT $_Invalid_parameter$4804

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01795	48 2b c8	 sub	 rcx, rax
  01798	48 83 e9 08	 sub	 rcx, 8
  0179c	48 83 f9 1f	 cmp	 rcx, 31
  017a0	76 07		 jbe	 SHORT $LN3980@Sprawd_P
$_Invalid_parameter$4804:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  017a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  017a8	cc		 int	 3
$LN3980@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  017a9	48 8b c8	 mov	 rcx, rax
  017ac	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN3977@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  017b1	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  017b9	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T447[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  017bf	c6 44 24 58 00	 mov	 BYTE PTR $T447[rsp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 837  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "b.wav").c_str(), ("G³os/" + g³os2 + "b.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  017c4	81 e3 ff ff d7
	ff		 and	 ebx, -2621441		; ffffffffffd7ffffH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  017ca	48 8b 55 b0	 mov	 rdx, QWORD PTR $T430[rbp-232]
  017ce	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  017d2	72 49		 jb	 SHORT $LN4037@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  017d4	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  017d7	48 8b 45 98	 mov	 rax, QWORD PTR $T430[rbp-256]
  017db	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  017de	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  017e5	72 2e		 jb	 SHORT $LN4040@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  017e7	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  017eb	4c 3b c2	 cmp	 r8, rdx
  017ee	76 1e		 jbe	 SHORT $_Invalid_parameter$4805

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  017f0	49 8b d0	 mov	 rdx, r8
  017f3	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  017f6	75 16		 jne	 SHORT $_Invalid_parameter$4805

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  017f8	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  017fc	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  017ff	73 0d		 jae	 SHORT $_Invalid_parameter$4805

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01801	48 2b c8	 sub	 rcx, rax
  01804	48 83 e9 08	 sub	 rcx, 8
  01808	48 83 f9 1f	 cmp	 rcx, 31
  0180c	76 07		 jbe	 SHORT $LN4040@Sprawd_P
$_Invalid_parameter$4805:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0180e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01814	cc		 int	 3
$LN4040@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01815	48 8b c8	 mov	 rcx, rax
  01818	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4037@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 838  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0181d	45 85 f6	 test	 r14d, r14d
  01820	0f 85 f3 0a 00
	00		 jne	 $LN4718@Sprawd_P
$LN59@Sprawd_P:

; 846  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01826	44 8b f3	 mov	 r14d, ebx
$_Invalid_parameter$4806:
$_Invalid_parameter$4807:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  01829	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01831	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T514[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01837	c6 44 24 38 00	 mov	 BYTE PTR $T514[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  0183c	0f ba eb 17	 bts	 ebx, 23
  01840	89 5c 24 30	 mov	 DWORD PTR $T1[rsp], ebx

; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  01844	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0184b	48 83 c2 05	 add	 rdx, 5
  0184f	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T514[rsp]
  01854	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01859	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  01861	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  01869	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  01870	48 8b d7	 mov	 rdx, rdi
  01873	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T514[rsp]
  01878	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0187d	41 b8 05 00 00
	00		 mov	 r8d, 5
  01883	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05ODKFBHJJ@g?4wav?$AA@
  0188a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T514[rsp]
  0188f	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01894	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T514[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01899	48 83 7c 24 50
	10		 cmp	 QWORD PTR $T514[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  0189f	48 0f 43 4c 24
	38		 cmovae	 rcx, QWORD PTR $T514[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 846  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  018a5	33 d2		 xor	 edx, edx
  018a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  018ad	8b d8		 mov	 ebx, eax
  018af	41 8b fe	 mov	 edi, r14d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  018b2	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T514[rsp+24]
  018b7	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  018bb	72 4a		 jb	 SHORT $LN4300@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  018bd	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  018c0	4c 8b 44 24 38	 mov	 r8, QWORD PTR $T514[rsp]
  018c5	49 8b c8	 mov	 rcx, r8

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  018c8	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  018cf	72 2e		 jb	 SHORT $LN4303@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  018d1	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  018d5	48 3b c2	 cmp	 rax, rdx
  018d8	76 1e		 jbe	 SHORT $_Invalid_parameter$4808

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  018da	48 8b d0	 mov	 rdx, rax
  018dd	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  018e0	75 16		 jne	 SHORT $_Invalid_parameter$4808

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  018e2	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  018e6	4c 3b c1	 cmp	 r8, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  018e9	73 0d		 jae	 SHORT $_Invalid_parameter$4808

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  018eb	49 2b c8	 sub	 rcx, r8
  018ee	48 83 e9 08	 sub	 rcx, 8
  018f2	48 83 f9 1f	 cmp	 rcx, 31
  018f6	76 07		 jbe	 SHORT $LN4303@Sprawd_P
$_Invalid_parameter$4808:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  018f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  018fe	cc		 int	 3
$LN4303@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  018ff	49 8b c8	 mov	 rcx, r8
  01902	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4300@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 846  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01907	85 db		 test	 ebx, ebx
  01909	0f 84 5b 02 00
	00		 je	 $LN62@Sprawd_P

; 847  : 		{
; 848  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  0190f	40 84 f6	 test	 sil, sil
  01912	75 26		 jne	 SHORT $LN61@Sprawd_P

; 849  : 			{
; 850  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01914	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0191b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01922	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01927	48 8b c8	 mov	 rcx, rax
  0192a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01931	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 851  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01937	40 b6 01	 mov	 sil, 1
$LN61@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0193a	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01942	f3 0f 7f 44 24
	68		 movdqu	 XMMWORD PTR $T532[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01948	c6 44 24 58 00	 mov	 BYTE PTR $T532[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3751 : 	return (_Ans);

  0194d	41 0f ba ee 18	 bts	 r14d, 24
  01952	44 89 74 24 30	 mov	 DWORD PTR $T1[rsp], r14d

; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  01957	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR g³os2$642[rbp-240]
  0195e	48 83 c2 05	 add	 rdx, 5
  01962	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T532[rsp]
  01967	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0196c	41 b8 05 00 00
	00		 mov	 r8d, 5
  01972	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  01979	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T532[rsp]
  0197e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01983	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0198a	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  01992	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0199a	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  019a1	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T532[rsp]
  019a6	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  019ab	41 b8 05 00 00
	00		 mov	 r8d, 5
  019b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05ODKFBHJJ@g?4wav?$AA@
  019b8	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T532[rsp]
  019bd	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  019c2	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  019c5	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T549[rbp-240], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  019ca	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  019cd	0f 11 44 24 78	 movups	 XMMWORD PTR $T549[rsp], xmm0
  019d2	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  019d6	0f 11 4d 88	 movups	 XMMWORD PTR $T549[rbp-240], xmm1

; 3683 : 		_My_data._Mysize = 0;

  019da	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  019de	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  019e6	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  019e9	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  019f1	f3 0f 7f 45 a8	 movdqu	 XMMWORD PTR $T558[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  019f6	c6 45 98 00	 mov	 BYTE PTR $T558[rbp-256], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3735 : 	return (_Ans);

  019fa	81 cf 00 00 00
	07		 or	 edi, 117440512		; 07000000H
  01a00	89 7c 24 30	 mov	 DWORD PTR $T1[rsp], edi

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());

  01a04	48 8b 95 b0 00
	00 00		 mov	 rdx, QWORD PTR link$643[rbp-240]
  01a0b	48 03 95 90 00
	00 00		 add	 rdx, QWORD PTR g³os2$642[rbp-240]
  01a12	48 8d 4d 98	 lea	 rcx, QWORD PTR $T558[rbp-256]
  01a16	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01a1b	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$643[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01a22	48 83 bd b8 00
	00 00 10	 cmp	 QWORD PTR link$643[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  01a2a	48 0f 43 95 a0
	00 00 00	 cmovae	 rdx, QWORD PTR link$643[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  01a32	4c 8b 85 b0 00
	00 00		 mov	 r8, QWORD PTR link$643[rbp-240]
  01a39	48 8d 4d 98	 lea	 rcx, QWORD PTR $T558[rbp-256]
  01a3d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01a42	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR g³os2$642[rbp-256]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01a49	48 83 bd 98 00
	00 00 10	 cmp	 QWORD PTR g³os2$642[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  01a51	48 0f 43 95 80
	00 00 00	 cmovae	 rdx, QWORD PTR g³os2$642[rbp-256]

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  01a59	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR g³os2$642[rbp-240]
  01a60	48 8d 4d 98	 lea	 rcx, QWORD PTR $T558[rbp-256]
  01a64	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01a69	41 b8 05 00 00
	00		 mov	 r8d, 5
  01a6f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05ODKFBHJJ@g?4wav?$AA@
  01a76	48 8d 4d 98	 lea	 rcx, QWORD PTR $T558[rbp-256]
  01a7a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  01a7f	0f 57 c0	 xorps	 xmm0, xmm0

; 1563 : 		_Mysize(0),

  01a82	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T577[rsp+16], xmm0

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01a88	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  01a8b	0f 11 44 24 38	 movups	 XMMWORD PTR $T577[rsp], xmm0
  01a90	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  01a94	0f 11 4c 24 48	 movups	 XMMWORD PTR $T577[rsp+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  01a99	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01a9d	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01aa5	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01aa8	4c 8d 44 24 78	 lea	 r8, QWORD PTR $T549[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01aad	48 83 7d 90 10	 cmp	 QWORD PTR $T549[rbp-232], 16

; 1594 : 		if (_Large_string_engaged())

  01ab2	4c 0f 43 44 24
	78		 cmovae	 r8, QWORD PTR $T549[rsp]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  01ab8	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T577[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01abd	48 83 7c 24 50
	10		 cmp	 QWORD PTR $T577[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  01ac3	48 0f 43 54 24
	38		 cmovae	 rdx, QWORD PTR $T577[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 853  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "g.wav").c_str(), ("G³os/" + g³os2 + "g.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01ac9	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  01ace	45 33 c9	 xor	 r9d, r9d
  01ad1	33 c9		 xor	 ecx, ecx
  01ad3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  01ad9	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  01adb	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T577[rsp+24]
  01ae0	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  01ae4	72 4a		 jb	 SHORT $LN4682@Sprawd_P

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01ae6	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  01ae9	4c 8b 44 24 38	 mov	 r8, QWORD PTR $T577[rsp]
  01aee	49 8b c8	 mov	 rcx, r8

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  01af1	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  01af8	72 2e		 jb	 SHORT $LN4685@Sprawd_P

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  01afa	4c 8d 4a 27	 lea	 r9, QWORD PTR [rdx+39]
  01afe	4c 3b ca	 cmp	 r9, rdx
  01b01	76 1e		 jbe	 SHORT $_Invalid_parameter$4809

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  01b03	49 8b d1	 mov	 rdx, r9
  01b06	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  01b09	75 16		 jne	 SHORT $_Invalid_parameter$4809

; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01b0b	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  01b0f	4c 3b c1	 cmp	 r8, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  01b12	73 0d		 jae	 SHORT $_Invalid_parameter$4809

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  01b14	49 2b c8	 sub	 rcx, r8
  01b17	48 83 e9 08	 sub	 rcx, 8
  01b1b	48 83 f9 1f	 cmp	 rcx, 31
  01b1f	76 07		 jbe	 SHORT $LN4685@Sprawd_P
$_Invalid_parameter$4809:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  01b21	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01b27	cc		 int	 3
$LN4685@Sprawd_P:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  01b28	49 8b c8	 mov	 rcx, r8
  01b2b	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4682@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  01b30	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01b38	f3 0f 7f 44 24
	48		 movdqu	 XMMWORD PTR $T577[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  01b3e	c6 44 24 38 00	 mov	 BYTE PTR $T577[rsp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 853  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "g.wav").c_str(), ("G³os/" + g³os2 + "g.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01b43	48 8d 4d 98	 lea	 rcx, QWORD PTR $T558[rbp-256]
  01b47	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01b4c	90		 npad	 1
  01b4d	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T549[rsp]
  01b52	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01b57	90		 npad	 1
  01b58	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T532[rsp]
  01b5d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 854  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01b62	85 db		 test	 ebx, ebx
  01b64	0f 85 af 07 00
	00		 jne	 $LN4718@Sprawd_P
$LN62@Sprawd_P:

; 855  : 			{
; 856  : 				cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 857  : 				G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 858  : 				return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 859  : 			}
; 860  : 		}
; 861  : 
; 862  : 		if ((_access((G³os + "d.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01b6a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05GFDBGFDH@d?4wav?$AA@
  01b71	48 8d 4d 98	 lea	 rcx, QWORD PTR $T596[rbp-256]
  01b75	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01b7a	48 8b c8	 mov	 rcx, rax
  01b7d	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01b82	48 8b c8	 mov	 rcx, rax
  01b85	33 d2		 xor	 edx, edx
  01b87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  01b8d	8b d8		 mov	 ebx, eax
  01b8f	48 8d 4d 98	 lea	 rcx, QWORD PTR $T596[rbp-256]
  01b93	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01b98	85 db		 test	 ebx, ebx
  01b9a	0f 84 dd 00 00
	00		 je	 $LN65@Sprawd_P

; 863  : 		{
; 864  : 			if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  01ba0	40 84 f6	 test	 sil, sil
  01ba3	75 26		 jne	 SHORT $LN64@Sprawd_P

; 865  : 			{
; 866  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01ba5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01bac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01bb3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01bb8	48 8b c8	 mov	 rcx, rax
  01bbb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01bc2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 867  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01bc8	40 b6 01	 mov	 sil, 1
$LN64@Sprawd_P:

; 868  : 			}
; 869  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "d.wav").c_str(), ("G³os/" + g³os2 + "d.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01bcb	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$642[rbp-256]
  01bd2	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T598[rsp]
  01bd7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01bdc	90		 npad	 1
  01bdd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05GFDBGFDH@d?4wav?$AA@
  01be4	48 8b d0	 mov	 rdx, rax
  01be7	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T599[rsp]
  01bec	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01bf1	48 8b d8	 mov	 rbx, rax
  01bf4	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$642[rbp-256]
  01bfb	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$643[rbp-256]
  01c02	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T600[rsp]
  01c07	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01c0c	90		 npad	 1
  01c0d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05GFDBGFDH@d?4wav?$AA@
  01c14	48 8b d0	 mov	 rdx, rax
  01c17	48 8d 4d 98	 lea	 rcx, QWORD PTR $T601[rbp-256]
  01c1b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01c20	48 8b d0	 mov	 rdx, rax
  01c23	48 8b cb	 mov	 rcx, rbx
  01c26	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01c2b	4c 8b c0	 mov	 r8, rax
  01c2e	48 8b ca	 mov	 rcx, rdx
  01c31	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01c36	48 8b d0	 mov	 rdx, rax
  01c39	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  01c3e	45 33 c9	 xor	 r9d, r9d
  01c41	33 c9		 xor	 ecx, ecx
  01c43	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  01c49	8b d8		 mov	 ebx, eax
  01c4b	48 8d 4d 98	 lea	 rcx, QWORD PTR $T601[rbp-256]
  01c4f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c54	90		 npad	 1
  01c55	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T600[rsp]
  01c5a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c5f	90		 npad	 1
  01c60	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T599[rsp]
  01c65	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c6a	90		 npad	 1
  01c6b	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T598[rsp]
  01c70	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 870  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01c75	85 db		 test	 ebx, ebx
  01c77	0f 85 9c 06 00
	00		 jne	 $LN4718@Sprawd_P
$LN65@Sprawd_P:

; 871  : 			{
; 872  : 				cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 873  : 				G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 874  : 				return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 875  : 			}
; 876  : 		}
; 877  : 
; 878  : 		for (unsigned short i = 1; i <= 3; ++i) //Pêtla licz¹ca od 1 do 3

  01c7d	41 0f b7 ff	 movzx	 edi, r15w
$LL6@Sprawd_P:

; 879  : 		{
; 880  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01c81	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01DICPFPGM@k?$AA@
  01c88	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T602[rsp]
  01c8d	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01c92	90		 npad	 1
  01c93	44 8d 77 30	 lea	 r14d, DWORD PTR [rdi+48]
  01c97	45 0f b6 c6	 movzx	 r8d, r14b
  01c9b	48 8b d0	 mov	 rdx, rax
  01c9e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T603[rsp]
  01ca3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ca8	90		 npad	 1
  01ca9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01cb0	48 8b d0	 mov	 rdx, rax
  01cb3	48 8d 4d 98	 lea	 rcx, QWORD PTR $T604[rbp-256]
  01cb7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01cbc	48 8b c8	 mov	 rcx, rax
  01cbf	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01cc4	48 8b c8	 mov	 rcx, rax
  01cc7	33 d2		 xor	 edx, edx
  01cc9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  01ccf	8b d8		 mov	 ebx, eax
  01cd1	48 8d 4d 98	 lea	 rcx, QWORD PTR $T604[rbp-256]
  01cd5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01cda	90		 npad	 1
  01cdb	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T603[rsp]
  01ce0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01ce5	90		 npad	 1
  01ce6	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T602[rsp]
  01ceb	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01cf0	85 db		 test	 ebx, ebx
  01cf2	0f 84 4f 01 00
	00		 je	 $LN4@Sprawd_P

; 881  : 			{
; 882  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  01cf8	40 84 f6	 test	 sil, sil
  01cfb	75 26		 jne	 SHORT $LN67@Sprawd_P

; 883  : 				{
; 884  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01cfd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01d04	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01d0b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01d10	48 8b c8	 mov	 rcx, rax
  01d13	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01d1a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 885  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01d20	40 b6 01	 mov	 sil, 1
$LN67@Sprawd_P:

; 886  : 				}
; 887  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01d23	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$642[rbp-256]
  01d2a	48 8d 4d b8	 lea	 rcx, QWORD PTR $T606[rbp-256]
  01d2e	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d33	90		 npad	 1
  01d34	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01DICPFPGM@k?$AA@
  01d3b	48 8b d0	 mov	 rdx, rax
  01d3e	48 8d 4d 18	 lea	 rcx, QWORD PTR $T607[rbp-256]
  01d42	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d47	90		 npad	 1
  01d48	45 0f b6 c6	 movzx	 r8d, r14b
  01d4c	48 8b d0	 mov	 rdx, rax
  01d4f	48 8d 4d f8	 lea	 rcx, QWORD PTR $T608[rbp-256]
  01d53	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d58	90		 npad	 1
  01d59	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01d60	48 8b d0	 mov	 rdx, rax
  01d63	48 8d 4d d8	 lea	 rcx, QWORD PTR $T609[rbp-256]
  01d67	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d6c	48 8b d8	 mov	 rbx, rax
  01d6f	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$642[rbp-256]
  01d76	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$643[rbp-256]
  01d7d	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T610[rsp]
  01d82	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d87	90		 npad	 1
  01d88	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01DICPFPGM@k?$AA@
  01d8f	48 8b d0	 mov	 rdx, rax
  01d92	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T611[rsp]
  01d97	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d9c	90		 npad	 1
  01d9d	45 0f b6 c6	 movzx	 r8d, r14b
  01da1	48 8b d0	 mov	 rdx, rax
  01da4	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T612[rsp]
  01da9	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01dae	90		 npad	 1
  01daf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01db6	48 8b d0	 mov	 rdx, rax
  01db9	48 8d 4d 98	 lea	 rcx, QWORD PTR $T613[rbp-256]
  01dbd	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01dc2	48 8b d0	 mov	 rdx, rax
  01dc5	48 8b cb	 mov	 rcx, rbx
  01dc8	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01dcd	4c 8b c0	 mov	 r8, rax
  01dd0	48 8b ca	 mov	 rcx, rdx
  01dd3	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01dd8	48 8b d0	 mov	 rdx, rax
  01ddb	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  01de0	45 33 c9	 xor	 r9d, r9d
  01de3	33 c9		 xor	 ecx, ecx
  01de5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  01deb	8b d8		 mov	 ebx, eax
  01ded	48 8d 4d 98	 lea	 rcx, QWORD PTR $T613[rbp-256]
  01df1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01df6	90		 npad	 1
  01df7	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T612[rsp]
  01dfc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e01	90		 npad	 1
  01e02	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T611[rsp]
  01e07	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e0c	90		 npad	 1
  01e0d	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T610[rsp]
  01e12	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e17	90		 npad	 1
  01e18	48 8d 4d d8	 lea	 rcx, QWORD PTR $T609[rbp-256]
  01e1c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e21	90		 npad	 1
  01e22	48 8d 4d f8	 lea	 rcx, QWORD PTR $T608[rbp-256]
  01e26	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e2b	90		 npad	 1
  01e2c	48 8d 4d 18	 lea	 rcx, QWORD PTR $T607[rbp-256]
  01e30	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e35	90		 npad	 1
  01e36	48 8d 4d b8	 lea	 rcx, QWORD PTR $T606[rbp-256]
  01e3a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 888  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01e3f	85 db		 test	 ebx, ebx
  01e41	0f 85 d2 04 00
	00		 jne	 $LN4718@Sprawd_P
$LN4@Sprawd_P:

; 871  : 			{
; 872  : 				cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 873  : 				G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio
; 874  : 				return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 875  : 			}
; 876  : 		}
; 877  : 
; 878  : 		for (unsigned short i = 1; i <= 3; ++i) //Pêtla licz¹ca od 1 do 3

  01e47	66 ff c7	 inc	 di
  01e4a	66 83 ff 03	 cmp	 di, 3
  01e4e	0f 86 2d fe ff
	ff		 jbe	 $LL6@Sprawd_P
$LL9@Sprawd_P:

; 898  : 		{
; 899  : 			stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  01e54	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$645[rbp-256]
  01e5b	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
  01e60	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$645[rbp-256]
  01e67	e8 00 00 00 00	 call	 ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  01e6c	90		 npad	 1

; 900  : 			numers << i; //Wpisanie do typu wartoci z obrotu pêtli

  01e6d	41 0f b7 d7	 movzx	 edx, r15w
  01e71	48 8d 8d d0 00
	00 00		 lea	 rcx, QWORD PTR numers$645[rbp-240]
  01e78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z

; 901  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01e7e	48 8d 55 d8	 lea	 rdx, QWORD PTR $T614[rbp-256]
  01e82	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$645[rbp-256]
  01e89	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01e8e	48 8b d8	 mov	 rbx, rax
  01e91	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
  01e98	48 8d 4d f8	 lea	 rcx, QWORD PTR $T615[rbp-256]
  01e9c	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ea1	90		 npad	 1
  01ea2	4c 8b c3	 mov	 r8, rbx
  01ea5	48 8b d0	 mov	 rdx, rax
  01ea8	48 8d 4d 18	 lea	 rcx, QWORD PTR $T616[rbp-256]
  01eac	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01eb1	90		 npad	 1
  01eb2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01eb9	48 8b d0	 mov	 rdx, rax
  01ebc	48 8d 4d b8	 lea	 rcx, QWORD PTR $T617[rbp-256]
  01ec0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ec5	48 8b c8	 mov	 rcx, rax
  01ec8	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01ecd	48 8b c8	 mov	 rcx, rax
  01ed0	33 d2		 xor	 edx, edx
  01ed2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  01ed8	8b d8		 mov	 ebx, eax
  01eda	48 8d 4d b8	 lea	 rcx, QWORD PTR $T617[rbp-256]
  01ede	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01ee3	90		 npad	 1
  01ee4	48 8d 4d 18	 lea	 rcx, QWORD PTR $T616[rbp-256]
  01ee8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01eed	90		 npad	 1
  01eee	48 8d 4d f8	 lea	 rcx, QWORD PTR $T615[rbp-256]
  01ef2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01ef7	90		 npad	 1
  01ef8	48 8d 4d d8	 lea	 rcx, QWORD PTR $T614[rbp-256]
  01efc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f01	85 db		 test	 ebx, ebx
  01f03	0f 84 87 01 00
	00		 je	 $LN71@Sprawd_P

; 902  : 			{
; 903  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  01f09	40 84 f6	 test	 sil, sil
  01f0c	75 26		 jne	 SHORT $LN70@Sprawd_P

; 904  : 				{
; 905  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01f0e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01f15	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01f1c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01f21	48 8b c8	 mov	 rcx, rax
  01f24	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01f2b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 906  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01f31	40 b6 01	 mov	 sil, 1
$LN70@Sprawd_P:

; 907  : 				}
; 908  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01f34	48 8d 55 58	 lea	 rdx, QWORD PTR $T619[rbp-256]
  01f38	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$645[rbp-256]
  01f3f	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01f44	48 8b d8	 mov	 rbx, rax
  01f47	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$642[rbp-256]
  01f4e	48 8d 4d 38	 lea	 rcx, QWORD PTR $T620[rbp-256]
  01f52	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01f57	90		 npad	 1
  01f58	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
  01f5f	48 8b d0	 mov	 rdx, rax
  01f62	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T621[rsp]
  01f67	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01f6c	90		 npad	 1
  01f6d	4c 8b c3	 mov	 r8, rbx
  01f70	48 8b d0	 mov	 rdx, rax
  01f73	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T622[rsp]
  01f78	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01f7d	90		 npad	 1
  01f7e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01f85	48 8b d0	 mov	 rdx, rax
  01f88	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T623[rsp]
  01f8d	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01f92	48 8b f8	 mov	 rdi, rax
  01f95	48 8d 55 98	 lea	 rdx, QWORD PTR $T624[rbp-256]
  01f99	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$645[rbp-256]
  01fa0	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01fa5	48 8b d8	 mov	 rbx, rax
  01fa8	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$642[rbp-256]
  01faf	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$643[rbp-256]
  01fb6	48 8d 4d d8	 lea	 rcx, QWORD PTR $T625[rbp-256]
  01fba	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01fbf	90		 npad	 1
  01fc0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
  01fc7	48 8b d0	 mov	 rdx, rax
  01fca	48 8d 4d f8	 lea	 rcx, QWORD PTR $T626[rbp-256]
  01fce	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01fd3	90		 npad	 1
  01fd4	4c 8b c3	 mov	 r8, rbx
  01fd7	48 8b d0	 mov	 rdx, rax
  01fda	48 8d 4d 18	 lea	 rcx, QWORD PTR $T627[rbp-256]
  01fde	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01fe3	90		 npad	 1
  01fe4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01feb	48 8b d0	 mov	 rdx, rax
  01fee	48 8d 4d b8	 lea	 rcx, QWORD PTR $T628[rbp-256]
  01ff2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ff7	48 8b d0	 mov	 rdx, rax
  01ffa	48 8b cf	 mov	 rcx, rdi
  01ffd	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  02002	4c 8b c0	 mov	 r8, rax
  02005	48 8b ca	 mov	 rcx, rdx
  02008	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0200d	48 8b d0	 mov	 rdx, rax
  02010	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  02015	45 33 c9	 xor	 r9d, r9d
  02018	33 c9		 xor	 ecx, ecx
  0201a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  02020	8b d8		 mov	 ebx, eax
  02022	48 8d 4d b8	 lea	 rcx, QWORD PTR $T628[rbp-256]
  02026	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0202b	90		 npad	 1
  0202c	48 8d 4d 18	 lea	 rcx, QWORD PTR $T627[rbp-256]
  02030	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02035	90		 npad	 1
  02036	48 8d 4d f8	 lea	 rcx, QWORD PTR $T626[rbp-256]
  0203a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0203f	90		 npad	 1
  02040	48 8d 4d d8	 lea	 rcx, QWORD PTR $T625[rbp-256]
  02044	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02049	90		 npad	 1
  0204a	48 8d 4d 98	 lea	 rcx, QWORD PTR $T624[rbp-256]
  0204e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02053	90		 npad	 1
  02054	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T623[rsp]
  02059	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0205e	90		 npad	 1
  0205f	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T622[rsp]
  02064	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02069	90		 npad	 1
  0206a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T621[rsp]
  0206f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02074	90		 npad	 1
  02075	48 8d 4d 38	 lea	 rcx, QWORD PTR $T620[rbp-256]
  02079	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0207e	90		 npad	 1
  0207f	48 8d 4d 58	 lea	 rcx, QWORD PTR $T619[rbp-256]
  02083	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 909  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  02088	85 db		 test	 ebx, ebx
  0208a	0f 85 b5 02 00
	00		 jne	 $LN4719@Sprawd_P
$LN71@Sprawd_P:

; 913  : 					return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 914  : 				}
; 915  : 			}
; 916  : 		}

  02090	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$645[rbp-256]
  02097	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ

; 892  : 					return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 893  : 				}
; 894  : 			}
; 895  : 		}
; 896  : 
; 897  : 		for (unsigned short i = 1; i <= 12; ++i) //Pêtla licz¹ca od 1 do 12

  0209c	66 41 ff c7	 inc	 r15w
  020a0	66 41 83 ff 0c	 cmp	 r15w, 12
  020a5	0f 86 a9 fd ff
	ff		 jbe	 $LL9@Sprawd_P

; 917  : 
; 918  : 		for (unsigned short i = 0; i <= 36; ++i) //Pêtla licz¹ca od 0 do 36

  020ab	45 0f b7 f5	 movzx	 r14d, r13w
  020af	90		 npad	 1
$LL12@Sprawd_P:

; 919  : 		{
; 920  : 			stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  020b0	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$644[rbp-256]
  020b7	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
  020bc	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$644[rbp-256]
  020c3	e8 00 00 00 00	 call	 ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  020c8	90		 npad	 1

; 921  : 			numers << i; //Wpisanie do typu wartoci z obrotu pêtli

  020c9	41 0f b7 d6	 movzx	 edx, r14w
  020cd	48 8d 8d d0 00
	00 00		 lea	 rcx, QWORD PTR numers$644[rbp-240]
  020d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z

; 922  : 			if ((_access((G³os + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  020da	48 8d 55 b8	 lea	 rdx, QWORD PTR $T629[rbp-256]
  020de	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$644[rbp-256]
  020e5	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  020ea	90		 npad	 1
  020eb	4c 8b c0	 mov	 r8, rax
  020ee	48 8d 4d 38	 lea	 rcx, QWORD PTR $T630[rbp-256]
  020f2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  020f7	90		 npad	 1
  020f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  020ff	48 8b d0	 mov	 rdx, rax
  02102	48 8d 4d 58	 lea	 rcx, QWORD PTR $T631[rbp-256]
  02106	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0210b	48 8b c8	 mov	 rcx, rax
  0210e	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  02113	48 8b c8	 mov	 rcx, rax
  02116	33 d2		 xor	 edx, edx
  02118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  0211e	8b d8		 mov	 ebx, eax
  02120	48 8d 4d 58	 lea	 rcx, QWORD PTR $T631[rbp-256]
  02124	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02129	90		 npad	 1
  0212a	48 8d 4d 38	 lea	 rcx, QWORD PTR $T630[rbp-256]
  0212e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02133	90		 npad	 1
  02134	48 8d 4d b8	 lea	 rcx, QWORD PTR $T629[rbp-256]
  02138	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0213d	85 db		 test	 ebx, ebx
  0213f	0f 84 47 01 00
	00		 je	 $LN74@Sprawd_P

; 923  : 			{
; 924  : 				if (!czy_pobierano) //Sprawdzanie czy jakie pobieranie siê rozpocze³o

  02145	40 84 f6	 test	 sil, sil
  02148	75 26		 jne	 SHORT $LN73@Sprawd_P

; 925  : 				{
; 926  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0214a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  02151	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  02158	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0215d	48 8b c8	 mov	 rcx, rax
  02160	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  02167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 927  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  0216d	40 b6 01	 mov	 sil, 1
$LN73@Sprawd_P:

; 928  : 				}
; 929  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  02170	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T633[rsp]
  02175	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$644[rbp-256]
  0217c	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  02181	48 8b d8	 mov	 rbx, rax
  02184	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$642[rbp-256]
  0218b	48 8d 4d 98	 lea	 rcx, QWORD PTR $T634[rbp-256]
  0218f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02194	90		 npad	 1
  02195	4c 8b c3	 mov	 r8, rbx
  02198	48 8b d0	 mov	 rdx, rax
  0219b	48 8d 4d d8	 lea	 rcx, QWORD PTR $T635[rbp-256]
  0219f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  021a4	90		 npad	 1
  021a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  021ac	48 8b d0	 mov	 rdx, rax
  021af	48 8d 4d f8	 lea	 rcx, QWORD PTR $T636[rbp-256]
  021b3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  021b8	48 8b f8	 mov	 rdi, rax
  021bb	48 8d 55 18	 lea	 rdx, QWORD PTR $T637[rbp-256]
  021bf	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$644[rbp-256]
  021c6	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  021cb	48 8b d8	 mov	 rbx, rax
  021ce	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$642[rbp-256]
  021d5	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$643[rbp-256]
  021dc	48 8d 4d b8	 lea	 rcx, QWORD PTR $T638[rbp-256]
  021e0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  021e5	90		 npad	 1
  021e6	4c 8b c3	 mov	 r8, rbx
  021e9	48 8b d0	 mov	 rdx, rax
  021ec	48 8d 4d 38	 lea	 rcx, QWORD PTR $T639[rbp-256]
  021f0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  021f5	90		 npad	 1
  021f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  021fd	48 8b d0	 mov	 rdx, rax
  02200	48 8d 4d 58	 lea	 rcx, QWORD PTR $T640[rbp-256]
  02204	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  02209	48 8b d0	 mov	 rdx, rax
  0220c	48 8b cf	 mov	 rcx, rdi
  0220f	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  02214	4c 8b c0	 mov	 r8, rax
  02217	48 8b ca	 mov	 rcx, rdx
  0221a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0221f	48 8b d0	 mov	 rdx, rax
  02222	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  02227	45 33 c9	 xor	 r9d, r9d
  0222a	33 c9		 xor	 ecx, ecx
  0222c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  02232	8b d8		 mov	 ebx, eax
  02234	48 8d 4d 58	 lea	 rcx, QWORD PTR $T640[rbp-256]
  02238	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0223d	90		 npad	 1
  0223e	48 8d 4d 38	 lea	 rcx, QWORD PTR $T639[rbp-256]
  02242	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02247	90		 npad	 1
  02248	48 8d 4d b8	 lea	 rcx, QWORD PTR $T638[rbp-256]
  0224c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02251	90		 npad	 1
  02252	48 8d 4d 18	 lea	 rcx, QWORD PTR $T637[rbp-256]
  02256	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0225b	90		 npad	 1
  0225c	48 8d 4d f8	 lea	 rcx, QWORD PTR $T636[rbp-256]
  02260	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02265	90		 npad	 1
  02266	48 8d 4d d8	 lea	 rcx, QWORD PTR $T635[rbp-256]
  0226a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0226f	90		 npad	 1
  02270	48 8d 4d 98	 lea	 rcx, QWORD PTR $T634[rbp-256]
  02274	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02279	90		 npad	 1
  0227a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T633[rsp]
  0227f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 930  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  02284	85 db		 test	 ebx, ebx
  02286	0f 85 f4 00 00
	00		 jne	 $LN4720@Sprawd_P
$LN74@Sprawd_P:

; 935  : 				}
; 936  : 			}
; 937  : 		}

  0228c	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$644[rbp-256]
  02293	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ

; 917  : 
; 918  : 		for (unsigned short i = 0; i <= 36; ++i) //Pêtla licz¹ca od 0 do 36

  02298	66 41 ff c6	 inc	 r14w
  0229c	66 41 83 fe 24	 cmp	 r14w, 36		; 00000024H
  022a1	0f 86 09 fe ff
	ff		 jbe	 $LL12@Sprawd_P

; 938  : 
; 939  : 		if (czy_pobierano) cout << "Pobrano brakuj¹ce pliki g³osów" << endl; //Poinformowanie o ukoñczonu pobierania plików

  022a7	40 84 f6	 test	 sil, sil
  022aa	74 24		 je	 SHORT $LN75@Sprawd_P
  022ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@
  022b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  022ba	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  022bf	48 8b c8	 mov	 rcx, rax
  022c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  022c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  022cf	90		 npad	 1
$LN75@Sprawd_P:

; 940  : 	}

  022d0	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR g³os2$642[rbp-256]
  022d7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  022dc	90		 npad	 1
  022dd	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR link$643[rbp-256]
  022e4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN35@Sprawd_P:

; 941  : }

  022e9	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  022f0	48 33 cc	 xor	 rcx, rsp
  022f3	e8 00 00 00 00	 call	 __security_check_cookie
  022f8	4c 8d 9c 24 d0
	02 00 00	 lea	 r11, QWORD PTR [rsp+720]
  02300	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  02304	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  02308	49 8b 7b 40	 mov	 rdi, QWORD PTR [r11+64]
  0230c	49 8b e3	 mov	 rsp, r11
  0230f	41 5f		 pop	 r15
  02311	41 5e		 pop	 r14
  02313	41 5d		 pop	 r13
  02315	41 5c		 pop	 r12
  02317	5d		 pop	 rbp
  02318	c3		 ret	 0
$LN4718@Sprawd_P:

; 889  : 				{
; 890  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  02319	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  02320	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  02327	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0232c	48 8b c8	 mov	 rcx, rax
  0232f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  02336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 891  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio

  0233c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  02343	eb 8b		 jmp	 SHORT $LN75@Sprawd_P
$LN4719@Sprawd_P:

; 910  : 				{
; 911  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  02345	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  0234c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  02353	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  02358	48 8b c8	 mov	 rcx, rax
  0235b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  02362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 912  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio

  02368	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne

; 934  : 					return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej

  0236f	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$644[rbp-256]
  02376	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
  0237b	e9 50 ff ff ff	 jmp	 $LN75@Sprawd_P
$LN4720@Sprawd_P:

; 931  : 				{
; 932  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  02380	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  02387	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0238e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  02393	48 8b c8	 mov	 rcx, rax
  02396	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0239d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 933  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoci false informuj¹cej o niekompletnych plikach audio

  023a3	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne

; 934  : 					return; //Wyjcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej

  023aa	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$644[rbp-256]
  023b1	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
  023b6	e9 15 ff ff ff	 jmp	 $LN75@Sprawd_P
$LN4776@Sprawd_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1611 : 			_Xran();

  023bb	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  023c0	cc		 int	 3
$LN4769@Sprawd_P:
  023c1	0f 1f 00	 npad	 3
$LN4768@Sprawd_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 941  : }

  023c4	00 00 00 00	 DD	 $LN36@Sprawd_P
  023c8	00 00 00 00	 DD	 $LN37@Sprawd_P
  023cc	00 00 00 00	 DD	 $LN38@Sprawd_P
  023d0	00 00 00 00	 DD	 $LN39@Sprawd_P
  023d4	00 00 00 00	 DD	 $LN40@Sprawd_P
  023d8	00 00 00 00	 DD	 $LN41@Sprawd_P
  023dc	00 00 00 00	 DD	 $LN42@Sprawd_P
  023e0	00 00 00 00	 DD	 $LN43@Sprawd_P
  023e4	00 00 00 00	 DD	 $LN44@Sprawd_P
?Sprawd_Pliki@@YAXXZ ENDP				; Sprawd_Pliki
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$0@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$0
  00000	48 8d 8a a0 01
	00 00		 lea	 rcx, QWORD PTR link$643[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$0
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$1@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$1
  0000c	48 8d 8a 80 01
	00 00		 lea	 rcx, QWORD PTR g³os2$642[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$1
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$118@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$118
  00018	40 55		 push	 rbp
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001e	48 8b ea	 mov	 rbp, rdx
  00021	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00024	83 e0 02	 and	 eax, 2
  00027	85 c0		 test	 eax, eax
  00029	74 0d		 je	 SHORT $LN453@dtor$118
  0002b	83 65 30 fd	 and	 DWORD PTR $T1[rbp], -3
  0002f	48 8d 4d 58	 lea	 rcx, QWORD PTR $T43[rbp]
  00033	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN453@dtor$118:
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?dtor$118@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$118
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$148@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$148
  0003e	40 55		 push	 rbp
  00040	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00044	48 8b ea	 mov	 rbp, rdx
  00047	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  0004a	83 e0 04	 and	 eax, 4
  0004d	85 c0		 test	 eax, eax
  0004f	74 0d		 je	 SHORT $LN607@dtor$148
  00051	83 65 30 fb	 and	 DWORD PTR $T1[rbp], -5
  00055	48 8d 4d 58	 lea	 rcx, QWORD PTR $T63[rbp]
  00059	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN607@dtor$148:
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5d		 pop	 rbp
  00063	c3		 ret	 0
?dtor$148@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$148
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$178@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$178
  00064	40 55		 push	 rbp
  00066	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0006a	48 8b ea	 mov	 rbp, rdx
  0006d	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00070	83 e0 08	 and	 eax, 8
  00073	85 c0		 test	 eax, eax
  00075	74 0d		 je	 SHORT $LN761@dtor$178
  00077	83 65 30 f7	 and	 DWORD PTR $T1[rbp], -9
  0007b	48 8d 4d 58	 lea	 rcx, QWORD PTR $T82[rbp]
  0007f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN761@dtor$178:
  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5d		 pop	 rbp
  00089	c3		 ret	 0
?dtor$178@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$178
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$208@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$208
  0008a	40 55		 push	 rbp
  0008c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00090	48 8b ea	 mov	 rbp, rdx
  00093	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00096	83 e0 10	 and	 eax, 16
  00099	85 c0		 test	 eax, eax
  0009b	74 10		 je	 SHORT $LN915@dtor$208
  0009d	83 65 30 ef	 and	 DWORD PTR $T1[rbp], -17
  000a1	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T102[rbp]
  000a8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN915@dtor$208:
  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5d		 pop	 rbp
  000b2	c3		 ret	 0
?dtor$208@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$208
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$6@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$6
  000b3	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T119[rdx]
  000ba	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$6
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$243@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$243
  000bf	40 55		 push	 rbp
  000c1	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000c5	48 8b ea	 mov	 rbp, rdx
  000c8	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  000cb	83 e0 40	 and	 eax, 64			; 00000040H
  000ce	85 c0		 test	 eax, eax
  000d0	74 0d		 je	 SHORT $LN1070@dtor$243
  000d2	83 65 30 bf	 and	 DWORD PTR $T1[rbp], -65	; ffffffffffffffbfH
  000d6	48 8d 4d 78	 lea	 rcx, QWORD PTR $T128[rbp]
  000da	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1070@dtor$243:
  000df	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e3	5d		 pop	 rbp
  000e4	c3		 ret	 0
?dtor$243@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$243
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$365@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$365
  000e5	40 55		 push	 rbp
  000e7	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000eb	48 8b ea	 mov	 rbp, rdx
  000ee	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  000f1	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000f6	85 c0		 test	 eax, eax
  000f8	74 10		 je	 SHORT $LN1663@dtor$365
  000fa	81 65 30 ff fe
	ff ff		 and	 DWORD PTR $T1[rbp], -257 ; fffffffffffffeffH
  00101	48 8d 4d 38	 lea	 rcx, QWORD PTR $T198[rbp]
  00105	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1663@dtor$365:
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	5d		 pop	 rbp
  0010f	c3		 ret	 0
?dtor$365@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$365
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$395@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$395
  00110	40 55		 push	 rbp
  00112	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00116	48 8b ea	 mov	 rbp, rdx
  00119	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  0011c	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00121	85 c0		 test	 eax, eax
  00123	74 13		 je	 SHORT $LN1817@dtor$395
  00125	81 65 30 ff fd
	ff ff		 and	 DWORD PTR $T1[rbp], -513 ; fffffffffffffdffH
  0012c	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T218[rbp]
  00133	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1817@dtor$395:
  00138	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013c	5d		 pop	 rbp
  0013d	c3		 ret	 0
?dtor$395@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$395
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$11@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$11
  0013e	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T235[rdx]
  00145	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$11
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$430@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$430
  0014a	40 55		 push	 rbp
  0014c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00150	48 8b ea	 mov	 rbp, rdx
  00153	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00156	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0015b	85 c0		 test	 eax, eax
  0015d	74 10		 je	 SHORT $LN1972@dtor$430
  0015f	81 65 30 ff f7
	ff ff		 and	 DWORD PTR $T1[rbp], -2049 ; fffffffffffff7ffH
  00166	48 8d 4d 78	 lea	 rcx, QWORD PTR $T244[rbp]
  0016a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1972@dtor$430:
  0016f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00173	5d		 pop	 rbp
  00174	c3		 ret	 0
?dtor$430@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$430
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$546@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$546
  00175	40 55		 push	 rbp
  00177	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0017b	48 8b ea	 mov	 rbp, rdx
  0017e	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00181	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00186	85 c0		 test	 eax, eax
  00188	74 10		 je	 SHORT $LN2543@dtor$546
  0018a	81 65 30 ff df
	ff ff		 and	 DWORD PTR $T1[rbp], -8193 ; ffffffffffffdfffH
  00191	48 8d 4d 38	 lea	 rcx, QWORD PTR $T310[rbp]
  00195	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2543@dtor$546:
  0019a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019e	5d		 pop	 rbp
  0019f	c3		 ret	 0
?dtor$546@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$546
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$573@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$573
  001a0	40 55		 push	 rbp
  001a2	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  001a6	48 8b ea	 mov	 rbp, rdx
  001a9	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  001ac	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  001b1	85 c0		 test	 eax, eax
  001b3	74 13		 je	 SHORT $LN2686@dtor$573
  001b5	81 65 30 ff bf
	ff ff		 and	 DWORD PTR $T1[rbp], -16385 ; ffffffffffffbfffH
  001bc	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T328[rbp]
  001c3	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2686@dtor$573:
  001c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001cc	5d		 pop	 rbp
  001cd	c3		 ret	 0
?dtor$573@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$573
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$16@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$16
  001ce	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T345[rdx]
  001d5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$16
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$608@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$608
  001da	40 55		 push	 rbp
  001dc	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  001e0	48 8b ea	 mov	 rbp, rdx
  001e3	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  001e6	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  001eb	85 c0		 test	 eax, eax
  001ed	74 10		 je	 SHORT $LN2841@dtor$608
  001ef	81 65 30 ff ff
	fe ff		 and	 DWORD PTR $T1[rbp], -65537 ; fffffffffffeffffH
  001f6	48 8d 4d 78	 lea	 rcx, QWORD PTR $T354[rbp]
  001fa	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2841@dtor$608:
  001ff	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00203	5d		 pop	 rbp
  00204	c3		 ret	 0
?dtor$608@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$608
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$712@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$712
  00205	40 55		 push	 rbp
  00207	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0020b	48 8b ea	 mov	 rbp, rdx
  0020e	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00211	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00216	85 c0		 test	 eax, eax
  00218	74 10		 je	 SHORT $LN3368@dtor$712
  0021a	81 65 30 ff ff
	fb ff		 and	 DWORD PTR $T1[rbp], -262145 ; fffffffffffbffffH
  00221	48 8d 4d 38	 lea	 rcx, QWORD PTR $T412[rbp]
  00225	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3368@dtor$712:
  0022a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0022e	5d		 pop	 rbp
  0022f	c3		 ret	 0
?dtor$712@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$712
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$739@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$739
  00230	40 55		 push	 rbp
  00232	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00236	48 8b ea	 mov	 rbp, rdx
  00239	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  0023c	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00241	85 c0		 test	 eax, eax
  00243	74 13		 je	 SHORT $LN3511@dtor$739
  00245	81 65 30 ff ff
	f7 ff		 and	 DWORD PTR $T1[rbp], -524289 ; fffffffffff7ffffH
  0024c	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T430[rbp]
  00253	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3511@dtor$739:
  00258	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0025c	5d		 pop	 rbp
  0025d	c3		 ret	 0
?dtor$739@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$739
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$21@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$21
  0025e	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T447[rdx]
  00265	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$21@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$21
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$774@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$774
  0026a	40 55		 push	 rbp
  0026c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00270	48 8b ea	 mov	 rbp, rdx
  00273	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00276	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  0027b	85 c0		 test	 eax, eax
  0027d	74 10		 je	 SHORT $LN3666@dtor$774
  0027f	81 65 30 ff ff
	df ff		 and	 DWORD PTR $T1[rbp], -2097153 ; ffffffffffdfffffH
  00286	48 8d 4d 78	 lea	 rcx, QWORD PTR $T456[rbp]
  0028a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3666@dtor$774:
  0028f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00293	5d		 pop	 rbp
  00294	c3		 ret	 0
?dtor$774@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$774
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$878@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$878
  00295	40 55		 push	 rbp
  00297	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0029b	48 8b ea	 mov	 rbp, rdx
  0029e	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  002a1	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  002a6	85 c0		 test	 eax, eax
  002a8	74 10		 je	 SHORT $LN4193@dtor$878
  002aa	81 65 30 ff ff
	7f ff		 and	 DWORD PTR $T1[rbp], -8388609 ; ffffffffff7fffffH
  002b1	48 8d 4d 38	 lea	 rcx, QWORD PTR $T514[rbp]
  002b5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4193@dtor$878:
  002ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002be	5d		 pop	 rbp
  002bf	c3		 ret	 0
?dtor$878@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$878
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$905@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$905
  002c0	40 55		 push	 rbp
  002c2	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  002c6	48 8b ea	 mov	 rbp, rdx
  002c9	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  002cc	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  002d1	85 c0		 test	 eax, eax
  002d3	74 10		 je	 SHORT $LN4336@dtor$905
  002d5	81 65 30 ff ff
	ff fe		 and	 DWORD PTR $T1[rbp], -16777217 ; fffffffffeffffffH
  002dc	48 8d 4d 58	 lea	 rcx, QWORD PTR $T532[rbp]
  002e0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4336@dtor$905:
  002e5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002e9	5d		 pop	 rbp
  002ea	c3		 ret	 0
?dtor$905@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$905
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$26@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$26
  002eb	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T549[rdx]
  002f2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$26@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$26
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$940@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$940
  002f7	40 55		 push	 rbp
  002f9	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  002fd	48 8b ea	 mov	 rbp, rdx
  00300	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00303	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00308	85 c0		 test	 eax, eax
  0030a	74 13		 je	 SHORT $LN4491@dtor$940
  0030c	81 65 30 ff ff
	ff fb		 and	 DWORD PTR $T1[rbp], -67108865 ; fffffffffbffffffH
  00313	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T558[rbp]
  0031a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4491@dtor$940:
  0031f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00323	5d		 pop	 rbp
  00324	c3		 ret	 0
?dtor$940@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$940
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$30@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$30
  00325	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T598[rdx]
  0032c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$30@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$30
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$31@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$31
  00331	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T599[rdx]
  00338	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$31@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$31
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$32@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$32
  0033d	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T600[rdx]
  00344	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$32@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$32
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$34@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$34
  00349	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T602[rdx]
  00350	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$34@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$34
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$35@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$35
  00355	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T603[rdx]
  0035c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$35@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$35
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$37@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$37
  00361	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T606[rdx]
  00368	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$37@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$37
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$38@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$38
  0036d	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T607[rdx]
  00374	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$38@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$38
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$39@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$39
  00379	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T608[rdx]
  00380	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$39@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$39
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$40@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$40
  00385	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T609[rdx]
  0038c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$40@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$40
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$41@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$41
  00391	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T610[rdx]
  00398	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$41@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$41
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$42@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$42
  0039d	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T611[rdx]
  003a4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$42@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$42
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$43@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$43
  003a9	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T612[rdx]
  003b0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$43@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$43
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$45@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$45
  003b5	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$645[rdx]
  003bc	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$45@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$45
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$46@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$46
  003c1	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T614[rdx]
  003c8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$46@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$46
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$47@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$47
  003cd	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T615[rdx]
  003d4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$47@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$47
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$48@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$48
  003d9	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T616[rdx]
  003e0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$48@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$48
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$50@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$50
  003e5	48 8d 8a 58 01
	00 00		 lea	 rcx, QWORD PTR $T619[rdx]
  003ec	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$50@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$50
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$51@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$51
  003f1	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T620[rdx]
  003f8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$51@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$51
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$52@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$52
  003fd	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T621[rdx]
  00404	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$52@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$52
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$53@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$53
  00409	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T622[rdx]
  00410	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$53@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$53
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$54@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$54
  00415	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T623[rdx]
  0041c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$54@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$54
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$55@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$55
  00421	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T624[rdx]
  00428	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$55@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$55
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$56@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$56
  0042d	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T625[rdx]
  00434	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$56@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$56
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$57@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$57
  00439	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T626[rdx]
  00440	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$57@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$57
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$58@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$58
  00445	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T627[rdx]
  0044c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$58@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$58
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$60@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$60
  00451	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$644[rdx]
  00458	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$60@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$60
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$61@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$61
  0045d	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T629[rdx]
  00464	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$61@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$61
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$62@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$62
  00469	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T630[rdx]
  00470	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$62@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$62
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$64@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$64
  00475	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T633[rdx]
  0047c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$64@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$64
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$65@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$65
  00481	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T634[rdx]
  00488	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$65@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$65
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$66@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$66
  0048d	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T635[rdx]
  00494	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$66@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$66
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$67@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$67
  00499	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T636[rdx]
  004a0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$67@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$67
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$68@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$68
  004a5	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T637[rdx]
  004ac	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$68@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$68
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$69@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$69
  004b1	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T638[rdx]
  004b8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$69@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$69
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$70@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$70
  004bd	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T639[rdx]
  004c4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$70@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$70
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$0@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$0
  00000	48 8d 8a a0 01
	00 00		 lea	 rcx, QWORD PTR link$643[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$1@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$1
  0000c	48 8d 8a 80 01
	00 00		 lea	 rcx, QWORD PTR g³os2$642[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$118@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$118
  00018	40 55		 push	 rbp
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001e	48 8b ea	 mov	 rbp, rdx
  00021	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00024	83 e0 02	 and	 eax, 2
  00027	85 c0		 test	 eax, eax
  00029	74 0d		 je	 SHORT $LN453@dtor$118
  0002b	83 65 30 fd	 and	 DWORD PTR $T1[rbp], -3
  0002f	48 8d 4d 58	 lea	 rcx, QWORD PTR $T43[rbp]
  00033	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN453@dtor$118:
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?dtor$118@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$118
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$148@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$148
  0003e	40 55		 push	 rbp
  00040	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00044	48 8b ea	 mov	 rbp, rdx
  00047	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  0004a	83 e0 04	 and	 eax, 4
  0004d	85 c0		 test	 eax, eax
  0004f	74 0d		 je	 SHORT $LN607@dtor$148
  00051	83 65 30 fb	 and	 DWORD PTR $T1[rbp], -5
  00055	48 8d 4d 58	 lea	 rcx, QWORD PTR $T63[rbp]
  00059	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN607@dtor$148:
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5d		 pop	 rbp
  00063	c3		 ret	 0
?dtor$148@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$148
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$178@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$178
  00064	40 55		 push	 rbp
  00066	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0006a	48 8b ea	 mov	 rbp, rdx
  0006d	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00070	83 e0 08	 and	 eax, 8
  00073	85 c0		 test	 eax, eax
  00075	74 0d		 je	 SHORT $LN761@dtor$178
  00077	83 65 30 f7	 and	 DWORD PTR $T1[rbp], -9
  0007b	48 8d 4d 58	 lea	 rcx, QWORD PTR $T82[rbp]
  0007f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN761@dtor$178:
  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5d		 pop	 rbp
  00089	c3		 ret	 0
?dtor$178@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$178
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$208@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$208
  0008a	40 55		 push	 rbp
  0008c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00090	48 8b ea	 mov	 rbp, rdx
  00093	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00096	83 e0 10	 and	 eax, 16
  00099	85 c0		 test	 eax, eax
  0009b	74 10		 je	 SHORT $LN915@dtor$208
  0009d	83 65 30 ef	 and	 DWORD PTR $T1[rbp], -17
  000a1	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T102[rbp]
  000a8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN915@dtor$208:
  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5d		 pop	 rbp
  000b2	c3		 ret	 0
?dtor$208@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$208
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$6@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$6
  000b3	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T119[rdx]
  000ba	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$243@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$243
  000bf	40 55		 push	 rbp
  000c1	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000c5	48 8b ea	 mov	 rbp, rdx
  000c8	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  000cb	83 e0 40	 and	 eax, 64			; 00000040H
  000ce	85 c0		 test	 eax, eax
  000d0	74 0d		 je	 SHORT $LN1070@dtor$243
  000d2	83 65 30 bf	 and	 DWORD PTR $T1[rbp], -65	; ffffffffffffffbfH
  000d6	48 8d 4d 78	 lea	 rcx, QWORD PTR $T128[rbp]
  000da	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1070@dtor$243:
  000df	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e3	5d		 pop	 rbp
  000e4	c3		 ret	 0
?dtor$243@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$243
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$365@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$365
  000e5	40 55		 push	 rbp
  000e7	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000eb	48 8b ea	 mov	 rbp, rdx
  000ee	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  000f1	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000f6	85 c0		 test	 eax, eax
  000f8	74 10		 je	 SHORT $LN1663@dtor$365
  000fa	81 65 30 ff fe
	ff ff		 and	 DWORD PTR $T1[rbp], -257 ; fffffffffffffeffH
  00101	48 8d 4d 38	 lea	 rcx, QWORD PTR $T198[rbp]
  00105	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1663@dtor$365:
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	5d		 pop	 rbp
  0010f	c3		 ret	 0
?dtor$365@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$365
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$395@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$395
  00110	40 55		 push	 rbp
  00112	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00116	48 8b ea	 mov	 rbp, rdx
  00119	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  0011c	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00121	85 c0		 test	 eax, eax
  00123	74 13		 je	 SHORT $LN1817@dtor$395
  00125	81 65 30 ff fd
	ff ff		 and	 DWORD PTR $T1[rbp], -513 ; fffffffffffffdffH
  0012c	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T218[rbp]
  00133	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1817@dtor$395:
  00138	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013c	5d		 pop	 rbp
  0013d	c3		 ret	 0
?dtor$395@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$395
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$11@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$11
  0013e	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T235[rdx]
  00145	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$430@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$430
  0014a	40 55		 push	 rbp
  0014c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00150	48 8b ea	 mov	 rbp, rdx
  00153	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00156	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0015b	85 c0		 test	 eax, eax
  0015d	74 10		 je	 SHORT $LN1972@dtor$430
  0015f	81 65 30 ff f7
	ff ff		 and	 DWORD PTR $T1[rbp], -2049 ; fffffffffffff7ffH
  00166	48 8d 4d 78	 lea	 rcx, QWORD PTR $T244[rbp]
  0016a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1972@dtor$430:
  0016f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00173	5d		 pop	 rbp
  00174	c3		 ret	 0
?dtor$430@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$430
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$546@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$546
  00175	40 55		 push	 rbp
  00177	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0017b	48 8b ea	 mov	 rbp, rdx
  0017e	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00181	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00186	85 c0		 test	 eax, eax
  00188	74 10		 je	 SHORT $LN2543@dtor$546
  0018a	81 65 30 ff df
	ff ff		 and	 DWORD PTR $T1[rbp], -8193 ; ffffffffffffdfffH
  00191	48 8d 4d 38	 lea	 rcx, QWORD PTR $T310[rbp]
  00195	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2543@dtor$546:
  0019a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019e	5d		 pop	 rbp
  0019f	c3		 ret	 0
?dtor$546@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$546
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$573@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$573
  001a0	40 55		 push	 rbp
  001a2	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  001a6	48 8b ea	 mov	 rbp, rdx
  001a9	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  001ac	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  001b1	85 c0		 test	 eax, eax
  001b3	74 13		 je	 SHORT $LN2686@dtor$573
  001b5	81 65 30 ff bf
	ff ff		 and	 DWORD PTR $T1[rbp], -16385 ; ffffffffffffbfffH
  001bc	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T328[rbp]
  001c3	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2686@dtor$573:
  001c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001cc	5d		 pop	 rbp
  001cd	c3		 ret	 0
?dtor$573@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$573
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$16@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$16
  001ce	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T345[rdx]
  001d5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$608@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$608
  001da	40 55		 push	 rbp
  001dc	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  001e0	48 8b ea	 mov	 rbp, rdx
  001e3	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  001e6	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  001eb	85 c0		 test	 eax, eax
  001ed	74 10		 je	 SHORT $LN2841@dtor$608
  001ef	81 65 30 ff ff
	fe ff		 and	 DWORD PTR $T1[rbp], -65537 ; fffffffffffeffffH
  001f6	48 8d 4d 78	 lea	 rcx, QWORD PTR $T354[rbp]
  001fa	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2841@dtor$608:
  001ff	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00203	5d		 pop	 rbp
  00204	c3		 ret	 0
?dtor$608@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$608
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$712@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$712
  00205	40 55		 push	 rbp
  00207	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0020b	48 8b ea	 mov	 rbp, rdx
  0020e	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00211	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00216	85 c0		 test	 eax, eax
  00218	74 10		 je	 SHORT $LN3368@dtor$712
  0021a	81 65 30 ff ff
	fb ff		 and	 DWORD PTR $T1[rbp], -262145 ; fffffffffffbffffH
  00221	48 8d 4d 38	 lea	 rcx, QWORD PTR $T412[rbp]
  00225	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3368@dtor$712:
  0022a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0022e	5d		 pop	 rbp
  0022f	c3		 ret	 0
?dtor$712@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$712
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$739@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$739
  00230	40 55		 push	 rbp
  00232	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00236	48 8b ea	 mov	 rbp, rdx
  00239	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  0023c	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00241	85 c0		 test	 eax, eax
  00243	74 13		 je	 SHORT $LN3511@dtor$739
  00245	81 65 30 ff ff
	f7 ff		 and	 DWORD PTR $T1[rbp], -524289 ; fffffffffff7ffffH
  0024c	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T430[rbp]
  00253	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3511@dtor$739:
  00258	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0025c	5d		 pop	 rbp
  0025d	c3		 ret	 0
?dtor$739@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$739
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$21@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$21
  0025e	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T447[rdx]
  00265	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$21@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$774@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$774
  0026a	40 55		 push	 rbp
  0026c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00270	48 8b ea	 mov	 rbp, rdx
  00273	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00276	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  0027b	85 c0		 test	 eax, eax
  0027d	74 10		 je	 SHORT $LN3666@dtor$774
  0027f	81 65 30 ff ff
	df ff		 and	 DWORD PTR $T1[rbp], -2097153 ; ffffffffffdfffffH
  00286	48 8d 4d 78	 lea	 rcx, QWORD PTR $T456[rbp]
  0028a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3666@dtor$774:
  0028f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00293	5d		 pop	 rbp
  00294	c3		 ret	 0
?dtor$774@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$774
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$878@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$878
  00295	40 55		 push	 rbp
  00297	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0029b	48 8b ea	 mov	 rbp, rdx
  0029e	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  002a1	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  002a6	85 c0		 test	 eax, eax
  002a8	74 10		 je	 SHORT $LN4193@dtor$878
  002aa	81 65 30 ff ff
	7f ff		 and	 DWORD PTR $T1[rbp], -8388609 ; ffffffffff7fffffH
  002b1	48 8d 4d 38	 lea	 rcx, QWORD PTR $T514[rbp]
  002b5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4193@dtor$878:
  002ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002be	5d		 pop	 rbp
  002bf	c3		 ret	 0
?dtor$878@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$878
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$905@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$905
  002c0	40 55		 push	 rbp
  002c2	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  002c6	48 8b ea	 mov	 rbp, rdx
  002c9	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  002cc	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  002d1	85 c0		 test	 eax, eax
  002d3	74 10		 je	 SHORT $LN4336@dtor$905
  002d5	81 65 30 ff ff
	ff fe		 and	 DWORD PTR $T1[rbp], -16777217 ; fffffffffeffffffH
  002dc	48 8d 4d 58	 lea	 rcx, QWORD PTR $T532[rbp]
  002e0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4336@dtor$905:
  002e5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002e9	5d		 pop	 rbp
  002ea	c3		 ret	 0
?dtor$905@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$905
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$26@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$26
  002eb	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T549[rdx]
  002f2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$26@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$940@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$940
  002f7	40 55		 push	 rbp
  002f9	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  002fd	48 8b ea	 mov	 rbp, rdx
  00300	8b 45 30	 mov	 eax, DWORD PTR $T1[rbp]
  00303	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00308	85 c0		 test	 eax, eax
  0030a	74 13		 je	 SHORT $LN4491@dtor$940
  0030c	81 65 30 ff ff
	ff fb		 and	 DWORD PTR $T1[rbp], -67108865 ; fffffffffbffffffH
  00313	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T558[rbp]
  0031a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4491@dtor$940:
  0031f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00323	5d		 pop	 rbp
  00324	c3		 ret	 0
?dtor$940@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$940
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$30@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$30
  00325	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T598[rdx]
  0032c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$30@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$30
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$31@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$31
  00331	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T599[rdx]
  00338	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$31@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$31
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$32@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$32
  0033d	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T600[rdx]
  00344	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$32@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$32
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$34@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$34
  00349	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T602[rdx]
  00350	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$34@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$34
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$35@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$35
  00355	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T603[rdx]
  0035c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$35@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$35
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$37@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$37
  00361	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T606[rdx]
  00368	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$37@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$37
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$38@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$38
  0036d	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T607[rdx]
  00374	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$38@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$38
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$39@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$39
  00379	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T608[rdx]
  00380	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$39@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$39
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$40@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$40
  00385	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T609[rdx]
  0038c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$40@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$40
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$41@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$41
  00391	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T610[rdx]
  00398	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$41@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$41
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$42@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$42
  0039d	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T611[rdx]
  003a4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$42@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$42
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$43@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$43
  003a9	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T612[rdx]
  003b0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$43@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$43
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$45@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$45
  003b5	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$645[rdx]
  003bc	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$45@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$45
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$46@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$46
  003c1	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T614[rdx]
  003c8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$46@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$46
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$47@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$47
  003cd	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T615[rdx]
  003d4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$47@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$47
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$48@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$48
  003d9	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T616[rdx]
  003e0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$48@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$48
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$50@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$50
  003e5	48 8d 8a 58 01
	00 00		 lea	 rcx, QWORD PTR $T619[rdx]
  003ec	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$50@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$50
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$51@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$51
  003f1	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T620[rdx]
  003f8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$51@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$51
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$52@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$52
  003fd	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T621[rdx]
  00404	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$52@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$52
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$53@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$53
  00409	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T622[rdx]
  00410	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$53@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$53
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$54@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$54
  00415	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T623[rdx]
  0041c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$54@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$54
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$55@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$55
  00421	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T624[rdx]
  00428	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$55@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$55
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$56@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$56
  0042d	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T625[rdx]
  00434	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$56@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$56
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$57@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$57
  00439	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T626[rdx]
  00440	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$57@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$57
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$58@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$58
  00445	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T627[rdx]
  0044c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$58@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$58
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$60@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$60
  00451	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$644[rdx]
  00458	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$60@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$60
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$61@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$61
  0045d	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T629[rdx]
  00464	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$61@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$61
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$62@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$62
  00469	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T630[rdx]
  00470	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$62@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$62
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$64@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$64
  00475	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T633[rdx]
  0047c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$64@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$64
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$65@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$65
  00481	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T634[rdx]
  00488	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$65@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$65
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$66@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$66
  0048d	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T635[rdx]
  00494	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$66@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$66
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$67@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$67
  00499	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T636[rdx]
  004a0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$67@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$67
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$68@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$68
  004a5	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T637[rdx]
  004ac	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$68@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$68
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$69@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$69
  004b1	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T638[rdx]
  004b8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$69@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$69
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T633 = 56
$T623 = 56
$T612 = 56
$T603 = 56
$T600 = 56
$T577 = 56
$T514 = 56
$T475 = 56
$T412 = 56
$T373 = 56
$T310 = 56
$T263 = 56
$T198 = 56
$T119 = 56
$T621 = 88
$T610 = 88
$T598 = 88
$T532 = 88
$T447 = 88
$T345 = 88
$T235 = 88
$T147 = 88
$T82 = 88
$T63 = 88
$T43 = 88
$T622 = 120
$T611 = 120
$T602 = 120
$T599 = 120
$T549 = 120
$T456 = 120
$T354 = 120
$T244 = 120
$T128 = 120
$T634 = 152
$T624 = 152
$T613 = 152
$T604 = 152
$T601 = 152
$T596 = 152
$T558 = 152
$T430 = 152
$T328 = 152
$T218 = 152
$T102 = 152
$T638 = 184
$T629 = 184
$T628 = 184
$T617 = 184
$T606 = 184
$T635 = 216
$T625 = 216
$T614 = 216
$T609 = 216
$T636 = 248
$T626 = 248
$T615 = 248
$T608 = 248
$T637 = 280
$T627 = 280
$T616 = 280
$T607 = 280
$T639 = 312
$T630 = 312
$T620 = 312
$T640 = 344
$T631 = 344
$T619 = 344
$T641 = 376
g³os2$642 = 384
link$643 = 416
numers$644 = 448
numers$645 = 448
__$ArrayPad$ = 704
?dtor$70@?0??Sprawd_Pliki@@YAXXZ@4HA PROC		; `Sprawd_Pliki'::`1'::dtor$70
  004bd	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T639[rdx]
  004c4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$70@?0??Sprawd_Pliki@@YAXXZ@4HA ENDP		; `Sprawd_Pliki'::`1'::dtor$70
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Sprawd_ustawienia@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?Sprawd_ustawienia@@YAXXZ PROC				; Sprawd_ustawienia, COMDAT

; 944  : {

$LN176:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	48 8d 6c 24 80	 lea	 rbp, QWORD PTR [rsp-128]
  00009	48 81 ec 80 01
	00 00		 sub	 rsp, 384		; 00000180H
  00010	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T12[rsp], -2
  00019	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  0001d	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  00021	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002c	48 33 c4	 xor	 rax, rsp
  0002f	48 89 45 70	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  00033	33 db		 xor	 ebx, ebx
  00035	89 5c 24 20	 mov	 DWORD PTR $T1[rsp], ebx

; 945  : 	if (!_access("setting.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  00039	33 d2		 xor	 edx, edx
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@COFBHHKL@setting?4txt?$AA@
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00048	8d 7b 01	 lea	 edi, QWORD PTR [rbx+1]
  0004b	33 d2		 xor	 edx, edx
  0004d	85 c0		 test	 eax, eax
  0004f	0f 85 c9 01 00
	00		 jne	 $LN4@Sprawd_u
  00055	41 b8 10 01 00
	00		 mov	 r8d, 272		; 00000110H
  0005b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$14[rsp]
  00060	e8 00 00 00 00	 call	 memset
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 771  : 		{	// construct unopened

  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  0006c	48 89 44 24 40	 mov	 QWORD PTR ustawienia$14[rsp], rax
  00071	48 8d 4d f0	 lea	 rcx, QWORD PTR ustawienia$14[rbp-80]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0007b	90		 npad	 1
  0007c	89 7c 24 20	 mov	 DWORD PTR $T1[rsp], edi

; 665  : 		}
; 666  : 
; 667  : 	bool _Endwrite()
; 668  : 		{	// put shift to initial conversion state, as needed
; 669  : 		if (_Pcvt == 0 || !_Wrotesome)
; 670  : 			return (true);
; 671  : 		else
; 672  : 			{	// may have to put
; 673  : 			const int _STRING_INC = 8;
; 674  : 			char *_Dest;
; 675  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 676  : 				return (false);
; 677  : 
; 678  : 			string _Str(_STRING_INC, '\0');
; 679  : 			for (;;)
; 680  : 				{
; 681  : 				switch (_Pcvt->unshift(_State,
; 682  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 683  : 					{	// test result of homing conversion
; 684  : 					case codecvt_base::ok:
; 685  : 						_Wrotesome = false;	// homed successfully
; 686  : 
; 687  : 					case codecvt_base::partial:	// fall through
; 688  : 						{	// put any generated bytes
; 689  : 						size_t _Count = _Dest - &*_Str.begin();
; 690  : 						if (0 < _Count && _Count !=
; 691  : 							fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 692  : 							return (false);	// write failed
; 693  : 						if (!_Wrotesome)
; 694  : 							return (true);
; 695  : 						if (_Count == 0)
; 696  : 							_Str.append(_STRING_INC, '\0');	// try with more space
; 697  : 						break;
; 698  : 						}
; 699  : 
; 700  : 					case codecvt_base::noconv:
; 701  : 						return (true);	// nothing to do
; 702  : 
; 703  : 					default:
; 704  : 						return (false);	// conversion failed
; 705  : 					}
; 706  : 				}
; 707  : 			}
; 708  : 		}
; 709  : 
; 710  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 711  : 		{	// initialize codecvt pointer
; 712  : 		if (_Newpcvt->always_noconv())
; 713  : 			_Pcvt = 0;	// nothing to do
; 714  : 		else
; 715  : 			{	// set up for nontrivial codecvt facet
; 716  : 			_Pcvt = _Newpcvt;
; 717  : 			_Mysb::_Init();	// reset any buffering
; 718  : 			}
; 719  : 		}
; 720  : 
; 721  : private:
; 722  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 723  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 724  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 725  : 	typename _Traits::state_type _State;	// current conversion state
; 726  : 	bool _Closef;	// true if C stream must be closed
; 727  : 	_Filet *_Myfile;	// pointer to C stream
; 728  : 
; 729  : 	void _Reset_back()
; 730  : 		{	// restore buffer after putback
; 731  : 		if (_Mysb::eback() == &_Mychar)
; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 733  : 		}
; 734  : 
; 735  : 	void _Set_back()
; 736  : 		{	// set up putback area
; 737  : 		if (_Mysb::eback() != &_Mychar)
; 738  : 			{	// save current get buffer
; 739  : 			_Set_eback = _Mysb::eback();
; 740  : 			_Set_egptr = _Mysb::egptr();
; 741  : 			}
; 742  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 743  : 		}
; 744  : 
; 745  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 746  : 	_Elem *_Set_egptr;	// saves egptr()
; 747  : 	};
; 748  : 
; 749  : template<class _Elem,
; 750  : 	class _Traits> inline
; 751  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 752  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 753  : 	{	// swap _Left and _Right basic_filebufs
; 754  : 	_Left.swap(_Right);
; 755  : 	}
; 756  : 
; 757  : 		// CLASS TEMPLATE basic_ifstream
; 758  : template<class _Elem,
; 759  : 	class _Traits>
; 760  : 	class basic_ifstream
; 761  : 		: public basic_istream<_Elem, _Traits>
; 762  : 	{	// input stream associated with a C stream
; 763  : public:
; 764  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 765  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 766  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 767  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 768  : 
; 769  : 	basic_ifstream()
; 770  : 		: _Mybase(&_Filebuffer)

  00080	45 33 c9	 xor	 r9d, r9d
  00083	45 33 c0	 xor	 r8d, r8d
  00086	48 8d 54 24 50	 lea	 rdx, QWORD PTR ustawienia$14[rsp+16]
  0008b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$14[rsp]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00096	90		 npad	 1

; 771  : 		{	// construct unopened

  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$14[rsp]
  0009c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  000a7	48 89 44 0c 40	 mov	 QWORD PTR ustawienia$14[rsp+rcx], rax
  000ac	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$14[rsp]
  000b1	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000b5	8d 91 50 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-176]
  000bb	89 54 0c 3c	 mov	 DWORD PTR ustawienia$14[rsp+rcx-4], edx
  000bf	48 8d 44 24 50	 lea	 rax, QWORD PTR ustawienia$14[rsp+16]
  000c4	48 89 44 24 30	 mov	 QWORD PTR this$[rsp], rax

; 155  : 		: _Mysb()

  000c9	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ustawienia$14[rsp+16]
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  000d4	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  000d5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  000dc	48 89 44 24 50	 mov	 QWORD PTR ustawienia$14[rsp+16], rax

; 636  : 		_Closef = _Which == _Openfl;

  000e1	88 5d cc	 mov	 BYTE PTR ustawienia$14[rbp-116], bl

; 637  : 		_Wrotesome = false;

  000e4	88 5d c1	 mov	 BYTE PTR ustawienia$14[rbp-127], bl

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  000e7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ustawienia$14[rsp+16]
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;

  000f2	48 89 5d d0	 mov	 QWORD PTR ustawienia$14[rbp-112], rbx

; 663  : 		_State = _Stinit;

  000f6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000fd	48 89 45 c4	 mov	 QWORD PTR ustawienia$14[rbp-124], rax

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  00101	48 89 5d b8	 mov	 QWORD PTR ustawienia$14[rbp-136], rbx

; 934  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00105	44 8b c7	 mov	 r8d, edi
  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@COFBHHKL@setting?4txt?$AA@
  0010f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ustawienia$14[rsp+16]
  00114	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00119	8d 5f 01	 lea	 ebx, QWORD PTR [rdi+1]

; 935  : 			_Myios::setstate(ios_base::failbit);

  0011c	45 33 c0	 xor	 r8d, r8d

; 772  : 		}
; 773  : 
; 774  : 	explicit basic_ifstream(const char *_Filename,
; 775  : 		ios_base::openmode _Mode = ios_base::in,
; 776  : 		int _Prot = (int)ios_base::_Openprot)
; 777  : 		: _Mybase(&_Filebuffer)
; 778  : 		{	// construct with named file and specified mode
; 779  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 780  : 			_Myios::setstate(ios_base::failbit);
; 781  : 		}
; 782  : 
; 783  : 	explicit basic_ifstream(const string& _Str,
; 784  : 		ios_base::openmode _Mode = ios_base::in,
; 785  : 		int _Prot = (int)ios_base::_Openprot)
; 786  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 787  : 		{	// construct with named file and specified mode
; 788  : 		}
; 789  : 
; 790  : 	explicit basic_ifstream(const wchar_t *_Filename,
; 791  : 		ios_base::openmode _Mode = ios_base::in,
; 792  : 		int _Prot = (int)ios_base::_Openprot)
; 793  : 		: _Mybase(&_Filebuffer)
; 794  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 795  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 796  : 			_Myios::setstate(ios_base::failbit);
; 797  : 		}
; 798  : 
; 799  : 	explicit basic_ifstream(const wstring& _Str,
; 800  : 		ios_base::openmode _Mode = ios_base::in,
; 801  : 		int _Prot = (int)ios_base::_Openprot)
; 802  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 803  : 		{	// construct with wide-named file -- EXTENSION
; 804  : 		}
; 805  : 
; 806  : 	template<class _Path_ish = experimental::filesystem::path>
; 807  : 		explicit basic_ifstream(const _Identity_t<_Path_ish>& _Path,
; 808  : 		ios_base::openmode _Mode = ios_base::in,
; 809  : 		int _Prot = (int)ios_base::_Openprot)
; 810  : 		: basic_ifstream(_Path.c_str(), _Mode, _Prot)
; 811  : 		{	// construct with path-named file
; 812  : 		}
; 813  : 
; 814  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 815  : 	explicit basic_ifstream(const unsigned short *_Filename,
; 816  : 		ios_base::openmode _Mode = ios_base::in,
; 817  : 		int _Prot = (int)ios_base::_Openprot)
; 818  : 		: _Mybase(&_Filebuffer)
; 819  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 820  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 821  : 			_Myios::setstate(ios_base::failbit);
; 822  : 		}
; 823  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 824  : 
; 825  : 	explicit basic_ifstream(_Filet *_File)
; 826  : 		: _Mybase(&_Filebuffer),
; 827  : 			_Filebuffer(_File)
; 828  : 		{	// construct with specified C stream
; 829  : 		}
; 830  : 
; 831  : 	basic_ifstream(_Myt&& _Right)
; 832  : 		: _Mybase(&_Filebuffer)
; 833  : 		{	// construct by moving _Right
; 834  : 		_Assign_rv(_STD move(_Right));
; 835  : 		}
; 836  : 
; 837  : 	_Myt& operator=(_Myt&& _Right)
; 838  : 		{	// move from _Right
; 839  : 		_Assign_rv(_STD move(_Right));
; 840  : 		return (*this);
; 841  : 		}
; 842  : 
; 843  : 	void _Assign_rv(_Myt&& _Right)
; 844  : 		{	// assign by moving _Right
; 845  : 		if (this != _STD addressof(_Right))
; 846  : 			{	// different, worth moving
; 847  : 			_Filebuffer.close();
; 848  : 			this->swap(_Right);
; 849  : 			}
; 850  : 		}
; 851  : 
; 852  : 	void swap(_Myt& _Right)
; 853  : 		{	// swap with _Right
; 854  : 		if (this != _STD addressof(_Right))
; 855  : 			{	// different, swap base and buffer
; 856  : 			_Mybase::swap(_Right);
; 857  : 			_Filebuffer.swap(_Right._Filebuffer);
; 858  : 			}
; 859  : 		}
; 860  : 
; 861  : 	basic_ifstream(const _Myt&) = delete;
; 862  : 	_Myt& operator=(const _Myt&) = delete;
; 863  : 
; 864  : 	void open(const wchar_t *_Filename,
; 865  : 		ios_base::openmode _Mode = ios_base::in,
; 866  : 		int _Prot = (int)ios_base::_Openprot)
; 867  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 868  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 869  : 			_Myios::setstate(ios_base::failbit);
; 870  : 		else
; 871  : 			_Myios::clear();	// added with C++11
; 872  : 		}
; 873  : 
; 874  : 	void open(const wstring& _Str,
; 875  : 		ios_base::openmode _Mode = ios_base::in,
; 876  : 		int _Prot = (int)ios_base::_Openprot)
; 877  : 		{	// open a wide-named C stream -- EXTENSION
; 878  : 		open(_Str.c_str(), _Mode, _Prot);
; 879  : 		}
; 880  : 
; 881  : 	template<class _Path_ish = experimental::filesystem::path>
; 882  : 		void open(const _Identity_t<_Path_ish>& _Path,
; 883  : 		ios_base::openmode _Mode = ios_base::in,
; 884  : 		int _Prot = (int)ios_base::_Openprot)
; 885  : 		{	// open a path-named C stream
; 886  : 		open(_Path.c_str(), _Mode, _Prot);
; 887  : 		}
; 888  : 
; 889  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 890  : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 891  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 892  : 		open(_Filename, (ios_base::openmode)_Mode);
; 893  : 		}
; 894  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 895  : 
; 896  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 897  : 	void open(const unsigned short *_Filename,
; 898  : 		ios_base::openmode _Mode = ios_base::in,
; 899  : 		int _Prot = (int)ios_base::_Openprot)
; 900  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 901  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 902  : 			_Myios::setstate(ios_base::failbit);
; 903  : 		else
; 904  : 			_Myios::clear();	// added with C++11
; 905  : 		}
; 906  : 
; 907  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 908  : 	void open(const unsigned short *_Filename,
; 909  : 		ios_base::open_mode _Mode)
; 910  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 911  : 		open(_Filename, (ios_base::openmode)_Mode);
; 912  : 		}
; 913  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 914  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 915  : 
; 916  : 	virtual __CLR_OR_THIS_CALL ~basic_ifstream() _NOEXCEPT
; 917  : 		{	// destroy the object
; 918  : 		}
; 919  : 
; 920  : 	_Myfb *rdbuf() const
; 921  : 		{	// return pointer to file buffer
; 922  : 		return ((_Myfb *)&_Filebuffer);
; 923  : 		}
; 924  : 
; 925  : 	bool is_open() const
; 926  : 		{	// test if C stream has been opened
; 927  : 		return (_Filebuffer.is_open());
; 928  : 		}
; 929  : 
; 930  : 	void open(const char *_Filename,
; 931  : 		ios_base::openmode _Mode = ios_base::in,
; 932  : 		int _Prot = (int)ios_base::_Openprot)
; 933  : 		{	// open a C stream with specified mode
; 934  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  0011f	48 85 c0	 test	 rax, rax

; 935  : 			_Myios::setstate(ios_base::failbit);

  00122	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$14[rsp]
  00127	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0012b	48 8d 44 24 40	 lea	 rax, QWORD PTR ustawienia$14[rsp]

; 772  : 		}
; 773  : 
; 774  : 	explicit basic_ifstream(const char *_Filename,
; 775  : 		ios_base::openmode _Mode = ios_base::in,
; 776  : 		int _Prot = (int)ios_base::_Openprot)
; 777  : 		: _Mybase(&_Filebuffer)
; 778  : 		{	// construct with named file and specified mode
; 779  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 780  : 			_Myios::setstate(ios_base::failbit);
; 781  : 		}
; 782  : 
; 783  : 	explicit basic_ifstream(const string& _Str,
; 784  : 		ios_base::openmode _Mode = ios_base::in,
; 785  : 		int _Prot = (int)ios_base::_Openprot)
; 786  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 787  : 		{	// construct with named file and specified mode
; 788  : 		}
; 789  : 
; 790  : 	explicit basic_ifstream(const wchar_t *_Filename,
; 791  : 		ios_base::openmode _Mode = ios_base::in,
; 792  : 		int _Prot = (int)ios_base::_Openprot)
; 793  : 		: _Mybase(&_Filebuffer)
; 794  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 795  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 796  : 			_Myios::setstate(ios_base::failbit);
; 797  : 		}
; 798  : 
; 799  : 	explicit basic_ifstream(const wstring& _Str,
; 800  : 		ios_base::openmode _Mode = ios_base::in,
; 801  : 		int _Prot = (int)ios_base::_Openprot)
; 802  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 803  : 		{	// construct with wide-named file -- EXTENSION
; 804  : 		}
; 805  : 
; 806  : 	template<class _Path_ish = experimental::filesystem::path>
; 807  : 		explicit basic_ifstream(const _Identity_t<_Path_ish>& _Path,
; 808  : 		ios_base::openmode _Mode = ios_base::in,
; 809  : 		int _Prot = (int)ios_base::_Openprot)
; 810  : 		: basic_ifstream(_Path.c_str(), _Mode, _Prot)
; 811  : 		{	// construct with path-named file
; 812  : 		}
; 813  : 
; 814  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 815  : 	explicit basic_ifstream(const unsigned short *_Filename,
; 816  : 		ios_base::openmode _Mode = ios_base::in,
; 817  : 		int _Prot = (int)ios_base::_Openprot)
; 818  : 		: _Mybase(&_Filebuffer)
; 819  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 820  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 821  : 			_Myios::setstate(ios_base::failbit);
; 822  : 		}
; 823  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 824  : 
; 825  : 	explicit basic_ifstream(_Filet *_File)
; 826  : 		: _Mybase(&_Filebuffer),
; 827  : 			_Filebuffer(_File)
; 828  : 		{	// construct with specified C stream
; 829  : 		}
; 830  : 
; 831  : 	basic_ifstream(_Myt&& _Right)
; 832  : 		: _Mybase(&_Filebuffer)
; 833  : 		{	// construct by moving _Right
; 834  : 		_Assign_rv(_STD move(_Right));
; 835  : 		}
; 836  : 
; 837  : 	_Myt& operator=(_Myt&& _Right)
; 838  : 		{	// move from _Right
; 839  : 		_Assign_rv(_STD move(_Right));
; 840  : 		return (*this);
; 841  : 		}
; 842  : 
; 843  : 	void _Assign_rv(_Myt&& _Right)
; 844  : 		{	// assign by moving _Right
; 845  : 		if (this != _STD addressof(_Right))
; 846  : 			{	// different, worth moving
; 847  : 			_Filebuffer.close();
; 848  : 			this->swap(_Right);
; 849  : 			}
; 850  : 		}
; 851  : 
; 852  : 	void swap(_Myt& _Right)
; 853  : 		{	// swap with _Right
; 854  : 		if (this != _STD addressof(_Right))
; 855  : 			{	// different, swap base and buffer
; 856  : 			_Mybase::swap(_Right);
; 857  : 			_Filebuffer.swap(_Right._Filebuffer);
; 858  : 			}
; 859  : 		}
; 860  : 
; 861  : 	basic_ifstream(const _Myt&) = delete;
; 862  : 	_Myt& operator=(const _Myt&) = delete;
; 863  : 
; 864  : 	void open(const wchar_t *_Filename,
; 865  : 		ios_base::openmode _Mode = ios_base::in,
; 866  : 		int _Prot = (int)ios_base::_Openprot)
; 867  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 868  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 869  : 			_Myios::setstate(ios_base::failbit);
; 870  : 		else
; 871  : 			_Myios::clear();	// added with C++11
; 872  : 		}
; 873  : 
; 874  : 	void open(const wstring& _Str,
; 875  : 		ios_base::openmode _Mode = ios_base::in,
; 876  : 		int _Prot = (int)ios_base::_Openprot)
; 877  : 		{	// open a wide-named C stream -- EXTENSION
; 878  : 		open(_Str.c_str(), _Mode, _Prot);
; 879  : 		}
; 880  : 
; 881  : 	template<class _Path_ish = experimental::filesystem::path>
; 882  : 		void open(const _Identity_t<_Path_ish>& _Path,
; 883  : 		ios_base::openmode _Mode = ios_base::in,
; 884  : 		int _Prot = (int)ios_base::_Openprot)
; 885  : 		{	// open a path-named C stream
; 886  : 		open(_Path.c_str(), _Mode, _Prot);
; 887  : 		}
; 888  : 
; 889  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 890  : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 891  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 892  : 		open(_Filename, (ios_base::openmode)_Mode);
; 893  : 		}
; 894  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 895  : 
; 896  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 897  : 	void open(const unsigned short *_Filename,
; 898  : 		ios_base::openmode _Mode = ios_base::in,
; 899  : 		int _Prot = (int)ios_base::_Openprot)
; 900  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 901  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 902  : 			_Myios::setstate(ios_base::failbit);
; 903  : 		else
; 904  : 			_Myios::clear();	// added with C++11
; 905  : 		}
; 906  : 
; 907  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 908  : 	void open(const unsigned short *_Filename,
; 909  : 		ios_base::open_mode _Mode)
; 910  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 911  : 		open(_Filename, (ios_base::openmode)_Mode);
; 912  : 		}
; 913  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 914  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 915  : 
; 916  : 	virtual __CLR_OR_THIS_CALL ~basic_ifstream() _NOEXCEPT
; 917  : 		{	// destroy the object
; 918  : 		}
; 919  : 
; 920  : 	_Myfb *rdbuf() const
; 921  : 		{	// return pointer to file buffer
; 922  : 		return ((_Myfb *)&_Filebuffer);
; 923  : 		}
; 924  : 
; 925  : 	bool is_open() const
; 926  : 		{	// test if C stream has been opened
; 927  : 		return (_Filebuffer.is_open());
; 928  : 		}
; 929  : 
; 930  : 	void open(const char *_Filename,
; 931  : 		ios_base::openmode _Mode = ios_base::in,
; 932  : 		int _Prot = (int)ios_base::_Openprot)
; 933  : 		{	// open a C stream with specified mode
; 934  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00130	75 0d		 jne	 SHORT $LN47@Sprawd_u

; 935  : 			_Myios::setstate(ios_base::failbit);

  00132	48 03 c8	 add	 rcx, rax
  00135	8b d3		 mov	 edx, ebx
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 936  : 		else

  0013d	eb 0b		 jmp	 SHORT $LN48@Sprawd_u
$LN47@Sprawd_u:

; 937  : 			_Myios::clear();	// added with C++11

  0013f	48 03 c8	 add	 rcx, rax
  00142	33 d2		 xor	 edx, edx
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN48@Sprawd_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0014a	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00152	f3 0f 7f 45 60	 movdqu	 XMMWORD PTR buf$15[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00157	c6 45 50 00	 mov	 BYTE PTR buf$15[rbp-256], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 950  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  0015b	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$14[rsp]
  00160	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 343  : 		return ((int)rdstate() & (int)eofbit);

  00164	f6 44 0c 50 01	 test	 BYTE PTR ustawienia$14[rsp+rcx+16], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 950  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  00169	75 40		 jne	 SHORT $LN3@Sprawd_u
  0016b	0f 1f 44 00 00	 npad	 5
$LL2@Sprawd_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00170	48 8d 44 24 40	 lea	 rax, QWORD PTR ustawienia$14[rsp]
  00175	48 03 c8	 add	 rcx, rax
  00178	b2 0a		 mov	 dl, 10
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  00180	44 0f b6 c0	 movzx	 r8d, al
  00184	48 8d 55 50	 lea	 rdx, QWORD PTR buf$15[rbp-256]
  00188	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$14[rsp]
  0018d	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 953  : 			Ustaw_ustawienia(buf); //Zamiana wczytanej lini na ustawienie programu

  00192	48 8d 4d 50	 lea	 rcx, QWORD PTR buf$15[rbp-256]
  00196	e8 00 00 00 00	 call	 ?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ustaw_ustawienia

; 950  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  0019b	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$14[rsp]
  001a0	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 343  : 		return ((int)rdstate() & (int)eofbit);

  001a4	f6 44 0c 50 01	 test	 BYTE PTR ustawienia$14[rsp+rcx+16], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 950  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  001a9	74 c5		 je	 SHORT $LL2@Sprawd_u
$LN3@Sprawd_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001ab	48 8b 55 68	 mov	 rdx, QWORD PTR buf$15[rbp-232]
  001af	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  001b3	72 49		 jb	 SHORT $LN120@Sprawd_u

; 3695 : 			{
; 3696 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3697 : 			auto& _Al = this->_Getal();
; 3698 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001b5	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001b8	48 8b 45 50	 mov	 rax, QWORD PTR buf$15[rbp-256]
  001bc	48 8b c8	 mov	 rcx, rax

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001bf	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  001c6	72 2e		 jb	 SHORT $LN123@Sprawd_u

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001c8	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  001cc	4c 3b c2	 cmp	 r8, rdx
  001cf	76 1e		 jbe	 SHORT $_Invalid_parameter$177

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001d1	49 8b d0	 mov	 rdx, r8
  001d4	f6 c1 1f	 test	 cl, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001d7	75 16		 jne	 SHORT $_Invalid_parameter$177

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001d9	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  001dd	48 3b c1	 cmp	 rax, rcx

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  001e0	73 0d		 jae	 SHORT $_Invalid_parameter$177

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001e2	48 2b c8	 sub	 rcx, rax
  001e5	48 83 e9 08	 sub	 rcx, 8
  001e9	48 83 f9 1f	 cmp	 rcx, 31
  001ed	76 07		 jbe	 SHORT $LN123@Sprawd_u
$_Invalid_parameter$177:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001f5	cc		 int	 3
$LN123@Sprawd_u:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  001f6	48 8b c8	 mov	 rcx, rax
  001f9	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN120@Sprawd_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  001fe	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00206	f3 0f 7f 45 60	 movdqu	 XMMWORD PTR buf$15[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0020b	c6 45 50 00	 mov	 BYTE PTR buf$15[rbp-256], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 955  : 	}

  0020f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$14[rsp]
  00214	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ

; 956  : 	else

  00219	e9 bc 01 00 00	 jmp	 $LN5@Sprawd_u
$LN4@Sprawd_u:
  0021e	41 b8 08 01 00
	00		 mov	 r8d, 264		; 00000108H
  00224	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  00229	e8 00 00 00 00	 call	 memset

; 957  : 	{
; 958  : 		ofstream ustawienia; //Utworzenie typu do celu zapisu do pliku

  0022e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  00233	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
  00238	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  00239	bb 02 00 00 00	 mov	 ebx, 2
  0023e	44 8b c3	 mov	 r8d, ebx
  00241	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@COFBHHKL@setting?4txt?$AA@
  00248	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ustawienia$13[rsp+8]
  0024d	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1150 : 			_Myios::setstate(ios_base::failbit);

  00252	45 33 c0	 xor	 r8d, r8d

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  00255	48 85 c0	 test	 rax, rax

; 1150 : 			_Myios::setstate(ios_base::failbit);

  00258	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$13[rsp]
  0025d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00261	48 8d 44 24 40	 lea	 rax, QWORD PTR ustawienia$13[rsp]

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  00266	75 0d		 jne	 SHORT $LN158@Sprawd_u

; 1150 : 			_Myios::setstate(ios_base::failbit);

  00268	48 03 c8	 add	 rcx, rax
  0026b	8b d3		 mov	 edx, ebx
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1151 : 		else

  00273	eb 0b		 jmp	 SHORT $LN159@Sprawd_u
$LN158@Sprawd_u:

; 1152 : 			_Myios::clear();	// added with C++11

  00275	48 03 c8	 add	 rcx, rax
  00278	33 d2		 xor	 edx, edx
  0027a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN159@Sprawd_u:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 960  : 		ustawienia << "iloæ_minimalna_obrotów_ruletki 2" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych iloæ_minimalna_obrotów_ruletki

  00280	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@
  00287	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  0028c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00291	48 8b c8	 mov	 rcx, rax
  00294	b2 0a		 mov	 dl, 10
  00296	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 961  : 		ustawienia << "iloæ_max_dodatkowych_obrotów_ruletki 3" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych iloæ_max_dodatkowych_obrotów_ruletki

  0029b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
  002a2	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  002a7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002ac	48 8b c8	 mov	 rcx, rax
  002af	b2 0a		 mov	 dl, 10
  002b1	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 962  : 		ustawienia << "czas_przeskoku_kulki_szybki 50" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czas_przeskoku_kulki_szybki

  002b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@
  002bd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  002c2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002c7	48 8b c8	 mov	 rcx, rax
  002ca	b2 0a		 mov	 dl, 10
  002cc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 963  : 		ustawienia << "czas_przeskoku_kulki_wolny 75" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czas_przeskoku_kulki_wolny

  002d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@
  002d8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  002dd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002e2	48 8b c8	 mov	 rcx, rax
  002e5	b2 0a		 mov	 dl, 10
  002e7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 964  : 		ustawienia << "czas_przerwy_dzwiêku 500" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czas_przerwy_dzwiêku

  002ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@
  002f3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  002f8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002fd	48 8b c8	 mov	 rcx, rax
  00300	b2 0a		 mov	 dl, 10
  00302	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 965  : 		ustawienia << "styl_liczenia_wygranej 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych styl_liczenia_wygranej

  00307	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@
  0030e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  00313	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00318	48 8b c8	 mov	 rcx, rax
  0031b	b2 0a		 mov	 dl, 10
  0031d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 966  : 		ustawienia << "kwota_pocz¹tkowa 1000" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych kwota_pocz¹tkowa

  00322	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@
  00329	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  0032e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00333	48 8b c8	 mov	 rcx, rax
  00336	b2 0a		 mov	 dl, 10
  00338	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 967  : 		ustawienia << "stan_dwiêków 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych stan_dwiêków

  0033d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@
  00344	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  00349	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0034e	48 8b c8	 mov	 rcx, rax
  00351	b2 0a		 mov	 dl, 10
  00353	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 968  : 		ustawienia << "czy_kontynuowaæ_grê 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych czy_kontynuowaæ_grê

  00358	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@
  0035f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  00364	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00369	48 8b c8	 mov	 rcx, rax
  0036c	b2 0a		 mov	 dl, 10
  0036e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 969  : 		ustawienia << "g³os_odczytu_numeru 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych g³os_odczytu_numeru

  00373	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@
  0037a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  0037f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00384	48 8b c8	 mov	 rcx, rax
  00387	b2 0a		 mov	 dl, 10
  00389	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 970  : 		ustawienia << "g³os_szybkoæ_odczytu_numeru 4" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych g³os_szybkoæ_odczytu_numeru

  0038e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@
  00395	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  0039a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0039f	48 8b c8	 mov	 rcx, rax
  003a2	b2 0a		 mov	 dl, 10
  003a4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 971  : 		ustawienia << "efekty_dwiêkowe 1" << '\n'; //Wpisanie do pliku domynych ustawieñ dotycz¹cych efekty_dwiêkowe

  003a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@
  003b0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  003b5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003ba	48 8b c8	 mov	 rcx, rax
  003bd	b2 0a		 mov	 dl, 10
  003bf	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 972  : 		ustawienia.flush(); //Zapisanie do pliku setting.txt danych wpisanych do bufora danych

  003c4	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  003c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
  003cf	90		 npad	 1

; 973  : 	}

  003d0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$13[rsp]
  003d5	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
$LN5@Sprawd_u:

; 974  : 
; 975  : 	if (Ustawienia.czas_przeskoku_kulki_wolny < Ustawienia.czas_przeskoku_kulki_szybki) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  003da	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4
  003e1	66 39 05 06 00
	00 00		 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+6, ax
  003e8	7d 55		 jge	 SHORT $LN6@Sprawd_u

; 976  : 	{
; 977  : 		cout << "Wartoæ wolnego czasu przeskoku kulki musi byæ ni¿sza ni¿ wartoæ szybkiego czasu przeskoku kulki" << endl; //(Wartoci tych zmiennych to czas opónienia wiêc im jest wy¿szy tym d³u¿sza przerwa)

  003ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@
  003f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  003f8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003fd	48 8b c8	 mov	 rcx, rax
  00400	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00407	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 978  : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  0040d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00414	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0041b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00420	48 8b c8	 mov	 rcx, rax
  00423	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0042a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 979  : 		Ustawienia.czas_przeskoku_kulki_szybki = 50; //Ustawienie wartoci domylnej

  00430	c7 05 04 00 00
	00 32 00 4b 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+4, 4915250 ; 004b0032H

; 980  : 		Ustawienia.czas_przeskoku_kulki_wolny = 75; //Ustawienie wartoci domylnej

  0043a	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
$LN6@Sprawd_u:

; 981  : 	}
; 982  : 	if (Ustawienia.iloæ_minimalna_obrotów_ruletki < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0043f	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A
  00446	66 85 c0	 test	 ax, ax
  00449	79 4f		 jns	 SHORT $LN7@Sprawd_u

; 983  : 	{
; 984  : 		cout << "Iloæ minimalna obrotów ruletki nie mo¿e byæ mniejsza od 0" << endl;

  0044b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@
  00452	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00459	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0045e	48 8b c8	 mov	 rcx, rax
  00461	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00468	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 985  : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  0046e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00475	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0047c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00481	48 8b c8	 mov	 rcx, rax
  00484	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0048b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 986  : 		Ustawienia.iloæ_minimalna_obrotów_ruletki = 2; //Ustawienie wartoci domylnej

  00491	8b c3		 mov	 eax, ebx
  00493	66 89 1d 00 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A, bx
$LN7@Sprawd_u:

; 987  : 	}
; 988  : 	if (Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0049a	be 03 00 00 00	 mov	 esi, 3
  0049f	0f b7 0d 02 00
	00 00		 movzx	 ecx, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2
  004a6	66 85 c9	 test	 cx, cx
  004a9	79 56		 jns	 SHORT $LN8@Sprawd_u

; 989  : 	{
; 990  : 		cout << "Iloæ max obrotów ruletki nie mo¿e byæ mniejsza od 0" << endl;

  004ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@
  004b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004b9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  004be	48 8b c8	 mov	 rcx, rax
  004c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  004c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 991  : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  004ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  004d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004dc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  004e1	48 8b c8	 mov	 rcx, rax
  004e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  004eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 992  : 		Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = 3; //Ustawienie wartoci domylnej

  004f1	8b ce		 mov	 ecx, esi
  004f3	66 89 0d 02 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2, cx
  004fa	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A
$LN8@Sprawd_u:

; 993  : 	}
; 994  : 	if ((Ustawienia.iloæ_minimalna_obrotów_ruletki == 0) && (Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki == 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00501	66 85 c0	 test	 ax, ax
  00504	75 55		 jne	 SHORT $LN9@Sprawd_u
  00506	66 85 c9	 test	 cx, cx
  00509	75 50		 jne	 SHORT $LN9@Sprawd_u

; 995  : 	{
; 996  : 		cout << "Jedna z deklaracji w sprawie obrotów ruletki musi byæ wiêksza od zera" << endl;

  0050b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@
  00512	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00519	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0051e	48 8b c8	 mov	 rcx, rax
  00521	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00528	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 997  : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  0052e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00535	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0053c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00541	48 8b c8	 mov	 rcx, rax
  00544	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0054b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 998  : 		Ustawienia.iloæ_minimalna_obrotów_ruletki = 2; //Ustawienie wartoci domylnej

  00551	c7 05 00 00 00
	00 02 00 03 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A, 196610 ; 00030002H
$LN9@Sprawd_u:

; 999  : 		Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = 3; //Ustawienie wartoci domylnej
; 1000 : 	}
; 1001 : 	if (((Ustawienia.styl_liczenia_wygranej > 1) || (Ustawienia.styl_liczenia_wygranej < 0))) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0055b	66 83 3d 0a 00
	00 00 01	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, 1
  00563	76 4d		 jbe	 SHORT $LN10@Sprawd_u

; 1002 : 	{
; 1003 : 		cout << "Styl liczeia wygranej przyjmuje wartoci tylko 0 lub 1" << endl;

  00565	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@
  0056c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00573	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00578	48 8b c8	 mov	 rcx, rax
  0057b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00582	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1004 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00588	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0058f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00596	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0059b	48 8b c8	 mov	 rcx, rax
  0059e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  005a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1005 : 		Ustawienia.styl_liczenia_wygranej = 1; //Ustawienie wartoci domylnej

  005ab	66 89 3d 0a 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, di
$LN10@Sprawd_u:

; 1006 : 	}
; 1007 : 	if (Ustawienia.czas_przerwy_dzwiêku < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  005b2	66 83 3d 08 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8, 0
  005ba	7d 52		 jge	 SHORT $LN12@Sprawd_u

; 1008 : 	{
; 1009 : 		cout << "Czas przerwy dwiêku nie mo¿e byæ mniejszy od zera" << endl;

  005bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@
  005c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005ca	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  005cf	48 8b c8	 mov	 rcx, rax
  005d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  005d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1010 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  005df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  005e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005ed	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  005f2	48 8b c8	 mov	 rcx, rax
  005f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  005fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1011 : 		Ustawienia.czas_przerwy_dzwiêku = 500; //Ustawienie wartoci domylnej

  00602	b8 f4 01 00 00	 mov	 eax, 500		; 000001f4H
  00607	66 89 05 08 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8, ax
$LN12@Sprawd_u:

; 1012 : 	}
; 1013 : 	if (Ustawienia.kwota_pocz¹tkowa < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0060e	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, 0
  00615	7d 50		 jge	 SHORT $LN13@Sprawd_u

; 1014 : 	{
; 1015 : 		cout << "Kwota pocz¹tkowa nie mo¿e byæ mniejsza od zera" << endl;

  00617	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@
  0061e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00625	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0062a	48 8b c8	 mov	 rcx, rax
  0062d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00634	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1016 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  0063a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00641	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00648	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0064d	48 8b c8	 mov	 rcx, rax
  00650	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00657	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1017 : 		Ustawienia.kwota_pocz¹tkowa = 1000; //Ustawienie wartoci domylnej

  0065d	c7 05 0c 00 00
	00 e8 03 00 00	 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, 1000 ; 000003e8H
$LN13@Sprawd_u:

; 1018 : 	}
; 1019 : 	if ((Ustawienia.stan_dwiêków > 1) || (Ustawienia.stan_dwiêków < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00667	66 83 3d 10 00
	00 00 01	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 1
  0066f	76 4d		 jbe	 SHORT $LN14@Sprawd_u

; 1020 : 	{
; 1021 : 		cout << "Stan dwiêków przyjmuje wartoci tylko 0 lub 1" << endl;

  00671	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@
  00678	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0067f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00684	48 8b c8	 mov	 rcx, rax
  00687	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0068e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1022 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00694	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  0069b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006a2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  006a7	48 8b c8	 mov	 rcx, rax
  006aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  006b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1023 : 		Ustawienia.stan_dwiêków = 1; //Ustawienie wartoci domylnej

  006b7	66 89 3d 10 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, di
$LN14@Sprawd_u:

; 1024 : 	}
; 1025 : 	if ((Ustawienia.czy_kontynuowaæ_grê > 1) || (Ustawienia.czy_kontynuowaæ_grê < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  006be	66 83 3d 12 00
	00 00 01	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, 1
  006c6	76 4d		 jbe	 SHORT $LN16@Sprawd_u

; 1026 : 	{
; 1027 : 		cout << "Opcja kontynuowania gry przyjmuje wartoci tylko 0 lub 1" << endl;

  006c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@
  006cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006d6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  006db	48 8b c8	 mov	 rcx, rax
  006de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  006e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1028 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  006eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  006f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006f9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  006fe	48 8b c8	 mov	 rcx, rax
  00701	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00708	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1029 : 		Ustawienia.czy_kontynuowaæ_grê = 1; //Ustawienie wartoci domylnej

  0070e	66 89 3d 12 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, di
$LN16@Sprawd_u:

; 1030 : 	}
; 1031 : 	if ((Ustawienia.g³os_odczytu_numeru > 10) || (Ustawienia.g³os_odczytu_numeru < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00715	66 83 3d 14 00
	00 00 0a	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, 10
  0071d	76 4d		 jbe	 SHORT $LN18@Sprawd_u

; 1032 : 	{
; 1033 : 		cout << "Opcja g³os odczytu numeru przyjmuje wartoci w przedziale [0;10]" << endl;

  0071f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@
  00726	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0072d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00732	48 8b c8	 mov	 rcx, rax
  00735	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0073c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1034 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00742	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00749	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00750	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00755	48 8b c8	 mov	 rcx, rax
  00758	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0075f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1035 : 		Ustawienia.g³os_odczytu_numeru = 1; //Ustawienie wartoci domylnej

  00765	66 89 3d 14 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, di
$LN18@Sprawd_u:

; 1036 : 	}
; 1037 : 	if ((Ustawienia.g³os_szybkoæ_odczytu_numeru > 5) || (Ustawienia.g³os_szybkoæ_odczytu_numeru < 1)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0076c	0f b7 05 16 00
	00 00		 movzx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22
  00773	66 ff c8	 dec	 ax
  00776	66 83 f8 04	 cmp	 ax, 4
  0077a	76 52		 jbe	 SHORT $LN20@Sprawd_u

; 1038 : 	{
; 1039 : 		cout << "Opcja szybkoæ g³osu odczytu przyjmuje wartoci w przedziale [1;5]" << endl;

  0077c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@
  00783	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0078a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0078f	48 8b c8	 mov	 rcx, rax
  00792	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00799	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1040 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  0079f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  007a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007ad	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  007b2	48 8b c8	 mov	 rcx, rax
  007b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  007bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1041 : 		Ustawienia.g³os_szybkoæ_odczytu_numeru = 4; //Ustawienie wartoci domylnej

  007c2	b8 04 00 00 00	 mov	 eax, 4
  007c7	66 89 05 16 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax
$LN20@Sprawd_u:

; 1042 : 	}
; 1043 : 	if ((Ustawienia.efekty_dwiêkowe > 1) || (Ustawienia.efekty_dwiêkowe < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  007ce	0f b7 05 18 00
	00 00		 movzx	 eax, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24
  007d5	66 83 f8 01	 cmp	 ax, 1
  007d9	76 4f		 jbe	 SHORT $LN174@Sprawd_u

; 1044 : 	{
; 1045 : 		cout << "Opcja efekty dwiêkowe przyjmuje wartoci 0 lub 1" << endl;

  007db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@
  007e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007e9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  007ee	48 8b c8	 mov	 rcx, rax
  007f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  007f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1046 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  007fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00805	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0080c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00811	48 8b c8	 mov	 rcx, rax
  00814	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0081b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1047 : 		Ustawienia.efekty_dwiêkowe = 1; //Ustawienie wartoci domylnej

  00821	66 89 3d 18 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, di

; 1048 : 	}
; 1049 : 	if (Ustawienia.efekty_dwiêkowe == 1 && Ustawienia.stan_dwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00828	eb 02		 jmp	 SHORT $LN165@Sprawd_u
$LN174@Sprawd_u:
  0082a	75 57		 jne	 SHORT $LN24@Sprawd_u
$LN165@Sprawd_u:
  0082c	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  00834	75 4d		 jne	 SHORT $LN24@Sprawd_u

; 1050 : 	{
; 1051 : 		cout << "Nie mo¿esz mieæ wy³¹czonych dwiêków i w³¹czonych efektów dwiêkowych" << endl;

  00836	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
  0083d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00844	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00849	48 8b c8	 mov	 rcx, rax
  0084c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00853	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1052 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  00859	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00860	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00867	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0086c	48 8b c8	 mov	 rcx, rax
  0086f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00876	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1053 : 		Ustawienia.stan_dwiêków = 1; //Ustawienie wartoci domylnej

  0087c	66 89 3d 10 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, di
$LN24@Sprawd_u:

; 1054 : 	}
; 1055 : 	if (Ustawienia.g³os_odczytu_numeru > 0 && Ustawienia.stan_dwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00883	66 83 3d 14 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, 0
  0088b	7e 57		 jle	 SHORT $LN25@Sprawd_u
  0088d	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  00895	75 4d		 jne	 SHORT $LN25@Sprawd_u

; 1056 : 	{
; 1057 : 		cout << "Nie mo¿esz mieæ wy³¹czonych dwiêków i w³¹czon¹ mowê" << endl;

  00897	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
  0089e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008a5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  008aa	48 8b c8	 mov	 rcx, rax
  008ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  008b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1058 : 		cout << "Ustawiam domylne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domylne

  008ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  008c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008c8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  008cd	48 8b c8	 mov	 rcx, rax
  008d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  008d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1059 : 		Ustawienia.stan_dwiêków = 1; //Ustawienie wartoci domylnej

  008dd	66 89 3d 10 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, di
$LN25@Sprawd_u:

; 1060 : 	}
; 1061 : }

  008e4	48 8b 4d 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  008e8	48 33 cc	 xor	 rcx, rsp
  008eb	e8 00 00 00 00	 call	 __security_check_cookie
  008f0	4c 8d 9c 24 80
	01 00 00	 lea	 r11, QWORD PTR [rsp+384]
  008f8	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  008fc	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00900	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  00904	49 8b e3	 mov	 rsp, r11
  00907	5d		 pop	 rbp
  00908	c3		 ret	 0
$LN173@Sprawd_u:
?Sprawd_ustawienia@@YAXXZ ENDP				; Sprawd_ustawienia
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$4@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$4
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN37@dtor$4
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 4d 40	 lea	 rcx, QWORD PTR ustawienia$14[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN37@dtor$4:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$4@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$4
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$5@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$5
  0002e	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$14[rdx]
  00035	48 83 c1 18	 add	 rcx, 24
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$5@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$5
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$7@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$7
  00040	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$7@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$7
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$0@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$0
  0004e	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$14[rdx]
  00055	e9 00 00 00 00	 jmp	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$0@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$0
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$1@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$1
  0005a	48 8d 8a 50 01
	00 00		 lea	 rcx, QWORD PTR buf$15[rdx]
  00061	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$1
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$2@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$2
  00066	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$13[rdx]
  0006d	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$2@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$4@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$4
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN37@dtor$4
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 4d 40	 lea	 rcx, QWORD PTR ustawienia$14[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN37@dtor$4:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$4@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$5@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$5
  0002e	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$14[rdx]
  00035	48 83 c1 18	 add	 rcx, 24
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$5@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$7@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$7
  00040	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$7@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$0@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$0
  0004e	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$14[rdx]
  00055	e9 00 00 00 00	 jmp	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$0@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$1@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$1
  0005a	48 8d 8a 50 01
	00 00		 lea	 rcx, QWORD PTR buf$15[rdx]
  00061	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T12 = 40
this$ = 48
ustawienia$13 = 64
ustawienia$14 = 64
buf$15 = 336
__$ArrayPad$ = 368
?dtor$2@?0??Sprawd_ustawienia@@YAXXZ@4HA PROC		; `Sprawd_ustawienia'::`1'::dtor$2
  00066	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$13[rdx]
  0006d	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$2@?0??Sprawd_ustawienia@@YAXXZ@4HA ENDP		; `Sprawd_ustawienia'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN19:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8d b9 b0 00
	00 00		 lea	 rdi, QWORD PTR [rcx+176]

; 917  : 		{	// destroy the object

  0001b	48 8b 87 50 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-176]
  00022	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  0002d	48 89 84 39 50
	ff ff ff	 mov	 QWORD PTR [rcx+rdi-176], rax
  00035	48 8b 87 50 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-176]
  0003c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00040	8d 91 50 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-176]
  00046	89 94 39 4c ff
	ff ff		 mov	 DWORD PTR [rcx+rdi-180], edx

; 918  : 		}

  0004d	48 8d 9f 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rdi-160]

; 161  : 		{	// destroy the object

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0005b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005e	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00066	74 2f		 je	 SHORT $LN12@vbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00068	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  0006c	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  00070	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00073	75 22		 jne	 SHORT $LN12@vbase

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00075	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007c	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00083	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00086	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0008a	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008d	44 2b c2	 sub	 r8d, edx
  00090	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00094	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN12@vbase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 164  : 		if (_Closef)

  00097	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  0009b	74 09		 je	 SHORT $LN8@vbase

; 165  : 			close();

  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a5	90		 npad	 1
$LN8@vbase:

; 166  : 		}

  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000af	90		 npad	 1

; 918  : 		}

  000b0	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000bd	90		 npad	 1
  000be	48 8b cf	 mov	 rcx, rdi
  000c1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ca	5f		 pop	 rdi
  000cb	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
classSize$dead$ = 56
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	33 d2		 xor	 edx, edx
  00006	41 b8 10 01 00
	00		 mov	 r8d, 272		; 00000110H
  0000c	e8 00 00 00 00	 call	 memset
  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T21 = 72
wygrana$ = 144
kwota_zak³adu$ = 152
iloæ_pieniêdzy$ = 160
log_ogólny$ = 168
log$ = 176
?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z PROC ; Og³o_wynik, COMDAT

; 1064 : {

$LN189:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 c7 44 24 48
	fe ff ff ff	 mov	 QWORD PTR $T21[rsp], -2
  00018	4d 8b e1	 mov	 r12, r9
  0001b	49 8b f0	 mov	 rsi, r8
  0001e	4c 8b f2	 mov	 r14, rdx
  00021	4c 8b f9	 mov	 r15, rcx
  00024	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR log$[rsp]
  0002c	45 33 c9	 xor	 r9d, r9d
  0002f	44 89 4c 24 20	 mov	 DWORD PTR $T1[rsp], r9d

; 1065 : 	if (wygrana >= kwota_zak³adu) //Je¿eli wygrana jest wiêksza lub równa kwocie zak³adu to znaczy, ¿e siê wygra³o zak³ad

  00034	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00036	8b 2a		 mov	 ebp, DWORD PTR [rdx]
  00038	3b cd		 cmp	 ecx, ebp
  0003a	0f 8c 37 02 00
	00		 jl	 $LN2@Og?

; 1066 : 	{
; 1067 : 		iloæ_pieniêdzy += wygrana; //Dopisanie do salda kwoty wygranej z zak³adu

  00040	8b 16		 mov	 edx, DWORD PTR [rsi]
  00042	03 d1		 add	 edx, ecx
  00044	89 16		 mov	 DWORD PTR [rsi], edx

; 1068 : 		if (Ustawienia.styl_liczenia_wygranej) iloæ_pieniêdzy += kwota_zak³adu; //Dopisanie do salda kwoty zak³adu

  00046	66 44 39 0d 0a
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, r9w
  0004e	74 07		 je	 SHORT $LN4@Og?
  00050	41 8b 0e	 mov	 ecx, DWORD PTR [r14]
  00053	03 ca		 add	 ecx, edx
  00055	89 0e		 mov	 DWORD PTR [rsi], ecx
$LN4@Og?:

; 1069 : 		log << " Wygrywasz " << wygrana << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie wygranej zak³adu

  00057	49 8d 78 10	 lea	 rdi, QWORD PTR [r8+16]
  0005b	48 8b df	 mov	 rbx, rdi
  0005e	4d 85 c0	 test	 r8, r8
  00061	49 0f 44 d9	 cmove	 rbx, r9
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00074	48 8b c8	 mov	 rcx, rax
  00077	41 8b 17	 mov	 edx, DWORD PTR [r15]
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00080	48 8b c8	 mov	 rcx, rax
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  0008a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1070 : 		log << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00096	48 8b cb	 mov	 rcx, rbx
  00099	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0009e	48 8b c8	 mov	 rcx, rax
  000a1	8b 16		 mov	 edx, DWORD PTR [rsi]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  000b3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	b2 0a		 mov	 dl, 10
  000bd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1071 : 		log_ogólny << " Wygrywasz " << wygrana << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie wygranej zak³adu

  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
  000c9	49 8b cc	 mov	 rcx, r12
  000cc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000d1	48 8b c8	 mov	 rcx, rax
  000d4	41 8b 17	 mov	 edx, DWORD PTR [r15]
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  000dd	48 8b c8	 mov	 rcx, rax
  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  000e7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1072 : 		log_ogólny << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  000f3	49 8b cc	 mov	 rcx, r12
  000f6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000fb	48 8b c8	 mov	 rcx, rax
  000fe	8b 16		 mov	 edx, DWORD PTR [rsi]
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00106	48 8b c8	 mov	 rcx, rax
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00110	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00115	48 8b c8	 mov	 rcx, rax
  00118	b2 0a		 mov	 dl, 10
  0011a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1073 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0011f	48 8b cf	 mov	 rcx, rdi
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1074 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00128	49 8b cc	 mov	 rcx, r12
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1075 : 		if (Ustawienia.stan_dwiêków) //Je¿eli stan_dwiêków == 1

  00131	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  00139	0f 84 45 03 00
	00		 je	 $LN14@Og?

; 1076 : 		{
; 1077 : 			if (G³osyKompletne) //Je¿eli s¹ wszystkie pliki g³osów to

  0013f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  00146	0f 84 f0 00 00
	00		 je	 $LN6@Og?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0014c	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00154	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T2[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0015a	c6 44 24 28 00	 mov	 BYTE PTR $T2[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  0015f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 3700 : 			}
; 3701 : 
; 3702 : 		_My_data._Mysize = 0;
; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;
; 3704 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3705 : 		// write can alias this
; 3706 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3707 : 		}
; 3708 : 
; 3709 : 	[[noreturn]] static void _Xlen()
; 3710 : 		{	// report a length_error
; 3711 : 		_Xlength_error("string too long");
; 3712 : 		}
; 3713 : 	};
; 3714 : 
; 3715 : template<class _Elem,
; 3716 : 	class _Traits,
; 3717 : 	class _Alloc> inline
; 3718 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3719 : 		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
; 3720 : 	{	// swap _Left and _Right strings
; 3721 : 	_Left.swap(_Right);
; 3722 : 	}
; 3723 : 
; 3724 : template<class _Elem,
; 3725 : 	class _Traits,
; 3726 : 	class _Alloc> inline
; 3727 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3728 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3729 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3730 : 	{	// return string + string
; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());
; 3733 : 	_Ans += _Left;
; 3734 : 	_Ans += _Right;
; 3735 : 	return (_Ans);
; 3736 : 	}
; 3737 : 
; 3738 : template<class _Elem,
; 3739 : 	class _Traits,
; 3740 : 	class _Alloc> inline
; 3741 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3742 : 		_In_z_ const _Elem * const _Left,
; 3743 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3744 : 	{	// return NTCTS + string
; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
; 3749 : 	_Ans += _Left;
; 3750 : 	_Ans += _Right;
; 3751 : 	return (_Ans);
; 3752 : 	}
; 3753 : 
; 3754 : template<class _Elem,
; 3755 : 	class _Traits,
; 3756 : 	class _Alloc> inline
; 3757 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3758 : 		const _Elem _Left,
; 3759 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 3760 : 	{	// return character + string
; 3761 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3762 : 	_Ans.reserve(1 + _Right.size());
; 3763 : 	_Ans += _Left;
; 3764 : 	_Ans += _Right;
; 3765 : 	return (_Ans);
; 3766 : 	}
; 3767 : 
; 3768 : template<class _Elem,
; 3769 : 	class _Traits,
; 3770 : 	class _Alloc> inline
; 3771 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 3772 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 3773 : 		_In_z_ const _Elem * const _Right)
; 3774 : 	{	// return string + NTCTS
; 3775 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3776 : 	using _Size_type = typename _String_type::size_type;
; 3777 : 	_String_type _Ans;
; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00167	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0016e	48 83 c2 07	 add	 rdx, 7
  00172	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  00177	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0017c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00183	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  0018b	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00193	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0019a	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  0019f	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  001a4	41 b8 07 00 00
	00		 mov	 r8d, 7
  001aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KIPBKJCE@win?4wav?$AA@
  001b1	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  001b6	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1593 : 		const value_type * _Result = _Bx._Buf;

  001bb	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001c0	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T2[rsp+24], 16

; 1594 : 		if (_Large_string_engaged())

  001c6	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T2[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1079 : 				PlaySound((G³os + "win.wav").c_str(), nullptr, SND_SYNC); //Odtworzenie efektu wygrania zak³adu

  001cc	45 33 c0	 xor	 r8d, r8d
  001cf	33 d2		 xor	 edx, edx
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  001d7	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001d8	48 8b 54 24 40	 mov	 rdx, QWORD PTR $T2[rsp+24]
  001dd	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  001e1	0f 82 9d 02 00
	00		 jb	 $LN14@Og?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001e7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  001ec	48 8b c1	 mov	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001ef	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001f2	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  001f9	72 2d		 jb	 SHORT $LN153@Og?

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  001fb	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  001ff	4c 3b c2	 cmp	 r8, rdx
  00202	76 1d		 jbe	 SHORT $_Invalid_parameter$190

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00204	49 8b d0	 mov	 rdx, r8
  00207	a8 1f		 test	 al, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00209	75 16		 jne	 SHORT $_Invalid_parameter$190

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0020b	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0020f	48 3b c8	 cmp	 rcx, rax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00212	73 0d		 jae	 SHORT $_Invalid_parameter$190

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00214	48 2b c1	 sub	 rax, rcx
  00217	48 83 e8 08	 sub	 rax, 8
  0021b	48 83 f8 1f	 cmp	 rax, 31
  0021f	76 07		 jbe	 SHORT $LN153@Og?
$_Invalid_parameter$190:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00221	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00227	cc		 int	 3
$LN153@Og?:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00228	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1119 : }

  0022d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00231	41 5f		 pop	 r15
  00233	41 5e		 pop	 r14
  00235	41 5c		 pop	 r12
  00237	5f		 pop	 rdi
  00238	5e		 pop	 rsi
  00239	5d		 pop	 rbp
  0023a	5b		 pop	 rbx
  0023b	c3		 ret	 0
$LN6@Og?:

; 1080 : 			}
; 1081 : 			else
; 1082 : 			{
; 1083 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku

  0023c	b2 07		 mov	 dl, 7
  0023e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00245	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1084 : 				Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  0024a	0f bf 0d 08 00
	00 00		 movsx	 ecx, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8
  00251	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
$LN187@Og?:

; 1085 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku

  00257	b2 07		 mov	 dl, 7
  00259	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00260	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1086 : 				Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  00265	0f bf 0d 08 00
	00 00		 movsx	 ecx, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 1087 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku
; 1088 : 			}
; 1089 : 		}
; 1090 : 	}

  00272	e9 ff 01 00 00	 jmp	 $LN186@Og?
$LN2@Og?:

; 1091 : 	else if (wygrana == (kwota_zak³adu / 2)) //Je¿eli wygrana jest równa po³owie kwocie zak³adu to znaczy, ¿e dostaje siê zwrot po³owy kwoty zak³adu

  00277	8b c5		 mov	 eax, ebp
  00279	99		 cdq
  0027a	2b c2		 sub	 eax, edx
  0027c	d1 f8		 sar	 eax, 1
  0027e	3b c8		 cmp	 ecx, eax
  00280	0f 85 fc 00 00
	00		 jne	 $LN8@Og?

; 1092 : 	{
; 1093 : 		iloæ_pieniêdzy += wygrana; //Dopisanie do salda kwoty zwrotu z zak³adu

  00286	01 0e		 add	 DWORD PTR [rsi], ecx

; 1094 : 		log << " Dostajesz polowe zak³adu " << wygrana << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie zwrotu zak³adu

  00288	49 8d 78 10	 lea	 rdi, QWORD PTR [r8+16]
  0028c	48 8b df	 mov	 rbx, rdi
  0028f	4d 85 c0	 test	 r8, r8
  00292	49 0f 44 d9	 cmove	 rbx, r9
  00296	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
  0029d	48 8b cb	 mov	 rcx, rbx
  002a0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002a5	48 8b c8	 mov	 rcx, rax
  002a8	41 8b 17	 mov	 edx, DWORD PTR [r15]
  002ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  002b1	48 8b c8	 mov	 rcx, rax
  002b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  002bb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1095 : 		log << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  002c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  002c7	48 8b cb	 mov	 rcx, rbx
  002ca	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002cf	48 8b c8	 mov	 rcx, rax
  002d2	8b 16		 mov	 edx, DWORD PTR [rsi]
  002d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  002da	48 8b c8	 mov	 rcx, rax
  002dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  002e4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002e9	48 8b c8	 mov	 rcx, rax
  002ec	b2 0a		 mov	 dl, 10
  002ee	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1096 : 		log_ogólny << " Dostajesz polowe zak³adu " << wygrana << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie zwrotu zak³adu

  002f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
  002fa	49 8b cc	 mov	 rcx, r12
  002fd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00302	48 8b c8	 mov	 rcx, rax
  00305	41 8b 17	 mov	 edx, DWORD PTR [r15]
  00308	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0030e	48 8b c8	 mov	 rcx, rax
  00311	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00318	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1097 : 		log_ogólny << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  0031d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00324	49 8b cc	 mov	 rcx, r12
  00327	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0032c	48 8b c8	 mov	 rcx, rax
  0032f	8b 16		 mov	 edx, DWORD PTR [rsi]
  00331	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00337	48 8b c8	 mov	 rcx, rax
  0033a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00341	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00346	48 8b c8	 mov	 rcx, rax
  00349	b2 0a		 mov	 dl, 10
  0034b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1098 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  00350	48 8b cf	 mov	 rcx, rdi
  00353	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1099 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00359	49 8b cc	 mov	 rcx, r12
  0035c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1100 : 		if (Ustawienia.stan_dwiêków) //Je¿eli stan_dwiêków == 1

  00362	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  0036a	0f 84 14 01 00
	00		 je	 $LN14@Og?

; 1101 : 			if (!G³osyKompletne) //Je¿eli nie ma wszystkich plików g³osów to

  00370	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  00377	0f 85 07 01 00
	00		 jne	 $LN14@Og?

; 1102 : 			{
; 1103 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku
; 1104 : 				Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem
; 1105 : 				cout << '\a'; //Wywo³anie pikniêcia w g³oniku
; 1106 : 			}
; 1107 : 	}

  0037d	e9 d5 fe ff ff	 jmp	 $LN187@Og?
$LN8@Og?:

; 1108 : 	else if (wygrana == 0) //Je¿eli wygrana jest równa 0 to znaczy, ¿e siê zak³ad przegra³o

  00382	85 c9		 test	 ecx, ecx
  00384	0f 85 fa 00 00
	00		 jne	 $LN14@Og?

; 1109 : 	{
; 1110 : 		log << " Przegrales " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o przegranej kwocie

  0038a	49 8d 78 10	 lea	 rdi, QWORD PTR [r8+16]
  0038e	48 8b df	 mov	 rbx, rdi
  00391	4d 85 c0	 test	 r8, r8
  00394	49 0f 44 d9	 cmove	 rbx, r9
  00398	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
  0039f	48 8b cb	 mov	 rcx, rbx
  003a2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003a7	48 8b c8	 mov	 rcx, rax
  003aa	8b d5		 mov	 edx, ebp
  003ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  003b2	48 8b c8	 mov	 rcx, rax
  003b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  003bc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1111 : 		log << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  003c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  003c8	48 8b cb	 mov	 rcx, rbx
  003cb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003d0	48 8b c8	 mov	 rcx, rax
  003d3	8b 16		 mov	 edx, DWORD PTR [rsi]
  003d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  003db	48 8b c8	 mov	 rcx, rax
  003de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  003e5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003ea	48 8b c8	 mov	 rcx, rax
  003ed	b2 0a		 mov	 dl, 10
  003ef	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1112 : 		log_ogólny << " Przegrales " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o przegranej kwocie

  003f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
  003fb	49 8b cc	 mov	 rcx, r12
  003fe	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00403	48 8b c8	 mov	 rcx, rax
  00406	41 8b 16	 mov	 edx, DWORD PTR [r14]
  00409	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0040f	48 8b c8	 mov	 rcx, rax
  00412	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00419	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1113 : 		log_ogólny << " Posiadasz " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  0041e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00425	49 8b cc	 mov	 rcx, r12
  00428	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0042d	48 8b c8	 mov	 rcx, rax
  00430	8b 16		 mov	 edx, DWORD PTR [rsi]
  00432	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00438	48 8b c8	 mov	 rcx, rax
  0043b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00442	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00447	48 8b c8	 mov	 rcx, rax
  0044a	b2 0a		 mov	 dl, 10
  0044c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1114 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  00451	48 8b cf	 mov	 rcx, rdi
  00454	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1115 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  0045a	49 8b cc	 mov	 rcx, r12
  0045d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1116 : 		if (Ustawienia.stan_dwiêków)

  00463	66 83 3d 10 00
	00 00 00	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 0
  0046b	74 17		 je	 SHORT $LN14@Og?

; 1117 : 			if (!G³osyKompletne) cout << '\a';  //Je¿eli nie ma wszystkich plików g³osów to wywo³anie pikniêcia w g³oniku

  0046d	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  00474	75 0e		 jne	 SHORT $LN14@Og?
$LN186@Og?:
  00476	b2 07		 mov	 dl, 7
  00478	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0047f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
$LN14@Og?:

; 1119 : }

  00484	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00488	41 5f		 pop	 r15
  0048a	41 5e		 pop	 r14
  0048c	41 5c		 pop	 r12
  0048e	5f		 pop	 rdi
  0048f	5e		 pop	 rsi
  00490	5d		 pop	 rbp
  00491	5b		 pop	 rbx
  00492	c3		 ret	 0
$LN185@Og?:
?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ENDP ; Og³o_wynik
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T21 = 72
wygrana$ = 144
kwota_zak³adu$ = 152
iloæ_pieniêdzy$ = 160
log_ogólny$ = 168
log$ = 176
?dtor$1@?0??Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA PROC ; `Og³o_wynik'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN32@dtor$1
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 4d 28	 lea	 rcx, QWORD PTR $T2[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN32@dtor$1:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$1@?0??Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA ENDP ; `Og³o_wynik'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T21 = 72
wygrana$ = 144
kwota_zak³adu$ = 152
iloæ_pieniêdzy$ = 160
log_ogólny$ = 168
log$ = 176
?dtor$1@?0??Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA PROC ; `Og³o_wynik'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN32@dtor$1
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 4d 28	 lea	 rcx, QWORD PTR $T2[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN32@dtor$1:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$1@?0??Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA ENDP ; `Og³o_wynik'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z
_TEXT	SEGMENT
log_ogólny$ = 48
log$ = 56
iloæ_pieniêdzy$ = 64
?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z PROC ; Koniec_gry, COMDAT

; 1122 : {

$LN28:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	4c 8b f2	 mov	 r14, rdx
  00018	48 8b f9	 mov	 rdi, rcx

; 1123 : 	cout << endl << "Koñczysz grê z wynikiem " << iloæ_pieniêdzy << "$" << endl; //Poinformowanie u¿ytkownika o saldzie konta

  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00029	49 8b f0	 mov	 rsi, r8
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  00032	48 8b c8	 mov	 rcx, rax
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  0003c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00041	8b 16		 mov	 edx, DWORD PTR [rsi]
  00043	48 8b c8	 mov	 rcx, rax
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00056	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1124 : 	log << '\n' << "Koñczysz grê z wynikiem " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  0006b	33 c0		 xor	 eax, eax
  0006d	49 8d 4e 10	 lea	 rcx, QWORD PTR [r14+16]
  00071	4d 85 f6	 test	 r14, r14
  00074	b2 0a		 mov	 dl, 10
  00076	48 0f 44 c8	 cmove	 rcx, rax
  0007a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
  0007f	48 8b c8	 mov	 rcx, rax
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  00089	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0008e	8b 16		 mov	 edx, DWORD PTR [rsi]
  00090	48 8b c8	 mov	 rcx, rax
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00099	48 8b c8	 mov	 rcx, rax
  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  000a3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	b2 0a		 mov	 dl, 10
  000ad	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1125 : 	log_ogólny << "Koñczysz grê z wynikiem " << iloæ_pieniêdzy << "$" << '\n'; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000c1	8b 16		 mov	 edx, DWORD PTR [rsi]
  000c3	48 8b c8	 mov	 rcx, rax
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  000cc	48 8b c8	 mov	 rcx, rax
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  000d6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000db	48 8b c8	 mov	 rcx, rax
  000de	b2 0a		 mov	 dl, 10
  000e0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1126 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  000e5	49 8d 4e 10	 lea	 rcx, QWORD PTR [r14+16]
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1127 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000ef	48 8b cf	 mov	 rcx, rdi
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 1391 : 		if (_Filebuffer.close() == 0)

  000f8	49 8d 4e 18	 lea	 rcx, QWORD PTR [r14+24]
  000fc	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00101	48 85 c0	 test	 rax, rax
  00104	75 17		 jne	 SHORT $LN20@Koniec_gry

; 1392 : 			_Myios::setstate(ios_base::failbit);

  00106	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00109	45 33 c0	 xor	 r8d, r8d
  0010c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00110	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  00114	49 03 ce	 add	 rcx, r14
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN20@Koniec_gry:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1129 : 	remove("log_aktualny.txt"); //Usuniêcie pliku log aktualny poniewa¿ skoñczy³o siê grê

  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_remove

; 1130 : 
; 1131 : 	if (Ustawienia.stan_dwiêków == 1) //Je¿eli stan_dwiêków == 1

  0012a	66 83 3d 10 00
	00 00 01	 cmp	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, 1
  00132	75 4d		 jne	 SHORT $LN3@Koniec_gry

; 1132 : 		if (iloæ_pieniêdzy == 0) //Je¿eli bud¿et jest równy 0 to

  00134	83 3e 00	 cmp	 DWORD PTR [rsi], 0
  00137	75 48		 jne	 SHORT $LN3@Koniec_gry

; 1133 : 			if (EfektyKompletne) PlaySound("Efekty_dwiêkowe/bankrut.wav", nullptr, SND_SYNC); //Je¿eli pliki efektów s¹ dostêpne, odtworzenie efektu bankruta

  00139	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  00140	74 14		 je	 SHORT $LN7@Koniec_gry
  00142	45 33 c0	 xor	 r8d, r8d
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  0014c	33 d2		 xor	 edx, edx
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA

; 1134 : 			else //W przeciwym wypadku

  00154	eb 2b		 jmp	 SHORT $LN3@Koniec_gry
$LN7@Koniec_gry:

; 1135 : 				for (unsigned short i = 0; i < 5; ++i) //Rozpoczêcie pêtli która wykona 5 obrotów

  00156	bb 05 00 00 00	 mov	 ebx, 5
  0015b	0f 1f 44 00 00	 npad	 5
$LL4@Koniec_gry:

; 1136 : 				{
; 1137 : 					cout << '\a'; //Wywo³anie pikniêcia w g³oniku

  00160	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00167	b2 07		 mov	 dl, 7
  00169	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1138 : 					Sleep(Ustawienia.czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem //Przerwa przed kolejnym pikniêciem

  0016e	0f bf 0d 08 00
	00 00		 movsx	 ecx, WORD PTR ?Ustawienia@@3US_Ustawienia@@A+8
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
  0017b	48 83 eb 01	 sub	 rbx, 1
  0017f	75 df		 jne	 SHORT $LL4@Koniec_gry
$LN3@Koniec_gry:

; 1139 : 				}
; 1140 : 
; 1141 : 	if (iloæ_pieniêdzy > Ustawienia.kwota_pocz¹tkowa && iloæ_pieniêdzy < Ustawienia.kwota_pocz¹tkowa * 2) //Sprawdzenie czy zwiêkszy³o siê bud¿et

  00181	44 8b 06	 mov	 r8d, DWORD PTR [rsi]
  00184	44 8b 0d 0c 00
	00 00		 mov	 r9d, DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12
  0018b	45 3b c1	 cmp	 r8d, r9d
  0018e	7e 44		 jle	 SHORT $LN9@Koniec_gry
  00190	43 8d 04 09	 lea	 eax, DWORD PTR [r9+r9]
  00194	44 3b c0	 cmp	 r8d, eax
  00197	7d 3b		 jge	 SHORT $LN9@Koniec_gry

; 1142 : 	{
; 1143 : 		cout << "Gratuluje zwiêkszy³e swój zasób finansowy" << endl; //Wywietlenie gratulacji z powodu zwiêkszenia bud¿etu

  00199	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@
  001a7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  001ac	48 8b c8	 mov	 rcx, rax
  001af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1144 : 		if (EfektyKompletne) //Je¿eli pliki efektów s¹ dostêpne

  001bc	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  001c3	74 79		 je	 SHORT $LN15@Koniec_gry

; 1145 : 			if (rand() % 1) PlaySound("Efekty_dwiêkowe/wygrana1.wav", nullptr, SND_SYNC); //Wylosowanie numeru otworzonego efektu, odtworzenie je¿eli wylosowano efekt 0

  001c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand

; 1146 : 			else PlaySound("Efekty_dwiêkowe/wygrana2.wav", nullptr, SND_SYNC); //Odtworzenie je¿eli wylosowano efekt 1

  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@

; 1147 : 	}

  001d2	eb 5f		 jmp	 SHORT $LN26@Koniec_gry
$LN9@Koniec_gry:

; 1148 : 	else if (iloæ_pieniêdzy >= Ustawienia.kwota_pocz¹tkowa * 2) //Sprawdzenie czy zwielokrotniono przynajmniej 2 razy bud¿et

  001d4	43 8d 0c 09	 lea	 ecx, DWORD PTR [r9+r9]
  001d8	44 3b c1	 cmp	 r8d, ecx
  001db	7c 61		 jl	 SHORT $LN15@Koniec_gry

; 1149 : 	{
; 1150 : 		cout << "Gratuluje zwiêkszy³e " << iloæ_pieniêdzy / Ustawienia.kwota_pocz¹tkowa << " krotnie swój zasób finansowy" << endl; //Wywietlenie gratulacji z powodu zwielokrotnienia przynajmniej 2 razy bud¿etu

  001dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001e4	41 8b c0	 mov	 eax, r8d
  001e7	99		 cdq
  001e8	41 f7 f9	 idiv	 r9d
  001eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@
  001f2	8b d8		 mov	 ebx, eax
  001f4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  001f9	48 8b c8	 mov	 rcx, rax
  001fc	8b d3		 mov	 edx, ebx
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00204	48 8b c8	 mov	 rcx, rax
  00207	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@
  0020e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00213	48 8b c8	 mov	 rcx, rax
  00216	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1151 : 		if (EfektyKompletne) PlaySound("Efekty_dwiêkowe/zwielokrotnenie.wav", nullptr, SND_SYNC); //Odtworzenie efektu dwiêkowego wzamian za zwielokrotnienie bud¿etu, je¿eli pliki efektów s¹ dostêpne

  00223	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  0022a	74 12		 je	 SHORT $LN15@Koniec_gry
  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
$LN26@Koniec_gry:
  00233	45 33 c0	 xor	 r8d, r8d
  00236	33 d2		 xor	 edx, edx
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
$LN15@Koniec_gry:

; 1152 : 	}
; 1153 : }

  0023e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00243	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00248	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0024d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00251	41 5e		 pop	 r14
  00253	c3		 ret	 0
?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z ENDP ; Koniec_gry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
$T1 = 48
wygrana$ = 128
kwota_zak³adu$ = 136
iloæ_pieniêdzy$ = 144
log_ogólny$ = 152
log$ = 160
co_kontynuowaæ$ = 168
typ_zak³adu$ = 176
wylosowana_liczba$ = 184
?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; Pêtla_g³ówna, COMDAT

; 1156 : {

$LN284:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1157 : 	if (co_kontynuowaæ == 'n') Wczytaj_Kwotê_Zak³adu(kwota_zak³adu, iloæ_pieniêdzy); //Przypisanie do zmiennej pobranej od u¿ytkownika kwoty zak³adu

  0001c	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR co_kontynuowaæ$[rsp]
  00024	4d 8b f9	 mov	 r15, r9
  00027	4d 8b e8	 mov	 r13, r8
  0002a	4c 8b e2	 mov	 r12, rdx
  0002d	80 3e 6e	 cmp	 BYTE PTR [rsi], 110	; 0000006eH
  00030	75 0d		 jne	 SHORT $LN2@P?
  00032	49 8b d0	 mov	 rdx, r8
  00035	49 8b cc	 mov	 rcx, r12
  00038	e8 00 00 00 00	 call	 ?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z ; Wczytaj_Kwotê_Zak³adu

; 1158 : 	else

  0003d	eb 7e		 jmp	 SHORT $LN3@P?
$LN2@P?:

; 1159 : 	{
; 1160 : 		cout << "Masz " << iloæ_pieniêdzy << "$" << endl; //Wypisanie wczytanej informacji o posiadanej iloci pieniêdzy

  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05OMMBNPEF@Masz?5?$AA@
  0004d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00052	41 8b 55 00	 mov	 edx, DWORD PTR [r13]
  00056	48 8b c8	 mov	 rcx, rax
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0005f	48 8b c8	 mov	 rcx, rax
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00069	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0006e	48 8b c8	 mov	 rcx, rax
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1161 : 		cout << "Obstawiono za " << kwota_zak³adu << "$" << endl; //Wypisanie wczytanej kwoty zak³adu

  0007e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  0008c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00091	41 8b 14 24	 mov	 edx, DWORD PTR [r12]
  00095	48 8b c8	 mov	 rcx, rax
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0009e	48 8b c8	 mov	 rcx, rax
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  000a8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
$LN3@P?:

; 1162 : 	}
; 1163 : 	if (co_kontynuowaæ == 'n') log << "Obstawiono za " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie obstawionego zak³adu

  000bd	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR log$[rsp]
  000c5	45 33 f6	 xor	 r14d, r14d
  000c8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  000cb	48 8d 6b 10	 lea	 rbp, QWORD PTR [rbx+16]
  000cf	3c 6e		 cmp	 al, 110			; 0000006eH
  000d1	75 64		 jne	 SHORT $LN5@P?
  000d3	48 85 db	 test	 rbx, rbx
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  000dd	48 8b cd	 mov	 rcx, rbp
  000e0	49 0f 44 ce	 cmove	 rcx, r14
  000e4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000e9	41 8b 14 24	 mov	 edx, DWORD PTR [r12]
  000ed	48 8b c8	 mov	 rcx, rax
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00100	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00105	0f b6 06	 movzx	 eax, BYTE PTR [rsi]

; 1164 : 	if (co_kontynuowaæ == 'n') log_ogólny << "Obstawiono za " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie obstawionego zak³adu

  00108	3c 6e		 cmp	 al, 110			; 0000006eH
  0010a	75 2b		 jne	 SHORT $LN5@P?
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  00113	49 8b cf	 mov	 rcx, r15
  00116	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0011b	41 8b 14 24	 mov	 edx, DWORD PTR [r12]
  0011f	48 8b c8	 mov	 rcx, rax
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00128	48 8b c8	 mov	 rcx, rax
  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00132	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
$LN5@P?:

; 1165 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  00137	48 8b cd	 mov	 rcx, rbp
  0013a	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rdi
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1166 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00148	49 8b cf	 mov	 rcx, r15
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1167 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  00151	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00154	3c 6e		 cmp	 al, 110			; 0000006eH
  00156	74 4d		 je	 SHORT $LN8@P?
  00158	3c 6b		 cmp	 al, 107			; 0000006bH
  0015a	74 49		 je	 SHORT $LN8@P?

; 1168 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  0015c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@
  0016a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3047 : 		return (this->_Get_data()._Mysize);

  0016f	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR typ_zak³adu$[rsp]

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00177	48 8b d7	 mov	 rdx, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0017a	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 1594 : 		if (_Large_string_engaged())

  0017f	72 03		 jb	 SHORT $LN267@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00181	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
$LN267@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  00184	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00188	48 8b c8	 mov	 rcx, rax
  0018b	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
  00190	48 8b c8	 mov	 rcx, rax
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1168 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  00193	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  001a0	e9 98 00 00 00	 jmp	 $LN145@P?
$LN8@P?:

; 1167 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  001a5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  001aa	e8 00 00 00 00	 call	 ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2071 : 		if (this != _STD addressof(_Right))

  001af	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR typ_zak³adu$[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1167 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  001b7	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2071 : 		if (this != _STD addressof(_Right))

  001ba	48 3b f8	 cmp	 rdi, rax
  001bd	74 25		 je	 SHORT $LN105@P?

; 2072 : 			{	// different, assign it
; 2073 : 			_Tidy_deallocate();

  001bf	48 8b cf	 mov	 rcx, rdi
  001c2	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  001c7	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]
  001ca	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0
  001cd	0f 10 4b 10	 movups	 xmm1, XMMWORD PTR [rbx+16]
  001d1	0f 11 4f 10	 movups	 XMMWORD PTR [rdi+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  001d5	4c 89 73 10	 mov	 QWORD PTR [rbx+16], r14

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001d9	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  001e1	44 88 33	 mov	 BYTE PTR [rbx], r14b
$LN105@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001e4	48 8b 54 24 48	 mov	 rdx, QWORD PTR $T1[rsp+24]
  001e9	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  001ed	72 46		 jb	 SHORT $LN279@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001ef	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001f4	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  001f7	48 8b c1	 mov	 rax, rcx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  001fa	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00201	72 2d		 jb	 SHORT $LN148@P?

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00203	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  00207	4c 3b c2	 cmp	 r8, rdx
  0020a	76 1d		 jbe	 SHORT $_Invalid_parameter$285

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0020c	49 8b d0	 mov	 rdx, r8
  0020f	a8 1f		 test	 al, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00211	75 16		 jne	 SHORT $_Invalid_parameter$285

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00213	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  00217	48 3b c8	 cmp	 rcx, rax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0021a	73 0d		 jae	 SHORT $_Invalid_parameter$285

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0021c	48 2b c1	 sub	 rax, rcx
  0021f	48 83 e8 08	 sub	 rax, 8
  00223	48 83 f8 1f	 cmp	 rax, 31
  00227	76 07		 jbe	 SHORT $LN148@P?
$_Invalid_parameter$285:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0022f	cc		 int	 3
$LN148@P?:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00230	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN279@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3694 : 		if (_My_data._Large_string_engaged())

  00235	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR log$[rsp]
$LN145@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1169 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') log << " Obstawiono zaklad " << typ_zak³adu; //Zapisanie do bufora pliku logu aktualnego informacji o typie obstawionego zak³adu

  0023d	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00240	3c 6e		 cmp	 al, 110			; 0000006eH
  00242	74 04		 je	 SHORT $LN10@P?
  00244	3c 6b		 cmp	 al, 107			; 0000006bH
  00246	75 32		 jne	 SHORT $LN9@P?
$LN10@P?:
  00248	48 85 db	 test	 rbx, rbx
  0024b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
  00252	48 8b cd	 mov	 rcx, rbp
  00255	49 0f 44 ce	 cmove	 rcx, r14
  00259	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0025e	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00263	48 8b d7	 mov	 rdx, rdi

; 1594 : 		if (_Large_string_engaged())

  00266	72 03		 jb	 SHORT $LN268@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00268	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
$LN268@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  0026b	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  0026f	48 8b c8	 mov	 rcx, rax
  00272	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
  00277	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
$LN9@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1170 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') log_ogólny << " Obstawiono zaklad " << typ_zak³adu; //Zapisanie do bufora pliku logu ogólnego informacji o typie obstawionego zak³adu

  0027a	3c 6e		 cmp	 al, 110			; 0000006eH
  0027c	74 04		 je	 SHORT $LN12@P?
  0027e	3c 6b		 cmp	 al, 107			; 0000006bH
  00280	75 28		 jne	 SHORT $LN11@P?
$LN12@P?:
  00282	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
  00289	49 8b cf	 mov	 rcx, r15
  0028c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00291	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00296	48 8b d7	 mov	 rdx, rdi

; 1594 : 		if (_Large_string_engaged())

  00299	72 03		 jb	 SHORT $LN254@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0029b	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
$LN254@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  0029e	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  002a2	48 8b c8	 mov	 rcx, rax
  002a5	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
$LN11@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1171 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  002aa	48 8b cd	 mov	 rcx, rbp
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1172 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  002b3	49 8b cf	 mov	 rcx, r15
  002b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1173 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') iloæ_pieniêdzy -= kwota_zak³adu; //Odjêcie od iloci pieniêdzy kwoty zak³adu

  002bc	0f b6 0e	 movzx	 ecx, BYTE PTR [rsi]
  002bf	ba 09 02 00 00	 mov	 edx, 521		; 00000209H
  002c4	8d 41 95	 lea	 eax, DWORD PTR [rcx-107]
  002c7	3c 09		 cmp	 al, 9
  002c9	77 08		 ja	 SHORT $LN270@P?
  002cb	0f be c0	 movsx	 eax, al
  002ce	0f a3 c2	 bt	 edx, eax
  002d1	72 05		 jb	 SHORT $LN14@P?
$LN270@P?:
  002d3	80 f9 77	 cmp	 cl, 119			; 00000077H
  002d6	75 0b		 jne	 SHORT $LN13@P?
$LN14@P?:
  002d8	41 8b 04 24	 mov	 eax, DWORD PTR [r12]
  002dc	41 29 45 00	 sub	 DWORD PTR [r13], eax
  002e0	0f b6 0e	 movzx	 ecx, BYTE PTR [rsi]
$LN13@P?:

; 1174 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') cout << "Kulka w grze, zaczekaj na wylosowanie numeru..." << endl; //Poinformowanie u¿ytkownika o rozpoczêciu losowania

  002e3	80 f9 6e	 cmp	 cl, 110			; 0000006eH
  002e6	74 0a		 je	 SHORT $LN16@P?
  002e8	80 f9 6b	 cmp	 cl, 107			; 0000006bH
  002eb	74 05		 je	 SHORT $LN16@P?
  002ed	80 f9 74	 cmp	 cl, 116			; 00000074H
  002f0	75 2b		 jne	 SHORT $LN15@P?
$LN16@P?:
  002f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@
  00300	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00305	48 8b c8	 mov	 rcx, rax
  00308	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0030f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  00315	0f b6 0e	 movzx	 ecx, BYTE PTR [rsi]
  00318	ba 09 02 00 00	 mov	 edx, 521		; 00000209H
$LN15@P?:

; 1175 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') wylosowana_liczba = Zakrêæ_Ruletk¹(); //Wylosowanie i przypisanie do zmiennej liczby bêdêcej na  wylosowanej pozycji na kole ruletki

  0031d	80 e9 6b	 sub	 cl, 107			; 0000006bH
  00320	80 f9 09	 cmp	 cl, 9
  00323	77 1a		 ja	 SHORT $LN272@P?
  00325	0f be c1	 movsx	 eax, cl
  00328	0f a3 c2	 bt	 edx, eax
  0032b	73 12		 jae	 SHORT $LN272@P?
  0032d	e8 00 00 00 00	 call	 ?Zakrêæ_Ruletk¹@@YAHXZ	; Zakrêæ_Ruletk¹
  00332	4c 8b b4 24 b8
	00 00 00	 mov	 r14, QWORD PTR wylosowana_liczba$[rsp]
  0033a	41 89 06	 mov	 DWORD PTR [r14], eax
  0033d	eb 7c		 jmp	 SHORT $LN18@P?
$LN272@P?:

; 1176 : 	else {
; 1177 : 		cout << "Wylosowano numer "; //Poinformowaniu o wylosowaniu liczby

  0033f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00346	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
  0034d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1178 : 		Change_Col(Ruletka_plansza_kolor_col[wylosowana_liczba]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  00352	4c 8b b4 24 b8
	00 00 00	 mov	 r14, QWORD PTR wylosowana_liczba$[rsp]
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Ruletka_plansza_kolor_col@@3QBGB
  00361	49 63 06	 movsxd	 rax, DWORD PTR [r14]
  00364	0f b7 1c 41	 movzx	 ebx, WORD PTR [rcx+rax*2]

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  00368	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0036d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00373	48 8b c8	 mov	 rcx, rax
  00376	0f b7 d3	 movzx	 edx, bx
  00379	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 1179 : 		cout << wylosowana_liczba; //Wypisanie wylosowanej liczby

  0037f	41 8b 16	 mov	 edx, DWORD PTR [r14]
  00382	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z

; 381  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjcia

  0038f	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  00394	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 382  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0039a	48 8b c8	 mov	 rcx, rax
  0039d	ba 07 00 00 00	 mov	 edx, 7
  003a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 1180 : 		Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 1181 : 		cout << ". "; //Wypisanie kropki koñcz¹cej zdanie

  003a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  003af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KHOJGJKF@?4?5?$AA@
  003b6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
$LN18@P?:

; 1182 : 	}
; 1183 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') log << " Wylosowano " << wylosowana_liczba; //Zapisanie do bufora pliku logu aktualnego informacji o wylosowanej liczbie

  003bb	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  003be	3c 6e		 cmp	 al, 110			; 0000006eH
  003c0	74 08		 je	 SHORT $LN21@P?
  003c2	3c 6b		 cmp	 al, 107			; 0000006bH
  003c4	74 04		 je	 SHORT $LN21@P?
  003c6	3c 74		 cmp	 al, 116			; 00000074H
  003c8	75 34		 jne	 SHORT $LN278@P?
$LN21@P?:
  003ca	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR log$[rsp]
  003d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
  003d9	b8 00 00 00 00	 mov	 eax, 0
  003de	48 85 db	 test	 rbx, rbx
  003e1	48 8b cd	 mov	 rcx, rbp
  003e4	48 0f 44 c8	 cmove	 rcx, rax
  003e8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003ed	41 8b 16	 mov	 edx, DWORD PTR [r14]
  003f0	48 8b c8	 mov	 rcx, rax
  003f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  003f9	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  003fc	eb 08		 jmp	 SHORT $LN20@P?
$LN278@P?:
  003fe	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR log$[rsp]
$LN20@P?:

; 1184 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') log_ogólny << " Wylosowano " << wylosowana_liczba; //Zapisanie do bufora pliku logu ogólnego informacji o wylosowanej liczbie

  00406	2c 6b		 sub	 al, 107			; 0000006bH
  00408	3c 09		 cmp	 al, 9
  0040a	77 28		 ja	 SHORT $LN22@P?
  0040c	0f be c0	 movsx	 eax, al
  0040f	b9 09 02 00 00	 mov	 ecx, 521		; 00000209H
  00414	0f a3 c1	 bt	 ecx, eax
  00417	73 1b		 jae	 SHORT $LN22@P?
  00419	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
  00420	49 8b cf	 mov	 rcx, r15
  00423	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00428	41 8b 16	 mov	 edx, DWORD PTR [r14]
  0042b	48 8b c8	 mov	 rcx, rax
  0042e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
$LN22@P?:

; 1185 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  00434	48 8b cd	 mov	 rcx, rbp
  00437	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1186 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  0043d	49 8b cf	 mov	 rcx, r15
  00440	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1187 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') Odczytaj_liczbê(wylosowana_liczba, typ_zak³adu);

  00446	0f b6 0e	 movzx	 ecx, BYTE PTR [rsi]
  00449	80 f9 6e	 cmp	 cl, 110			; 0000006eH
  0044c	74 0a		 je	 SHORT $LN25@P?
  0044e	80 f9 6b	 cmp	 cl, 107			; 0000006bH
  00451	74 05		 je	 SHORT $LN25@P?
  00453	80 f9 74	 cmp	 cl, 116			; 00000074H
  00456	75 0e		 jne	 SHORT $LN24@P?
$LN25@P?:
  00458	48 8b d7	 mov	 rdx, rdi
  0045b	49 8b ce	 mov	 rcx, r14
  0045e	e8 00 00 00 00	 call	 ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Odczytaj_liczbê
  00463	0f b6 0e	 movzx	 ecx, BYTE PTR [rsi]
$LN24@P?:

; 1188 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') wygrana = Sprawd_Zak³ad(kwota_zak³adu, typ_zak³adu, wylosowana_liczba); //Przypisanie do wygranej kwoty zgodnej z wygran¹, je¿eli siê cowygra³o

  00466	8d 41 95	 lea	 eax, DWORD PTR [rcx-107]
  00469	3c 09		 cmp	 al, 9
  0046b	77 0a		 ja	 SHORT $LN275@P?
  0046d	ba 09 02 00 00	 mov	 edx, 521		; 00000209H
  00472	0f a3 c2	 bt	 edx, eax
  00475	72 05		 jb	 SHORT $LN27@P?
$LN275@P?:
  00477	80 f9 77	 cmp	 cl, 119			; 00000077H
  0047a	75 1e		 jne	 SHORT $LN280@P?
$LN27@P?:
  0047c	4d 8b c6	 mov	 r8, r14
  0047f	48 8b d7	 mov	 rdx, rdi
  00482	49 8b cc	 mov	 rcx, r12
  00485	e8 00 00 00 00	 call	 ?Sprawd_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Sprawd_Zak³ad
  0048a	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR wygrana$[rsp]
  00492	41 89 02	 mov	 DWORD PTR [r10], eax
  00495	0f b6 0e	 movzx	 ecx, BYTE PTR [rsi]
  00498	eb 08		 jmp	 SHORT $LN26@P?
$LN280@P?:
  0049a	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR wygrana$[rsp]
$LN26@P?:

; 1189 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') Og³o_wynik(wygrana, kwota_zak³adu, iloæ_pieniêdzy, log_ogólny, log); //Funkcja informuj¹ca u¿ytkownika czy wygra³ zak³ad

  004a2	80 e9 6b	 sub	 cl, 107			; 0000006bH
  004a5	80 f9 0c	 cmp	 cl, 12
  004a8	77 20		 ja	 SHORT $LN28@P?
  004aa	b8 09 12 00 00	 mov	 eax, 4617		; 00001209H
  004af	0f a3 c8	 bt	 eax, ecx
  004b2	73 16		 jae	 SHORT $LN28@P?
  004b4	4d 8b cf	 mov	 r9, r15
  004b7	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  004bc	4d 8b c5	 mov	 r8, r13
  004bf	49 8b d4	 mov	 rdx, r12
  004c2	49 8b ca	 mov	 rcx, r10
  004c5	e8 00 00 00 00	 call	 ?Og³o_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ; Og³o_wynik
$LN28@P?:

; 1190 : }

  004ca	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]
  004d2	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  004d7	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  004db	49 8b 6b 48	 mov	 rbp, QWORD PTR [r11+72]
  004df	49 8b e3	 mov	 rsp, r11
  004e2	41 5f		 pop	 r15
  004e4	41 5e		 pop	 r14
  004e6	41 5d		 pop	 r13
  004e8	41 5c		 pop	 r12
  004ea	5e		 pop	 rsi
  004eb	c3		 ret	 0
$LN283@P?:
?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; Pêtla_g³ówna
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
tekst$ = 64
?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Ustaw_ustawienia, COMDAT

; 1192 : {

$LN1761:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00008	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1192 : {

  0000d	48 8b d9	 mov	 rbx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00010	48 8b e9	 mov	 rbp, rcx

; 1594 : 		if (_Large_string_engaged())

  00013	72 03		 jb	 SHORT $LN1697@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00015	48 8b 29	 mov	 rbp, QWORD PTR [rcx]
$LN1697@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  00018	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0001c	48 8d 79 10	 lea	 rdi, QWORD PTR [rcx+16]
  00020	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00025	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0002a	48 83 f8 1f	 cmp	 rax, 31
  0002e	72 6d		 jb	 SHORT $LN35@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00030	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00034	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00039	4d 8d 46 e2	 lea	 r8, QWORD PTR [r14-30]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  0003d	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00040	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00049	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  0004c	48 85 c0	 test	 rax, rax
  0004f	74 4c		 je	 SHORT $LN35@Ustaw_usta
  00051	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL112@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00060	41 b8 1f 00 00
	00		 mov	 r8d, 31
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@
  0006d	48 8b ce	 mov	 rcx, rsi
  00070	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00075	85 c0		 test	 eax, eax
  00077	0f 84 12 05 00
	00		 je	 $LN1555@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0007d	48 ff c6	 inc	 rsi
  00080	4d 8d 46 e2	 lea	 r8, QWORD PTR [r14-30]
  00084	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00087	48 8b ce	 mov	 rcx, rsi
  0008a	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00095	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00098	48 85 c0	 test	 rax, rax
  0009b	75 c3		 jne	 SHORT $LL112@Ustaw_usta
$LN35@Ustaw_usta:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0009d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  000a2	48 8b eb	 mov	 rbp, rbx

; 1594 : 		if (_Large_string_engaged())

  000a5	72 03		 jb	 SHORT $LN1701@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000a7	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN1701@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  000aa	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  000ad	48 83 f8 25	 cmp	 rax, 37			; 00000025H
  000b1	72 6a		 jb	 SHORT $LN40@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  000b3	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  000b7	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  000bc	4d 8d 46 dc	 lea	 r8, QWORD PTR [r14-36]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  000c0	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  000c3	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000cc	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  000cf	48 85 c0	 test	 rax, rax
  000d2	74 49		 je	 SHORT $LN40@Ustaw_usta
  000d4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL244@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000e0	41 b8 25 00 00
	00		 mov	 r8d, 37			; 00000025H
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
  000ed	48 8b ce	 mov	 rcx, rsi
  000f0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  000f5	85 c0		 test	 eax, eax
  000f7	0f 84 42 05 00
	00		 je	 $LN1558@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  000fd	48 ff c6	 inc	 rsi
  00100	4d 8d 46 dc	 lea	 r8, QWORD PTR [r14-36]
  00104	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00107	48 8b ce	 mov	 rcx, rsi
  0010a	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00115	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00118	48 85 c0	 test	 rax, rax
  0011b	75 c3		 jne	 SHORT $LL244@Ustaw_usta
$LN40@Ustaw_usta:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0011d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00122	48 8b eb	 mov	 rbp, rbx

; 1594 : 		if (_Large_string_engaged())

  00125	72 03		 jb	 SHORT $LN1705@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00127	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN1705@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  0012a	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0012d	41 be 1b 00 00
	00		 mov	 r14d, 27
  00133	4c 89 7c 24 58	 mov	 QWORD PTR [rsp+88], r15
  00138	49 3b c6	 cmp	 rax, r14
  0013b	72 5d		 jb	 SHORT $LN45@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0013d	4c 8d 3c 28	 lea	 r15, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00141	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00144	4d 8d 47 e6	 lea	 r8, QWORD PTR [r15-26]
  00148	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  0014b	41 8d 56 48	 lea	 edx, QWORD PTR [r14+72]
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00155	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00158	48 85 c0	 test	 rax, rax
  0015b	74 3d		 je	 SHORT $LN45@Ustaw_usta
  0015d	0f 1f 00	 npad	 3
$LL375@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00160	4d 8b c6	 mov	 r8, r14
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@
  0016a	48 8b ce	 mov	 rcx, rsi
  0016d	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00172	85 c0		 test	 eax, eax
  00174	0f 84 75 05 00
	00		 je	 $LN1561@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0017a	48 ff c6	 inc	 rsi
  0017d	4d 8d 47 e6	 lea	 r8, QWORD PTR [r15-26]
  00181	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00184	48 8b ce	 mov	 rcx, rsi
  00187	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00192	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00195	48 85 c0	 test	 rax, rax
  00198	75 c6		 jne	 SHORT $LL375@Ustaw_usta
$LN45@Ustaw_usta:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0019a	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0019f	48 8b eb	 mov	 rbp, rbx

; 1594 : 		if (_Large_string_engaged())

  001a2	72 03		 jb	 SHORT $LN1709@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001a4	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN1709@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  001a7	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  001aa	48 83 f8 1a	 cmp	 rax, 26
  001ae	72 6d		 jb	 SHORT $LN50@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  001b0	4c 8d 3c 28	 lea	 r15, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  001b4	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  001b9	4d 8d 47 e7	 lea	 r8, QWORD PTR [r15-25]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  001bd	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  001c0	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  001c9	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  001cc	48 85 c0	 test	 rax, rax
  001cf	74 4c		 je	 SHORT $LN50@Ustaw_usta
  001d1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL506@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001e0	41 b8 1a 00 00
	00		 mov	 r8d, 26
  001e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@
  001ed	48 8b ce	 mov	 rcx, rsi
  001f0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  001f5	85 c0		 test	 eax, eax
  001f7	0f 84 a2 05 00
	00		 je	 $LN1564@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  001fd	48 ff c6	 inc	 rsi
  00200	4d 8d 47 e7	 lea	 r8, QWORD PTR [r15-25]
  00204	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00207	48 8b ce	 mov	 rcx, rsi
  0020a	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00215	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00218	48 85 c0	 test	 rax, rax
  0021b	75 c3		 jne	 SHORT $LL506@Ustaw_usta
$LN50@Ustaw_usta:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0021d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00222	48 8b eb	 mov	 rbp, rbx

; 1594 : 		if (_Large_string_engaged())

  00225	72 03		 jb	 SHORT $LN1713@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00227	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN1713@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  0022a	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0022d	48 83 f8 16	 cmp	 rax, 22
  00231	72 6a		 jb	 SHORT $LN55@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00233	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00237	ba 73 00 00 00	 mov	 edx, 115		; 00000073H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0023c	4d 8d 46 eb	 lea	 r8, QWORD PTR [r14-21]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00240	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00243	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0024c	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  0024f	48 85 c0	 test	 rax, rax
  00252	74 49		 je	 SHORT $LN55@Ustaw_usta
  00254	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL637@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00260	41 b8 16 00 00
	00		 mov	 r8d, 22
  00266	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@
  0026d	48 8b ce	 mov	 rcx, rsi
  00270	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00275	85 c0		 test	 eax, eax
  00277	0f 84 d2 05 00
	00		 je	 $LN1567@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0027d	48 ff c6	 inc	 rsi
  00280	4d 8d 46 eb	 lea	 r8, QWORD PTR [r14-21]
  00284	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00287	48 8b ce	 mov	 rcx, rsi
  0028a	ba 73 00 00 00	 mov	 edx, 115		; 00000073H
  0028f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00295	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00298	48 85 c0	 test	 rax, rax
  0029b	75 c3		 jne	 SHORT $LL637@Ustaw_usta
$LN55@Ustaw_usta:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0029d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  002a2	48 8b f3	 mov	 rsi, rbx

; 1594 : 		if (_Large_string_engaged())

  002a5	72 03		 jb	 SHORT $LN1717@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  002a7	48 8b 33	 mov	 rsi, QWORD PTR [rbx]
$LN1717@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  002aa	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  002ad	48 83 f8 10	 cmp	 rax, 16
  002b1	72 58		 jb	 SHORT $LN1744@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  002b3	48 8d 2c 30	 lea	 rbp, QWORD PTR [rax+rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  002b7	ba 6b 00 00 00	 mov	 edx, 107		; 0000006bH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  002bc	4c 8d 45 f1	 lea	 r8, QWORD PTR [rbp-15]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  002c0	48 8b ce	 mov	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  002c3	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  002c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  002cc	48 85 c0	 test	 rax, rax
  002cf	74 3a		 je	 SHORT $LN1744@Ustaw_usta
$LL768@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002d1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002d4	48 3b 0d 00 00
	00 00		 cmp	 rcx, QWORD PTR ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@
  002db	75 11		 jne	 SHORT $LN1743@Ustaw_usta
  002dd	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  002e1	48 3b 0d 08 00
	00 00		 cmp	 rcx, QWORD PTR ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@+8
  002e8	0f 84 11 06 00
	00		 je	 $LN1570@Ustaw_usta
$LN1743@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  002ee	48 ff c0	 inc	 rax

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  002f1	4c 8d 45 f1	 lea	 r8, QWORD PTR [rbp-15]
  002f5	4c 2b c0	 sub	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  002f8	48 8b c8	 mov	 rcx, rax
  002fb	ba 6b 00 00 00	 mov	 edx, 107		; 0000006bH
  00300	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00306	48 85 c0	 test	 rax, rax
  00309	75 c6		 jne	 SHORT $LL768@Ustaw_usta
$LN1744@Ustaw_usta:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0030b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00310	48 8b f3	 mov	 rsi, rbx

; 1594 : 		if (_Large_string_engaged())

  00313	72 03		 jb	 SHORT $LN1721@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00315	48 8b 33	 mov	 rsi, QWORD PTR [rbx]
$LN1721@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  00318	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0031b	48 83 f8 0d	 cmp	 rax, 13
  0031f	72 6a		 jb	 SHORT $LN1745@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00321	48 8d 2c 30	 lea	 rbp, QWORD PTR [rax+rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00325	ba 73 00 00 00	 mov	 edx, 115		; 00000073H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0032a	4c 8d 45 f4	 lea	 r8, QWORD PTR [rbp-12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  0032e	48 8b ce	 mov	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00331	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00334	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0033a	4c 8b c8	 mov	 r9, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  0033d	48 85 c0	 test	 rax, rax
  00340	74 49		 je	 SHORT $LN1745@Ustaw_usta
$LL899@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00342	49 8b 09	 mov	 rcx, QWORD PTR [r9]
  00345	48 3b 0d 00 00
	00 00		 cmp	 rcx, QWORD PTR ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@
  0034c	75 1d		 jne	 SHORT $LN1742@Ustaw_usta
  0034e	41 8b 49 08	 mov	 ecx, DWORD PTR [r9+8]
  00352	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@+8
  00358	75 11		 jne	 SHORT $LN1742@Ustaw_usta
  0035a	41 0f b6 41 0c	 movzx	 eax, BYTE PTR [r9+12]
  0035f	3a 05 0c 00 00
	00		 cmp	 al, BYTE PTR ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@+12
  00365	0f 84 43 06 00
	00		 je	 $LN1573@Ustaw_usta
$LN1742@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  0036b	49 ff c1	 inc	 r9

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0036e	4c 8d 45 f4	 lea	 r8, QWORD PTR [rbp-12]
  00372	4d 2b c1	 sub	 r8, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00375	49 8b c9	 mov	 rcx, r9
  00378	ba 73 00 00 00	 mov	 edx, 115		; 00000073H
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00383	4c 8b c8	 mov	 r9, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00386	48 85 c0	 test	 rax, rax
  00389	75 b7		 jne	 SHORT $LL899@Ustaw_usta
$LN1745@Ustaw_usta:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0038b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00390	48 8b eb	 mov	 rbp, rbx

; 1594 : 		if (_Large_string_engaged())

  00393	72 03		 jb	 SHORT $LN1725@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00395	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN1725@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  00398	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0039b	48 83 f8 13	 cmp	 rax, 19
  0039f	72 6c		 jb	 SHORT $LN70@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  003a1	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  003a5	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  003aa	4d 8d 46 ee	 lea	 r8, QWORD PTR [r14-18]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  003ae	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  003b1	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  003ba	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  003bd	48 85 c0	 test	 rax, rax
  003c0	74 4b		 je	 SHORT $LN70@Ustaw_usta
  003c2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL1030@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  003d0	41 b8 13 00 00
	00		 mov	 r8d, 19
  003d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@
  003dd	48 8b ce	 mov	 rcx, rsi
  003e0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  003e5	85 c0		 test	 eax, eax
  003e7	0f 84 72 06 00
	00		 je	 $LN1576@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  003ed	48 ff c6	 inc	 rsi
  003f0	4d 8d 46 ee	 lea	 r8, QWORD PTR [r14-18]
  003f4	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  003f7	48 8b ce	 mov	 rcx, rsi
  003fa	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
  003ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00405	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00408	48 85 c0	 test	 rax, rax
  0040b	75 c3		 jne	 SHORT $LL1030@Ustaw_usta
$LN70@Ustaw_usta:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0040d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00412	48 8b eb	 mov	 rbp, rbx

; 1594 : 		if (_Large_string_engaged())

  00415	72 03		 jb	 SHORT $LN1729@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00417	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN1729@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  0041a	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0041d	48 83 f8 13	 cmp	 rax, 19
  00421	72 6a		 jb	 SHORT $LN75@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00423	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00427	ba 67 00 00 00	 mov	 edx, 103		; 00000067H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0042c	4d 8d 46 ee	 lea	 r8, QWORD PTR [r14-18]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00430	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00433	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00436	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0043c	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  0043f	48 85 c0	 test	 rax, rax
  00442	74 49		 je	 SHORT $LN75@Ustaw_usta
  00444	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL1161@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00450	41 b8 13 00 00
	00		 mov	 r8d, 19
  00456	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@
  0045d	48 8b ce	 mov	 rcx, rsi
  00460	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00465	85 c0		 test	 eax, eax
  00467	0f 84 a2 06 00
	00		 je	 $LN1579@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0046d	48 ff c6	 inc	 rsi
  00470	4d 8d 46 ee	 lea	 r8, QWORD PTR [r14-18]
  00474	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00477	48 8b ce	 mov	 rcx, rsi
  0047a	ba 67 00 00 00	 mov	 edx, 103		; 00000067H
  0047f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00485	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00488	48 85 c0	 test	 rax, rax
  0048b	75 c3		 jne	 SHORT $LL1161@Ustaw_usta
$LN75@Ustaw_usta:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0048d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00492	4c 8b f3	 mov	 r14, rbx

; 1594 : 		if (_Large_string_engaged())

  00495	72 03		 jb	 SHORT $LN1733@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00497	4c 8b 33	 mov	 r14, QWORD PTR [rbx]
$LN1733@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  0049a	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0049d	48 83 f8 1c	 cmp	 rax, 28
  004a1	72 67		 jb	 SHORT $LN80@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  004a3	4e 8d 3c 30	 lea	 r15, QWORD PTR [rax+r14]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  004a7	ba 67 00 00 00	 mov	 edx, 103		; 00000067H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  004ac	4d 8d 47 e5	 lea	 r8, QWORD PTR [r15-27]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  004b0	49 8b ce	 mov	 rcx, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  004b3	4d 2b c6	 sub	 r8, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  004b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  004bc	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  004bf	48 85 c0	 test	 rax, rax
  004c2	74 46		 je	 SHORT $LN80@Ustaw_usta
  004c4	bd 1c 00 00 00	 mov	 ebp, 28
  004c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL1292@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  004d0	4c 8b c5	 mov	 r8, rbp
  004d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@
  004da	48 8b ce	 mov	 rcx, rsi
  004dd	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  004e2	85 c0		 test	 eax, eax
  004e4	0f 84 d5 06 00
	00		 je	 $LN1582@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  004ea	48 ff c6	 inc	 rsi
  004ed	4d 8d 47 e5	 lea	 r8, QWORD PTR [r15-27]
  004f1	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  004f4	48 8b ce	 mov	 rcx, rsi
  004f7	ba 67 00 00 00	 mov	 edx, 103		; 00000067H
  004fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00502	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00505	48 85 c0	 test	 rax, rax
  00508	75 c6		 jne	 SHORT $LL1292@Ustaw_usta
$LN80@Ustaw_usta:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0050a	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0050f	48 8b f3	 mov	 rsi, rbx

; 1594 : 		if (_Large_string_engaged())

  00512	72 03		 jb	 SHORT $LN1737@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00514	48 8b 33	 mov	 rsi, QWORD PTR [rbx]
$LN1737@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  00517	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0051a	48 83 f8 10	 cmp	 rax, 16
  0051e	0f 82 e6 07 00
	00		 jb	 $LN1747@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00524	48 8d 2c 30	 lea	 rbp, QWORD PTR [rax+rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00528	ba 65 00 00 00	 mov	 edx, 101		; 00000065H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0052d	4c 8d 45 f1	 lea	 r8, QWORD PTR [rbp-15]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00531	48 8b ce	 mov	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00534	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00537	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  0053d	48 85 c0	 test	 rax, rax
  00540	0f 84 c4 07 00
	00		 je	 $LN1747@Ustaw_usta
  00546	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL1423@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00550	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00553	48 3b 0d 00 00
	00 00		 cmp	 rcx, QWORD PTR ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@
  0055a	75 11		 jne	 SHORT $LN1741@Ustaw_usta
  0055c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00560	48 3b 0d 08 00
	00 00		 cmp	 rcx, QWORD PTR ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@+8
  00567	0f 84 02 07 00
	00		 je	 $LN1585@Ustaw_usta
$LN1741@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  0056d	48 ff c0	 inc	 rax

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00570	4c 8d 45 f1	 lea	 r8, QWORD PTR [rbp-15]
  00574	4c 2b c0	 sub	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00577	48 8b c8	 mov	 rcx, rax
  0057a	ba 65 00 00 00	 mov	 edx, 101		; 00000065H
  0057f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00585	48 85 c0	 test	 rax, rax
  00588	75 c6		 jne	 SHORT $LL1423@Ustaw_usta
  0058a	e9 7b 07 00 00	 jmp	 $LN1747@Ustaw_usta
$LN1555@Ustaw_usta:

; 85   : 			return (_Match_try - _Haystack);

  0058f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1193 : 	if (tekst.find("iloæ_minimalna_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00592	48 83 fe ff	 cmp	 rsi, -1
  00596	0f 84 01 fb ff
	ff		 je	 $LN35@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  0059c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0059f	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  005a4	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  005a7	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  005aa	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005ae	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  005b3	72 03		 jb	 SHORT $LN1698@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005b5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1698@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  005b8	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;
; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  005bb	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  005bf	4c 89 07	 mov	 QWORD PTR [rdi], r8
  005c2	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  005c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005cb	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  005d0	48 8b cb	 mov	 rcx, rbx

; 1594 : 		if (_Large_string_engaged())

  005d3	72 03		 jb	 SHORT $LN1699@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005d5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1699@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1196 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_minimalna_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  005de	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  005e2	85 c0		 test	 eax, eax
  005e4	74 1e		 je	 SHORT $LN37@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  005e6	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  005ea	72 03		 jb	 SHORT $LN184@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  005ec	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN184@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1196 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_minimalna_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  005ef	48 8b cb	 mov	 rcx, rbx
  005f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  005f8	66 89 05 00 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A, ax

; 1197 : 		else //W przeciwym wypadku

  005ff	e9 0b 07 00 00	 jmp	 $LN1746@Ustaw_usta
$LN37@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00604	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00607	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  0060b	72 06		 jb	 SHORT $LN216@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0060d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00610	48 8b d9	 mov	 rbx, rcx
$LN216@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00613	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00616	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1199 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00619	48 3b ca	 cmp	 rcx, rdx
  0061c	74 13		 je	 SHORT $LN3@Ustaw_usta
  0061e	66 90		 npad	 2
$LL4@Ustaw_usta:

; 1200 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00620	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00623	0f 85 e6 06 00
	00		 jne	 $LN1746@Ustaw_usta

; 1199 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00629	48 ff c1	 inc	 rcx
  0062c	48 3b ca	 cmp	 rcx, rdx
  0062f	75 ef		 jne	 SHORT $LL4@Ustaw_usta
$LN3@Ustaw_usta:

; 1201 : 			Ustawienia.g³os_szybkoæ_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00631	33 c0		 xor	 eax, eax
  00633	66 89 05 16 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax

; 1204 : 	else if (tekst.find("iloæ_max_dodatkowych_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0063a	e9 d0 06 00 00	 jmp	 $LN1746@Ustaw_usta
$LN1558@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  0063f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1204 : 	else if (tekst.find("iloæ_max_dodatkowych_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00642	48 83 fe ff	 cmp	 rsi, -1
  00646	0f 84 d1 fa ff
	ff		 je	 $LN40@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  0064c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0064f	b8 26 00 00 00	 mov	 eax, 38			; 00000026H
  00654	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00657	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0065a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0065e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  00663	72 03		 jb	 SHORT $LN1702@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00665	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1702@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00668	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;
; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0066b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  0066f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00672	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00675	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0067b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00680	48 8b cb	 mov	 rcx, rbx

; 1594 : 		if (_Large_string_engaged())

  00683	72 03		 jb	 SHORT $LN1703@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00685	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1703@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1207 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00688	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0068e	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00692	85 c0		 test	 eax, eax
  00694	74 1e		 je	 SHORT $LN42@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00696	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0069a	72 03		 jb	 SHORT $LN315@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0069c	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN315@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1207 : 		if (atoi(tekst.c_str())) Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0069f	48 8b cb	 mov	 rcx, rbx
  006a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  006a8	66 89 05 02 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2, ax

; 1208 : 		else //W przeciwym wypadku

  006af	e9 5b 06 00 00	 jmp	 $LN1746@Ustaw_usta
$LN42@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  006b4	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  006b7	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  006bb	72 06		 jb	 SHORT $LN347@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  006bd	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  006c0	48 8b d9	 mov	 rbx, rcx
$LN347@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  006c3	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  006c6	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1210 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  006c9	48 3b ca	 cmp	 rcx, rdx
  006cc	74 13		 je	 SHORT $LN6@Ustaw_usta
  006ce	66 90		 npad	 2
$LL7@Ustaw_usta:

; 1211 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  006d0	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  006d3	0f 85 36 06 00
	00		 jne	 $LN1746@Ustaw_usta

; 1210 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  006d9	48 ff c1	 inc	 rcx
  006dc	48 3b ca	 cmp	 rcx, rdx
  006df	75 ef		 jne	 SHORT $LL7@Ustaw_usta
$LN6@Ustaw_usta:

; 1212 : 			Ustawienia.iloæ_max_dodatkowych_obrotów_ruletki = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  006e1	33 c0		 xor	 eax, eax
  006e3	66 89 05 02 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+2, ax

; 1215 : 	else if (tekst.find("czas_przeskoku_kulki_szybki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  006ea	e9 20 06 00 00	 jmp	 $LN1746@Ustaw_usta
$LN1561@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  006ef	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1215 : 	else if (tekst.find("czas_przeskoku_kulki_szybki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  006f2	48 83 fe ff	 cmp	 rsi, -1
  006f6	0f 84 9e fa ff
	ff		 je	 $LN45@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  006fc	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  006ff	bd 1c 00 00 00	 mov	 ebp, 28
  00704	4c 3b c5	 cmp	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00707	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0070a	49 0f 42 e8	 cmovb	 rbp, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0070e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  00713	72 03		 jb	 SHORT $LN1706@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00715	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1706@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00718	4c 2b c5	 sub	 r8, rbp

; 2607 : 		_My_data._Mysize = _New_size;
; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0071b	48 8d 14 29	 lea	 rdx, QWORD PTR [rcx+rbp]
  0071f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00722	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00725	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0072b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00730	48 8b cb	 mov	 rcx, rbx

; 1594 : 		if (_Large_string_engaged())

  00733	72 03		 jb	 SHORT $LN1707@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00735	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1707@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1218 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_szybki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00738	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0073e	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00742	85 c0		 test	 eax, eax
  00744	74 1e		 je	 SHORT $LN47@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00746	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0074a	72 03		 jb	 SHORT $LN446@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0074c	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN446@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1218 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_szybki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0074f	48 8b cb	 mov	 rcx, rbx
  00752	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00758	66 89 05 04 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4, ax

; 1219 : 		else //W przeciwym wypadku

  0075f	e9 a6 05 00 00	 jmp	 $LN1747@Ustaw_usta
$LN47@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00764	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00767	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  0076b	72 06		 jb	 SHORT $LN478@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0076d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00770	48 8b d9	 mov	 rbx, rcx
$LN478@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00773	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00776	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1221 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00779	48 3b ca	 cmp	 rcx, rdx
  0077c	74 13		 je	 SHORT $LN9@Ustaw_usta
  0077e	66 90		 npad	 2
$LL10@Ustaw_usta:

; 1222 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00780	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00783	0f 85 81 05 00
	00		 jne	 $LN1747@Ustaw_usta

; 1221 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00789	48 ff c1	 inc	 rcx
  0078c	48 3b ca	 cmp	 rcx, rdx
  0078f	75 ef		 jne	 SHORT $LL10@Ustaw_usta
$LN9@Ustaw_usta:

; 1223 : 			Ustawienia.czas_przeskoku_kulki_szybki = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00791	33 c0		 xor	 eax, eax
  00793	66 89 05 04 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+4, ax

; 1226 : 	else if (tekst.find("czas_przeskoku_kulki_wolny") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0079a	e9 6b 05 00 00	 jmp	 $LN1747@Ustaw_usta
$LN1564@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  0079f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1226 : 	else if (tekst.find("czas_przeskoku_kulki_wolny") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  007a2	48 83 fe ff	 cmp	 rsi, -1
  007a6	0f 84 71 fa ff
	ff		 je	 $LN50@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  007ac	4c 8b 07	 mov	 r8, QWORD PTR [rdi]

; 1582 : 		value_type * _Result = _Bx._Buf;

  007af	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  007b2	4d 3b c6	 cmp	 r8, r14
  007b5	4d 0f 42 f0	 cmovb	 r14, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007b9	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  007be	72 03		 jb	 SHORT $LN1710@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  007c0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1710@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  007c3	4d 2b c6	 sub	 r8, r14

; 2607 : 		_My_data._Mysize = _New_size;
; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  007c6	4a 8d 14 31	 lea	 rdx, QWORD PTR [rcx+r14]
  007ca	4c 89 07	 mov	 QWORD PTR [rdi], r8
  007cd	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  007d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007d6	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  007db	48 8b cb	 mov	 rcx, rbx

; 1594 : 		if (_Large_string_engaged())

  007de	72 03		 jb	 SHORT $LN1711@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  007e0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1711@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1229 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_wolny = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  007e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  007e9	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  007ed	85 c0		 test	 eax, eax
  007ef	74 1e		 je	 SHORT $LN52@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  007f1	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  007f5	72 03		 jb	 SHORT $LN577@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  007f7	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN577@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1229 : 		if (atoi(tekst.c_str())) Ustawienia.czas_przeskoku_kulki_wolny = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  007fa	48 8b cb	 mov	 rcx, rbx
  007fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00803	66 89 05 06 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+6, ax

; 1230 : 		else //W przeciwym wypadku

  0080a	e9 fb 04 00 00	 jmp	 $LN1747@Ustaw_usta
$LN52@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0080f	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00812	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  00816	72 06		 jb	 SHORT $LN609@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00818	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0081b	48 8b d9	 mov	 rbx, rcx
$LN609@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0081e	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00821	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1232 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00824	48 3b ca	 cmp	 rcx, rdx
  00827	74 18		 je	 SHORT $LN12@Ustaw_usta
  00829	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@Ustaw_usta:

; 1233 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00830	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00833	0f 85 d1 04 00
	00		 jne	 $LN1747@Ustaw_usta

; 1232 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00839	48 ff c1	 inc	 rcx
  0083c	48 3b ca	 cmp	 rcx, rdx
  0083f	75 ef		 jne	 SHORT $LL13@Ustaw_usta
$LN12@Ustaw_usta:

; 1234 : 			Ustawienia.czas_przeskoku_kulki_wolny = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00841	33 c0		 xor	 eax, eax
  00843	66 89 05 06 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+6, ax

; 1237 : 	else if (tekst.find("styl_liczenia_wygranej") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0084a	e9 bb 04 00 00	 jmp	 $LN1747@Ustaw_usta
$LN1567@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  0084f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1237 : 	else if (tekst.find("styl_liczenia_wygranej") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00852	48 83 fe ff	 cmp	 rsi, -1
  00856	0f 84 41 fa ff
	ff		 je	 $LN55@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  0085c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0085f	b8 17 00 00 00	 mov	 eax, 23
  00864	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00867	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0086a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0086e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  00873	72 03		 jb	 SHORT $LN1714@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00875	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1714@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00878	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;
; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0087b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  0087f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00882	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00885	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0088b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00890	48 8b cb	 mov	 rcx, rbx

; 1594 : 		if (_Large_string_engaged())

  00893	72 03		 jb	 SHORT $LN1715@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00895	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1715@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1240 : 		if (atoi(tekst.c_str())) Ustawienia.styl_liczenia_wygranej = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00898	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0089e	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  008a2	85 c0		 test	 eax, eax
  008a4	74 1e		 je	 SHORT $LN57@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008a6	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  008aa	72 03		 jb	 SHORT $LN708@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  008ac	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN708@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1240 : 		if (atoi(tekst.c_str())) Ustawienia.styl_liczenia_wygranej = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  008af	48 8b cb	 mov	 rcx, rbx
  008b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  008b8	66 89 05 0a 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, ax

; 1241 : 		else //W przeciwym wypadku

  008bf	e9 46 04 00 00	 jmp	 $LN1747@Ustaw_usta
$LN57@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  008c4	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  008c7	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  008cb	72 06		 jb	 SHORT $LN740@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  008cd	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  008d0	48 8b d9	 mov	 rbx, rcx
$LN740@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  008d3	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  008d6	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1243 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  008d9	48 3b ca	 cmp	 rcx, rdx
  008dc	74 13		 je	 SHORT $LN15@Ustaw_usta
  008de	66 90		 npad	 2
$LL16@Ustaw_usta:

; 1244 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  008e0	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  008e3	0f 85 21 04 00
	00		 jne	 $LN1747@Ustaw_usta

; 1243 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  008e9	48 ff c1	 inc	 rcx
  008ec	48 3b ca	 cmp	 rcx, rdx
  008ef	75 ef		 jne	 SHORT $LL16@Ustaw_usta
$LN15@Ustaw_usta:

; 1245 : 			Ustawienia.styl_liczenia_wygranej = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  008f1	33 c0		 xor	 eax, eax
  008f3	66 89 05 0a 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+10, ax

; 1248 : 	else if (tekst.find("kwota_pocz¹tkowa") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  008fa	e9 0b 04 00 00	 jmp	 $LN1747@Ustaw_usta
$LN1570@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  008ff	48 2b c6	 sub	 rax, rsi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1248 : 	else if (tekst.find("kwota_pocz¹tkowa") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00902	48 83 f8 ff	 cmp	 rax, -1
  00906	0f 84 ff f9 ff
	ff		 je	 $LN1744@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  0090c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0090f	b8 11 00 00 00	 mov	 eax, 17
  00914	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00917	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0091a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0091e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  00923	72 03		 jb	 SHORT $LN1718@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00925	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1718@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00928	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;
; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0092b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  0092f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00932	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00935	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0093b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00940	48 8b cb	 mov	 rcx, rbx

; 1594 : 		if (_Large_string_engaged())

  00943	72 03		 jb	 SHORT $LN1719@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00945	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1719@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1251 : 		if (atoi(tekst.c_str())) Ustawienia.kwota_pocz¹tkowa = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00948	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0094e	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00952	85 c0		 test	 eax, eax
  00954	74 1d		 je	 SHORT $LN62@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00956	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  0095a	72 03		 jb	 SHORT $LN839@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0095c	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN839@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1251 : 		if (atoi(tekst.c_str())) Ustawienia.kwota_pocz¹tkowa = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  0095f	48 8b cb	 mov	 rcx, rbx
  00962	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00968	89 05 0c 00 00
	00		 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, eax

; 1252 : 		else //W przeciwym wypadku

  0096e	e9 97 03 00 00	 jmp	 $LN1747@Ustaw_usta
$LN62@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00973	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00976	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  0097a	72 06		 jb	 SHORT $LN871@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0097c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0097f	48 8b d9	 mov	 rbx, rcx
$LN871@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00982	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00985	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1254 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00988	48 3b ca	 cmp	 rcx, rdx
  0098b	74 14		 je	 SHORT $LN18@Ustaw_usta
  0098d	0f 1f 00	 npad	 3
$LL19@Ustaw_usta:

; 1255 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00990	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00993	0f 85 71 03 00
	00		 jne	 $LN1747@Ustaw_usta

; 1254 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00999	48 ff c1	 inc	 rcx
  0099c	48 3b ca	 cmp	 rcx, rdx
  0099f	75 ef		 jne	 SHORT $LL19@Ustaw_usta
$LN18@Ustaw_usta:

; 1256 : 			Ustawienia.kwota_pocz¹tkowa = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  009a1	33 c0		 xor	 eax, eax
  009a3	89 05 0c 00 00
	00		 mov	 DWORD PTR ?Ustawienia@@3US_Ustawienia@@A+12, eax

; 1259 : 	else if (tekst.find("stan_dwiêków") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  009a9	e9 5c 03 00 00	 jmp	 $LN1747@Ustaw_usta
$LN1573@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  009ae	4c 2b ce	 sub	 r9, rsi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1259 : 	else if (tekst.find("stan_dwiêków") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  009b1	49 83 f9 ff	 cmp	 r9, -1
  009b5	0f 84 d0 f9 ff
	ff		 je	 $LN1745@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  009bb	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  009be	b8 0e 00 00 00	 mov	 eax, 14
  009c3	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  009c6	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  009c9	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009cd	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  009d2	72 03		 jb	 SHORT $LN1722@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  009d4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1722@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  009d7	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;
; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  009da	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  009de	4c 89 07	 mov	 QWORD PTR [rdi], r8
  009e1	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  009e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  009ea	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  009ef	48 8b cb	 mov	 rcx, rbx

; 1594 : 		if (_Large_string_engaged())

  009f2	72 03		 jb	 SHORT $LN1723@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  009f4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1723@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1262 : 		if (atoi(tekst.c_str())) Ustawienia.stan_dwiêków = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  009f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  009fd	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00a01	85 c0		 test	 eax, eax
  00a03	74 1e		 je	 SHORT $LN67@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a05	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00a09	72 03		 jb	 SHORT $LN970@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a0b	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN970@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1262 : 		if (atoi(tekst.c_str())) Ustawienia.stan_dwiêków = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00a0e	48 8b cb	 mov	 rcx, rbx
  00a11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00a17	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, ax

; 1263 : 		else //W przeciwym wypadku

  00a1e	e9 e7 02 00 00	 jmp	 $LN1747@Ustaw_usta
$LN67@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00a23	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a26	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  00a2a	72 06		 jb	 SHORT $LN1002@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a2c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00a2f	48 8b d9	 mov	 rbx, rcx
$LN1002@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00a32	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00a35	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1265 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00a38	48 3b ca	 cmp	 rcx, rdx
  00a3b	74 14		 je	 SHORT $LN21@Ustaw_usta
  00a3d	0f 1f 00	 npad	 3
$LL22@Ustaw_usta:

; 1266 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00a40	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00a43	0f 85 c1 02 00
	00		 jne	 $LN1747@Ustaw_usta

; 1265 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00a49	48 ff c1	 inc	 rcx
  00a4c	48 3b ca	 cmp	 rcx, rdx
  00a4f	75 ef		 jne	 SHORT $LL22@Ustaw_usta
$LN21@Ustaw_usta:

; 1267 : 			Ustawienia.stan_dwiêków = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00a51	33 c0		 xor	 eax, eax
  00a53	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+16, ax

; 1270 : 	else if (tekst.find("czy_kontynuowaæ_grê") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00a5a	e9 ab 02 00 00	 jmp	 $LN1747@Ustaw_usta
$LN1576@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  00a5f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1270 : 	else if (tekst.find("czy_kontynuowaæ_grê") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00a62	48 83 fe ff	 cmp	 rsi, -1
  00a66	0f 84 a1 f9 ff
	ff		 je	 $LN70@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00a6c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00a6f	b8 14 00 00 00	 mov	 eax, 20
  00a74	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00a77	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00a7a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a7e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  00a83	72 03		 jb	 SHORT $LN1726@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00a85	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1726@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00a88	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;
; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00a8b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00a8f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00a92	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00a95	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00a9b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00aa0	48 8b cb	 mov	 rcx, rbx

; 1594 : 		if (_Large_string_engaged())

  00aa3	72 03		 jb	 SHORT $LN1727@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00aa5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1727@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1273 : 		if (atoi(tekst.c_str())) Ustawienia.czy_kontynuowaæ_grê = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00aa8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00aae	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00ab2	85 c0		 test	 eax, eax
  00ab4	74 1e		 je	 SHORT $LN72@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ab6	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00aba	72 03		 jb	 SHORT $LN1101@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00abc	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN1101@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1273 : 		if (atoi(tekst.c_str())) Ustawienia.czy_kontynuowaæ_grê = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00abf	48 8b cb	 mov	 rcx, rbx
  00ac2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00ac8	66 89 05 12 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, ax

; 1274 : 		else //W przeciwym wypadku

  00acf	e9 36 02 00 00	 jmp	 $LN1747@Ustaw_usta
$LN72@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00ad4	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00ad7	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  00adb	72 06		 jb	 SHORT $LN1133@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00add	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00ae0	48 8b d9	 mov	 rbx, rcx
$LN1133@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00ae3	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00ae6	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1276 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00ae9	48 3b ca	 cmp	 rcx, rdx
  00aec	74 13		 je	 SHORT $LN24@Ustaw_usta
  00aee	66 90		 npad	 2
$LL25@Ustaw_usta:

; 1277 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00af0	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00af3	0f 85 11 02 00
	00		 jne	 $LN1747@Ustaw_usta

; 1276 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00af9	48 ff c1	 inc	 rcx
  00afc	48 3b ca	 cmp	 rcx, rdx
  00aff	75 ef		 jne	 SHORT $LL25@Ustaw_usta
$LN24@Ustaw_usta:

; 1278 : 			Ustawienia.czy_kontynuowaæ_grê = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00b01	33 c0		 xor	 eax, eax
  00b03	66 89 05 12 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+18, ax

; 1281 : 	else if (tekst.find("g³os_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00b0a	e9 fb 01 00 00	 jmp	 $LN1747@Ustaw_usta
$LN1579@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  00b0f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1281 : 	else if (tekst.find("g³os_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00b12	48 83 fe ff	 cmp	 rsi, -1
  00b16	0f 84 71 f9 ff
	ff		 je	 $LN75@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00b1c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00b1f	b8 14 00 00 00	 mov	 eax, 20
  00b24	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00b27	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00b2a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b2e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  00b33	72 03		 jb	 SHORT $LN1730@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00b35	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1730@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00b38	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;
; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00b3b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00b3f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00b42	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00b45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b4b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00b50	48 8b cb	 mov	 rcx, rbx

; 1594 : 		if (_Large_string_engaged())

  00b53	72 03		 jb	 SHORT $LN1731@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00b55	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1731@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1284 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00b58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00b5e	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00b62	85 c0		 test	 eax, eax
  00b64	74 1e		 je	 SHORT $LN77@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b66	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00b6a	72 03		 jb	 SHORT $LN1232@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00b6c	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN1232@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1284 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00b6f	48 8b cb	 mov	 rcx, rbx
  00b72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00b78	66 89 05 14 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, ax

; 1285 : 		else //W przeciwym wypadku

  00b7f	e9 86 01 00 00	 jmp	 $LN1747@Ustaw_usta
$LN77@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00b84	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00b87	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  00b8b	72 06		 jb	 SHORT $LN1264@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00b8d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00b90	48 8b d9	 mov	 rbx, rcx
$LN1264@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00b93	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00b96	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1287 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00b99	48 3b ca	 cmp	 rcx, rdx
  00b9c	74 13		 je	 SHORT $LN27@Ustaw_usta
  00b9e	66 90		 npad	 2
$LL28@Ustaw_usta:

; 1288 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00ba0	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00ba3	0f 85 61 01 00
	00		 jne	 $LN1747@Ustaw_usta

; 1287 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00ba9	48 ff c1	 inc	 rcx
  00bac	48 3b ca	 cmp	 rcx, rdx
  00baf	75 ef		 jne	 SHORT $LL28@Ustaw_usta
$LN27@Ustaw_usta:

; 1289 : 			Ustawienia.g³os_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00bb1	33 c0		 xor	 eax, eax
  00bb3	66 89 05 14 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+20, ax

; 1292 : 	else if (tekst.find("g³os_szybkoæ_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00bba	e9 4b 01 00 00	 jmp	 $LN1747@Ustaw_usta
$LN1582@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  00bbf	49 2b f6	 sub	 rsi, r14
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1292 : 	else if (tekst.find("g³os_szybkoæ_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00bc2	48 83 fe ff	 cmp	 rsi, -1
  00bc6	0f 84 3e f9 ff
	ff		 je	 $LN80@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00bcc	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00bcf	b8 1d 00 00 00	 mov	 eax, 29
  00bd4	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00bd7	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00bda	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00bde	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  00be3	72 03		 jb	 SHORT $LN1734@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00be5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1734@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00be8	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;
; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00beb	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00bef	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00bf2	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00bf5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00bfb	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00c00	48 8b cb	 mov	 rcx, rbx

; 1594 : 		if (_Large_string_engaged())

  00c03	72 03		 jb	 SHORT $LN1735@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00c05	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1735@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1295 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_szybkoæ_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00c08	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00c0e	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00c12	85 c0		 test	 eax, eax
  00c14	74 1e		 je	 SHORT $LN82@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c16	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00c1a	72 03		 jb	 SHORT $LN1363@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00c1c	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN1363@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1295 : 		if (atoi(tekst.c_str())) Ustawienia.g³os_szybkoæ_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00c1f	48 8b cb	 mov	 rcx, rbx
  00c22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00c28	66 89 05 16 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax

; 1296 : 		else //W przeciwym wypadku

  00c2f	e9 d6 00 00 00	 jmp	 $LN1747@Ustaw_usta
$LN82@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00c34	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c37	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  00c3b	72 06		 jb	 SHORT $LN1395@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00c3d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00c40	48 8b d9	 mov	 rbx, rcx
$LN1395@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00c43	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00c46	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1298 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00c49	48 3b ca	 cmp	 rcx, rdx
  00c4c	74 13		 je	 SHORT $LN30@Ustaw_usta
  00c4e	66 90		 npad	 2
$LL31@Ustaw_usta:

; 1299 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00c50	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00c53	0f 85 b1 00 00
	00		 jne	 $LN1747@Ustaw_usta

; 1298 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00c59	48 ff c1	 inc	 rcx
  00c5c	48 3b ca	 cmp	 rcx, rdx
  00c5f	75 ef		 jne	 SHORT $LL31@Ustaw_usta
$LN30@Ustaw_usta:

; 1300 : 			Ustawienia.g³os_szybkoæ_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00c61	33 c0		 xor	 eax, eax
  00c63	66 89 05 16 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+22, ax

; 1303 : 	else if (tekst.find("efekty_dwiêkowe") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00c6a	e9 9b 00 00 00	 jmp	 $LN1747@Ustaw_usta
$LN1585@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  00c6f	48 2b c6	 sub	 rax, rsi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1303 : 	else if (tekst.find("efekty_dwiêkowe") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00c72	48 83 f8 ff	 cmp	 rax, -1
  00c76	0f 84 8e 00 00
	00		 je	 $LN1747@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  00c7c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00c7f	b8 11 00 00 00	 mov	 eax, 17
  00c84	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00c87	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00c8a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00c8e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  00c93	72 03		 jb	 SHORT $LN1738@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00c95	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1738@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00c98	4c 2b c0	 sub	 r8, rax

; 2607 : 		_My_data._Mysize = _New_size;
; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00c9b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00c9f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00ca2	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00ca5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00cab	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00cb0	48 8b cb	 mov	 rcx, rbx

; 1594 : 		if (_Large_string_engaged())

  00cb3	72 03		 jb	 SHORT $LN1739@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00cb5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1739@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1306 : 		if (atoi(tekst.c_str())) Ustawienia.efekty_dwiêkowe = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00cb8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00cbe	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00cc2	85 c0		 test	 eax, eax
  00cc4	74 14		 je	 SHORT $LN86@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00cc6	48 83 fa 10	 cmp	 rdx, 16

; 1594 : 		if (_Large_string_engaged())

  00cca	72 03		 jb	 SHORT $LN1494@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00ccc	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN1494@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1306 : 		if (atoi(tekst.c_str())) Ustawienia.efekty_dwiêkowe = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoci¹ ró¿n¹ od zera

  00ccf	48 8b cb	 mov	 rcx, rbx
  00cd2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi

; 1307 : 		else //W przeciwym wypadku

  00cd8	eb 29		 jmp	 SHORT $LN1758@Ustaw_usta
$LN86@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00cda	48 8b cb	 mov	 rcx, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00cdd	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  00ce1	72 06		 jb	 SHORT $LN1526@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00ce3	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00ce6	48 8b d9	 mov	 rbx, rcx
$LN1526@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00ce9	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00cec	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1309 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00cef	48 3b ca	 cmp	 rcx, rdx
  00cf2	74 0d		 je	 SHORT $LN33@Ustaw_usta
$LL34@Ustaw_usta:

; 1310 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00cf4	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00cf7	75 11		 jne	 SHORT $LN1747@Ustaw_usta

; 1309 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoæ na tym polu do zmiennej i

  00cf9	48 ff c1	 inc	 rcx
  00cfc	48 3b ca	 cmp	 rcx, rdx
  00cff	75 f3		 jne	 SHORT $LL34@Ustaw_usta
$LN33@Ustaw_usta:

; 1311 : 			Ustawienia.efekty_dwiêkowe = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoæ liczbowa to 0

  00d01	33 c0		 xor	 eax, eax
$LN1758@Ustaw_usta:
  00d03	66 89 05 18 00
	00 00		 mov	 WORD PTR ?Ustawienia@@3US_Ustawienia@@A+24, ax
$LN1747@Ustaw_usta:
  00d0a	4c 8b 7c 24 58	 mov	 r15, QWORD PTR [rsp+88]
$LN1746@Ustaw_usta:
  00d0f	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]

; 1312 : 		}
; 1313 : 	}
; 1314 : }

  00d14	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00d19	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00d1d	5f		 pop	 rdi
  00d1e	5d		 pop	 rbp
  00d1f	5b		 pop	 rbx
  00d20	c3		 ret	 0
?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Ustaw_ustawienia
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0?$uniform_int_distribution@H@std@@QEAA@HH@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
??0?$uniform_int_distribution@H@std@@QEAA@HH@Z PROC	; std::uniform_int_distribution<int>::uniform_int_distribution<int>, COMDAT

; 2224 : 			_Min = _Min0;

  00000	89 11		 mov	 DWORD PTR [rcx], edx

; 2413 : 		}

  00002	48 8b c1	 mov	 rax, rcx

; 2225 : 			_Max = _Max0;

  00005	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d

; 2413 : 		}

  00009	c3		 ret	 0
??0?$uniform_int_distribution@H@std@@QEAA@HH@Z ENDP	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
_TEXT	SEGMENT
this$ = 16
??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ PROC ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::operator(), COMDAT

; 1346 : 		{	// return next value

$LN32:
  00000	48 83 ec 08	 sub	 rsp, 8
  00004	4c 8b d1	 mov	 r10, rcx

; 1347 : 		if (this->_Idx == _Nx)

  00007	41 b9 38 01 00
	00		 mov	 r9d, 312		; 00000138H
  0000d	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0000f	41 3b c9	 cmp	 ecx, r9d
  00012	75 5e		 jne	 SHORT $LN2@operator

; 1353 : 		_Res ^= (_Res >> _Ux) & _Dxval;

  00014	4d 8d 42 10	 lea	 r8, QWORD PTR [r10+16]
  00018	49 bb e9 19 66
	a9 5a 6f 02 b5	 mov	 r11, -5403634167711393303 ; b5026f5aa96619e9H
  00022	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL9@operator:

; 1401 : 				| (this->_Ax[_Ix - _Nx + 1] & _LMSK);

  00030	41 8b 50 f8	 mov	 edx, DWORD PTR [r8-8]
  00034	41 33 10	 xor	 edx, DWORD PTR [r8]
  00037	4d 8d 40 08	 lea	 r8, QWORD PTR [r8+8]
  0003b	0f ba f2 1f	 btr	 edx, 31
  0003f	49 33 50 f0	 xor	 rdx, QWORD PTR [r8-16]

; 1402 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00043	0f b6 c2	 movzx	 eax, dl
  00046	24 01		 and	 al, 1
  00048	f6 d8		 neg	 al
  0004a	48 1b c9	 sbb	 rcx, rcx
  0004d	48 d1 ea	 shr	 rdx, 1
  00050	49 23 cb	 and	 rcx, r11
  00053	49 33 88 d0 04
	00 00		 xor	 rcx, QWORD PTR [r8+1232]
  0005a	48 33 ca	 xor	 rcx, rdx
  0005d	49 89 88 b0 09
	00 00		 mov	 QWORD PTR [r8+2480], rcx
  00064	49 83 e9 01	 sub	 r9, 1
  00068	75 c6		 jne	 SHORT $LL9@operator

; 1403 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1404 : 			}
; 1405 : 		}

  0006a	41 8b 0a	 mov	 ecx, DWORD PTR [r10]
  0006d	e9 01 01 00 00	 jmp	 $LN4@operator
$LN2@operator:

; 1348 : 			_Refill_upper();
; 1349 : 		else if (2 * _Nx <= this->_Idx)

  00072	81 f9 70 02 00
	00		 cmp	 ecx, 624		; 00000270H
  00078	0f 82 f5 00 00
	00		 jb	 $LN4@operator

; 1353 : 		_Res ^= (_Res >> _Ux) & _Dxval;

  0007e	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00083	49 bb e9 19 66
	a9 5a 6f 02 b5	 mov	 r11, -5403634167711393303 ; b5026f5aa96619e9H
  0008d	49 8d 9a c8 09
	00 00		 lea	 rbx, QWORD PTR [r10+2504]
  00094	48 89 3c 24	 mov	 QWORD PTR [rsp], rdi
  00098	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0009b	bf 9c 00 00 00	 mov	 edi, 156		; 0000009cH
$LL14@operator:

; 1376 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  000a0	48 8b d0	 mov	 rdx, rax
  000a3	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  000a7	49 33 10	 xor	 rdx, QWORD PTR [r8]
  000aa	0f ba f2 1f	 btr	 edx, 31
  000ae	48 33 d0	 xor	 rdx, rax

; 1377 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  000b1	0f b6 c2	 movzx	 eax, dl
  000b4	24 01		 and	 al, 1
  000b6	f6 d8		 neg	 al
  000b8	49 8b 00	 mov	 rax, QWORD PTR [r8]
  000bb	48 1b c9	 sbb	 rcx, rcx
  000be	48 d1 ea	 shr	 rdx, 1
  000c1	49 23 cb	 and	 rcx, r11
  000c4	48 33 8b e0 04
	00 00		 xor	 rcx, QWORD PTR [rbx+1248]
  000cb	48 33 ca	 xor	 rcx, rdx
  000ce	48 89 8b 40 f6
	ff ff		 mov	 QWORD PTR [rbx-2496], rcx
  000d5	49 8d 18	 lea	 rbx, QWORD PTR [r8]
  000d8	48 83 ef 01	 sub	 rdi, 1
  000dc	75 c2		 jne	 SHORT $LL14@operator

; 1378 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];
; 1379 : 			}
; 1380 : 
; 1381 : 		for (; _Ix < _Nx - 1; ++_Ix)

  000de	49 8d 9a a8 0e
	00 00		 lea	 rbx, QWORD PTR [r10+3752]
  000e5	bf 9b 00 00 00	 mov	 edi, 155		; 0000009bH
  000ea	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000ed	0f 1f 00	 npad	 3
$LL17@operator:

; 1382 : 			{	// fill in upper region (avoids modulus operation)
; 1383 : 			_Ty _Tmp = (this->_Ax[_Ix +_Nx] & _HMSK)
; 1384 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  000f0	48 8b d0	 mov	 rdx, rax
  000f3	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  000f7	49 33 10	 xor	 rdx, QWORD PTR [r8]
  000fa	0f ba f2 1f	 btr	 edx, 31
  000fe	48 33 d0	 xor	 rdx, rax

; 1385 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00101	0f b6 c2	 movzx	 eax, dl
  00104	24 01		 and	 al, 1
  00106	f6 d8		 neg	 al
  00108	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0010b	48 1b c9	 sbb	 rcx, rcx
  0010e	48 d1 ea	 shr	 rdx, 1
  00111	49 23 cb	 and	 rcx, r11
  00114	48 33 8b 60 f1
	ff ff		 xor	 rcx, QWORD PTR [rbx-3744]
  0011b	48 33 ca	 xor	 rcx, rdx
  0011e	48 89 8b 40 f6
	ff ff		 mov	 QWORD PTR [rbx-2496], rcx
  00125	49 8d 18	 lea	 rbx, QWORD PTR [r8]
  00128	48 83 ef 01	 sub	 rdi, 1
  0012c	75 c2		 jne	 SHORT $LL17@operator

; 1386 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1387 : 			}
; 1388 : 
; 1389 : 		_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

  0012e	41 8b 92 80 13
	00 00		 mov	 edx, DWORD PTR [r10+4992]
  00135	41 33 52 08	 xor	 edx, DWORD PTR [r10+8]

; 1390 : 		this->_Ax[_Ix] = (_Tmp >> 1)
; 1391 : 			^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];
; 1392 : 		this->_Idx = 0;

  00139	48 8b 3c 24	 mov	 rdi, QWORD PTR [rsp]
  0013d	0f ba f2 1f	 btr	 edx, 31
  00141	49 33 92 80 13
	00 00		 xor	 rdx, QWORD PTR [r10+4992]
  00148	48 8b 5c 24 10	 mov	 rbx, QWORD PTR [rsp+16]
  0014d	0f b6 c2	 movzx	 eax, dl
  00150	24 01		 and	 al, 1
  00152	f6 d8		 neg	 al
  00154	48 1b c9	 sbb	 rcx, rcx
  00157	48 d1 ea	 shr	 rdx, 1
  0015a	49 23 cb	 and	 rcx, r11
  0015d	49 33 8a e0 04
	00 00		 xor	 rcx, QWORD PTR [r10+1248]
  00164	48 33 ca	 xor	 rcx, rdx
  00167	49 89 8a c0 09
	00 00		 mov	 QWORD PTR [r10+2496], rcx
  0016e	33 c9		 xor	 ecx, ecx
  00170	41 89 0a	 mov	 DWORD PTR [r10], ecx
$LN4@operator:

; 1350 : 			_Refill_lower();
; 1351 : 
; 1352 : 		_Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

  00173	8b c1		 mov	 eax, ecx
  00175	49 8b 54 c2 08	 mov	 rdx, QWORD PTR [r10+rax*8+8]
  0017a	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  0017d	41 89 02	 mov	 DWORD PTR [r10], eax

; 1353 : 		_Res ^= (_Res >> _Ux) & _Dxval;

  00180	48 8b ca	 mov	 rcx, rdx
  00183	49 8b 82 88 13
	00 00		 mov	 rax, QWORD PTR [r10+5000]
  0018a	48 c1 e9 1d	 shr	 rcx, 29
  0018e	48 23 c1	 and	 rax, rcx

; 1354 : 		_Res ^= (_Res << _Sx) & _Bx;

  00191	48 b9 d3 f6 ff
	3f eb 38 00 00	 mov	 rcx, 62583042209491	; 000038eb3ffff6d3H
  0019b	48 33 d0	 xor	 rdx, rax
  0019e	48 8b c2	 mov	 rax, rdx
  001a1	48 23 c1	 and	 rax, rcx
  001a4	48 c1 e0 11	 shl	 rax, 17
  001a8	48 33 d0	 xor	 rdx, rax

; 1355 : 		_Res ^= (_Res << _Tx) & _Cx;

  001ab	48 8b c2	 mov	 rax, rdx
  001ae	48 25 77 bf ff
	ff		 and	 rax, -16521		; ffffffffffffbf77H
  001b4	48 c1 e0 25	 shl	 rax, 37			; 00000025H
  001b8	48 33 d0	 xor	 rdx, rax

; 1356 : 		_Res ^= (_Res & _WMSK) >> _Lx;

  001bb	48 8b c2	 mov	 rax, rdx
  001be	48 c1 e8 2b	 shr	 rax, 43			; 0000002bH
  001c2	48 33 c2	 xor	 rax, rdx

; 1357 : 		return (_Res);
; 1358 : 		}

  001c5	48 83 c4 08	 add	 rsp, 8
  001c9	c3		 ret	 0
??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ ENDP ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0?$mersenne_twister_engine@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0FFFFFFFFFFFFFFFF@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@$0FIFBPECNEMJFHPCN@@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 8
_X0$ = 16
??0?$mersenne_twister_engine@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0FFFFFFFFFFFFFFFF@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@$0FIFBPECNEMJFHPCN@@std@@QEAA@_K@Z PROC ; std::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>, COMDAT

; 1293 : 		: _Dxval(_Dxarg)

  00000	48 b8 55 55 55
	55 55 55 55 55	 mov	 rax, 6148914691236517205 ; 5555555555555555H
  0000a	4c 8d 49 10	 lea	 r9, QWORD PTR [rcx+16]
  0000e	48 89 81 88 13
	00 00		 mov	 QWORD PTR [rcx+5000], rax
  00015	41 b8 01 00 00
	00		 mov	 r8d, 1

; 1309 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  0001b	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 1293 : 		: _Dxval(_Dxarg)

  0001f	41 ba 37 01 00
	00		 mov	 r10d, 311		; 00000137H
  00025	49 bb 2d 7f 95
	4c 2d f4 51 58	 mov	 r11, 6364136223846793005 ; 5851f42d4c957f2dH
  0002f	90		 npad	 1
$LL8@mersenne_t:

; 1311 : 			_Prev = this->_Ax[_Ix] =

  00030	48 8b c2	 mov	 rax, rdx
  00033	4d 8d 49 08	 lea	 r9, QWORD PTR [r9+8]
  00037	48 c1 e8 3e	 shr	 rax, 62			; 0000003eH
  0003b	48 33 d0	 xor	 rdx, rax
  0003e	49 0f af d3	 imul	 rdx, r11
  00042	49 03 d0	 add	 rdx, r8
  00045	49 ff c0	 inc	 r8
  00048	49 89 51 f8	 mov	 QWORD PTR [r9-8], rdx
  0004c	49 83 ea 01	 sub	 r10, 1
  00050	75 de		 jne	 SHORT $LL8@mersenne_t

; 1312 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;
; 1313 : 		this->_Idx = _Nx;

  00052	c7 01 38 01 00
	00		 mov	 DWORD PTR [rcx], 312	; 00000138H

; 1518 : 		}

  00058	48 8b c1	 mov	 rax, rcx
  0005b	c3		 ret	 0
??0?$mersenne_twister_engine@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0FFFFFFFFFFFFFFFF@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@$0FIFBPECNEMJFHPCN@@std@@QEAA@_K@Z ENDP ; std::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
_TEXT	SEGMENT
this$dead$ = 48
__$ReturnUdt$ = 56
_Off$dead$ = 64
_Count$dead$ = 72
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT

; 3467 : 		{	// return [_Off, _Off + _Count) as new string

$LN91:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3683 : 		_My_data._Mysize = 0;

  00006	48 c7 42 10 00
	00 00 00	 mov	 QWORD PTR [rdx+16], 0

; 3467 : 		{	// return [_Off, _Off + _Count) as new string

  0000e	48 8b da	 mov	 rbx, rdx

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00011	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00019	c6 02 00	 mov	 BYTE PTR [rdx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  0001c	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00023	48 83 f8 05	 cmp	 rax, 5
  00027	0f 82 8c 00 00
	00		 jb	 $LN89@substr

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  0002d	48 83 c0 fb	 add	 rax, -5
  00031	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00036	48 83 cf ff	 or	 rdi, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00041	48 3b c7	 cmp	 rax, rdi
  00044	48 0f 42 f8	 cmovb	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00048	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 2420 : 		if (_Count <= _My_data._Myres)

  00050	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]

; 1594 : 		if (_Large_string_engaged())

  00054	4c 0f 43 0d 00
	00 00 00	 cmovae	 r9, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0005c	49 83 c1 05	 add	 r9, 5

; 2420 : 		if (_Count <= _My_data._Myres)

  00060	48 3b f8	 cmp	 rdi, rax
  00063	77 3b		 ja	 SHORT $LN65@substr

; 1582 : 		value_type * _Result = _Bx._Buf;

  00065	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0006a	48 8b f2	 mov	 rsi, rdx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0006d	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00071	72 03		 jb	 SHORT $LN74@substr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00073	48 8b 32	 mov	 rsi, QWORD PTR [rdx]
$LN74@substr:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  00076	48 89 7a 10	 mov	 QWORD PTR [rdx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0007a	4c 8b c7	 mov	 r8, rdi
  0007d	49 8b d1	 mov	 rdx, r9
  00080	48 8b ce	 mov	 rcx, rsi
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00089	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3468 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  0008d	48 8b c3	 mov	 rax, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00090	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3468 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  00095	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3469 : 		}

  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5b		 pop	 rbx
  0009f	c3		 ret	 0
$LN65@substr:

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  000a0	48 8b d7	 mov	 rdx, rdi
  000a3	48 8b cb	 mov	 rcx, rbx
  000a6	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 3468 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  000ab	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000b0	48 8b c3	 mov	 rax, rbx

; 3469 : 		}

  000b3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b7	5b		 pop	 rbx
  000b8	c3		 ret	 0
$LN89@substr:

; 1611 : 			_Xran();

  000b9	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  000be	cc		 int	 3
$LN88@substr:
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Off$dead$ = 64
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT

; 3256 : 		{	// look for [_Ptr, <null>) beginning at or after _Off

$LN46:
  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f2	 mov	 rsi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00012	48 83 cf ff	 or	 rdi, -1
$LL42@find:
  00016	48 ff c7	 inc	 rdi
  00019	80 3c 3a 00	 cmp	 BYTE PTR [rdx+rdi], 0
  0001d	75 f7		 jne	 SHORT $LL42@find
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0001f	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00024	48 8b e9	 mov	 rbp, rcx

; 1594 : 		if (_Large_string_engaged())

  00027	72 03		 jb	 SHORT $LN13@find
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00029	48 8b 29	 mov	 rbp, QWORD PTR [rcx]
$LN13@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3258 : 		return (static_cast<size_type>(

  0002c	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00030	48 3b f8	 cmp	 rdi, rax
  00033	0f 87 9d 00 00
	00		 ja	 $LN24@find

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)

  00039	48 85 ff	 test	 rdi, rdi
  0003c	75 12		 jne	 SHORT $LN25@find

; 3258 : 		return (static_cast<size_type>(

  0003e	33 c0		 xor	 eax, eax

; 3259 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3260 : 		}

  00040	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00045	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN25@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00050	0f be 12	 movsx	 edx, BYTE PTR [rdx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00053	48 2b c7	 sub	 rax, rdi
  00056	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  0005b	48 8b cd	 mov	 rcx, rbp
  0005e	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00063	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00067	4d 8d 46 01	 lea	 r8, QWORD PTR [r14+1]
  0006b	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00074	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00077	48 85 c0	 test	 rax, rax
  0007a	74 34		 je	 SHORT $LN37@find
  0007c	0f 1f 40 00	 npad	 4
$LL22@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00080	4c 8b c7	 mov	 r8, rdi
  00083	48 8b d6	 mov	 rdx, rsi
  00086	48 8b cb	 mov	 rcx, rbx
  00089	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  0008e	85 c0		 test	 eax, eax
  00090	74 3c		 je	 SHORT $LN38@find
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00092	0f be 16	 movsx	 edx, BYTE PTR [rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00095	4d 8d 46 01	 lea	 r8, QWORD PTR [r14+1]
  00099	48 ff c3	 inc	 rbx
  0009c	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000a8	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  000ab	48 85 c0	 test	 rax, rax
  000ae	75 d0		 jne	 SHORT $LL22@find
$LN37@find:

; 3258 : 		return (static_cast<size_type>(

  000b0	48 83 c8 ff	 or	 rax, -1
$LN44@find:
  000b4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b9	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]

; 3259 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3260 : 		}

  000be	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000c3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	5f		 pop	 rdi
  000cd	c3		 ret	 0
$LN38@find:

; 85   : 			return (_Match_try - _Haystack);

  000ce	48 2b dd	 sub	 rbx, rbp

; 3258 : 		return (static_cast<size_type>(

  000d1	48 8b c3	 mov	 rax, rbx

; 85   : 			return (_Match_try - _Haystack);

  000d4	eb de		 jmp	 SHORT $LN44@find
$LN24@find:

; 3259 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3260 : 		}

  000d6	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000db	48 83 c8 ff	 or	 rax, -1
  000df	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000e4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 3047 : 		return (this->_Get_data()._Mysize);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 3048 : 		}

  00004	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1594 : 		if (_Large_string_engaged())

  00005	72 04		 jb	 SHORT $LN16@c_str

; 3025 : 		return (this->_Get_data()._Myptr());

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 3026 : 		}

  0000a	c3		 ret	 0
$LN16@c_str:

; 3025 : 		return (this->_Get_data()._Myptr());

  0000b	48 8b c1	 mov	 rax, rcx

; 3026 : 		}

  0000e	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1594 : 		if (_Large_string_engaged())

  00005	72 07		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2962 : 		return (_My_data._Myptr()[_Off]);

  0000a	48 03 c2	 add	 rax, rdx

; 2963 : 		}

  0000d	c3		 ret	 0
$LN16@operator:

; 2962 : 		return (_My_data._Myptr()[_Off]);

  0000e	48 8d 04 11	 lea	 rax, QWORD PTR [rcx+rdx]

; 2963 : 		}

  00012	c3		 ret	 0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1583 : 		if (_Large_string_engaged())

  00005	72 07		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2955 : 		return (_My_data._Myptr()[_Off]);

  0000a	48 03 c2	 add	 rax, rdx

; 2956 : 		}

  0000d	c3		 ret	 0
$LN16@operator:

; 2955 : 		return (_My_data._Myptr()[_Off]);

  0000e	48 8d 04 11	 lea	 rax, QWORD PTR [rcx+rdx]

; 2956 : 		}

  00012	c3		 ret	 0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1582 : 		value_type * _Result = _Bx._Buf;

  00005	48 8b d1	 mov	 rdx, rcx

; 1583 : 		if (_Large_string_engaged())

  00008	72 03		 jb	 SHORT $LN10@Unchecked_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000a	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
$LN10@Unchecked_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2861 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0000d	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00011	48 03 c2	 add	 rax, rdx

; 2862 : 		}

  00014	c3		 ret	 0
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1583 : 		if (_Large_string_engaged())

  00005	72 04		 jb	 SHORT $LN16@Unchecked_

; 2850 : 		return (this->_Get_data()._Myptr());

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 2851 : 		}

  0000a	c3		 ret	 0
$LN16@Unchecked_:

; 2850 : 		return (this->_Get_data()._Myptr());

  0000b	48 8b c1	 mov	 rax, rcx

; 2851 : 		}

  0000e	c3		 ret	 0
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
_Count$ = 64
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 2599 : 		{	// erase elements [_Off, _Off + _Count)

$LN32:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4d 8b c8	 mov	 r9, r8
  00009	48 8b d9	 mov	 rbx, rcx

; 1609 : 		if (_Mysize < _Off)

  0000c	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00010	4c 3b c2	 cmp	 r8, rdx
  00013	72 3e		 jb	 SHORT $LN30@erase

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00015	49 8b c0	 mov	 rax, r8
  00018	48 2b c2	 sub	 rax, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0001b	49 3b c1	 cmp	 rax, r9
  0001e	4c 0f 42 c8	 cmovb	 r9, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00022	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1582 : 		value_type * _Result = _Bx._Buf;

  00027	48 8b c1	 mov	 rax, rcx

; 1583 : 		if (_Large_string_engaged())

  0002a	72 03		 jb	 SHORT $LN20@erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0002c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
$LN20@erase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  0002f	4d 2b c1	 sub	 r8, r9
  00032	48 8d 0c 02	 lea	 rcx, QWORD PTR [rdx+rax]

; 2607 : 		_My_data._Mysize = _New_size;

  00036	4c 89 43 10	 mov	 QWORD PTR [rbx+16], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0003a	4c 2b c2	 sub	 r8, rdx
  0003d	49 ff c0	 inc	 r8
  00040	49 8d 14 09	 lea	 rdx, QWORD PTR [r9+rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2609 : 		return (*this);

  0004a	48 8b c3	 mov	 rax, rbx

; 2610 : 		}

  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5b		 pop	 rbx
  00052	c3		 ret	 0
$LN30@erase:

; 1611 : 			_Xran();

  00053	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00058	cc		 int	 3
$LN29@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00000	49 83 c8 ff	 or	 r8, -1
$LL8@append:
  00004	49 ff c0	 inc	 r8
  00007	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  0000c	75 f6		 jne	 SHORT $LL8@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0000e	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00005	48 8b c2	 mov	 rax, rdx

; 1594 : 		if (_Large_string_engaged())

  00008	72 03		 jb	 SHORT $LN10@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN10@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0000d	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]
  00011	48 8b d0	 mov	 rdx, rax
  00014	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 2298 : 		{	// append 1 * _Ch

$LN27:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  00006	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2298 : 		{	// append 1 * _Ch

  0000a	48 8b d9	 mov	 rbx, rcx

; 2977 : 		if (_Old_size < _My_data._Myres)

  0000d	4c 8b 49 18	 mov	 r9, QWORD PTR [rcx+24]
  00011	4d 3b c1	 cmp	 r8, r9
  00014	73 27		 jae	 SHORT $LN4@operator

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  00016	49 8d 48 01	 lea	 rcx, QWORD PTR [r8+1]

; 1582 : 		value_type * _Result = _Bx._Buf;

  0001a	48 8b c3	 mov	 rax, rbx

; 2979 : 			_My_data._Mysize = _Old_size + 1;

  0001d	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00021	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  00025	72 03		 jb	 SHORT $LN13@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00027	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN13@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0002a	42 88 14 00	 mov	 BYTE PTR [rax+r8], dl
  0002e	42 c6 44 00 01
	00		 mov	 BYTE PTR [rax+r8+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2300 : 		return (*this);

  00034	48 8b c3	 mov	 rax, rbx

; 2301 : 		}

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
$LN4@operator:

; 2986 : 		_Reallocate_grow_by(1,

  0003d	44 0f b6 ca	 movzx	 r9d, dl
  00041	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>

; 2300 : 		return (*this);

  00046	48 8b c3	 mov	 rax, rbx

; 2301 : 		}

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00000	49 83 c8 ff	 or	 r8, -1
$LL10@operator:
  00004	49 ff c0	 inc	 r8
  00007	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  0000c	75 f6		 jne	 SHORT $LL10@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0000e	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$dead$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 2266 : 		{	// assign [_Ptr, <null>)

$LN33:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2420 : 		if (_Count <= _My_data._Myres)

  00004	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24
  0000b	48 83 f9 05	 cmp	 rcx, 5
  0000f	72 4e		 jb	 SHORT $LN11@operator

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00011	48 83 f9 10	 cmp	 rcx, 16

; 1583 : 		if (_Large_string_engaged())

  00015	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0001a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2423 : 			_My_data._Mysize = _Count;

  00021	48 c7 05 10 00
	00 00 05 00 00
	00		 mov	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 5

; 1583 : 		if (_Large_string_engaged())

  0002c	48 0f 43 1d 00
	00 00 00	 cmovae	 rbx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	41 b8 05 00 00
	00		 mov	 r8d, 5
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  0004a	c6 43 05 00	 mov	 BYTE PTR [rbx+5], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2267 : 		return (assign(_Ptr));

  0004e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00055	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 2268 : 		}

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
$LN11@operator:

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0005f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  00066	ba 05 00 00 00	 mov	 edx, 5
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2268 : 		}

  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00076	e9 00 00 00 00	 jmp	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 2237 : 		{	// assign _Right

$LN66:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2238 : 		if (this != _STD addressof(_Right))

  00009	48 3b ca	 cmp	 rcx, rdx
  0000c	74 70		 je	 SHORT $LN63@operator

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0000e	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00013	4c 8b ca	 mov	 r9, rdx
  00016	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 1594 : 		if (_Large_string_engaged())

  0001b	72 03		 jb	 SHORT $LN35@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0001d	4c 8b 0a	 mov	 r9, QWORD PTR [rdx]
$LN35@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2252 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00020	48 8b 7a 10	 mov	 rdi, QWORD PTR [rdx+16]

; 2420 : 		if (_Count <= _My_data._Myres)

  00024	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00028	48 3b f8	 cmp	 rdi, rax
  0002b	77 3b		 ja	 SHORT $LN42@operator

; 1582 : 		value_type * _Result = _Bx._Buf;

  0002d	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00032	48 8b f3	 mov	 rsi, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00035	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00039	72 03		 jb	 SHORT $LN51@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0003b	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN51@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  0003e	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00042	4c 8b c7	 mov	 r8, rdi
  00045	48 8b ce	 mov	 rcx, rsi
  00048	49 8b d1	 mov	 rdx, r9
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00051	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2255 : 		return (*this);

  00055	48 8b c3	 mov	 rax, rbx
  00058	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0005d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 2256 : 		}

  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5b		 pop	 rbx
  00067	c3		 ret	 0
$LN42@operator:

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00068	48 8b d7	 mov	 rdx, rdi
  0006b	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
  00070	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 2255 : 		return (*this);

  00075	48 8b c3	 mov	 rax, rbx

; 2256 : 		}

  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5b		 pop	 rbx
  0007d	c3		 ret	 0
$LN63@operator:

; 2255 : 		return (*this);

  0007e	48 8b c3	 mov	 rax, rbx

; 2256 : 		}

  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	5b		 pop	 rbx
  00086	c3		 ret	 0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2230 : 		{	// destroy the string

$LN74:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00006	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]

; 2230 : 		{	// destroy the string

  0000a	48 8b d9	 mov	 rbx, rcx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0000d	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00011	72 3e		 jb	 SHORT $LN38@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00016	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00019	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00020	72 2a		 jb	 SHORT $LN41@basic_stri

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00022	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00026	48 3b c2	 cmp	 rax, rdx
  00029	76 3f		 jbe	 SHORT $_Invalid_parameter$75

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0002b	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0002e	f6 c1 1f	 test	 cl, 31
  00031	75 37		 jne	 SHORT $_Invalid_parameter$75

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00033	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00037	48 3b c1	 cmp	 rax, rcx
  0003a	73 2e		 jae	 SHORT $_Invalid_parameter$75

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0003c	48 2b c8	 sub	 rcx, rax
  0003f	48 83 e9 08	 sub	 rcx, 8
  00043	48 83 f9 1f	 cmp	 rcx, 31
  00047	77 21		 ja	 SHORT $_Invalid_parameter$75

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00049	48 8b c8	 mov	 rcx, rax
$LN41@basic_stri:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0004c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN38@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00051	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00059	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00061	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2232 : 		}

  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
$_Invalid_parameter$75:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00070	cc		 int	 3
$LN73@basic_stri:
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 2070 : 		{	// assign by moving _Right

$LN71:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 2071 : 		if (this != _STD addressof(_Right))

  00010	48 3b ca	 cmp	 rcx, rdx
  00013	74 26		 je	 SHORT $LN69@operator

; 2072 : 			{	// different, assign it
; 2073 : 			_Tidy_deallocate();

  00015	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0001a	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]
  0001d	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00020	0f 10 4f 10	 movups	 xmm1, XMMWORD PTR [rdi+16]
  00024	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00028	48 c7 47 10 00
	00 00 00	 mov	 QWORD PTR [rdi+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00030	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00038	c6 07 00	 mov	 BYTE PTR [rdi], 0
$LN69@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2082 : 		return (*this);

  0003b	48 8b c3	 mov	 rax, rbx

; 2083 : 		}

  0003e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1563 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1564 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0000a	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  0000d	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00010	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  00014	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00018	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0001c	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00024	88 02		 mov	 BYTE PTR [rdx], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2041 : 		}

  00026	48 8b c1	 mov	 rax, rcx
  00029	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
_Ch$dead$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1976 : 		{	// construct from _Count * _Ch

$LN24:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3683 : 		_My_data._Mysize = 0;

  00006	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1976 : 		{	// construct from _Count * _Ch

  0000e	48 8b d9	 mov	 rbx, rcx

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00011	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00019	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1978 : 		assign(_Count, _Ch);

  0001c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1979 : 		}

  00021	48 8b c3	 mov	 rax, rbx
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$dead$ = 56
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1962 : 		{	// construct from [_Ptr, <null>)

$LN54:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3683 : 		_My_data._Mysize = 0;

  00006	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1962 : 		{	// construct from [_Ptr, <null>)

  0000e	48 8b d9	 mov	 rbx, rcx

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00011	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00019	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2420 : 		if (_Count <= _My_data._Myres)

  0001c	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00020	48 83 f8 42	 cmp	 rax, 66			; 00000042H
  00024	72 41		 jb	 SHORT $LN31@basic_stri

; 1582 : 		value_type * _Result = _Bx._Buf;

  00026	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0002b	48 8b f9	 mov	 rdi, rcx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0002e	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00032	72 03		 jb	 SHORT $LN40@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00034	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
$LN40@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  00037	48 c7 41 10 42
	00 00 00	 mov	 QWORD PTR [rcx+16], 66	; 00000042H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
  00046	48 8b cf	 mov	 rcx, rdi
  00049	41 b8 42 00 00
	00		 mov	 r8d, 66			; 00000042H
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00055	c6 47 42 00	 mov	 BYTE PTR [rdi+66], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1965 : 		}

  00059	48 8b c3	 mov	 rax, rbx
  0005c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
$LN31@basic_stri:

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00067	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
  0006e	ba 42 00 00 00	 mov	 edx, 66			; 00000042H
  00073	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 1965 : 		}

  00078	48 8b c3	 mov	 rax, rbx
  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1947 : 		{	// construct from [_Ptr, _Ptr + _Count)

$LN47:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3683 : 		_My_data._Mysize = 0;

  0000a	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1947 : 		{	// construct from [_Ptr, _Ptr + _Count)

  00012	49 8b f8	 mov	 rdi, r8

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00015	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15

; 1947 : 		{	// construct from [_Ptr, _Ptr + _Count)

  0001d	48 8b d9	 mov	 rbx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00020	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2420 : 		if (_Count <= _My_data._Myres)

  00023	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00027	4c 3b c0	 cmp	 r8, rax
  0002a	77 35		 ja	 SHORT $LN24@basic_stri

; 1582 : 		value_type * _Result = _Bx._Buf;

  0002c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00031	48 8b f1	 mov	 rsi, rcx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00034	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00038	72 03		 jb	 SHORT $LN33@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0003a	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN33@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  0003d	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00041	48 8b ce	 mov	 rcx, rsi
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  0004a	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1950 : 		}

  0004e	48 8b c3	 mov	 rax, rbx
  00051	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00056	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
$LN24@basic_stri:

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00061	4c 8b ca	 mov	 r9, rdx
  00064	48 8b d7	 mov	 rdx, rdi
  00067	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 1950 : 		}

  0006c	48 8b c3	 mov	 rax, rbx
  0006f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3683 : 		_My_data._Mysize = 0;

  00000	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1923 : 		}

  00008	48 8b c1	 mov	 rax, rcx

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0000b	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00013	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1923 : 		}

  00016	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1909 : 		{	// construct by copying _Right

$LN112:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00008	48 8b d9	 mov	 rbx, rcx
  0000b	48 8b fa	 mov	 rdi, rdx

; 1563 : 		_Mysize(0),

  0000e	33 c9		 xor	 ecx, ecx
  00010	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 1564 : 		_Myres(0)

  00014	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00018	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 2171 : 		const size_type _Right_size = _Right_data._Mysize;

  0001d	48 8b 6a 10	 mov	 rbp, QWORD PTR [rdx+16]

; 1594 : 		if (_Large_string_engaged())

  00021	72 03		 jb	 SHORT $LN39@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00023	48 8b 3a	 mov	 rdi, QWORD PTR [rdx]
$LN39@basic_stri:
  00026	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2173 : 		if (_Right_size < this->_BUF_SIZE)

  0002b	48 83 fd 10	 cmp	 rbp, 16
  0002f	73 0d		 jae	 SHORT $LN24@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00031	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2177 : 			_My_data._Myres = this->_BUF_SIZE - 1;

  00034	be 0f 00 00 00	 mov	 esi, 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00039	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2178 : 			return;

  0003c	eb 5f		 jmp	 SHORT $LN23@basic_stri
$LN24@basic_stri:

; 2179 : 			}
; 2180 : 
; 2181 : 		auto& _Al = this->_Getal();
; 2182 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  0003e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00048	48 8b f5	 mov	 rsi, rbp
  0004b	48 83 ce 0f	 or	 rsi, 15
  0004f	48 3b f0	 cmp	 rsi, rax
  00052	48 0f 47 f0	 cmova	 rsi, rax

; 2183 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  00056	48 8d 46 01	 lea	 rax, QWORD PTR [rsi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0005a	48 85 c0	 test	 rax, rax
  0005d	74 2f		 je	 SHORT $LN80@basic_stri

; 79   : 		{
; 80   : 		return (nullptr);
; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  0005f	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00065	72 1c		 jb	 SHORT $LN83@basic_stri

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00067	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]

; 117  : 			if (_Block_size <= _User_size)

  0006b	48 3b c8	 cmp	 rcx, rax
  0006e	76 45		 jbe	 SHORT $LN110@basic_stri

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00070	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00075	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  00079	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0007d	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00081	eb 0b		 jmp	 SHORT $LN80@basic_stri
$LN83@basic_stri:

; 67   : 			_Ptr = ::operator new(_Bytes);

  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0008b	48 8b c8	 mov	 rcx, rax
$LN80@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2185 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  0008e	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 944  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00092	48 89 0b	 mov	 QWORD PTR [rbx], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00095	48 8b d7	 mov	 rdx, rdi
  00098	e8 00 00 00 00	 call	 memcpy
$LN23@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1911 : 		}

  0009d	48 89 6b 10	 mov	 QWORD PTR [rbx+16], rbp
  000a1	48 8b c3	 mov	 rax, rbx
  000a4	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi
  000a8	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5f		 pop	 rdi
  000b2	5d		 pop	 rbp
  000b3	5b		 pop	 rbx
  000b4	c3		 ret	 0
$LN110@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  000b5	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  000ba	cc		 int	 3
$LN109@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::close, COMDAT

; 1390 : 		{	// close the C stream

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1391 : 		if (_Filebuffer.close() == 0)

  00009	48 83 c1 18	 add	 rcx, 24
  0000d	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00012	48 85 c0	 test	 rax, rax
  00015	75 1d		 jne	 SHORT $LN2@close

; 1392 : 			_Myios::setstate(ios_base::failbit);

  00017	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001a	45 33 c0	 xor	 r8d, r8d
  0001d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00021	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  00025	48 03 cb	 add	 rcx, rbx

; 1393 : 	}

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx

; 1392 : 			_Myios::setstate(ios_base::failbit);

  0002d	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@close:

; 1393 : 	}

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
_TEXT	SEGMENT
this$ = 48
_Filename$dead$ = 56
_Mode$ = 64
_Prot$dead$ = 72
?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::open, COMDAT

; 1368 : 		{	// open a C stream with specified mode

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1369 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00010	48 83 c1 18	 add	 rcx, 24
  00014	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00019	48 8b 13	 mov	 rdx, QWORD PTR [rbx]

; 1370 : 			_Myios::setstate(ios_base::failbit);

  0001c	45 33 c0	 xor	 r8d, r8d
  0001f	48 63 4a 04	 movsxd	 rcx, DWORD PTR [rdx+4]
  00023	48 03 cb	 add	 rcx, rbx
  00026	48 85 c0	 test	 rax, rax
  00029	75 0f		 jne	 SHORT $LN2@open
  0002b	8d 50 02	 lea	 edx, QWORD PTR [rax+2]

; 1373 : 		}

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx

; 1370 : 			_Myios::setstate(ios_base::failbit);

  00033	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@open:

; 1371 : 		else
; 1372 : 			_Myios::clear();	// added with C++11

  0003a	33 d2		 xor	 edx, edx

; 1373 : 		}

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5b		 pop	 rbx

; 1371 : 		else
; 1372 : 			_Myios::clear();	// added with C++11

  00041	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >, COMDAT

; 1352 : 		{	// destroy the object

$LN16:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 8b 81 48 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-184]
  0001e	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00029	48 89 84 0a 48
	ff ff ff	 mov	 QWORD PTR [rdx+rcx-184], rax
  00031	48 8b 81 48 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-184]
  00038	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0003c	44 8d 82 48 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-184]
  00043	44 89 84 0a 44
	ff ff ff	 mov	 DWORD PTR [rdx+rcx-188], r8d

; 1353 : 		}

  0004b	48 8d 99 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rcx-160]

; 161  : 		{	// destroy the object

  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00059	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005c	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00064	74 2f		 je	 SHORT $LN9@basic_fstr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00066	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  0006a	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  0006e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00071	75 22		 jne	 SHORT $LN9@basic_fstr

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00073	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007a	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00081	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00084	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00088	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008b	44 2b c2	 sub	 r8d, edx
  0008e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00092	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN9@basic_fstr:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 164  : 		if (_Closef)

  00095	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  00099	74 09		 je	 SHORT $LN5@basic_fstr

; 165  : 			close();

  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a3	90		 npad	 1
$LN5@basic_fstr:

; 166  : 		}

  000a4	48 8b cb	 mov	 rcx, rbx
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000ad	90		 npad	 1

; 1353 : 		}

  000ae	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >, COMDAT

; 1206 : 		{	// construct unopened

$LN23:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 89 4c 24 30	 mov	 QWORD PTR this$GSCopy$[rsp], rcx
  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0002b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00035	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00039	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00046	90		 npad	 1
  00047	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 665  : 		}
; 666  : 
; 667  : 	bool _Endwrite()
; 668  : 		{	// put shift to initial conversion state, as needed
; 669  : 		if (_Pcvt == 0 || !_Wrotesome)
; 670  : 			return (true);
; 671  : 		else
; 672  : 			{	// may have to put
; 673  : 			const int _STRING_INC = 8;
; 674  : 			char *_Dest;
; 675  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 676  : 				return (false);
; 677  : 
; 678  : 			string _Str(_STRING_INC, '\0');
; 679  : 			for (;;)
; 680  : 				{
; 681  : 				switch (_Pcvt->unshift(_State,
; 682  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 683  : 					{	// test result of homing conversion
; 684  : 					case codecvt_base::ok:
; 685  : 						_Wrotesome = false;	// homed successfully
; 686  : 
; 687  : 					case codecvt_base::partial:	// fall through
; 688  : 						{	// put any generated bytes
; 689  : 						size_t _Count = _Dest - &*_Str.begin();
; 690  : 						if (0 < _Count && _Count !=
; 691  : 							fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 692  : 							return (false);	// write failed
; 693  : 						if (!_Wrotesome)
; 694  : 							return (true);
; 695  : 						if (_Count == 0)
; 696  : 							_Str.append(_STRING_INC, '\0');	// try with more space
; 697  : 						break;
; 698  : 						}
; 699  : 
; 700  : 					case codecvt_base::noconv:
; 701  : 						return (true);	// nothing to do
; 702  : 
; 703  : 					default:
; 704  : 						return (false);	// conversion failed
; 705  : 					}
; 706  : 				}
; 707  : 			}
; 708  : 		}
; 709  : 
; 710  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 711  : 		{	// initialize codecvt pointer
; 712  : 		if (_Newpcvt->always_noconv())
; 713  : 			_Pcvt = 0;	// nothing to do
; 714  : 		else
; 715  : 			{	// set up for nontrivial codecvt facet
; 716  : 			_Pcvt = _Newpcvt;
; 717  : 			_Mysb::_Init();	// reset any buffering
; 718  : 			}
; 719  : 		}
; 720  : 
; 721  : private:
; 722  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 723  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 724  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 725  : 	typename _Traits::state_type _State;	// current conversion state
; 726  : 	bool _Closef;	// true if C stream must be closed
; 727  : 	_Filet *_Myfile;	// pointer to C stream
; 728  : 
; 729  : 	void _Reset_back()
; 730  : 		{	// restore buffer after putback
; 731  : 		if (_Mysb::eback() == &_Mychar)
; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 733  : 		}
; 734  : 
; 735  : 	void _Set_back()
; 736  : 		{	// set up putback area
; 737  : 		if (_Mysb::eback() != &_Mychar)
; 738  : 			{	// save current get buffer
; 739  : 			_Set_eback = _Mysb::eback();
; 740  : 			_Set_egptr = _Mysb::egptr();
; 741  : 			}
; 742  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 743  : 		}
; 744  : 
; 745  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 746  : 	_Elem *_Set_egptr;	// saves egptr()
; 747  : 	};
; 748  : 
; 749  : template<class _Elem,
; 750  : 	class _Traits> inline
; 751  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 752  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 753  : 	{	// swap _Left and _Right basic_filebufs
; 754  : 	_Left.swap(_Right);
; 755  : 	}
; 756  : 
; 757  : 		// CLASS TEMPLATE basic_ifstream
; 758  : template<class _Elem,
; 759  : 	class _Traits>
; 760  : 	class basic_ifstream
; 761  : 		: public basic_istream<_Elem, _Traits>
; 762  : 	{	// input stream associated with a C stream
; 763  : public:
; 764  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 765  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 766  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 767  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 768  : 
; 769  : 	basic_ifstream()
; 770  : 		: _Mybase(&_Filebuffer)
; 771  : 		{	// construct unopened
; 772  : 		}
; 773  : 
; 774  : 	explicit basic_ifstream(const char *_Filename,
; 775  : 		ios_base::openmode _Mode = ios_base::in,
; 776  : 		int _Prot = (int)ios_base::_Openprot)
; 777  : 		: _Mybase(&_Filebuffer)
; 778  : 		{	// construct with named file and specified mode
; 779  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 780  : 			_Myios::setstate(ios_base::failbit);
; 781  : 		}
; 782  : 
; 783  : 	explicit basic_ifstream(const string& _Str,
; 784  : 		ios_base::openmode _Mode = ios_base::in,
; 785  : 		int _Prot = (int)ios_base::_Openprot)
; 786  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 787  : 		{	// construct with named file and specified mode
; 788  : 		}
; 789  : 
; 790  : 	explicit basic_ifstream(const wchar_t *_Filename,
; 791  : 		ios_base::openmode _Mode = ios_base::in,
; 792  : 		int _Prot = (int)ios_base::_Openprot)
; 793  : 		: _Mybase(&_Filebuffer)
; 794  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 795  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 796  : 			_Myios::setstate(ios_base::failbit);
; 797  : 		}
; 798  : 
; 799  : 	explicit basic_ifstream(const wstring& _Str,
; 800  : 		ios_base::openmode _Mode = ios_base::in,
; 801  : 		int _Prot = (int)ios_base::_Openprot)
; 802  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 803  : 		{	// construct with wide-named file -- EXTENSION
; 804  : 		}
; 805  : 
; 806  : 	template<class _Path_ish = experimental::filesystem::path>
; 807  : 		explicit basic_ifstream(const _Identity_t<_Path_ish>& _Path,
; 808  : 		ios_base::openmode _Mode = ios_base::in,
; 809  : 		int _Prot = (int)ios_base::_Openprot)
; 810  : 		: basic_ifstream(_Path.c_str(), _Mode, _Prot)
; 811  : 		{	// construct with path-named file
; 812  : 		}
; 813  : 
; 814  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 815  : 	explicit basic_ifstream(const unsigned short *_Filename,
; 816  : 		ios_base::openmode _Mode = ios_base::in,
; 817  : 		int _Prot = (int)ios_base::_Openprot)
; 818  : 		: _Mybase(&_Filebuffer)
; 819  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 820  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 821  : 			_Myios::setstate(ios_base::failbit);
; 822  : 		}
; 823  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 824  : 
; 825  : 	explicit basic_ifstream(_Filet *_File)
; 826  : 		: _Mybase(&_Filebuffer),
; 827  : 			_Filebuffer(_File)
; 828  : 		{	// construct with specified C stream
; 829  : 		}
; 830  : 
; 831  : 	basic_ifstream(_Myt&& _Right)
; 832  : 		: _Mybase(&_Filebuffer)
; 833  : 		{	// construct by moving _Right
; 834  : 		_Assign_rv(_STD move(_Right));
; 835  : 		}
; 836  : 
; 837  : 	_Myt& operator=(_Myt&& _Right)
; 838  : 		{	// move from _Right
; 839  : 		_Assign_rv(_STD move(_Right));
; 840  : 		return (*this);
; 841  : 		}
; 842  : 
; 843  : 	void _Assign_rv(_Myt&& _Right)
; 844  : 		{	// assign by moving _Right
; 845  : 		if (this != _STD addressof(_Right))
; 846  : 			{	// different, worth moving
; 847  : 			_Filebuffer.close();
; 848  : 			this->swap(_Right);
; 849  : 			}
; 850  : 		}
; 851  : 
; 852  : 	void swap(_Myt& _Right)
; 853  : 		{	// swap with _Right
; 854  : 		if (this != _STD addressof(_Right))
; 855  : 			{	// different, swap base and buffer
; 856  : 			_Mybase::swap(_Right);
; 857  : 			_Filebuffer.swap(_Right._Filebuffer);
; 858  : 			}
; 859  : 		}
; 860  : 
; 861  : 	basic_ifstream(const _Myt&) = delete;
; 862  : 	_Myt& operator=(const _Myt&) = delete;
; 863  : 
; 864  : 	void open(const wchar_t *_Filename,
; 865  : 		ios_base::openmode _Mode = ios_base::in,
; 866  : 		int _Prot = (int)ios_base::_Openprot)
; 867  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 868  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 869  : 			_Myios::setstate(ios_base::failbit);
; 870  : 		else
; 871  : 			_Myios::clear();	// added with C++11
; 872  : 		}
; 873  : 
; 874  : 	void open(const wstring& _Str,
; 875  : 		ios_base::openmode _Mode = ios_base::in,
; 876  : 		int _Prot = (int)ios_base::_Openprot)
; 877  : 		{	// open a wide-named C stream -- EXTENSION
; 878  : 		open(_Str.c_str(), _Mode, _Prot);
; 879  : 		}
; 880  : 
; 881  : 	template<class _Path_ish = experimental::filesystem::path>
; 882  : 		void open(const _Identity_t<_Path_ish>& _Path,
; 883  : 		ios_base::openmode _Mode = ios_base::in,
; 884  : 		int _Prot = (int)ios_base::_Openprot)
; 885  : 		{	// open a path-named C stream
; 886  : 		open(_Path.c_str(), _Mode, _Prot);
; 887  : 		}
; 888  : 
; 889  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 890  : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 891  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 892  : 		open(_Filename, (ios_base::openmode)_Mode);
; 893  : 		}
; 894  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 895  : 
; 896  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 897  : 	void open(const unsigned short *_Filename,
; 898  : 		ios_base::openmode _Mode = ios_base::in,
; 899  : 		int _Prot = (int)ios_base::_Openprot)
; 900  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 901  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 902  : 			_Myios::setstate(ios_base::failbit);
; 903  : 		else
; 904  : 			_Myios::clear();	// added with C++11
; 905  : 		}
; 906  : 
; 907  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 908  : 	void open(const unsigned short *_Filename,
; 909  : 		ios_base::open_mode _Mode)
; 910  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 911  : 		open(_Filename, (ios_base::openmode)_Mode);
; 912  : 		}
; 913  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 914  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 915  : 
; 916  : 	virtual __CLR_OR_THIS_CALL ~basic_ifstream() _NOEXCEPT
; 917  : 		{	// destroy the object
; 918  : 		}
; 919  : 
; 920  : 	_Myfb *rdbuf() const
; 921  : 		{	// return pointer to file buffer
; 922  : 		return ((_Myfb *)&_Filebuffer);
; 923  : 		}
; 924  : 
; 925  : 	bool is_open() const
; 926  : 		{	// test if C stream has been opened
; 927  : 		return (_Filebuffer.is_open());
; 928  : 		}
; 929  : 
; 930  : 	void open(const char *_Filename,
; 931  : 		ios_base::openmode _Mode = ios_base::in,
; 932  : 		int _Prot = (int)ios_base::_Openprot)
; 933  : 		{	// open a C stream with specified mode
; 934  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 935  : 			_Myios::setstate(ios_base::failbit);
; 936  : 		else
; 937  : 			_Myios::clear();	// added with C++11
; 938  : 		}
; 939  : 
; 940  : 	void open(const string& _Str,
; 941  : 		ios_base::openmode _Mode = ios_base::in,
; 942  : 		int _Prot = (int)ios_base::_Openprot)
; 943  : 		{	// open a C stream with specified mode
; 944  : 		open(_Str.c_str(), _Mode, _Prot);
; 945  : 		}
; 946  : 
; 947  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 948  : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 949  : 		{	// open named file with specified mode (old style)
; 950  : 		open(_Filename, (ios_base::openmode)_Mode);
; 951  : 		}
; 952  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 953  : 
; 954  : 	void close()
; 955  : 		{	// close the C stream
; 956  : 		if (_Filebuffer.close() == 0)
; 957  : 			_Myios::setstate(ios_base::failbit);
; 958  : 		}
; 959  : 
; 960  : private:
; 961  : 	_Myfb _Filebuffer;	// the file buffer
; 962  : 	};
; 963  : 
; 964  : template<class _Elem,
; 965  : 	class _Traits> inline
; 966  : 	void swap(basic_ifstream<_Elem, _Traits>& _Left,
; 967  : 		basic_ifstream<_Elem, _Traits>& _Right)
; 968  : 	{	// swap _Left and _Right basic_ifstreams
; 969  : 	_Left.swap(_Right);
; 970  : 	}
; 971  : 
; 972  : 		// CLASS TEMPLATE basic_ofstream
; 973  : template<class _Elem,
; 974  : 	class _Traits>
; 975  : 	class basic_ofstream
; 976  : 		: public basic_ostream<_Elem, _Traits>
; 977  : 	{	// output stream associated with a C stream
; 978  : public:
; 979  : 	typedef basic_ofstream<_Elem, _Traits> _Myt;
; 980  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 981  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 982  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 983  : 
; 984  : 	basic_ofstream()
; 985  : 		: _Mybase(&_Filebuffer)
; 986  : 		{	// construct unopened
; 987  : 		}
; 988  : 
; 989  : 	explicit basic_ofstream(const char *_Filename,
; 990  : 		ios_base::openmode _Mode = ios_base::out,
; 991  : 		int _Prot = (int)ios_base::_Openprot)
; 992  : 		: _Mybase(&_Filebuffer)
; 993  : 		{	// construct with named file and specified mode
; 994  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 995  : 			_Myios::setstate(ios_base::failbit);
; 996  : 		}
; 997  : 
; 998  : 	explicit basic_ofstream(const string& _Str,
; 999  : 		ios_base::openmode _Mode = ios_base::out,
; 1000 : 		int _Prot = (int)ios_base::_Openprot)
; 1001 : 		: basic_ofstream(_Str.c_str(), _Mode, _Prot)
; 1002 : 		{	// construct with named file and specified mode
; 1003 : 		}
; 1004 : 
; 1005 : 	explicit basic_ofstream(const wchar_t *_Filename,
; 1006 : 		ios_base::openmode _Mode = ios_base::out,
; 1007 : 		int _Prot = (int)ios_base::_Openprot)
; 1008 : 		: _Mybase(&_Filebuffer)
; 1009 : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 1010 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1011 : 			_Myios::setstate(ios_base::failbit);
; 1012 : 		}
; 1013 : 
; 1014 : 	explicit basic_ofstream(const wstring& _Str,
; 1015 : 		ios_base::openmode _Mode = ios_base::out,
; 1016 : 		int _Prot = (int)ios_base::_Openprot)
; 1017 : 		: basic_ofstream(_Str.c_str(), _Mode, _Prot)
; 1018 : 		{	// construct with wide-named file -- EXTENSION
; 1019 : 		}
; 1020 : 
; 1021 : 	template<class _Path_ish = experimental::filesystem::path>
; 1022 : 		explicit basic_ofstream(const _Identity_t<_Path_ish>& _Path,
; 1023 : 		ios_base::openmode _Mode = ios_base::out,
; 1024 : 		int _Prot = (int)ios_base::_Openprot)
; 1025 : 		: basic_ofstream(_Path.c_str(), _Mode, _Prot)
; 1026 : 		{	// construct with path-named file
; 1027 : 		}
; 1028 : 
; 1029 :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 1030 : 	explicit basic_ofstream(const unsigned short *_Filename,
; 1031 : 		ios_base::openmode _Mode = ios_base::out,
; 1032 : 		int _Prot = (int)ios_base::_Openprot)
; 1033 : 		: _Mybase(&_Filebuffer)
; 1034 : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 1035 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1036 : 			_Myios::setstate(ios_base::failbit);
; 1037 : 		}
; 1038 :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 1039 : 
; 1040 : 	explicit basic_ofstream(_Filet *_File)
; 1041 : 		: _Mybase(&_Filebuffer),
; 1042 : 			_Filebuffer(_File)
; 1043 : 		{	// construct with specified C stream
; 1044 : 		}
; 1045 : 
; 1046 : 	basic_ofstream(_Myt&& _Right)
; 1047 : 		: _Mybase(&_Filebuffer)
; 1048 : 		{	// construct by moving _Right
; 1049 : 		_Assign_rv(_STD move(_Right));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& operator=(_Myt&& _Right)
; 1053 : 		{	// move from _Right
; 1054 : 		_Assign_rv(_STD move(_Right));
; 1055 : 		return (*this);
; 1056 : 		}
; 1057 : 
; 1058 : 	void _Assign_rv(_Myt&& _Right)
; 1059 : 		{	// assign by moving _Right
; 1060 : 		if (this != _STD addressof(_Right))
; 1061 : 			{	// different, worth moving
; 1062 : 			_Filebuffer.close();
; 1063 : 			this->swap(_Right);
; 1064 : 			}
; 1065 : 		}
; 1066 : 
; 1067 : 	void swap(_Myt& _Right)
; 1068 : 		{	// swap with _Right
; 1069 : 		if (this != _STD addressof(_Right))
; 1070 : 			{	// different, swap base and buffer
; 1071 : 			_Mybase::swap(_Right);
; 1072 : 			_Filebuffer.swap(_Right._Filebuffer);
; 1073 : 			}
; 1074 : 		}
; 1075 : 
; 1076 : 	basic_ofstream(const _Myt&) = delete;
; 1077 : 	_Myt& operator=(const _Myt&) = delete;
; 1078 : 
; 1079 : 	void open(const wchar_t *_Filename,
; 1080 : 		ios_base::openmode _Mode = ios_base::out,
; 1081 : 		int _Prot = (int)ios_base::_Openprot)
; 1082 : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 1083 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1084 : 			_Myios::setstate(ios_base::failbit);
; 1085 : 		else
; 1086 : 			_Myios::clear();	// added with C++11
; 1087 : 		}
; 1088 : 
; 1089 : 	void open(const wstring& _Str,
; 1090 : 		ios_base::openmode _Mode = ios_base::out,
; 1091 : 		int _Prot = (int)ios_base::_Openprot)
; 1092 : 		{	// open a wide-named C stream -- EXTENSION
; 1093 : 		open(_Str.c_str(), _Mode, _Prot);
; 1094 : 		}
; 1095 : 
; 1096 : 	template<class _Path_ish = experimental::filesystem::path>
; 1097 : 		void open(const _Identity_t<_Path_ish>& _Path,
; 1098 : 		ios_base::openmode _Mode = ios_base::out,
; 1099 : 		int _Prot = (int)ios_base::_Openprot)
; 1100 : 		{	// open a path-named C stream
; 1101 : 		open(_Path.c_str(), _Mode, _Prot);
; 1102 : 		}
; 1103 : 
; 1104 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1105 : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 1106 : 		{	// open a wide-named C stream (old style) (in standard as const std::filesystem::path::value_type *)
; 1107 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1108 : 		}
; 1109 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1110 : 
; 1111 :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 1112 : 	void open(const unsigned short *_Filename,
; 1113 : 		ios_base::openmode _Mode = ios_base::out,
; 1114 : 		int _Prot = (int)ios_base::_Openprot)
; 1115 : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 1116 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1117 : 			_Myios::setstate(ios_base::failbit);
; 1118 : 		else
; 1119 : 			_Myios::clear();	// added with C++11
; 1120 : 		}
; 1121 : 
; 1122 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1123 : 	void open(const unsigned short *_Filename,
; 1124 : 		ios_base::open_mode _Mode)
; 1125 : 		{	// open a wide-named C stream (old style) (in standard as const std::filesystem::path::value_type *)
; 1126 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1127 : 		}
; 1128 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1129 :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 1130 : 
; 1131 : 	virtual __CLR_OR_THIS_CALL ~basic_ofstream() _NOEXCEPT
; 1132 : 		{	// destroy the object
; 1133 : 		}
; 1134 : 
; 1135 : 	_Myfb *rdbuf() const
; 1136 : 		{	// return pointer to file buffer
; 1137 : 		return ((_Myfb *)&_Filebuffer);
; 1138 : 		}
; 1139 : 
; 1140 : 	bool is_open() const
; 1141 : 		{	// test if C stream has been opened
; 1142 : 		return (_Filebuffer.is_open());
; 1143 : 		}
; 1144 : 
; 1145 : 	void open(const char *_Filename,
; 1146 : 		ios_base::openmode _Mode = ios_base::out,
; 1147 : 		int _Prot = (int)ios_base::_Openprot)
; 1148 : 		{	// open a C stream with specified mode
; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1150 : 			_Myios::setstate(ios_base::failbit);
; 1151 : 		else
; 1152 : 			_Myios::clear();	// added with C++11
; 1153 : 		}
; 1154 : 
; 1155 : 	void open(const string& _Str,
; 1156 : 		ios_base::openmode _Mode = ios_base::out,
; 1157 : 		int _Prot = (int)ios_base::_Openprot)
; 1158 : 		{	// open a C stream with specified mode
; 1159 : 		open(_Str.c_str(), _Mode, _Prot);
; 1160 : 		}
; 1161 : 
; 1162 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1163 : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 1164 : 		{	// open a C stream with specified mode (old style)
; 1165 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1166 : 		}
; 1167 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1168 : 
; 1169 : 	void close()
; 1170 : 		{	// close the C stream
; 1171 : 		if (_Filebuffer.close() == 0)
; 1172 : 			_Myios::setstate(ios_base::failbit);
; 1173 : 		}
; 1174 : 
; 1175 : private:
; 1176 : 	_Myfb _Filebuffer;	// the file buffer
; 1177 : 	};
; 1178 : 
; 1179 : template<class _Elem,
; 1180 : 	class _Traits> inline
; 1181 : 	void swap(basic_ofstream<_Elem, _Traits>& _Left,
; 1182 : 		basic_ofstream<_Elem, _Traits>& _Right)
; 1183 : 	{	// swap _Left and _Right basic_ofstreams
; 1184 : 	_Left.swap(_Right);
; 1185 : 	}
; 1186 : 
; 1187 : 		// CLASS TEMPLATE basic_fstream
; 1188 : template<class _Elem,
; 1189 : 	class _Traits>
; 1190 : 	class basic_fstream
; 1191 : 		: public basic_iostream<_Elem, _Traits>
; 1192 : 	{	// input/output stream associated with a C stream
; 1193 : public:
; 1194 : 	typedef basic_fstream<_Elem, _Traits> _Myt;
; 1195 : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 1196 : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 1197 : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 1198 : 	typedef _Elem char_type;
; 1199 : 	typedef _Traits traits_type;
; 1200 : 	typedef typename _Traits::int_type int_type;
; 1201 : 	typedef typename _Traits::pos_type pos_type;
; 1202 : 	typedef typename _Traits::off_type off_type;
; 1203 : 
; 1204 : 	basic_fstream()
; 1205 : 		: _Mybase(&_Filebuffer)

  0004f	48 8d 5f 18	 lea	 rbx, QWORD PTR [rdi+24]
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b d3	 mov	 rdx, rbx
  00059	48 8b cf	 mov	 rcx, rdi
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00062	90		 npad	 1

; 1206 : 		{	// construct unopened

  00063	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00066	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00071	48 89 04 39	 mov	 QWORD PTR [rcx+rdi], rax
  00075	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00078	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0007c	8d 91 48 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-184]
  00082	89 54 39 fc	 mov	 DWORD PTR [rcx+rdi-4], edx
  00086	48 89 5c 24 40	 mov	 QWORD PTR this$[rsp], rbx

; 155  : 		: _Mysb()

  0008b	48 8b cb	 mov	 rcx, rbx
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00094	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  00095	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0009c	48 89 03	 mov	 QWORD PTR [rbx], rax

; 636  : 		_Closef = _Which == _Openfl;

  0009f	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0

; 637  : 		_Wrotesome = false;

  000a3	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  000a7	48 8b cb	 mov	 rcx, rbx
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;

  000b0	48 c7 83 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+128], 0

; 663  : 		_State = _Stinit;

  000bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000c2	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c6	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 1207 : 		}

  000ce	48 8b c7	 mov	 rax, rdi
  000d1	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000d6	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000da	5f		 pop	 rdi
  000db	c3		 ret	 0
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
_TEXT	SEGMENT
this$ = 48
_Filename$ = 56
_Mode$ = 64
_Prot$dead$ = 72
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::open, COMDAT

; 1148 : 		{	// open a C stream with specified mode

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1149 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  00009	41 83 c8 02	 or	 r8d, 2
  0000d	48 83 c1 08	 add	 rcx, 8
  00011	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00016	48 8b 13	 mov	 rdx, QWORD PTR [rbx]

; 1150 : 			_Myios::setstate(ios_base::failbit);

  00019	45 33 c0	 xor	 r8d, r8d
  0001c	48 63 4a 04	 movsxd	 rcx, DWORD PTR [rdx+4]
  00020	48 03 cb	 add	 rcx, rbx
  00023	48 85 c0	 test	 rax, rax
  00026	75 0f		 jne	 SHORT $LN2@open
  00028	8d 50 02	 lea	 edx, QWORD PTR [rax+2]

; 1153 : 		}

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx

; 1150 : 			_Myios::setstate(ios_base::failbit);

  00030	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@open:

; 1151 : 		else
; 1152 : 			_Myios::clear();	// added with C++11

  00037	33 d2		 xor	 edx, edx

; 1153 : 		}

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx

; 1151 : 		else
; 1152 : 			_Myios::clear();	// added with C++11

  0003e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >, COMDAT

; 1132 : 		{	// destroy the object

$LN16:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 8b 81 58 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-168]
  0001e	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00029	48 89 84 0a 58
	ff ff ff	 mov	 QWORD PTR [rdx+rcx-168], rax
  00031	48 8b 81 58 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-168]
  00038	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0003c	44 8d 82 58 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-168]
  00043	44 89 84 0a 54
	ff ff ff	 mov	 DWORD PTR [rdx+rcx-172], r8d

; 1133 : 		}

  0004b	48 8d 99 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rcx-160]

; 161  : 		{	// destroy the object

  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00059	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005c	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00064	74 2f		 je	 SHORT $LN9@basic_ofst
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00066	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  0006a	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  0006e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00071	75 22		 jne	 SHORT $LN9@basic_ofst

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00073	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007a	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00081	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00084	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00088	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008b	44 2b c2	 sub	 r8d, edx
  0008e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00092	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN9@basic_ofst:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 164  : 		if (_Closef)

  00095	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  00099	74 09		 je	 SHORT $LN5@basic_ofst

; 165  : 			close();

  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a3	90		 npad	 1
$LN5@basic_ofst:

; 166  : 		}

  000a4	48 8b cb	 mov	 rcx, rbx
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000ad	90		 npad	 1

; 1133 : 		}

  000ae	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT

; 986  : 		{	// construct unopened

$LN23:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 89 4c 24 30	 mov	 QWORD PTR this$GSCopy$[rsp], rcx
  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
  0002b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002e	48 81 c1 a8 00
	00 00		 add	 rcx, 168		; 000000a8H
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0003b	90		 npad	 1
  0003c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 665  : 		}
; 666  : 
; 667  : 	bool _Endwrite()
; 668  : 		{	// put shift to initial conversion state, as needed
; 669  : 		if (_Pcvt == 0 || !_Wrotesome)
; 670  : 			return (true);
; 671  : 		else
; 672  : 			{	// may have to put
; 673  : 			const int _STRING_INC = 8;
; 674  : 			char *_Dest;
; 675  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 676  : 				return (false);
; 677  : 
; 678  : 			string _Str(_STRING_INC, '\0');
; 679  : 			for (;;)
; 680  : 				{
; 681  : 				switch (_Pcvt->unshift(_State,
; 682  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 683  : 					{	// test result of homing conversion
; 684  : 					case codecvt_base::ok:
; 685  : 						_Wrotesome = false;	// homed successfully
; 686  : 
; 687  : 					case codecvt_base::partial:	// fall through
; 688  : 						{	// put any generated bytes
; 689  : 						size_t _Count = _Dest - &*_Str.begin();
; 690  : 						if (0 < _Count && _Count !=
; 691  : 							fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 692  : 							return (false);	// write failed
; 693  : 						if (!_Wrotesome)
; 694  : 							return (true);
; 695  : 						if (_Count == 0)
; 696  : 							_Str.append(_STRING_INC, '\0');	// try with more space
; 697  : 						break;
; 698  : 						}
; 699  : 
; 700  : 					case codecvt_base::noconv:
; 701  : 						return (true);	// nothing to do
; 702  : 
; 703  : 					default:
; 704  : 						return (false);	// conversion failed
; 705  : 					}
; 706  : 				}
; 707  : 			}
; 708  : 		}
; 709  : 
; 710  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 711  : 		{	// initialize codecvt pointer
; 712  : 		if (_Newpcvt->always_noconv())
; 713  : 			_Pcvt = 0;	// nothing to do
; 714  : 		else
; 715  : 			{	// set up for nontrivial codecvt facet
; 716  : 			_Pcvt = _Newpcvt;
; 717  : 			_Mysb::_Init();	// reset any buffering
; 718  : 			}
; 719  : 		}
; 720  : 
; 721  : private:
; 722  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 723  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 724  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 725  : 	typename _Traits::state_type _State;	// current conversion state
; 726  : 	bool _Closef;	// true if C stream must be closed
; 727  : 	_Filet *_Myfile;	// pointer to C stream
; 728  : 
; 729  : 	void _Reset_back()
; 730  : 		{	// restore buffer after putback
; 731  : 		if (_Mysb::eback() == &_Mychar)
; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 733  : 		}
; 734  : 
; 735  : 	void _Set_back()
; 736  : 		{	// set up putback area
; 737  : 		if (_Mysb::eback() != &_Mychar)
; 738  : 			{	// save current get buffer
; 739  : 			_Set_eback = _Mysb::eback();
; 740  : 			_Set_egptr = _Mysb::egptr();
; 741  : 			}
; 742  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 743  : 		}
; 744  : 
; 745  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 746  : 	_Elem *_Set_egptr;	// saves egptr()
; 747  : 	};
; 748  : 
; 749  : template<class _Elem,
; 750  : 	class _Traits> inline
; 751  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 752  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 753  : 	{	// swap _Left and _Right basic_filebufs
; 754  : 	_Left.swap(_Right);
; 755  : 	}
; 756  : 
; 757  : 		// CLASS TEMPLATE basic_ifstream
; 758  : template<class _Elem,
; 759  : 	class _Traits>
; 760  : 	class basic_ifstream
; 761  : 		: public basic_istream<_Elem, _Traits>
; 762  : 	{	// input stream associated with a C stream
; 763  : public:
; 764  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 765  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 766  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 767  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 768  : 
; 769  : 	basic_ifstream()
; 770  : 		: _Mybase(&_Filebuffer)
; 771  : 		{	// construct unopened
; 772  : 		}
; 773  : 
; 774  : 	explicit basic_ifstream(const char *_Filename,
; 775  : 		ios_base::openmode _Mode = ios_base::in,
; 776  : 		int _Prot = (int)ios_base::_Openprot)
; 777  : 		: _Mybase(&_Filebuffer)
; 778  : 		{	// construct with named file and specified mode
; 779  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 780  : 			_Myios::setstate(ios_base::failbit);
; 781  : 		}
; 782  : 
; 783  : 	explicit basic_ifstream(const string& _Str,
; 784  : 		ios_base::openmode _Mode = ios_base::in,
; 785  : 		int _Prot = (int)ios_base::_Openprot)
; 786  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 787  : 		{	// construct with named file and specified mode
; 788  : 		}
; 789  : 
; 790  : 	explicit basic_ifstream(const wchar_t *_Filename,
; 791  : 		ios_base::openmode _Mode = ios_base::in,
; 792  : 		int _Prot = (int)ios_base::_Openprot)
; 793  : 		: _Mybase(&_Filebuffer)
; 794  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 795  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 796  : 			_Myios::setstate(ios_base::failbit);
; 797  : 		}
; 798  : 
; 799  : 	explicit basic_ifstream(const wstring& _Str,
; 800  : 		ios_base::openmode _Mode = ios_base::in,
; 801  : 		int _Prot = (int)ios_base::_Openprot)
; 802  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 803  : 		{	// construct with wide-named file -- EXTENSION
; 804  : 		}
; 805  : 
; 806  : 	template<class _Path_ish = experimental::filesystem::path>
; 807  : 		explicit basic_ifstream(const _Identity_t<_Path_ish>& _Path,
; 808  : 		ios_base::openmode _Mode = ios_base::in,
; 809  : 		int _Prot = (int)ios_base::_Openprot)
; 810  : 		: basic_ifstream(_Path.c_str(), _Mode, _Prot)
; 811  : 		{	// construct with path-named file
; 812  : 		}
; 813  : 
; 814  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 815  : 	explicit basic_ifstream(const unsigned short *_Filename,
; 816  : 		ios_base::openmode _Mode = ios_base::in,
; 817  : 		int _Prot = (int)ios_base::_Openprot)
; 818  : 		: _Mybase(&_Filebuffer)
; 819  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 820  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 821  : 			_Myios::setstate(ios_base::failbit);
; 822  : 		}
; 823  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 824  : 
; 825  : 	explicit basic_ifstream(_Filet *_File)
; 826  : 		: _Mybase(&_Filebuffer),
; 827  : 			_Filebuffer(_File)
; 828  : 		{	// construct with specified C stream
; 829  : 		}
; 830  : 
; 831  : 	basic_ifstream(_Myt&& _Right)
; 832  : 		: _Mybase(&_Filebuffer)
; 833  : 		{	// construct by moving _Right
; 834  : 		_Assign_rv(_STD move(_Right));
; 835  : 		}
; 836  : 
; 837  : 	_Myt& operator=(_Myt&& _Right)
; 838  : 		{	// move from _Right
; 839  : 		_Assign_rv(_STD move(_Right));
; 840  : 		return (*this);
; 841  : 		}
; 842  : 
; 843  : 	void _Assign_rv(_Myt&& _Right)
; 844  : 		{	// assign by moving _Right
; 845  : 		if (this != _STD addressof(_Right))
; 846  : 			{	// different, worth moving
; 847  : 			_Filebuffer.close();
; 848  : 			this->swap(_Right);
; 849  : 			}
; 850  : 		}
; 851  : 
; 852  : 	void swap(_Myt& _Right)
; 853  : 		{	// swap with _Right
; 854  : 		if (this != _STD addressof(_Right))
; 855  : 			{	// different, swap base and buffer
; 856  : 			_Mybase::swap(_Right);
; 857  : 			_Filebuffer.swap(_Right._Filebuffer);
; 858  : 			}
; 859  : 		}
; 860  : 
; 861  : 	basic_ifstream(const _Myt&) = delete;
; 862  : 	_Myt& operator=(const _Myt&) = delete;
; 863  : 
; 864  : 	void open(const wchar_t *_Filename,
; 865  : 		ios_base::openmode _Mode = ios_base::in,
; 866  : 		int _Prot = (int)ios_base::_Openprot)
; 867  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 868  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 869  : 			_Myios::setstate(ios_base::failbit);
; 870  : 		else
; 871  : 			_Myios::clear();	// added with C++11
; 872  : 		}
; 873  : 
; 874  : 	void open(const wstring& _Str,
; 875  : 		ios_base::openmode _Mode = ios_base::in,
; 876  : 		int _Prot = (int)ios_base::_Openprot)
; 877  : 		{	// open a wide-named C stream -- EXTENSION
; 878  : 		open(_Str.c_str(), _Mode, _Prot);
; 879  : 		}
; 880  : 
; 881  : 	template<class _Path_ish = experimental::filesystem::path>
; 882  : 		void open(const _Identity_t<_Path_ish>& _Path,
; 883  : 		ios_base::openmode _Mode = ios_base::in,
; 884  : 		int _Prot = (int)ios_base::_Openprot)
; 885  : 		{	// open a path-named C stream
; 886  : 		open(_Path.c_str(), _Mode, _Prot);
; 887  : 		}
; 888  : 
; 889  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 890  : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 891  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 892  : 		open(_Filename, (ios_base::openmode)_Mode);
; 893  : 		}
; 894  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 895  : 
; 896  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 897  : 	void open(const unsigned short *_Filename,
; 898  : 		ios_base::openmode _Mode = ios_base::in,
; 899  : 		int _Prot = (int)ios_base::_Openprot)
; 900  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 901  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 902  : 			_Myios::setstate(ios_base::failbit);
; 903  : 		else
; 904  : 			_Myios::clear();	// added with C++11
; 905  : 		}
; 906  : 
; 907  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 908  : 	void open(const unsigned short *_Filename,
; 909  : 		ios_base::open_mode _Mode)
; 910  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 911  : 		open(_Filename, (ios_base::openmode)_Mode);
; 912  : 		}
; 913  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 914  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 915  : 
; 916  : 	virtual __CLR_OR_THIS_CALL ~basic_ifstream() _NOEXCEPT
; 917  : 		{	// destroy the object
; 918  : 		}
; 919  : 
; 920  : 	_Myfb *rdbuf() const
; 921  : 		{	// return pointer to file buffer
; 922  : 		return ((_Myfb *)&_Filebuffer);
; 923  : 		}
; 924  : 
; 925  : 	bool is_open() const
; 926  : 		{	// test if C stream has been opened
; 927  : 		return (_Filebuffer.is_open());
; 928  : 		}
; 929  : 
; 930  : 	void open(const char *_Filename,
; 931  : 		ios_base::openmode _Mode = ios_base::in,
; 932  : 		int _Prot = (int)ios_base::_Openprot)
; 933  : 		{	// open a C stream with specified mode
; 934  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 935  : 			_Myios::setstate(ios_base::failbit);
; 936  : 		else
; 937  : 			_Myios::clear();	// added with C++11
; 938  : 		}
; 939  : 
; 940  : 	void open(const string& _Str,
; 941  : 		ios_base::openmode _Mode = ios_base::in,
; 942  : 		int _Prot = (int)ios_base::_Openprot)
; 943  : 		{	// open a C stream with specified mode
; 944  : 		open(_Str.c_str(), _Mode, _Prot);
; 945  : 		}
; 946  : 
; 947  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 948  : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 949  : 		{	// open named file with specified mode (old style)
; 950  : 		open(_Filename, (ios_base::openmode)_Mode);
; 951  : 		}
; 952  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 953  : 
; 954  : 	void close()
; 955  : 		{	// close the C stream
; 956  : 		if (_Filebuffer.close() == 0)
; 957  : 			_Myios::setstate(ios_base::failbit);
; 958  : 		}
; 959  : 
; 960  : private:
; 961  : 	_Myfb _Filebuffer;	// the file buffer
; 962  : 	};
; 963  : 
; 964  : template<class _Elem,
; 965  : 	class _Traits> inline
; 966  : 	void swap(basic_ifstream<_Elem, _Traits>& _Left,
; 967  : 		basic_ifstream<_Elem, _Traits>& _Right)
; 968  : 	{	// swap _Left and _Right basic_ifstreams
; 969  : 	_Left.swap(_Right);
; 970  : 	}
; 971  : 
; 972  : 		// CLASS TEMPLATE basic_ofstream
; 973  : template<class _Elem,
; 974  : 	class _Traits>
; 975  : 	class basic_ofstream
; 976  : 		: public basic_ostream<_Elem, _Traits>
; 977  : 	{	// output stream associated with a C stream
; 978  : public:
; 979  : 	typedef basic_ofstream<_Elem, _Traits> _Myt;
; 980  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 981  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 982  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 983  : 
; 984  : 	basic_ofstream()
; 985  : 		: _Mybase(&_Filebuffer)

  00044	48 8d 5f 08	 lea	 rbx, QWORD PTR [rdi+8]
  00048	45 33 c9	 xor	 r9d, r9d
  0004b	45 33 c0	 xor	 r8d, r8d
  0004e	48 8b d3	 mov	 rdx, rbx
  00051	48 8b cf	 mov	 rcx, rdi
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  0005a	90		 npad	 1

; 986  : 		{	// construct unopened

  0005b	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0005e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00069	48 89 04 39	 mov	 QWORD PTR [rcx+rdi], rax
  0006d	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00070	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00074	8d 91 58 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-168]
  0007a	89 54 39 fc	 mov	 DWORD PTR [rcx+rdi-4], edx
  0007e	48 89 5c 24 40	 mov	 QWORD PTR this$[rsp], rbx

; 155  : 		: _Mysb()

  00083	48 8b cb	 mov	 rcx, rbx
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0008c	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  0008d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00094	48 89 03	 mov	 QWORD PTR [rbx], rax

; 636  : 		_Closef = _Which == _Openfl;

  00097	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0

; 637  : 		_Wrotesome = false;

  0009b	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;

  000a8	48 c7 83 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+128], 0

; 663  : 		_State = _Stinit;

  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000ba	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  000be	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 987  : 		}

  000c6	48 8b c7	 mov	 rax, rdi
  000c9	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000ce	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 a8 00
	00 00		 add	 rcx, 168		; 000000a8H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$0
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 10	 add	 rcx, 16
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$1
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 a8 00
	00 00		 add	 rcx, 168		; 000000a8H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 10	 add	 rcx, 16
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
_TEXT	SEGMENT
this$ = 48
_Filename$dead$ = 56
_Mode$dead$ = 64
_Prot$dead$ = 72
?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::open, COMDAT

; 933  : 		{	// open a C stream with specified mode

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 934  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@COFBHHKL@setting?4txt?$AA@
  00010	48 83 c1 10	 add	 rcx, 16
  00014	41 b8 01 00 00
	00		 mov	 r8d, 1
  0001a	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  0001f	48 8b 13	 mov	 rdx, QWORD PTR [rbx]

; 935  : 			_Myios::setstate(ios_base::failbit);

  00022	45 33 c0	 xor	 r8d, r8d
  00025	48 63 4a 04	 movsxd	 rcx, DWORD PTR [rdx+4]
  00029	48 03 cb	 add	 rcx, rbx
  0002c	48 85 c0	 test	 rax, rax
  0002f	75 0f		 jne	 SHORT $LN2@open
  00031	8d 50 02	 lea	 edx, QWORD PTR [rax+2]

; 938  : 		}

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5b		 pop	 rbx

; 935  : 			_Myios::setstate(ios_base::failbit);

  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@open:

; 936  : 		else
; 937  : 			_Myios::clear();	// added with C++11

  00040	33 d2		 xor	 edx, edx

; 938  : 		}

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5b		 pop	 rbx

; 936  : 		else
; 937  : 			_Myios::clear();	// added with C++11

  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >, COMDAT

; 917  : 		{	// destroy the object

$LN16:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 8b 81 50 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-176]
  0001e	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00029	48 89 84 0a 50
	ff ff ff	 mov	 QWORD PTR [rdx+rcx-176], rax
  00031	48 8b 81 50 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-176]
  00038	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0003c	44 8d 82 50 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-176]
  00043	44 89 84 0a 4c
	ff ff ff	 mov	 DWORD PTR [rdx+rcx-180], r8d

; 918  : 		}

  0004b	48 8d 99 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rcx-160]

; 161  : 		{	// destroy the object

  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00059	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005c	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00064	74 2f		 je	 SHORT $LN9@basic_ifst
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00066	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  0006a	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  0006e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00071	75 22		 jne	 SHORT $LN9@basic_ifst

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00073	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007a	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00081	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00084	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00088	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008b	44 2b c2	 sub	 r8d, edx
  0008e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00092	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN9@basic_ifst:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 164  : 		if (_Closef)

  00095	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  00099	74 09		 je	 SHORT $LN5@basic_ifst

; 165  : 			close();

  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a3	90		 npad	 1
$LN5@basic_ifst:

; 166  : 		}

  000a4	48 8b cb	 mov	 rcx, rbx
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000ad	90		 npad	 1

; 918  : 		}

  000ae	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT

; 771  : 		{	// construct unopened

$LN23:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 89 4c 24 30	 mov	 QWORD PTR this$GSCopy$[rsp], rcx
  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  0002b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002e	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0003b	90		 npad	 1
  0003c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 665  : 		}
; 666  : 
; 667  : 	bool _Endwrite()
; 668  : 		{	// put shift to initial conversion state, as needed
; 669  : 		if (_Pcvt == 0 || !_Wrotesome)
; 670  : 			return (true);
; 671  : 		else
; 672  : 			{	// may have to put
; 673  : 			const int _STRING_INC = 8;
; 674  : 			char *_Dest;
; 675  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 676  : 				return (false);
; 677  : 
; 678  : 			string _Str(_STRING_INC, '\0');
; 679  : 			for (;;)
; 680  : 				{
; 681  : 				switch (_Pcvt->unshift(_State,
; 682  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 683  : 					{	// test result of homing conversion
; 684  : 					case codecvt_base::ok:
; 685  : 						_Wrotesome = false;	// homed successfully
; 686  : 
; 687  : 					case codecvt_base::partial:	// fall through
; 688  : 						{	// put any generated bytes
; 689  : 						size_t _Count = _Dest - &*_Str.begin();
; 690  : 						if (0 < _Count && _Count !=
; 691  : 							fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 692  : 							return (false);	// write failed
; 693  : 						if (!_Wrotesome)
; 694  : 							return (true);
; 695  : 						if (_Count == 0)
; 696  : 							_Str.append(_STRING_INC, '\0');	// try with more space
; 697  : 						break;
; 698  : 						}
; 699  : 
; 700  : 					case codecvt_base::noconv:
; 701  : 						return (true);	// nothing to do
; 702  : 
; 703  : 					default:
; 704  : 						return (false);	// conversion failed
; 705  : 					}
; 706  : 				}
; 707  : 			}
; 708  : 		}
; 709  : 
; 710  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 711  : 		{	// initialize codecvt pointer
; 712  : 		if (_Newpcvt->always_noconv())
; 713  : 			_Pcvt = 0;	// nothing to do
; 714  : 		else
; 715  : 			{	// set up for nontrivial codecvt facet
; 716  : 			_Pcvt = _Newpcvt;
; 717  : 			_Mysb::_Init();	// reset any buffering
; 718  : 			}
; 719  : 		}
; 720  : 
; 721  : private:
; 722  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 723  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 724  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 725  : 	typename _Traits::state_type _State;	// current conversion state
; 726  : 	bool _Closef;	// true if C stream must be closed
; 727  : 	_Filet *_Myfile;	// pointer to C stream
; 728  : 
; 729  : 	void _Reset_back()
; 730  : 		{	// restore buffer after putback
; 731  : 		if (_Mysb::eback() == &_Mychar)
; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 733  : 		}
; 734  : 
; 735  : 	void _Set_back()
; 736  : 		{	// set up putback area
; 737  : 		if (_Mysb::eback() != &_Mychar)
; 738  : 			{	// save current get buffer
; 739  : 			_Set_eback = _Mysb::eback();
; 740  : 			_Set_egptr = _Mysb::egptr();
; 741  : 			}
; 742  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 743  : 		}
; 744  : 
; 745  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 746  : 	_Elem *_Set_egptr;	// saves egptr()
; 747  : 	};
; 748  : 
; 749  : template<class _Elem,
; 750  : 	class _Traits> inline
; 751  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 752  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 753  : 	{	// swap _Left and _Right basic_filebufs
; 754  : 	_Left.swap(_Right);
; 755  : 	}
; 756  : 
; 757  : 		// CLASS TEMPLATE basic_ifstream
; 758  : template<class _Elem,
; 759  : 	class _Traits>
; 760  : 	class basic_ifstream
; 761  : 		: public basic_istream<_Elem, _Traits>
; 762  : 	{	// input stream associated with a C stream
; 763  : public:
; 764  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 765  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 766  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 767  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 768  : 
; 769  : 	basic_ifstream()
; 770  : 		: _Mybase(&_Filebuffer)

  00044	48 8d 5f 10	 lea	 rbx, QWORD PTR [rdi+16]
  00048	45 33 c9	 xor	 r9d, r9d
  0004b	45 33 c0	 xor	 r8d, r8d
  0004e	48 8b d3	 mov	 rdx, rbx
  00051	48 8b cf	 mov	 rcx, rdi
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  0005a	90		 npad	 1

; 771  : 		{	// construct unopened

  0005b	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0005e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00069	48 89 04 39	 mov	 QWORD PTR [rcx+rdi], rax
  0006d	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00070	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00074	8d 91 50 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-176]
  0007a	89 54 39 fc	 mov	 DWORD PTR [rcx+rdi-4], edx
  0007e	48 89 5c 24 40	 mov	 QWORD PTR this$[rsp], rbx

; 155  : 		: _Mysb()

  00083	48 8b cb	 mov	 rcx, rbx
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0008c	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  0008d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00094	48 89 03	 mov	 QWORD PTR [rbx], rax

; 636  : 		_Closef = _Which == _Openfl;

  00097	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0

; 637  : 		_Wrotesome = false;

  0009b	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;

  000a8	48 c7 83 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+128], 0

; 663  : 		_State = _Stinit;

  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000ba	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  000be	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 772  : 		}

  000c6	48 8b c7	 mov	 rax, rdi
  000c9	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000ce	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 18	 add	 rcx, 24
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 18	 add	 rcx, 24
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
_TEXT	SEGMENT
this$ = 48
_Loc$ = 56
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT

; 628  : 		{	// set locale to argument (capture nontrivial codecvt facet)

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 629  : 		_Initcvt(&_USE(_Loc, _Cvt));

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >

; 712  : 		if (_Newpcvt->always_noconv())

  00015	48 8b c8	 mov	 rcx, rax

; 629  : 		_Initcvt(&_USE(_Loc, _Cvt));

  00018	48 8b f8	 mov	 rdi, rax

; 712  : 		if (_Newpcvt->always_noconv())

  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  00021	84 c0		 test	 al, al
  00023	74 13		 je	 SHORT $LN4@imbue

; 713  : 			_Pcvt = 0;	// nothing to do

  00025	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 630  : 		}

  0002d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
$LN4@imbue:

; 717  : 			_Mysb::_Init();	// reset any buffering

  00038	48 8b cb	 mov	 rcx, rbx
  0003b	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 630  : 		}

  0003f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi

; 717  : 			_Mysb::_Init();	// reset any buffering

  00049	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT

; 621  : 		{	// synchronize C stream with external file

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 622  : 		return (_Myfile == 0

  00006	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 28		 je	 SHORT $LN3@sync
  00013	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00016	83 ca ff	 or	 edx, -1
  00019	ff 50 18	 call	 QWORD PTR [rax+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  0001c	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 622  : 		return (_Myfile == 0

  0001f	74 1a		 je	 SHORT $LN3@sync
  00021	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
  0002e	85 c0		 test	 eax, eax
  00030	79 09		 jns	 SHORT $LN3@sync
  00032	83 c8 ff	 or	 eax, -1

; 623  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 624  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 625  : 		}

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
$LN3@sync:

; 622  : 		return (_Myfile == 0

  0003b	33 c0		 xor	 eax, eax

; 623  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 624  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 625  : 		}

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5b		 pop	 rbx
  00042	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
_TEXT	SEGMENT
this$ = 48
_Buffer$ = 56
_Count$ = 64
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT

; 608  : 		{	// offer _Buffer to C stream

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	4d 8b c8	 mov	 r9, r8

; 609  : 		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,

  0000c	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00013	48 85 c9	 test	 rcx, rcx
  00016	74 39		 je	 SHORT $LN4@setbuf
  00018	48 85 d2	 test	 rdx, rdx
  0001b	75 0b		 jne	 SHORT $LN6@setbuf
  0001d	4d 85 c0	 test	 r8, r8
  00020	75 06		 jne	 SHORT $LN6@setbuf
  00022	45 8d 41 04	 lea	 r8d, QWORD PTR [r9+4]
  00026	eb 03		 jmp	 SHORT $LN7@setbuf
$LN6@setbuf:
  00028	45 33 c0	 xor	 r8d, r8d
$LN7@setbuf:
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf
  00031	85 c0		 test	 eax, eax
  00033	75 1c		 jne	 SHORT $LN4@setbuf

; 613  : 		else
; 614  : 			{	// new buffer, reinitialize pointers
; 615  : 			_Init(_Myfile, _Openfl);

  00035	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0003c	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 616  : 			return (this);

  00048	48 8b c3	 mov	 rax, rbx

; 617  : 			}
; 618  : 		}

  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5b		 pop	 rbx
  00050	c3		 ret	 0
$LN4@setbuf:

; 610  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 611  : 			(size_t)_Count * sizeof (_Elem)) != 0)
; 612  : 			return (0);	// failed

  00051	33 c0		 xor	 eax, eax

; 617  : 			}
; 618  : 		}

  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5b		 pop	 rbx
  00058	c3		 ret	 0
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
_Fileposition$ = 32
__$ArrayPad$ = 40
this$ = 80
__$ReturnUdt$ = 88
_Pos$ = 96
__formal$ = 104
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT

; 590  : 		{	// change position to _Pos

$LN18:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 56		 push	 r14
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 591  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);
; 592  : 		off_type _Off = static_cast<off_type>(_Pos) - static_cast<off_type>(_Fileposition);
; 593  : 
; 594  : 		if (_Myfile == 0 || !_Endwrite()
; 595  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 596  : 			|| (_Off != 0 && _fseeki64(_Myfile, _Off, SEEK_CUR) != 0)
; 597  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  0001c	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00024	4d 8b f0	 mov	 r14, r8
  00027	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  0002b	48 8b da	 mov	 rbx, rdx
  0002e	49 8b 30	 mov	 rsi, QWORD PTR [r8]
  00031	48 8b f9	 mov	 rdi, rcx
  00034	48 89 44 24 20	 mov	 QWORD PTR _Fileposition$[rsp], rax
  00039	74 7c		 je	 SHORT $LN3@seekpos
  0003b	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00040	84 c0		 test	 al, al
  00042	74 73		 je	 SHORT $LN3@seekpos
  00044	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  0004b	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Fileposition$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fsetpos
  00056	85 c0		 test	 eax, eax
  00058	75 5d		 jne	 SHORT $LN3@seekpos
  0005a	48 85 f6	 test	 rsi, rsi
  0005d	74 18		 je	 SHORT $LN4@seekpos
  0005f	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  00066	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  0006a	48 8b d6	 mov	 rdx, rsi
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  00073	85 c0		 test	 eax, eax
  00075	75 40		 jne	 SHORT $LN3@seekpos
$LN4@seekpos:
  00077	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  0007e	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Fileposition$[rsp]
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetpos
  00089	85 c0		 test	 eax, eax
  0008b	75 2a		 jne	 SHORT $LN3@seekpos

; 599  : 
; 600  : 		_State = _POS_TYPE_TO_STATE(_Pos);

  0008d	49 8b 4e 10	 mov	 rcx, QWORD PTR [r14+16]
  00091	48 89 4f 74	 mov	 QWORD PTR [rdi+116], rcx

; 601  : 
; 602  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

  00095	48 8b cf	 mov	 rcx, rdi
  00098	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 603  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  0009d	48 8b 4f 74	 mov	 rcx, QWORD PTR [rdi+116]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 42   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  000a1	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Fileposition$[rsp]
  000a6	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx
  000aa	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
  000b1	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 603  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000b5	eb 1b		 jmp	 SHORT $LN16@seekpos
$LN3@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  000b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
  000be	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000c1	33 c0		 xor	 eax, eax
  000c3	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  000c6	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
  000ce	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN16@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 598  : 			return (pos_type(_BADOFF));	// report failure

  000d2	48 8b c3	 mov	 rax, rbx

; 604  : 			_Fileposition));	// return new position
; 605  : 		}

  000d5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000da	48 33 cc	 xor	 rcx, rsp
  000dd	e8 00 00 00 00	 call	 __security_check_cookie
  000e2	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000e7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000eb	41 5e		 pop	 r14
  000ed	5f		 pop	 rdi
  000ee	5e		 pop	 rsi
  000ef	c3		 ret	 0
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
_Fileposition$ = 32
__$ArrayPad$ = 40
this$ = 96
__$ReturnUdt$ = 104
_Off$ = 112
_Way$ = 120
__formal$ = 128
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT

; 568  : 		{	// change position by _Off

$LN23:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 56		 push	 r14
  00007	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  0001a	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 573  : 			&& _Pcvt == 0)	// not converting

  0001e	4c 8d 71 70	 lea	 r14, QWORD PTR [rcx+112]
  00022	41 8b e9	 mov	 ebp, r9d
  00025	49 8b f0	 mov	 rsi, r8
  00028	48 8b fa	 mov	 rdi, rdx
  0002b	48 8b d9	 mov	 rbx, rcx
  0002e	4c 39 30	 cmp	 QWORD PTR [rax], r14
  00031	75 10		 jne	 SHORT $LN2@seekoff
  00033	41 83 f9 01	 cmp	 r9d, 1
  00037	75 0a		 jne	 SHORT $LN2@seekoff
  00039	48 83 79 68 00	 cmp	 QWORD PTR [rcx+104], 0
  0003e	75 03		 jne	 SHORT $LN2@seekoff

; 574  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

  00040	48 ff ce	 dec	 rsi
$LN2@seekoff:

; 575  : 
; 576  : 		if (_Myfile == 0 || !_Endwrite()
; 577  : 			|| ((_Off != 0 || _Way != ios_base::cur)
; 578  : 				&& _fseeki64(_Myfile, _Off, _Way) != 0)
; 579  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  00043	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0004b	0f 84 85 00 00
	00		 je	 $LN4@seekoff
  00051	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00056	84 c0		 test	 al, al
  00058	74 7c		 je	 SHORT $LN4@seekoff
  0005a	48 85 f6	 test	 rsi, rsi
  0005d	75 05		 jne	 SHORT $LN6@seekoff
  0005f	83 fd 01	 cmp	 ebp, 1
  00062	74 17		 je	 SHORT $LN5@seekoff
$LN6@seekoff:
  00064	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0006b	44 8b c5	 mov	 r8d, ebp
  0006e	48 8b d6	 mov	 rdx, rsi
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  00077	85 c0		 test	 eax, eax
  00079	75 5b		 jne	 SHORT $LN4@seekoff
$LN5@seekoff:
  0007b	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00082	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Fileposition$[rsp]
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetpos
  0008d	85 c0		 test	 eax, eax
  0008f	75 45		 jne	 SHORT $LN4@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00091	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  00095	4c 39 30	 cmp	 QWORD PTR [rax], r14
  00098	75 22		 jne	 SHORT $LN13@seekoff

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0009a	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
  000a1	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  000a8	48 89 10	 mov	 QWORD PTR [rax], rdx

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  000ab	44 2b c2	 sub	 r8d, edx
  000ae	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000b2	48 89 11	 mov	 QWORD PTR [rcx], rdx
  000b5	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  000b9	44 89 01	 mov	 DWORD PTR [rcx], r8d
$LN13@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 583  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000bc	48 8b 4b 74	 mov	 rcx, QWORD PTR [rbx+116]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 42   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  000c0	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Fileposition$[rsp]
  000c5	48 89 57 08	 mov	 QWORD PTR [rdi+8], rdx
  000c9	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx
  000cd	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 583  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000d4	eb 1b		 jmp	 SHORT $LN21@seekoff
$LN4@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  000d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
  000dd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e0	33 c0		 xor	 eax, eax
  000e2	48 89 0f	 mov	 QWORD PTR [rdi], rcx
  000e5	48 c7 47 08 00
	00 00 00	 mov	 QWORD PTR [rdi+8], 0
  000ed	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
$LN21@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 580  : 			return (pos_type(_BADOFF));	// report failure

  000f1	48 8b c7	 mov	 rax, rdi

; 584  : 			_Fileposition));	// return new position
; 585  : 		}

  000f4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000f9	48 33 cc	 xor	 rcx, rsp
  000fc	e8 00 00 00 00	 call	 __security_check_cookie
  00101	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00105	41 5e		 pop	 r14
  00107	5f		 pop	 rdi
  00108	5e		 pop	 rsi
  00109	5d		 pop	 rbp
  0010a	5b		 pop	 rbx
  0010b	c3		 ret	 0
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
$T87 = 64
_Src$88 = 72
_Dest$89 = 80
_Ch$90 = 88
_Str$91 = 96
__$ArrayPad$ = 128
this$ = 160
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT

; 498  : 		{	// get an element from stream, point past it

$LN721:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	48 8d 68 a1	 lea	 rbp, QWORD PTR [rax-95]
  00008	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000f	48 c7 45 07 fe
	ff ff ff	 mov	 QWORD PTR $T87[rbp-57], -2
  00017	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  0001b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c4	 xor	 rax, rsp
  00029	48 89 45 47	 mov	 QWORD PTR __$ArrayPad$[rbp-57], rax
  0002d	48 8b d9	 mov	 rbx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00030	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00034	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 500  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00037	48 85 c9	 test	 rcx, rcx
  0003a	74 2c		 je	 SHORT $LN709@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0003c	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]
  00040	4c 63 02	 movsxd	 r8, DWORD PTR [rdx]
  00043	4a 8d 04 01	 lea	 rax, QWORD PTR [rcx+r8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 500  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00047	48 3b c8	 cmp	 rcx, rax
  0004a	73 1c		 jae	 SHORT $LN709@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 270  : 		--*_IGcount;

  0004c	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00050	89 02		 mov	 DWORD PTR [rdx], eax

; 271  : 		return ((*_IGnext)++);

  00052	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00056	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00059	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  0005d	48 89 01	 mov	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  00060	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 501  : 			return (_Traits::to_int_type(

  00063	e9 81 02 00 00	 jmp	 $LN680@uflow
$LN709@uflow:

; 502  : 				*_Mysb::_Gninc()));	// return buffered
; 503  : 		else if (_Myfile == 0)

  00068	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00070	75 08		 jne	 SHORT $LN11@uflow

; 504  : 			return (_Traits::eof());	// no open C stream, fail

  00072	83 c8 ff	 or	 eax, -1
  00075	e9 6f 02 00 00	 jmp	 $LN680@uflow
$LN11@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0007a	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  0007e	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  00082	49 39 00	 cmp	 QWORD PTR [r8], rax
  00085	75 20		 jne	 SHORT $LN43@uflow

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00087	48 8b 93 90 00
	00 00		 mov	 rdx, QWORD PTR [rbx+144]
  0008e	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00095	49 89 08	 mov	 QWORD PTR [r8], rcx

; 253  : 		*_IGnext = _Next;

  00098	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0009c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0009f	2b d1		 sub	 edx, ecx
  000a1	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000a5	89 10		 mov	 DWORD PTR [rax], edx
$LN43@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 506  : 		if (_Pcvt == 0)

  000a7	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  000ae	48 83 7b 68 00	 cmp	 QWORD PTR [rbx+104], 0
  000b3	75 1b		 jne	 SHORT $LN12@uflow

; 49   : 	if ((_Meta = fgetc(_File)) == EOF)

  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  000bb	83 f8 ff	 cmp	 eax, -1
  000be	74 08		 je	 SHORT $LN22@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  000c0	0f b6 d8	 movzx	 ebx, al

; 463  : 		}

  000c3	e9 1f 02 00 00	 jmp	 $LN591@uflow
$LN22@uflow:

; 477  : 		return (EOF);

  000c8	83 cb ff	 or	 ebx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 509  : 			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)

  000cb	e9 17 02 00 00	 jmp	 $LN591@uflow
$LN12@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  000d0	48 c7 45 37 00
	00 00 00	 mov	 QWORD PTR _Str$91[rbp-41], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000d8	48 c7 45 3f 0f
	00 00 00	 mov	 QWORD PTR _Str$91[rbp-33], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000e0	c6 45 27 00	 mov	 BYTE PTR _Str$91[rbp-57], 0
$LN718@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 521  : 				int _Meta = fgetc(_Myfile);

  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc

; 522  : 
; 523  : 				if (_Meta == EOF)

  000ea	83 f8 ff	 cmp	 eax, -1

; 521  : 				int _Meta = fgetc(_Myfile);

  000ed	8b d0		 mov	 edx, eax

; 522  : 
; 523  : 				if (_Meta == EOF)

  000ef	0f 84 a0 01 00
	00		 je	 $LN697@uflow
$_Invalid_parameter$722:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2362 : 		const size_type _Old_size = _My_data._Mysize;

  000f5	4c 8b 45 37	 mov	 r8, QWORD PTR _Str$91[rbp-41]
  000f9	4c 8b 4d 3f	 mov	 r9, QWORD PTR _Str$91[rbp-33]
  000fd	49 8b c9	 mov	 rcx, r9
  00100	49 2b c8	 sub	 rcx, r8

; 2363 : 		if (_Count <= _My_data._Myres - _Old_size)

  00103	48 83 f9 01	 cmp	 rcx, 1

; 1582 : 		value_type * _Result = _Bx._Buf;

  00107	48 8d 4d 27	 lea	 rcx, QWORD PTR _Str$91[rbp-57]

; 2363 : 		if (_Count <= _My_data._Myres - _Old_size)

  0010b	72 23		 jb	 SHORT $LN158@uflow

; 2364 : 			{
; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  0010d	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  00111	48 89 45 37	 mov	 QWORD PTR _Str$91[rbp-41], rax

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00115	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  00119	48 0f 43 4d 27	 cmovae	 rcx, QWORD PTR _Str$91[rbp-57]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  0011e	0f be c2	 movsx	 eax, dl
  00121	0f b6 c0	 movzx	 al, al
  00124	42 88 04 01	 mov	 BYTE PTR [rcx+r8], al

; 442  : 		_Left = _Right;

  00128	42 c6 44 01 01
	00		 mov	 BYTE PTR [rcx+r8+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2369 : 			return (*this);

  0012e	eb 11		 jmp	 SHORT $LN157@uflow
$LN158@uflow:

; 2370 : 			}
; 2371 : 
; 2372 : 		return (_Reallocate_grow_by(_Count,

  00130	88 54 24 20	 mov	 BYTE PTR [rsp+32], dl
  00134	ba 01 00 00 00	 mov	 edx, 1
  00139	44 8b ca	 mov	 r9d, edx
  0013c	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
$LN157@uflow:

; 1582 : 		value_type * _Result = _Bx._Buf;

  00141	48 8d 55 27	 lea	 rdx, QWORD PTR _Str$91[rbp-57]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00145	48 83 7d 3f 10	 cmp	 QWORD PTR _Str$91[rbp-33], 16

; 1583 : 		if (_Large_string_engaged())

  0014a	48 0f 43 55 27	 cmovae	 rdx, QWORD PTR _Str$91[rbp-57]

; 1582 : 		value_type * _Result = _Bx._Buf;

  0014f	4c 8d 45 27	 lea	 r8, QWORD PTR _Str$91[rbp-57]

; 1583 : 		if (_Large_string_engaged())

  00153	4c 0f 43 45 27	 cmovae	 r8, QWORD PTR _Str$91[rbp-57]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 527  : 				switch (_Pcvt->in(_State,

  00158	4c 8b 4d 37	 mov	 r9, QWORD PTR _Str$91[rbp-41]
  0015c	4c 03 ca	 add	 r9, rdx
  0015f	48 8d 45 17	 lea	 rax, QWORD PTR _Dest$89[rbp-57]
  00163	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00168	48 8d 45 20	 lea	 rax, QWORD PTR _Ch$90[rbp-56]
  0016c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00171	48 8d 45 1f	 lea	 rax, QWORD PTR _Ch$90[rbp-57]
  00175	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017a	48 8d 45 0f	 lea	 rax, QWORD PTR _Src$88[rbp-57]
  0017e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00183	48 8d 53 74	 lea	 rdx, QWORD PTR [rbx+116]
  00187	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  00191	85 c0		 test	 eax, eax
  00193	0f 88 fc 00 00
	00		 js	 $LN697@uflow
  00199	83 f8 01	 cmp	 eax, 1
  0019c	7e 4d		 jle	 SHORT $LN15@uflow
  0019e	83 f8 03	 cmp	 eax, 3
  001a1	0f 85 ee 00 00
	00		 jne	 $LN697@uflow

; 545  : 							(size_t)(_Src - &*_Str.begin()));
; 546  : 					break;
; 547  : 
; 548  : 				case codecvt_base::noconv:
; 549  : 					if (_Str.size() < sizeof (_Elem))

  001a7	48 83 7d 37 01	 cmp	 QWORD PTR _Str$91[rbp-41], 1
  001ac	0f 82 85 00 00
	00		 jb	 $LN425@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  001b2	48 8d 45 27	 lea	 rax, QWORD PTR _Str$91[rbp-57]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001b6	48 83 7d 3f 10	 cmp	 QWORD PTR _Str$91[rbp-33], 16

; 1583 : 		if (_Large_string_engaged())

  001bb	0f 82 82 00 00
	00		 jb	 $LN708@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  001c1	48 8b 45 27	 mov	 rax, QWORD PTR _Str$91[rbp-57]
  001c5	48 85 c0	 test	 rax, rax
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  001c8	75 79		 jne	 SHORT $LN708@uflow

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  001ca	88 45 1f	 mov	 BYTE PTR _Ch$90[rbp-57], al

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001d3	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo
  001df	0f b6 45 1f	 movzx	 eax, BYTE PTR _Ch$90[rbp-57]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  001e3	0f b6 d8	 movzx	 ebx, al
  001e6	e9 ad 00 00 00	 jmp	 $LN477@uflow
$LN15@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 533  : 					if (_Dest != &_Ch)

  001eb	48 8d 45 1f	 lea	 rax, QWORD PTR _Ch$90[rbp-57]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  001ef	48 8d 4d 27	 lea	 rcx, QWORD PTR _Str$91[rbp-57]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 533  : 					if (_Dest != &_Ch)

  001f3	48 39 45 17	 cmp	 QWORD PTR _Dest$89[rbp-57], rax
  001f7	75 55		 jne	 SHORT $LN699@uflow
$_Invalid_parameter$723:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  001f9	48 8d 45 27	 lea	 rax, QWORD PTR _Str$91[rbp-57]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001fd	48 83 7d 3f 10	 cmp	 QWORD PTR _Str$91[rbp-33], 16

; 1583 : 		if (_Large_string_engaged())

  00202	48 0f 43 45 27	 cmovae	 rax, QWORD PTR _Str$91[rbp-57]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 544  : 						_Str.erase((size_t)0,	// partial, discard used input

  00207	4c 8b 55 0f	 mov	 r10, QWORD PTR _Src$88[rbp-57]
  0020b	4c 2b d0	 sub	 r10, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  0020e	4c 8b 45 37	 mov	 r8, QWORD PTR _Str$91[rbp-41]
  00212	4d 3b c2	 cmp	 r8, r10
  00215	4d 0f 42 d0	 cmovb	 r10, r8

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00219	48 83 7d 3f 10	 cmp	 QWORD PTR _Str$91[rbp-33], 16

; 1583 : 		if (_Large_string_engaged())

  0021e	48 0f 43 4d 27	 cmovae	 rcx, QWORD PTR _Str$91[rbp-57]

; 2606 : 		const size_type _New_size = _Old_size - _Count;

  00223	4d 2b c2	 sub	 r8, r10

; 2607 : 		_My_data._Mysize = _New_size;

  00226	4c 89 45 37	 mov	 QWORD PTR _Str$91[rbp-41], r8

; 2608 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0022a	49 ff c0	 inc	 r8
  0022d	4a 8d 14 11	 lea	 rdx, QWORD PTR [rcx+r10]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN425@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 521  : 				int _Meta = fgetc(_Myfile);

  00237	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]

; 522  : 
; 523  : 				if (_Meta == EOF)

  0023e	e9 a1 fe ff ff	 jmp	 $LN718@uflow
$LN708@uflow:
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h

; 59   :         memcpy(_Destination, _Source, _SourceSize);

  00243	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00246	88 45 1f	 mov	 BYTE PTR _Ch$90[rbp-57], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  00249	0f b6 d8	 movzx	 ebx, al
  0024c	eb 4a		 jmp	 SHORT $LN477@uflow
$LN699@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0024e	48 83 7d 3f 10	 cmp	 QWORD PTR _Str$91[rbp-33], 16

; 1583 : 		if (_Large_string_engaged())

  00253	48 0f 43 4d 27	 cmovae	 rcx, QWORD PTR _Str$91[rbp-57]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 535  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  00258	8b 45 37	 mov	 eax, DWORD PTR _Str$91[rbp-41]
  0025b	48 8b 55 0f	 mov	 rdx, QWORD PTR _Src$88[rbp-57]
  0025f	2b c2		 sub	 eax, edx
  00261	03 c1		 add	 eax, ecx
  00263	48 63 f8	 movsxd	 rdi, eax

; 536  : 						while (0 < _Nleft)

  00266	85 c0		 test	 eax, eax
  00268	7e 25		 jle	 SHORT $LN714@uflow
  0026a	66 0f 1f 44 00
	00		 npad	 6
$LL7@uflow:

; 537  : 							{
; 538  : 							ungetc(_Src[--_Nleft], _Myfile);

  00270	48 ff cf	 dec	 rdi
  00273	0f be 0c 17	 movsx	 ecx, BYTE PTR [rdi+rdx]
  00277	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0027e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc

; 536  : 						while (0 < _Nleft)

  00284	48 85 ff	 test	 rdi, rdi
  00287	7e 06		 jle	 SHORT $LN714@uflow
  00289	48 8b 55 0f	 mov	 rdx, QWORD PTR _Src$88[rbp-57]
  0028d	eb e1		 jmp	 SHORT $LL7@uflow
$LN714@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  0028f	0f b6 5d 1f	 movzx	 ebx, BYTE PTR _Ch$90[rbp-57]
  00293	eb 03		 jmp	 SHORT $LN477@uflow
$LN697@uflow:
$_Invalid_parameter$724:
  00295	83 cb ff	 or	 ebx, -1
$LN477@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00298	48 8b 55 3f	 mov	 rdx, QWORD PTR _Str$91[rbp-33]
  0029c	48 83 fa 10	 cmp	 rdx, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  002a0	72 45		 jb	 SHORT $LN591@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  002a2	48 8b 4d 27	 mov	 rcx, QWORD PTR _Str$91[rbp-57]
  002a6	48 8b c1	 mov	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002a9	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  002ac	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  002b3	72 2d		 jb	 SHORT $LN594@uflow

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  002b5	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  002b9	4c 3b c2	 cmp	 r8, rdx
  002bc	76 1d		 jbe	 SHORT $_Invalid_parameter$725

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  002be	49 8b d0	 mov	 rdx, r8
  002c1	a8 1f		 test	 al, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  002c3	75 16		 jne	 SHORT $_Invalid_parameter$725

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002c5	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  002c9	48 3b c8	 cmp	 rcx, rax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  002cc	73 0d		 jae	 SHORT $_Invalid_parameter$725

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  002ce	48 2b c1	 sub	 rax, rcx
  002d1	48 83 e8 08	 sub	 rax, 8
  002d5	48 83 f8 1f	 cmp	 rax, 31
  002d9	76 07		 jbe	 SHORT $LN594@uflow
$_Invalid_parameter$725:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  002e1	cc		 int	 3
$LN594@uflow:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  002e2	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN591@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 558  : 					return (_Traits::eof());	// conversion failed

  002e7	8b c3		 mov	 eax, ebx
$LN680@uflow:

; 559  : 					}
; 560  : 				}
; 561  : 			}
; 562  : 		}

  002e9	48 8b 4d 47	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-57]
  002ed	48 33 cc	 xor	 rcx, rsp
  002f0	e8 00 00 00 00	 call	 __security_check_cookie
  002f5	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  002fd	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  00301	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  00305	49 8b e3	 mov	 rsp, r11
  00308	5d		 pop	 rbp
  00309	c3		 ret	 0
$LN716@uflow:
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T87 = 64
_Src$88 = 72
_Dest$89 = 80
_Ch$90 = 88
_Str$91 = 96
__$ArrayPad$ = 128
this$ = 160
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Str$91[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T87 = 64
_Src$88 = 72
_Dest$89 = 80
_Ch$90 = 88
_Str$91 = 96
__$ArrayPad$ = 128
this$ = 160
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Str$91[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT

; 483  : 		{	// get an element from stream, but don't point past it

$LN26:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00006	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 483  : 		{	// get an element from stream, but don't point past it

  0000a	48 8b d9	 mov	 rbx, rcx

; 486  : 			&& _Mysb::gptr() < _Mysb::egptr())

  0000d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00010	48 85 c9	 test	 rcx, rcx
  00013	74 18		 je	 SHORT $LN2@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00015	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00019	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  0001c	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 486  : 			&& _Mysb::gptr() < _Mysb::egptr())

  0001f	48 3b ca	 cmp	 rcx, rdx
  00022	73 09		 jae	 SHORT $LN2@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  00024	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 495  : 		}

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
$LN2@underflow:

; 488  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0002d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00030	48 8b cb	 mov	 rcx, rbx
  00033	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00038	ff 50 38	 call	 QWORD PTR [rax+56]
  0003b	8b f8		 mov	 edi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  0003d	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 488  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  00040	75 0d		 jne	 SHORT $LN4@underflow

; 489  : 			return (_Meta);	// uflow failed, return EOF

  00042	0b c0		 or	 eax, eax
  00044	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 495  : 		}

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
$LN4@underflow:

; 490  : 		else
; 491  : 			{	// get a char, don't point past it
; 492  : 			pbackfail(_Meta);

  0004f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00052	8b d7		 mov	 edx, edi
  00054	48 8b cb	 mov	 rcx, rbx
  00057	ff 50 20	 call	 QWORD PTR [rax+32]

; 493  : 			return (_Meta);

  0005a	8b c7		 mov	 eax, edi
  0005c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 495  : 		}

  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 48
_Meta$ = 56
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT

; 458  : 		{	// put an element back to stream

$LN85:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  0000a	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 458  : 		{	// put an element back to stream

  0000e	8b fa		 mov	 edi, edx
  00010	48 8b d9	 mov	 rbx, rcx

; 461  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00013	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00016	4d 85 c0	 test	 r8, r8
  00019	74 3b		 je	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0001b	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 461  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001f	4c 39 00	 cmp	 QWORD PTR [rax], r8
  00022	73 32		 jae	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  00024	8b ca		 mov	 ecx, edx
  00026	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 461  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00029	74 09		 je	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  0002b	41 0f b6 40 ff	 movzx	 eax, BYTE PTR [r8-1]
  00030	3b c2		 cmp	 eax, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 461  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00032	75 22		 jne	 SHORT $LN2@pbackfail
$LN4@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 264  : 		++*_IGcount;

  00034	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00038	ff 00		 inc	 DWORD PTR [rax]

; 265  : 		return (--*_IGnext);

  0003a	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0003e	48 ff 08	 dec	 QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 466  : 			return (_Traits::not_eof(_Meta));

  00041	33 c0		 xor	 eax, eax
  00043	83 f9 ff	 cmp	 ecx, -1
  00046	0f 44 c8	 cmove	 ecx, eax
  00049	8b c1		 mov	 eax, ecx

; 477  : 			}
; 478  : 		else
; 479  : 			return (_Traits::eof());	// nowhere to put back
; 480  : 	}

  0004b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
$LN2@pbackfail:

; 468  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  00056	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  0005d	48 85 c0	 test	 rax, rax
  00060	74 75		 je	 SHORT $LN7@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  00062	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 468  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  00065	74 70		 je	 SHORT $LN7@pbackfail

; 470  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  00067	48 83 7b 68 00	 cmp	 QWORD PTR [rbx+104], 0
  0006c	75 11		 jne	 SHORT $LN81@pbackfail

; 117  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  0006e	0f b6 ca	 movzx	 ecx, dl
  00071	48 8b d0	 mov	 rdx, rax
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
  0007a	83 f8 ff	 cmp	 eax, -1

; 470  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  0007d	75 4b		 jne	 SHORT $LN83@pbackfail
$LN81@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  0007f	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 472  : 		else if (_Mysb::gptr() != &_Mychar)

  00083	48 8d 53 70	 lea	 rdx, QWORD PTR [rbx+112]
  00087	49 39 10	 cmp	 QWORD PTR [r8], rdx
  0008a	74 4b		 je	 SHORT $LN7@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0008c	4c 8b 4b 18	 mov	 r9, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 474  : 			_Mychar = _Traits::to_char_type(_Meta);

  00090	40 88 3a	 mov	 BYTE PTR [rdx], dil

; 737  : 		if (_Mysb::eback() != &_Mychar)

  00093	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00096	48 3b c2	 cmp	 rax, rdx
  00099	74 18		 je	 SHORT $LN82@pbackfail

; 738  : 			{	// save current get buffer
; 739  : 			_Set_eback = _Mysb::eback();

  0009b	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  000a2	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000a6	48 63 08	 movsxd	 rcx, DWORD PTR [rax]
  000a9	49 03 08	 add	 rcx, QWORD PTR [r8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 740  : 			_Set_egptr = _Mysb::egptr();

  000ac	48 89 8b 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rcx
$LN82@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  000b3	49 89 11	 mov	 QWORD PTR [r9], rdx

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  000b6	8b cb		 mov	 ecx, ebx
  000b8	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000bc	2b ca		 sub	 ecx, edx
  000be	83 c1 71	 add	 ecx, 113		; 00000071H
  000c1	48 89 10	 mov	 QWORD PTR [rax], rdx
  000c4	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000c8	89 08		 mov	 DWORD PTR [rax], ecx
$LN83@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 476  : 			return (_Meta);

  000ca	8b c7		 mov	 eax, edi

; 477  : 			}
; 478  : 		else
; 479  : 			return (_Traits::eof());	// nowhere to put back
; 480  : 	}

  000cc	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d5	5f		 pop	 rdi
  000d6	c3		 ret	 0
$LN7@pbackfail:

; 469  : 			return (_Traits::eof());	// no open C stream or EOF, fail

  000d7	83 c8 ff	 or	 eax, -1

; 477  : 			}
; 478  : 		else
; 479  : 			return (_Traits::eof());	// nowhere to put back
; 480  : 	}

  000da	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000df	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e3	5f		 pop	 rdi
  000e4	c3		 ret	 0
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
$T86 = 64
_Dest$87 = 72
_Src$88 = 80
_Ch$89 = 88
_Str$90 = 96
__$ArrayPad$ = 128
this$ = 176
_Meta$ = 184
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT

; 389  : 		{	// put an element to stream

$LN724:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	57		 push	 rdi
  00005	41 56		 push	 r14
  00007	48 8d 68 a1	 lea	 rbp, QWORD PTR [rax-95]
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 c7 45 f7 fe
	ff ff ff	 mov	 QWORD PTR $T86[rbp-73], -2
  0001a	48 89 58 18	 mov	 QWORD PTR [rax+24], rbx
  0001e	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 45 37	 mov	 QWORD PTR __$ArrayPad$[rbp-73], rax
  00030	8b f2		 mov	 esi, edx
  00032	48 8b d9	 mov	 rbx, rcx

; 390  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00035	83 fa ff	 cmp	 edx, -1
  00038	75 0e		 jne	 SHORT $LN7@overflow

; 391  : 			{
; 392  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  0003a	33 c0		 xor	 eax, eax
  0003c	3b d2		 cmp	 edx, edx
  0003e	0f 44 f0	 cmove	 esi, eax
  00041	8b c6		 mov	 eax, esi
  00043	e9 61 02 00 00	 jmp	 $LN698@overflow
$LN7@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00048	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
  0004c	48 8b 10	 mov	 rdx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 394  : 		else if (_Mysb::pptr() != 0 && _Mysb::pptr() < _Mysb::epptr())

  0004f	48 85 d2	 test	 rdx, rdx
  00052	74 2e		 je	 SHORT $LN9@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00054	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00058	4c 63 00	 movsxd	 r8, DWORD PTR [rax]
  0005b	4a 8d 0c 02	 lea	 rcx, QWORD PTR [rdx+r8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 394  : 		else if (_Mysb::pptr() != 0 && _Mysb::pptr() < _Mysb::epptr())

  0005f	48 3b d1	 cmp	 rdx, rcx
  00062	73 1e		 jae	 SHORT $LN9@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 307  : 		--*_IPcount;

  00064	41 8d 48 ff	 lea	 ecx, DWORD PTR [r8-1]
  00068	89 08		 mov	 DWORD PTR [rax], ecx

; 308  : 		return ((*_IPnext)++);

  0006a	48 8b 53 40	 mov	 rdx, QWORD PTR [rbx+64]
  0006e	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
  00071	49 8d 48 01	 lea	 rcx, QWORD PTR [r8+1]
  00075	48 89 0a	 mov	 QWORD PTR [rdx], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 396  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00078	41 88 30	 mov	 BYTE PTR [r8], sil

; 397  : 			return (_Meta);

  0007b	8b c6		 mov	 eax, esi
  0007d	e9 27 02 00 00	 jmp	 $LN698@overflow
$LN9@overflow:

; 398  : 			}
; 399  : 		else if (_Myfile == 0)

  00082	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  0008a	75 08		 jne	 SHORT $LN11@overflow

; 400  : 			{
; 401  : 			return (_Traits::eof());	// no open C stream, fail

  0008c	83 c8 ff	 or	 eax, -1
  0008f	e9 15 02 00 00	 jmp	 $LN698@overflow
$LN11@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00094	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  00098	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  0009c	49 39 00	 cmp	 QWORD PTR [r8], rax
  0009f	75 20		 jne	 SHORT $LN65@overflow

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  000a1	48 8b 93 90 00
	00 00		 mov	 rdx, QWORD PTR [rbx+144]
  000a8	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  000af	49 89 08	 mov	 QWORD PTR [r8], rcx

; 253  : 		*_IGnext = _Next;

  000b2	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000b6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  000b9	2b d1		 sub	 edx, ecx
  000bb	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000bf	89 10		 mov	 DWORD PTR [rax], edx
$LN65@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 405  : 		if (_Pcvt == 0)

  000c1	48 83 7b 68 00	 cmp	 QWORD PTR [rbx+104], 0
  000c6	75 1e		 jne	 SHORT $LN12@overflow

; 93   : 	return (fputc(_Byte, _File) != EOF);

  000c8	40 0f be ce	 movsx	 ecx, sil
  000cc	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 406  : 			{
; 407  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)

  000d9	83 cb ff	 or	 ebx, -1

; 93   : 	return (fputc(_Byte, _File) != EOF);

  000dc	3b c3		 cmp	 eax, ebx

; 406  : 			{
; 407  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)

  000de	0f 45 de	 cmovne	 ebx, esi
  000e1	e9 c1 01 00 00	 jmp	 $LN609@overflow
$LN12@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 457  : 		return (static_cast<char>(_Meta));

  000e6	40 88 75 0f	 mov	 BYTE PTR _Ch$89[rbp-73], sil
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  000ea	33 c0		 xor	 eax, eax
  000ec	48 89 45 27	 mov	 QWORD PTR _Str$90[rbp-57], rax

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000f0	48 c7 45 2f 0f
	00 00 00	 mov	 QWORD PTR _Str$90[rbp-49], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000f8	88 45 17	 mov	 BYTE PTR _Str$90[rbp-73], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1978 : 		assign(_Count, _Ch);

  000fb	48 8d 4d 17	 lea	 rcx, QWORD PTR _Str$90[rbp-73]
  000ff	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00104	90		 npad	 1
$LN721@overflow:
$_Invalid_parameter$725:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 417  : 			string _Str(_STRING_INC, '\0');

  00105	4c 8b 4d 2f	 mov	 r9, QWORD PTR _Str$90[rbp-49]
  00109	4c 8b 45 17	 mov	 r8, QWORD PTR _Str$90[rbp-73]
  0010d	0f 1f 00	 npad	 3
$LL2@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00110	48 8d 4d 17	 lea	 rcx, QWORD PTR _Str$90[rbp-73]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00114	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  00118	49 0f 43 c8	 cmovae	 rcx, r8

; 1582 : 		value_type * _Result = _Bx._Buf;

  0011c	48 8d 55 17	 lea	 rdx, QWORD PTR _Str$90[rbp-73]

; 1583 : 		if (_Large_string_engaged())

  00120	49 0f 43 d0	 cmovae	 rdx, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 420  : 				switch (_Pcvt->out(_State,

  00124	48 03 4d 27	 add	 rcx, QWORD PTR _Str$90[rbp-57]
  00128	48 8d 45 ff	 lea	 rax, QWORD PTR _Dest$87[rbp-73]
  0012c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00131	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00136	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0013b	48 8d 45 07	 lea	 rax, QWORD PTR _Src$88[rbp-73]
  0013f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00144	4c 8d 4d 10	 lea	 r9, QWORD PTR _Ch$89[rbp-72]
  00148	4c 8d 45 0f	 lea	 r8, QWORD PTR _Ch$89[rbp-73]
  0014c	48 8d 53 74	 lea	 rdx, QWORD PTR [rbx+116]
  00150	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  0015a	85 c0		 test	 eax, eax
  0015c	0f 88 ef 00 00
	00		 js	 $LN22@overflow
  00162	83 f8 01	 cmp	 eax, 1
  00165	0f 8f be 00 00
	00		 jg	 $LN714@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  0016b	48 8d 45 17	 lea	 rax, QWORD PTR _Str$90[rbp-73]

; 1583 : 		if (_Large_string_engaged())

  0016f	4c 8b 45 17	 mov	 r8, QWORD PTR _Str$90[rbp-73]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00173	4c 8b 4d 2f	 mov	 r9, QWORD PTR _Str$90[rbp-49]
  00177	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  0017b	49 0f 43 c0	 cmovae	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 427  : 						size_t _Count = _Dest - &*_Str.begin();

  0017f	48 8b 7d ff	 mov	 rdi, QWORD PTR _Dest$87[rbp-73]
  00183	48 2b f8	 sub	 rdi, rax

; 428  : 						if (0 < _Count && _Count !=

  00186	74 32		 je	 SHORT $LN15@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00188	48 8d 4d 17	 lea	 rcx, QWORD PTR _Str$90[rbp-73]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0018c	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  00190	49 0f 43 c8	 cmovae	 rcx, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 428  : 						if (0 < _Count && _Count !=

  00194	4c 8b 8b 80 00
	00 00		 mov	 r9, QWORD PTR [rbx+128]
  0019b	4c 8b c7	 mov	 r8, rdi
  0019e	ba 01 00 00 00	 mov	 edx, 1
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  001a9	4c 8b 4d 2f	 mov	 r9, QWORD PTR _Str$90[rbp-49]
  001ad	4c 8b 45 17	 mov	 r8, QWORD PTR _Str$90[rbp-73]
  001b1	48 3b f8	 cmp	 rdi, rax
  001b4	0f 85 9f 00 00
	00		 jne	 $LN19@overflow
$LN15@overflow:
$_Invalid_parameter$726:

; 429  : 							fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 430  : 							return (_Traits::eof());	// write failed
; 431  : 
; 432  : 						_Wrotesome = true;	// write succeeded

  001ba	c6 43 71 01	 mov	 BYTE PTR [rbx+113], 1

; 433  : 						if (_Src != &_Ch)

  001be	48 8d 45 0f	 lea	 rax, QWORD PTR _Ch$89[rbp-73]
  001c2	48 39 45 07	 cmp	 QWORD PTR _Src$88[rbp-73], rax
  001c6	75 5d		 jne	 SHORT $LN716@overflow
$_Invalid_parameter$727:

; 435  : 
; 436  : 						if (0 < _Count)

  001c8	48 85 ff	 test	 rdi, rdi
  001cb	0f 85 3f ff ff
	ff		 jne	 $LL2@overflow

; 437  : 							;
; 438  : 						else if (_Str.size() < 4 * _STRING_INC)

  001d1	48 8b 4d 27	 mov	 rcx, QWORD PTR _Str$90[rbp-57]
  001d5	48 83 f9 20	 cmp	 rcx, 32			; 00000020H
  001d9	73 7e		 jae	 SHORT $LN19@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2362 : 		const size_type _Old_size = _My_data._Mysize;

  001db	49 8b c1	 mov	 rax, r9
  001de	48 2b c1	 sub	 rax, rcx

; 2363 : 		if (_Count <= _My_data._Myres - _Old_size)

  001e1	48 83 f8 08	 cmp	 rax, 8
  001e5	72 23		 jb	 SHORT $LN397@overflow

; 2364 : 			{
; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  001e7	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
  001eb	48 89 45 27	 mov	 QWORD PTR _Str$90[rbp-57], rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  001ef	48 8d 45 17	 lea	 rax, QWORD PTR _Str$90[rbp-73]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  001f3	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  001f7	49 0f 43 c0	 cmovae	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  001fb	33 d2		 xor	 edx, edx
  001fd	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 442  : 		_Left = _Right;

  00201	88 54 08 08	 mov	 BYTE PTR [rax+rcx+8], dl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2369 : 			return (*this);

  00205	e9 fb fe ff ff	 jmp	 $LN721@overflow
$LN397@overflow:

; 2370 : 			}
; 2371 : 
; 2372 : 		return (_Reallocate_grow_by(_Count,

  0020a	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0020f	ba 08 00 00 00	 mov	 edx, 8
  00214	44 8b ca	 mov	 r9d, edx
  00217	48 8d 4d 17	 lea	 rcx, QWORD PTR _Str$90[rbp-73]
  0021b	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 452  : 				}

  00220	e9 e0 fe ff ff	 jmp	 $LN721@overflow
$LN716@overflow:

; 434  : 							return (_Meta);	// converted whole element

  00225	8b de		 mov	 ebx, esi
  00227	eb 33		 jmp	 SHORT $LN569@overflow
$LN714@overflow:

; 420  : 				switch (_Pcvt->out(_State,

  00229	83 f8 03	 cmp	 eax, 3
  0022c	75 23		 jne	 SHORT $LN22@overflow

; 93   : 	return (fputc(_Byte, _File) != EOF);

  0022e	0f be 4d 0f	 movsx	 ecx, BYTE PTR _Ch$89[rbp-73]
  00232	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 439  : 							_Str.append(_STRING_INC, '\0');	// try with more space
; 440  : 						else
; 441  : 							return (_Traits::eof());	// conversion failed
; 442  : 						break;
; 443  : 						}
; 444  : 
; 445  : 					case codecvt_base::noconv:
; 446  : 						return (_Fputc(_Ch, _Myfile) ? _Meta

  0023f	83 cb ff	 or	 ebx, -1

; 93   : 	return (fputc(_Byte, _File) != EOF);

  00242	3b c3		 cmp	 eax, ebx

; 439  : 							_Str.append(_STRING_INC, '\0');	// try with more space
; 440  : 						else
; 441  : 							return (_Traits::eof());	// conversion failed
; 442  : 						break;
; 443  : 						}
; 444  : 
; 445  : 					case codecvt_base::noconv:
; 446  : 						return (_Fputc(_Ch, _Myfile) ? _Meta

  00244	0f 45 de	 cmovne	 ebx, esi
  00247	4c 8b 4d 2f	 mov	 r9, QWORD PTR _Str$90[rbp-49]
  0024b	4c 8b 45 17	 mov	 r8, QWORD PTR _Str$90[rbp-73]
  0024f	eb 0b		 jmp	 SHORT $LN569@overflow
$LN22@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 477  : 		return (EOF);

  00251	4c 8b 4d 2f	 mov	 r9, QWORD PTR _Str$90[rbp-49]
  00255	4c 8b 45 17	 mov	 r8, QWORD PTR _Str$90[rbp-73]
$LN19@overflow:
$_Invalid_parameter$728:
  00259	83 cb ff	 or	 ebx, -1
$LN569@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0025c	49 83 f9 10	 cmp	 r9, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00260	72 45		 jb	 SHORT $LN609@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00262	49 8b c0	 mov	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00265	49 8d 51 01	 lea	 rdx, QWORD PTR [r9+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00269	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00270	72 2d		 jb	 SHORT $LN612@overflow

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00272	48 8d 4a 27	 lea	 rcx, QWORD PTR [rdx+39]
  00276	48 3b ca	 cmp	 rcx, rdx
  00279	76 1d		 jbe	 SHORT $_Invalid_parameter$729

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0027b	48 8b d1	 mov	 rdx, rcx
  0027e	a8 1f		 test	 al, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00280	75 16		 jne	 SHORT $_Invalid_parameter$729

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00282	4d 8b 40 f8	 mov	 r8, QWORD PTR [r8-8]
  00286	4c 3b c0	 cmp	 r8, rax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00289	73 0d		 jae	 SHORT $_Invalid_parameter$729

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0028b	49 2b c0	 sub	 rax, r8
  0028e	48 83 e8 08	 sub	 rax, 8
  00292	48 83 f8 1f	 cmp	 rax, 31
  00296	76 07		 jbe	 SHORT $LN612@overflow
$_Invalid_parameter$729:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0029e	cc		 int	 3
$LN612@overflow:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0029f	49 8b c8	 mov	 rcx, r8
  002a2	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN609@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 450  : 						return (_Traits::eof());	// conversion failed

  002a7	8b c3		 mov	 eax, ebx
$LN698@overflow:

; 453  : 			}
; 454  : 		}

  002a9	48 8b 4d 37	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-73]
  002ad	48 33 cc	 xor	 rcx, rsp
  002b0	e8 00 00 00 00	 call	 __security_check_cookie
  002b5	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  002bd	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  002c1	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  002c5	49 8b e3	 mov	 rsp, r11
  002c8	41 5e		 pop	 r14
  002ca	5f		 pop	 rdi
  002cb	5d		 pop	 rbp
  002cc	c3		 ret	 0
$LN720@overflow:
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T86 = 64
_Dest$87 = 72
_Src$88 = 80
_Ch$89 = 88
_Str$90 = 96
__$ArrayPad$ = 128
this$ = 176
_Meta$ = 184
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Str$90[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T86 = 64
_Dest$87 = 72
_Src$88 = 80
_Ch$89 = 88
_Str$90 = 96
__$ArrayPad$ = 128
this$ = 176
_Meta$ = 184
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Str$90[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT

; 382  : 		if (_Myfile)

  00000	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 07		 je	 SHORT $LN2@Unlock

; 383  : 			_CSTD _unlock_file(_Myfile);

  0000c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__unlock_file
$LN2@Unlock:

; 384  : 		}

  00013	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT

; 376  : 		if (_Myfile)

  00000	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 07		 je	 SHORT $LN2@Lock

; 377  : 			_CSTD _lock_file(_Myfile);

  0000c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__lock_file
$LN2@Lock:

; 378  : 		}

  00013	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT

; 161  : 		{	// destroy the object

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00019	48 89 01	 mov	 QWORD PTR [rcx], rax

; 162  : 		if (_Myfile != 0)

  0001c	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00024	74 2f		 je	 SHORT $LN6@basic_file
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00026	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  0002a	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  0002e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00031	75 22		 jne	 SHORT $LN6@basic_file

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00033	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0003a	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00041	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00044	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00048	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0004b	44 2b c2	 sub	 r8d, edx
  0004e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00052	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN6@basic_file:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 164  : 		if (_Closef)

  00055	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  00059	74 09		 je	 SHORT $LN3@basic_file

; 165  : 			close();

  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00063	90		 npad	 1
$LN3@basic_file:

; 166  : 		}

  00064	48 8b cb	 mov	 rcx, rbx
  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5b		 pop	 rbx
  0006c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_Nul$75 = 32
_Str$76 = 32
_Str$77 = 64
__$ArrayPad$ = 96
this$ = 128
__$ReturnUdt$ = 136
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT

; 643  : 		{	// return string copy of character array

$LN539:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  00019	44 8b 81 88 00
	00 00		 mov	 r8d, DWORD PTR [rcx+136]

; 643  : 		{	// return string copy of character array

  00020	48 8b da	 mov	 rbx, rdx

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  00023	41 f6 c0 02	 test	 r8b, 2
  00027	75 7e		 jne	 SHORT $LN6@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00029	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0002d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00030	48 85 d2	 test	 rdx, rdx
  00033	74 72		 je	 SHORT $LN6@str

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00035	48 8b b9 80 00
	00 00		 mov	 rdi, QWORD PTR [rcx+128]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 231  : 		return (*_IPfirst);

  0003c	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00040	48 3b fa	 cmp	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00043	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0004b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Str$77[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00050	48 0f 42 fa	 cmovb	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 231  : 		return (*_IPfirst);

  00054	4c 8b 08	 mov	 r9, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00057	49 2b f9	 sub	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0005a	c6 44 24 40 00	 mov	 BYTE PTR _Str$77[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0005f	f3 0f 7f 44 24
	50		 movdqu	 XMMWORD PTR _Str$77[rsp+16], xmm0

; 2420 : 		if (_Count <= _My_data._Myres)

  00065	48 83 ff 0f	 cmp	 rdi, 15
  00069	77 25		 ja	 SHORT $LN51@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0006b	4c 8b c7	 mov	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  0006e	48 89 7c 24 50	 mov	 QWORD PTR _Str$77[rsp+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00073	49 8b d1	 mov	 rdx, r9
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  0007c	c6 44 3c 40 00	 mov	 BYTE PTR _Str$77[rsp+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00081	0f 10 44 24 40	 movups	 xmm0, XMMWORD PTR _Str$77[rsp]
  00086	0f 10 4c 24 50	 movups	 xmm1, XMMWORD PTR _Str$77[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 98   : 			return (_Str);

  0008b	e9 98 00 00 00	 jmp	 $LN536@str
$LN51@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00090	48 8b d7	 mov	 rdx, rdi
  00093	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00098	0f 10 44 24 40	 movups	 xmm0, XMMWORD PTR _Str$77[rsp]
  0009d	0f 10 4c 24 50	 movups	 xmm1, XMMWORD PTR _Str$77[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 98   : 			return (_Str);

  000a2	e9 81 00 00 00	 jmp	 $LN536@str
$LN6@str:

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  000a7	41 f6 c0 04	 test	 r8b, 4
  000ab	75 6a		 jne	 SHORT $LN8@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  000ad	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  000b1	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000b4	48 85 d2	 test	 rdx, rdx
  000b7	74 5e		 je	 SHORT $LN8@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  000b9	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  000bd	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  000c5	4c 8b 08	 mov	 r9, QWORD PTR [rax]

; 241  : 		return (*_IGnext + *_IGcount);

  000c8	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000cc	48 8d 4c 24 20	 lea	 rcx, QWORD PTR _Str$76[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  000d1	48 63 38	 movsxd	 rdi, DWORD PTR [rax]

; 241  : 		return (*_IGnext + *_IGcount);

  000d4	49 2b f9	 sub	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000d7	c6 44 24 20 00	 mov	 BYTE PTR _Str$76[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

  000dc	48 03 fa	 add	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  000df	f3 0f 7f 44 24
	30		 movdqu	 XMMWORD PTR _Str$76[rsp+16], xmm0

; 2420 : 		if (_Count <= _My_data._Myres)

  000e5	48 83 ff 0f	 cmp	 rdi, 15
  000e9	77 1d		 ja	 SHORT $LN233@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000eb	4c 8b c7	 mov	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  000ee	48 89 7c 24 30	 mov	 QWORD PTR _Str$76[rsp+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000f3	49 8b d1	 mov	 rdx, r9
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  000fc	c6 44 3c 20 00	 mov	 BYTE PTR _Str$76[rsp+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00101	0f 10 4c 24 30	 movups	 xmm1, XMMWORD PTR _Str$76[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 103  : 			return (_Str);

  00106	eb 1b		 jmp	 SHORT $LN537@str
$LN233@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00108	48 8b d7	 mov	 rdx, rdi
  0010b	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00110	0f 10 4c 24 30	 movups	 xmm1, XMMWORD PTR _Str$76[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 103  : 			return (_Str);

  00115	eb 0c		 jmp	 SHORT $LN537@str
$LN8@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00117	0f 10 0d 00 00
	00 00		 movups	 xmm1, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0011e	c6 44 24 20 00	 mov	 BYTE PTR _Nul$75[rsp], 0
$LN537@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00123	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR _Nul$75[rsp]
$LN536@str:
  00128	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 644  : 		return (_Stringbuffer.str());

  0012b	48 8b c3	 mov	 rax, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0012e	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 645  : 		}

  00132	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00137	48 33 cc	 xor	 rcx, rsp
  0013a	e8 00 00 00 00	 call	 __security_check_cookie
  0013f	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  00147	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0014b	5f		 pop	 rdi
  0014c	c3		 ret	 0
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 634  : 		{	// destroy the object

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b 81 68 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-152]
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00014	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0001b	48 89 84 0a 68
	ff ff ff	 mov	 QWORD PTR [rdx+rcx-152], rax
  00023	48 8b 81 68 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-152]
  0002a	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0002e	44 8d 82 68 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-152]
  00035	44 89 84 0a 64
	ff ff ff	 mov	 DWORD PTR [rdx+rcx-156], r8d

; 635  : 		}

  0003d	48 83 c1 80	 add	 rcx, -128		; ffffffffffffff80H
  00041	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00046	48 8d 4b 88	 lea	 rcx, QWORD PTR [rbx-120]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5b		 pop	 rbx
  0004f	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
_TEXT	SEGMENT
$T7 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 590  : 		{	// construct empty character buffer

$LN59:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T7[rsp], -2
  00018	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  0001d	48 8b f9	 mov	 rdi, rcx
  00020	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00028	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0002f	48 89 01	 mov	 QWORD PTR [rcx], rax
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00039	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0003d	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0004a	90		 npad	 1
  0004b	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	typedef typename allocator_traits<allocator_type>::pointer _Ptrty;
; 350  : 
; 351  : 	enum
; 352  : 		{	// constant for minimum buffer size
; 353  : 		_MINSIZE = 32};
; 354  : 
; 355  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 356  : 		{	// convert open mode to stream state bits
; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);
; 367  : 		}
; 368  : 
; 369  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 370  : 	_Strstate _Mystate;	// the stream state
; 371  : 	allocator_type _Al;	// the allocator object
; 372  : 	};
; 373  : 
; 374  : template<class _Elem,
; 375  : 	class _Traits,
; 376  : 	class _Alloc> inline
; 377  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 378  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 379  : 	{	// swap _Left and _Right basic_stringbufs
; 380  : 	_Left.swap(_Right);
; 381  : 	}
; 382  : 
; 383  : 		// CLASS TEMPLATE basic_istringstream
; 384  : template<class _Elem,
; 385  : 	class _Traits,
; 386  : 	class _Alloc>
; 387  : 	class basic_istringstream
; 388  : 		: public basic_istream<_Elem, _Traits>
; 389  : 	{	// input stream associated with a character array
; 390  : public:
; 391  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 392  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 393  : 	typedef _Alloc allocator_type;
; 394  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 395  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 396  : 
; 397  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 398  : 		: _Mybase(&_Stringbuffer),
; 399  : 			_Stringbuffer(_Mode | ios_base::in)
; 400  : 		{	// construct empty readable character buffer
; 401  : 		}
; 402  : 
; 403  : 	explicit basic_istringstream(const _Mystr& _Str,
; 404  : 		ios_base::openmode _Mode = ios_base::in)
; 405  : 		: _Mybase(&_Stringbuffer),
; 406  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 407  : 		{	// construct readable character buffer from NTCS
; 408  : 		}
; 409  : 
; 410  : 	basic_istringstream(_Myt&& _Right)
; 411  : 		: _Mybase(&_Stringbuffer)
; 412  : 		{	// construct by moving _Right
; 413  : 		_Assign_rv(_STD move(_Right));
; 414  : 		}
; 415  : 
; 416  : 	_Myt& operator=(_Myt&& _Right)
; 417  : 		{	// move from _Right
; 418  : 		_Assign_rv(_STD move(_Right));
; 419  : 		return (*this);
; 420  : 		}
; 421  : 
; 422  : 	void _Assign_rv(_Myt&& _Right)
; 423  : 		{	// assign by moving _Right
; 424  : 		if (this != _STD addressof(_Right))
; 425  : 			{	// different, worth moving
; 426  : 			_Stringbuffer.str(_Mystr());
; 427  : 			this->swap(_Right);
; 428  : 			}
; 429  : 		}
; 430  : 
; 431  : 	void swap(_Myt& _Right)
; 432  : 		{	// swap with _Right
; 433  : 		if (this != _STD addressof(_Right))
; 434  : 			{	// different, swap base and buffer
; 435  : 			_Mybase::swap(_Right);
; 436  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 437  : 			}
; 438  : 		}
; 439  : 
; 440  : 	basic_istringstream(const _Myt&) = delete;
; 441  : 	_Myt& operator=(const _Myt&) = delete;
; 442  : 
; 443  : 	virtual ~basic_istringstream() _NOEXCEPT
; 444  : 		{	// destroy the object
; 445  : 		}
; 446  : 
; 447  : 	_Mysb *rdbuf() const
; 448  : 		{	// return pointer to file buffer
; 449  : 		return ((_Mysb *)&_Stringbuffer);
; 450  : 		}
; 451  : 
; 452  : 	_Mystr str() const
; 453  : 		{	// return string copy of character array
; 454  : 		return (_Stringbuffer.str());
; 455  : 		}
; 456  : 
; 457  : 	void str(const _Mystr& _Newstr)
; 458  : 		{	// replace character array from string
; 459  : 		_Stringbuffer.str(_Newstr);
; 460  : 		}
; 461  : 
; 462  : private:
; 463  : 	_Mysb _Stringbuffer;	// the string buffer
; 464  : 	};
; 465  : 
; 466  : template<class _Elem,
; 467  : 	class _Traits,
; 468  : 	class _Alloc> inline
; 469  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 470  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 471  : 	{	// swap _Left and _Right basic_istringstreams
; 472  : 	_Left.swap(_Right);
; 473  : 	}
; 474  : 
; 475  : 		// CLASS TEMPLATE basic_ostringstream
; 476  : template<class _Elem,
; 477  : 	class _Traits,
; 478  : 	class _Alloc>
; 479  : 	class basic_ostringstream
; 480  : 		: public basic_ostream<_Elem, _Traits>
; 481  : 	{	// output stream associated with a character array
; 482  : public:
; 483  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 484  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 485  : 	typedef _Alloc allocator_type;
; 486  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 487  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 488  : 
; 489  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 490  : 		: _Mybase(&_Stringbuffer),
; 491  : 			_Stringbuffer(_Mode | ios_base::out)
; 492  : 		{	// construct empty writable character buffer
; 493  : 		}
; 494  : 
; 495  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 496  : 		ios_base::openmode _Mode = ios_base::out)
; 497  : 		: _Mybase(&_Stringbuffer),
; 498  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 499  : 		{	// construct writable character buffer from NTCS
; 500  : 		}
; 501  : 
; 502  : 	basic_ostringstream(_Myt&& _Right)
; 503  : 		: _Mybase(&_Stringbuffer)
; 504  : 		{	// construct by moving _Right
; 505  : 		_Assign_rv(_STD move(_Right));
; 506  : 		}
; 507  : 
; 508  : 	_Myt& operator=(_Myt&& _Right)
; 509  : 		{	// move from _Right
; 510  : 		_Assign_rv(_STD move(_Right));
; 511  : 		return (*this);
; 512  : 		}
; 513  : 
; 514  : 	void _Assign_rv(_Myt&& _Right)
; 515  : 		{	// assign by moving _Right
; 516  : 		if (this != _STD addressof(_Right))
; 517  : 			{	// different, worth moving
; 518  : 			_Stringbuffer.str(_Mystr());
; 519  : 			this->swap(_Right);
; 520  : 			}
; 521  : 		}
; 522  : 
; 523  : 	void swap(_Myt& _Right)
; 524  : 		{	// swap with _Right
; 525  : 		if (this != _STD addressof(_Right))
; 526  : 			{	// different, swap base and buffer
; 527  : 			_Mybase::swap(_Right);
; 528  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 529  : 			}
; 530  : 		}
; 531  : 
; 532  : 	basic_ostringstream(const _Myt&) = delete;
; 533  : 	_Myt& operator=(const _Myt&) = delete;
; 534  : 
; 535  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 536  : 		{	// destroy the object
; 537  : 		}
; 538  : 
; 539  : 	_Mysb *rdbuf() const
; 540  : 		{	// return pointer to buffer
; 541  : 		return ((_Mysb *)&_Stringbuffer);
; 542  : 		}
; 543  : 
; 544  : 	_Mystr str() const
; 545  : 		{	// return string copy of character array
; 546  : 		return (_Stringbuffer.str());
; 547  : 		}
; 548  : 
; 549  : 	void str(const _Mystr& _Newstr)
; 550  : 		{	// replace character array from string
; 551  : 		_Stringbuffer.str(_Newstr);
; 552  : 		}
; 553  : 
; 554  : private:
; 555  : 	_Mysb _Stringbuffer;	// the string buffer
; 556  : 	};
; 557  : 
; 558  : template<class _Elem,
; 559  : 	class _Traits,
; 560  : 	class _Alloc> inline
; 561  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 562  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 563  : 	{	// swap _Left and _Right basic_ostringstreams
; 564  : 	_Left.swap(_Right);
; 565  : 	}
; 566  : 
; 567  : 		// CLASS TEMPLATE basic_stringstream
; 568  : template<class _Elem,
; 569  : 	class _Traits,
; 570  : 	class _Alloc>
; 571  : 	class basic_stringstream
; 572  : 		: public basic_iostream<_Elem, _Traits>
; 573  : 	{	// input/output stream associated with a character array
; 574  : public:
; 575  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 576  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 577  : 	typedef _Elem char_type;
; 578  : 	typedef _Traits traits_type;
; 579  : 	typedef _Alloc allocator_type;
; 580  : 	typedef typename _Traits::int_type int_type;
; 581  : 	typedef typename _Traits::pos_type pos_type;
; 582  : 	typedef typename _Traits::off_type off_type;
; 583  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 584  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 585  : 
; 586  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 587  : 		ios_base::in | ios_base::out)
; 588  : 		: _Mybase(&_Stringbuffer),

  00053	48 8d 5f 18	 lea	 rbx, QWORD PTR [rdi+24]
  00057	45 33 c0	 xor	 r8d, r8d
  0005a	48 8b d3	 mov	 rdx, rbx
  0005d	48 8b cf	 mov	 rcx, rdi
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00066	90		 npad	 1

; 590  : 		{	// construct empty character buffer

  00067	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0006a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00075	48 89 04 39	 mov	 QWORD PTR [rcx+rdi], rax
  00079	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0007c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00080	8d 91 68 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-152]
  00086	89 54 39 fc	 mov	 DWORD PTR [rcx+rdi-4], edx

; 589  : 			_Stringbuffer(_Mode)

  0008a	48 89 5c 24 58	 mov	 QWORD PTR this$[rsp], rbx

; 30   : 		{	// construct empty character buffer from mode

  0008f	48 8b cb	 mov	 rcx, rbx
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00098	90		 npad	 1
  00099	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  000a0	48 89 03	 mov	 QWORD PTR [rbx], rax

; 311  : 		_Seekhigh = 0;

  000a3	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 312  : 		_Mystate = _State;

  000ab	c7 43 70 00 00
	00 00		 mov	 DWORD PTR [rbx+112], 0

; 591  : 		}

  000b2	48 8b c7	 mov	 rax, rdi
  000b5	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T7 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 50	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 50 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
$T7 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  0002e	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00035	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
$T7 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
  00040	48 8b 8a 58 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T7 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 50	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 50 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T7 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  0002e	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00035	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T7 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
  00040	48 8b 8a 58 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Ptr$ = 24
_Mode$ = 32
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT

; 276  : 		{	// change position to _Pos, according to _Mode

$LN57:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 63   : 		return (_Myoff + _Fpos);

  00005	4d 8b 50 08	 mov	 r10, QWORD PTR [r8+8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

  00009	48 8b da	 mov	 rbx, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  0000c	48 8b 51 40	 mov	 rdx, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

  00010	4c 8b d9	 mov	 r11, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 63   : 		return (_Myoff + _Fpos);

  00013	4d 03 10	 add	 r10, QWORD PTR [r8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00016	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00019	48 85 c0	 test	 rax, rax
  0001c	74 0a		 je	 SHORT $LN2@seekpos
  0001e	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  00022	73 04		 jae	 SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00024	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
  0002f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00032	4c 3b d1	 cmp	 r10, rcx
  00035	0f 84 b9 00 00
	00		 je	 $LN11@seekpos

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  0003b	41 f6 c1 01	 test	 r9b, 1
  0003f	74 72		 je	 SHORT $LN5@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00041	49 8b 43 38	 mov	 rax, QWORD PTR [r11+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  00045	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00048	4d 85 c0	 test	 r8, r8
  0004b	74 66		 je	 SHORT $LN5@seekpos

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0004d	4d 85 d2	 test	 r10, r10
  00050	0f 88 9b 00 00
	00		 js	 $LN10@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00056	49 8b 43 18	 mov	 rax, QWORD PTR [r11+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0005a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0005d	49 8b 43 68	 mov	 rax, QWORD PTR [r11+104]
  00061	48 2b c2	 sub	 rax, rdx
  00064	4c 3b d0	 cmp	 r10, rax
  00067	0f 8f 84 00 00
	00		 jg	 $LN10@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 246  : 		*_IGcount -= _Off;

  0006d	49 8b 43 50	 mov	 rax, QWORD PTR [r11+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  00071	41 2b d0	 sub	 edx, r8d
  00074	41 03 d2	 add	 edx, r10d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 246  : 		*_IGcount -= _Off;

  00077	29 10		 sub	 DWORD PTR [rax], edx

; 247  : 		*_IGnext += _Off;

  00079	49 8b 4b 38	 mov	 rcx, QWORD PTR [r11+56]
  0007d	48 63 c2	 movsxd	 rax, edx
  00080	48 01 01	 add	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  00083	41 f6 c1 02	 test	 r9b, 2
  00087	74 6b		 je	 SHORT $LN11@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00089	4d 8b 43 40	 mov	 r8, QWORD PTR [r11+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  0008d	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  00090	48 85 c9	 test	 rcx, rcx
  00093	74 5f		 je	 SHORT $LN11@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00095	49 8b 43 58	 mov	 rax, QWORD PTR [r11+88]
  00099	48 63 10	 movsxd	 rdx, DWORD PTR [rax]

; 226  : 		return (*_IGnext);

  0009c	49 8b 43 38	 mov	 rax, QWORD PTR [r11+56]

; 259  : 		return (*_IPnext + *_IPcount);

  000a0	48 03 d1	 add	 rdx, rcx

; 226  : 		return (*_IGnext);

  000a3	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 301  : 		*_IPnext = _Next;

  000a6	49 89 08	 mov	 QWORD PTR [r8], rcx

; 302  : 		*_IPcount = (int)(_Last - _Next);

  000a9	2b d1		 sub	 edx, ecx
  000ab	49 8b 43 58	 mov	 rax, QWORD PTR [r11+88]
  000af	89 10		 mov	 DWORD PTR [rax], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 293  : 				_Off = _BADOFF;

  000b1	eb 41		 jmp	 SHORT $LN11@seekpos
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  000b3	41 f6 c1 02	 test	 r9b, 2
  000b7	74 38		 je	 SHORT $LN10@seekpos
  000b9	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
  000bc	4d 85 c0	 test	 r8, r8
  000bf	74 30		 je	 SHORT $LN10@seekpos

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000c1	4d 85 d2	 test	 r10, r10
  000c4	78 2b		 js	 SHORT $LN10@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  000c6	49 8b 43 18	 mov	 rax, QWORD PTR [r11+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000ca	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000cd	49 8b 43 68	 mov	 rax, QWORD PTR [r11+104]
  000d1	48 2b c2	 sub	 rax, rdx
  000d4	4c 3b d0	 cmp	 r10, rax
  000d7	7f 18		 jg	 SHORT $LN10@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 287  : 		*_IPcount -= _Off;

  000d9	49 8b 43 58	 mov	 rax, QWORD PTR [r11+88]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000dd	41 2b d0	 sub	 edx, r8d
  000e0	41 03 d2	 add	 edx, r10d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 287  : 		*_IPcount -= _Off;

  000e3	29 10		 sub	 DWORD PTR [rax], edx

; 288  : 		*_IPnext += _Off;

  000e5	49 8b 4b 40	 mov	 rcx, QWORD PTR [r11+64]
  000e9	48 63 c2	 movsxd	 rax, edx
  000ec	48 01 01	 add	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 300  : 			else

  000ef	eb 03		 jmp	 SHORT $LN11@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  000f1	4c 8b d1	 mov	 r10, rcx
$LN11@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  000f4	33 c0		 xor	 eax, eax
  000f6	4c 89 13	 mov	 QWORD PTR [rbx], r10
  000f9	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
  00101	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 305  : 		return (streampos(_Off));

  00105	48 8b c3	 mov	 rax, rbx

; 306  : 		}

  00108	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0010d	c3		 ret	 0
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$ = 24
_Way$ = 32
_Which$ = 40
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT

; 227  : 		{	// change position by _Off, according to _Way, _Mode

$LN77:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0000a	4c 8b d1	 mov	 r10, rcx
  0000d	45 8b d9	 mov	 r11d, r9d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00010	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 227  : 		{	// change position by _Off, according to _Way, _Mode

  00014	48 8b fa	 mov	 rdi, rdx

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00017	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001a	48 85 c0	 test	 rax, rax
  0001d	74 0a		 je	 SHORT $LN2@seekoff
  0001f	49 39 42 68	 cmp	 QWORD PTR [r10+104], rax
  00023	73 04		 jae	 SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00025	49 89 42 68	 mov	 QWORD PTR [r10+104], rax
$LN2@seekoff:

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  00029	8b 5c 24 28	 mov	 ebx, DWORD PTR _Which$[rsp]
  0002d	f6 c3 01	 test	 bl, 1
  00030	0f 84 c7 00 00
	00		 je	 $LN3@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00036	49 8b 42 38	 mov	 rax, QWORD PTR [r10+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  0003a	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  0003d	4d 85 c9	 test	 r9, r9
  00040	0f 84 b7 00 00
	00		 je	 $LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

  00046	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_?_BADOFF@std@@3_JB
  0004d	41 83 fb 02	 cmp	 r11d, 2
  00051	75 10		 jne	 SHORT $LN5@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00053	49 8b 42 18	 mov	 rax, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  00057	49 8b 4a 68	 mov	 rcx, QWORD PTR [r10+104]
  0005b	48 2b 08	 sub	 rcx, QWORD PTR [rax]
  0005e	4c 03 c1	 add	 r8, rcx

; 235  : 			else if (_Way == ios_base::cur

  00061	eb 28		 jmp	 SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

  00063	41 8b c1	 mov	 eax, r9d
  00066	41 83 fb 01	 cmp	 r11d, 1
  0006a	75 14		 jne	 SHORT $LN74@seekoff
  0006c	f6 c3 02	 test	 bl, 2
  0006f	75 14		 jne	 SHORT $LN75@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00071	49 8b 42 18	 mov	 rax, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

  00075	49 8b c9	 mov	 rcx, r9
  00078	48 2b 08	 sub	 rcx, QWORD PTR [rax]
  0007b	4c 03 c1	 add	 r8, rcx
  0007e	eb 0b		 jmp	 SHORT $LN9@seekoff
$LN74@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

  00080	45 85 db	 test	 r11d, r11d
  00083	74 06		 je	 SHORT $LN9@seekoff
$LN75@seekoff:

; 239  : 				_Off = _BADOFF;

  00085	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
  00088	44 8b c8	 mov	 r9d, eax
$LN9@seekoff:

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0008b	4d 85 c0	 test	 r8, r8
  0008e	0f 88 e2 00 00
	00		 js	 $LN20@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00094	49 8b 42 18	 mov	 rax, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00098	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0009b	49 8b 42 68	 mov	 rax, QWORD PTR [r10+104]
  0009f	48 2b c1	 sub	 rax, rcx
  000a2	4c 3b c0	 cmp	 r8, rax
  000a5	0f 8f cb 00 00
	00		 jg	 $LN20@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 246  : 		*_IGcount -= _Off;

  000ab	49 8b 42 50	 mov	 rax, QWORD PTR [r10+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  000af	41 8b d0	 mov	 edx, r8d
  000b2	41 2b d1	 sub	 edx, r9d
  000b5	03 d1		 add	 edx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 246  : 		*_IGcount -= _Off;

  000b7	29 10		 sub	 DWORD PTR [rax], edx

; 247  : 		*_IGnext += _Off;

  000b9	49 8b 4a 38	 mov	 rcx, QWORD PTR [r10+56]
  000bd	48 63 c2	 movsxd	 rax, edx
  000c0	48 01 01	 add	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000c3	f6 c3 02	 test	 bl, 2
  000c6	0f 84 be 00 00
	00		 je	 $LN22@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  000cc	4d 8b 4a 40	 mov	 r9, QWORD PTR [r10+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000d0	49 8b 09	 mov	 rcx, QWORD PTR [r9]
  000d3	48 85 c9	 test	 rcx, rcx
  000d6	0f 84 ae 00 00
	00		 je	 $LN22@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  000dc	49 8b 42 58	 mov	 rax, QWORD PTR [r10+88]
  000e0	48 63 10	 movsxd	 rdx, DWORD PTR [rax]

; 226  : 		return (*_IGnext);

  000e3	49 8b 42 38	 mov	 rax, QWORD PTR [r10+56]

; 259  : 		return (*_IPnext + *_IPcount);

  000e7	48 03 d1	 add	 rdx, rcx

; 226  : 		return (*_IGnext);

  000ea	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 301  : 		*_IPnext = _Next;

  000ed	49 89 09	 mov	 QWORD PTR [r9], rcx

; 302  : 		*_IPcount = (int)(_Last - _Next);

  000f0	2b d1		 sub	 edx, ecx
  000f2	49 8b 42 58	 mov	 rax, QWORD PTR [r10+88]
  000f6	89 10		 mov	 DWORD PTR [rax], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 248  : 			else

  000f8	e9 8d 00 00 00	 jmp	 $LN22@seekoff
$LN3@seekoff:

; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000fd	f6 c3 02	 test	 bl, 2
  00100	74 79		 je	 SHORT $LN13@seekoff
  00102	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00105	4d 85 c9	 test	 r9, r9
  00108	74 71		 je	 SHORT $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

  0010a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_?_BADOFF@std@@3_JB
  00111	41 83 fb 02	 cmp	 r11d, 2
  00115	75 10		 jne	 SHORT $LN15@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00117	49 8b 42 18	 mov	 rax, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  0011b	49 8b 4a 68	 mov	 rcx, QWORD PTR [r10+104]
  0011f	48 2b 08	 sub	 rcx, QWORD PTR [rax]
  00122	4c 03 c1	 add	 r8, rcx
  00125	eb 1d		 jmp	 SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

  00127	41 83 fb 01	 cmp	 r11d, 1
  0012b	75 0f		 jne	 SHORT $LN17@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0012d	49 8b 42 18	 mov	 rax, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

  00131	49 8b c9	 mov	 rcx, r9
  00134	48 2b 08	 sub	 rcx, QWORD PTR [rax]
  00137	4c 03 c1	 add	 r8, rcx
  0013a	eb 08		 jmp	 SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

  0013c	45 85 db	 test	 r11d, r11d
  0013f	74 03		 je	 SHORT $LN19@seekoff

; 258  : 				_Off = _BADOFF;

  00141	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
$LN19@seekoff:

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00144	4d 85 c0	 test	 r8, r8
  00147	78 2d		 js	 SHORT $LN20@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00149	49 8b 42 18	 mov	 rax, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0014d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00150	49 8b 42 68	 mov	 rax, QWORD PTR [r10+104]
  00154	48 2b c1	 sub	 rax, rcx
  00157	4c 3b c0	 cmp	 r8, rax
  0015a	7f 1a		 jg	 SHORT $LN20@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 287  : 		*_IPcount -= _Off;

  0015c	49 8b 42 58	 mov	 rax, QWORD PTR [r10+88]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

  00160	41 8b d0	 mov	 edx, r8d
  00163	41 2b d1	 sub	 edx, r9d
  00166	03 d1		 add	 edx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 287  : 		*_IPcount -= _Off;

  00168	29 10		 sub	 DWORD PTR [rax], edx

; 288  : 		*_IPnext += _Off;

  0016a	49 8b 4a 40	 mov	 rcx, QWORD PTR [r10+64]
  0016e	48 63 c2	 movsxd	 rax, edx
  00171	48 01 01	 add	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 263  : 			else

  00174	eb 14		 jmp	 SHORT $LN22@seekoff
$LN20@seekoff:

; 264  : 				_Off = _BADOFF;

  00176	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
  00179	eb 0f		 jmp	 SHORT $LN22@seekoff
$LN13@seekoff:

; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

  0017b	4d 85 c0	 test	 r8, r8
  0017e	74 0a		 je	 SHORT $LN22@seekoff

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  00180	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
  00187	4c 8b 00	 mov	 r8, QWORD PTR [rax]
$LN22@seekoff:

; 272  : 		}

  0018a	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  0018f	33 c0		 xor	 eax, eax
  00191	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00194	48 c7 47 08 00
	00 00 00	 mov	 QWORD PTR [rdi+8], 0
  0019c	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 271  : 		return (pos_type(_Off));

  001a0	48 8b c7	 mov	 rax, rdi

; 272  : 		}

  001a3	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  001a8	c3		 ret	 0
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 8
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00000	4c 8b 49 38	 mov	 r9, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 208  : 		if (_Mysb::gptr() == 0)

  00004	49 8b 11	 mov	 rdx, QWORD PTR [r9]
  00007	48 85 d2	 test	 rdx, rdx
  0000a	74 53		 je	 SHORT $LN8@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0000c	4c 8b 51 50	 mov	 r10, QWORD PTR [rcx+80]
  00010	49 63 02	 movsxd	 rax, DWORD PTR [r10]
  00013	48 03 c2	 add	 rax, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

  00016	48 3b d0	 cmp	 rdx, rax
  00019	73 04		 jae	 SHORT $LN4@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  0001b	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 222  : 		}

  0001e	c3		 ret	 0
$LN4@underflow:

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  0001f	f6 41 70 04	 test	 BYTE PTR [rcx+112], 4
  00023	75 3a		 jne	 SHORT $LN8@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00025	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  00029	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0002c	4d 85 c0	 test	 r8, r8
  0002f	74 2e		 je	 SHORT $LN8@underflow
  00031	4c 3b c2	 cmp	 r8, rdx
  00034	77 06		 ja	 SHORT $LN52@underflow
  00036	48 39 51 68	 cmp	 QWORD PTR [rcx+104], rdx
  0003a	76 23		 jbe	 SHORT $LN8@underflow
$LN52@underflow:

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

  0003c	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  00040	49 3b c0	 cmp	 rax, r8
  00043	73 0a		 jae	 SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

  00045	4c 89 41 68	 mov	 QWORD PTR [rcx+104], r8
  00049	41 8b c0	 mov	 eax, r8d
  0004c	49 8b 11	 mov	 rdx, QWORD PTR [r9]
$LN9@underflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  0004f	2b c2		 sub	 eax, edx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00051	41 89 02	 mov	 DWORD PTR [r10], eax

; 226  : 		return (*_IGnext);

  00054	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00058	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 462  : 		return (static_cast<unsigned char>(_Ch));

  0005b	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 222  : 		}

  0005e	c3		 ret	 0
$LN8@underflow:

; 214  : 			return (_Traits::eof());	// can't read, fail

  0005f	83 c8 ff	 or	 eax, -1

; 222  : 		}

  00062	c3		 ret	 0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 8
_Meta$ = 16
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00000	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00004	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00007	4d 85 c0	 test	 r8, r8
  0000a	74 40		 je	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0000c	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00010	4c 3b 00	 cmp	 r8, QWORD PTR [rax]
  00013	76 37		 jbe	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  00015	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00018	74 0c		 je	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 447  : 		return (_Left == _Right);

  0001a	41 3a 50 ff	 cmp	 dl, BYTE PTR [r8-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001e	74 06		 je	 SHORT $LN2@pbackfail
  00020	f6 41 70 02	 test	 BYTE PTR [rcx+112], 2
  00024	75 26		 jne	 SHORT $LN4@pbackfail
$LN2@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 246  : 		*_IGcount -= _Off;

  00026	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
  0002a	ff 00		 inc	 DWORD PTR [rax]

; 247  : 		*_IGnext += _Off;

  0002c	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00030	48 ff 08	 dec	 QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  00033	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

  00036	74 09		 je	 SHORT $LN5@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00038	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0003c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

  0003f	88 11		 mov	 BYTE PTR [rcx], dl
$LN5@pbackfail:

; 202  : 			return (_Traits::not_eof(_Meta));

  00041	33 c0		 xor	 eax, eax
  00043	83 fa ff	 cmp	 edx, -1
  00046	0f 44 d0	 cmove	 edx, eax
  00049	8b c2		 mov	 eax, edx

; 203  : 			}
; 204  : 		}

  0004b	c3		 ret	 0
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

  0004c	83 c8 ff	 or	 eax, -1

; 203  : 			}
; 204  : 		}

  0004f	c3		 ret	 0
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 80
_Meta$ = 88
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT

; 120  : 		{	// put an element to stream

$LN171:
  00000	40 53		 push	 rbx
  00002	41 56		 push	 r14
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 121  : 		if (_Mystate & _Constant)

  00008	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0000b	44 8b f2	 mov	 r14d, edx
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	a8 02		 test	 al, 2
  00013	74 0b		 je	 SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

  00015	83 c8 ff	 or	 eax, -1

; 187  : 		}

  00018	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001c	41 5e		 pop	 r14
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
$LN4@overflow:
  00020	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00025	41 83 fe ff	 cmp	 r14d, -1
  00029	75 1a		 jne	 SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  0002b	45 33 e4	 xor	 r12d, r12d
  0002e	45 3b f6	 cmp	 r14d, r14d
  00031	45 0f 44 f4	 cmove	 r14d, r12d
  00035	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]
  0003a	41 8b c6	 mov	 eax, r14d

; 187  : 		}

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	41 5e		 pop	 r14
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN6@overflow:

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  00045	a8 08		 test	 al, 8
  00047	74 2b		 je	 SHORT $LN7@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00049	4c 8b 49 40	 mov	 r9, QWORD PTR [rcx+64]
  0004d	49 8b 11	 mov	 rdx, QWORD PTR [r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  00050	48 85 d2	 test	 rdx, rdx
  00053	74 1f		 je	 SHORT $LN7@overflow
  00055	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  00059	49 3b d0	 cmp	 rdx, r8
  0005c	73 16		 jae	 SHORT $LN7@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  0005e	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00062	48 63 08	 movsxd	 rcx, DWORD PTR [rax]

; 301  : 		*_IPnext = _Next;

  00065	4d 89 01	 mov	 QWORD PTR [r9], r8

; 259  : 		return (*_IPnext + *_IPcount);

  00068	48 03 ca	 add	 rcx, rdx

; 302  : 		*_IPcount = (int)(_Last - _Next);

  0006b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0006f	41 2b c8	 sub	 ecx, r8d
  00072	89 08		 mov	 DWORD PTR [rax], ecx
$LN7@overflow:

; 236  : 		return (*_IPnext);

  00074	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00078	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  0007b	48 85 c9	 test	 rcx, rcx
  0007e	74 37		 je	 SHORT $LN150@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00080	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  00084	4c 63 02	 movsxd	 r8, DWORD PTR [rdx]
  00087	4a 8d 04 01	 lea	 rax, QWORD PTR [rcx+r8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  0008b	48 3b c8	 cmp	 rcx, rax
  0008e	73 27		 jae	 SHORT $LN150@overflow
  00090	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 307  : 		--*_IPcount;

  00095	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00099	89 02		 mov	 DWORD PTR [rdx], eax

; 308  : 		return ((*_IPnext)++);

  0009b	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0009f	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  000a2	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  000a6	48 89 01	 mov	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 134  : 			return (_Meta);

  000a9	41 8b c6	 mov	 eax, r14d
  000ac	44 88 32	 mov	 BYTE PTR [rdx], r14b

; 187  : 		}

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	41 5e		 pop	 r14
  000b5	5b		 pop	 rbx
  000b6	c3		 ret	 0
$LN150@overflow:

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

  000b7	45 33 e4	 xor	 r12d, r12d
  000ba	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  000bf	48 85 c9	 test	 rcx, rcx
  000c2	75 05		 jne	 SHORT $LN20@overflow
  000c4	41 8b fc	 mov	 edi, r12d
  000c7	eb 11		 jmp	 SHORT $LN21@overflow
$LN20@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  000c9	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000cd	48 63 38	 movsxd	 rdi, DWORD PTR [rax]

; 221  : 		return (*_IGfirst);

  000d0	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 259  : 		return (*_IPnext + *_IPcount);

  000d4	48 03 f9	 add	 rdi, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

  000d7	48 2b 38	 sub	 rdi, QWORD PTR [rax]
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

  000da	48 8b cf	 mov	 rcx, rdi
  000dd	48 d1 e9	 shr	 rcx, 1
  000e0	48 83 f9 20	 cmp	 rcx, 32			; 00000020H
  000e4	73 07		 jae	 SHORT $LN22@overflow
  000e6	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000eb	eb 05		 jmp	 SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000ed	48 85 c9	 test	 rcx, rcx
  000f0	74 17		 je	 SHORT $LN166@overflow
$LL2@overflow:
  000f2	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000f7	48 2b c1	 sub	 rax, rcx
  000fa	48 3b c7	 cmp	 rax, rdi
  000fd	73 05		 jae	 SHORT $LN157@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

  000ff	48 d1 e9	 shr	 rcx, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  00102	75 ee		 jne	 SHORT $LL2@overflow
$LN157@overflow:

; 146  : 			if (_Inc == 0)

  00104	48 85 c9	 test	 rcx, rcx
  00107	75 15		 jne	 SHORT $LN10@overflow
$LN166@overflow:
  00109	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

  0010e	83 c8 ff	 or	 eax, -1
  00111	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]

; 187  : 		}

  00116	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011a	41 5e		 pop	 r14
  0011c	5b		 pop	 rbx
  0011d	c3		 ret	 0
$LN10@overflow:
  0011e	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00123	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 148  : 
; 149  : 			_Newsize += _Inc;

  00128	4c 8d 3c 39	 lea	 r15, QWORD PTR [rcx+rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0012c	4d 85 ff	 test	 r15, r15
  0012f	75 05		 jne	 SHORT $LN78@overflow

; 79   : 		{
; 80   : 		return (nullptr);

  00131	49 8b ec	 mov	 rbp, r12
  00134	eb 34		 jmp	 SHORT $LN76@overflow
$LN78@overflow:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00136	49 81 ff 00 10
	00 00		 cmp	 r15, 4096		; 00001000H
  0013d	72 20		 jb	 SHORT $LN79@overflow

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  0013f	49 8d 4f 27	 lea	 rcx, QWORD PTR [r15+39]

; 117  : 			if (_Block_size <= _User_size)

  00143	49 3b cf	 cmp	 rcx, r15
  00146	0f 86 99 01 00
	00		 jbe	 $LN169@overflow

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0014c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00151	48 8d 68 27	 lea	 rbp, QWORD PTR [rax+39]
  00155	48 83 e5 e0	 and	 rbp, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00159	48 89 45 f8	 mov	 QWORD PTR [rbp-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  0015d	eb 0b		 jmp	 SHORT $LN76@overflow
$LN79@overflow:

; 67   : 			_Ptr = ::operator new(_Bytes);

  0015f	49 8b cf	 mov	 rcx, r15
  00162	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00167	48 8b e8	 mov	 rbp, rax
$LN76@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0016a	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  0016e	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00173	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 154  : 			if (0 < _Oldsize)

  00176	48 85 ff	 test	 rdi, rdi
  00179	74 13		 je	 SHORT $LN168@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0017b	4c 8b c7	 mov	 r8, rdi
  0017e	48 8b d6	 mov	 rdx, rsi
  00181	48 8b cd	 mov	 rcx, rbp
  00184	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 157  : 			if (_Oldsize == 0)

  00189	48 85 ff	 test	 rdi, rdi
  0018c	75 4c		 jne	 SHORT $LN12@overflow
$LN168@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 293  : 		*_IPfirst = _First;

  0018e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 159  : 				_Seekhigh = _Newptr;

  00192	48 89 6b 68	 mov	 QWORD PTR [rbx+104], rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 293  : 		*_IPfirst = _First;

  00196	48 89 28	 mov	 QWORD PTR [rax], rbp

; 294  : 		*_IPnext = _First;

  00199	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  0019d	48 89 28	 mov	 QWORD PTR [rax], rbp

; 295  : 		*_IPcount = (int)(_Last - _First);

  001a0	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001a4	44 89 38	 mov	 DWORD PTR [rax], r15d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 161  : 				if (_Mystate & _Noread)

  001a7	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  001ab	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  001ae	48 89 28	 mov	 QWORD PTR [rax], rbp
  001b1	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  001b5	83 e1 04	 and	 ecx, 4
  001b8	74 0e		 je	 SHORT $LN14@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 253  : 		*_IGnext = _Next;

  001ba	4c 89 20	 mov	 QWORD PTR [rax], r12

; 254  : 		*_IGcount = (int)(_Last - _Next);

  001bd	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001c1	89 28		 mov	 DWORD PTR [rax], ebp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 163  : 				else

  001c3	e9 92 00 00 00	 jmp	 $LN17@overflow
$LN14@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 253  : 		*_IGnext = _Next;

  001c8	48 89 28	 mov	 QWORD PTR [rax], rbp

; 254  : 		*_IGcount = (int)(_Last - _Next);

  001cb	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001cf	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 166  : 			else

  001d5	e9 80 00 00 00	 jmp	 $LN17@overflow
$LN12@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 231  : 		return (*_IPfirst);

  001da	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

  001de	48 8b c5	 mov	 rax, rbp
  001e1	48 2b c6	 sub	 rax, rsi
  001e4	48 01 43 68	 add	 QWORD PTR [rbx+104], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  001e8	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  001ec	48 8b 10	 mov	 rdx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  001ef	48 8b c5	 mov	 rax, rbp
  001f2	48 2b c6	 sub	 rax, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  001f5	48 2b d6	 sub	 rdx, rsi

; 300  : 		*_IPfirst = _First;

  001f8	48 01 01	 add	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  001fb	48 03 d5	 add	 rdx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 301  : 		*_IPnext = _Next;

  001fe	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]

; 302  : 		*_IPcount = (int)(_Last - _Next);

  00202	8b cd		 mov	 ecx, ebp
  00204	2b ca		 sub	 ecx, edx
  00206	41 03 cf	 add	 ecx, r15d
  00209	48 89 10	 mov	 QWORD PTR [rax], rdx
  0020c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00210	89 08		 mov	 DWORD PTR [rax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 172  : 				if (_Mystate & _Noread)

  00212	f6 43 70 04	 test	 BYTE PTR [rbx+112], 4
  00216	74 16		 je	 SHORT $LN16@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00218	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0021c	48 89 28	 mov	 QWORD PTR [rax], rbp

; 253  : 		*_IGnext = _Next;

  0021f	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00223	4c 89 20	 mov	 QWORD PTR [rax], r12

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00226	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0022a	89 28		 mov	 DWORD PTR [rax], ebp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 174  : 				else

  0022c	eb 2c		 jmp	 SHORT $LN17@overflow
$LN16@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  0022e	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00232	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 226  : 		return (*_IGnext);

  00235	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00239	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 252  : 		*_IGfirst = _First;

  0023c	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 226  : 		return (*_IGnext);

  00240	48 2b ce	 sub	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 175  : 					_Mysb::setg(_Newptr,

  00243	48 03 cd	 add	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00246	2b d1		 sub	 edx, ecx
  00248	ff c2		 inc	 edx
  0024a	48 89 28	 mov	 QWORD PTR [rax], rbp
  0024d	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00251	48 89 08	 mov	 QWORD PTR [rax], rcx
  00254	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00258	89 10		 mov	 DWORD PTR [rax], edx
$LN17@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 180  : 			if (_Mystate & _Allocated)

  0025a	f6 43 70 01	 test	 BYTE PTR [rbx+112], 1
  0025e	74 3f		 je	 SHORT $LN123@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00260	48 81 ff 00 10
	00 00		 cmp	 rdi, 4096		; 00001000H
  00267	72 2b		 jb	 SHORT $LN126@overflow

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00269	48 8d 47 27	 lea	 rax, QWORD PTR [rdi+39]
  0026d	48 3b c7	 cmp	 rax, rdi
  00270	76 6c		 jbe	 SHORT $_Invalid_parameter$172

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00272	48 8b f8	 mov	 rdi, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00275	40 f6 c6 1f	 test	 sil, 31
  00279	75 63		 jne	 SHORT $_Invalid_parameter$172

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0027b	48 8b 46 f8	 mov	 rax, QWORD PTR [rsi-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0027f	48 3b c6	 cmp	 rax, rsi
  00282	73 5a		 jae	 SHORT $_Invalid_parameter$172

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00284	48 2b f0	 sub	 rsi, rax
  00287	48 83 ee 08	 sub	 rsi, 8
  0028b	48 83 fe 1f	 cmp	 rsi, 31
  0028f	77 4d		 ja	 SHORT $_Invalid_parameter$172

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00291	48 8b f0	 mov	 rsi, rax
$LN126@overflow:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00294	48 8b d7	 mov	 rdx, rdi
  00297	48 8b ce	 mov	 rcx, rsi
  0029a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN123@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 307  : 		--*_IPcount;

  0029f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 182  : 			_Mystate |= _Allocated;

  002a3	83 4b 70 01	 or	 DWORD PTR [rbx+112], 1
  002a7	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  002ac	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 307  : 		--*_IPcount;

  002b1	ff 08		 dec	 DWORD PTR [rax]

; 308  : 		return ((*_IPnext)++);

  002b3	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  002b7	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  002bc	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  002c1	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]
  002c6	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  002c9	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  002cd	48 89 01	 mov	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 185  : 			return (_Meta);

  002d0	41 8b c6	 mov	 eax, r14d
  002d3	44 88 32	 mov	 BYTE PTR [rdx], r14b

; 187  : 		}

  002d6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002da	41 5e		 pop	 r14
  002dc	5b		 pop	 rbx
  002dd	c3		 ret	 0
$_Invalid_parameter$172:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  002e4	cc		 int	 3
$LN169@overflow:

; 119  : 				_Traits::_Fail();	// report no memory

  002e5	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  002ea	cc		 int	 3
$LN164@overflow:
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 75   : 		{	// destroy the object

$LN50:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 338  : 		if (_Mystate & _Allocated)

  00006	f6 41 70 01	 test	 BYTE PTR [rcx+112], 1

; 75   : 		{	// destroy the object

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00011	48 89 01	 mov	 QWORD PTR [rcx], rax
  00014	48 8b d9	 mov	 rbx, rcx

; 338  : 		if (_Mystate & _Allocated)

  00017	74 68		 je	 SHORT $LN25@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00019	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  0001d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00020	48 85 c9	 test	 rcx, rcx
  00023	74 0c		 je	 SHORT $LN6@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00025	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00029	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  0002c	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  0002f	eb 0e		 jmp	 SHORT $LN7@basic_stri
$LN6@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00031	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00035	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  00038	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0003c	48 03 10	 add	 rdx, QWORD PTR [rax]
$LN7@basic_stri:

; 221  : 		return (*_IGfirst);

  0003f	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00043	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00046	48 2b d1	 sub	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00049	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00050	72 2a		 jb	 SHORT $LN28@basic_stri

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00052	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00056	48 3b c2	 cmp	 rax, rdx
  00059	76 67		 jbe	 SHORT $_Invalid_parameter$51

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0005b	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0005e	f6 c1 1f	 test	 cl, 31
  00061	75 5f		 jne	 SHORT $_Invalid_parameter$51

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00063	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00067	48 3b c1	 cmp	 rax, rcx
  0006a	73 56		 jae	 SHORT $_Invalid_parameter$51

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0006c	48 2b c8	 sub	 rcx, rax
  0006f	48 83 e9 08	 sub	 rcx, 8
  00073	48 83 f9 1f	 cmp	 rcx, 31
  00077	77 49		 ja	 SHORT $_Invalid_parameter$51

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00079	48 8b c8	 mov	 rcx, rax
$LN28@basic_stri:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0007c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN25@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00081	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00085	33 c9		 xor	 ecx, ecx
  00087	48 89 08	 mov	 QWORD PTR [rax], rcx

; 253  : 		*_IGnext = _Next;

  0008a	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0008e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00091	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00095	89 08		 mov	 DWORD PTR [rax], ecx

; 293  : 		*_IPfirst = _First;

  00097	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0009b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 294  : 		*_IPnext = _First;

  0009e	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  000a2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 295  : 		*_IPcount = (int)(_Last - _First);

  000a5	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a9	89 08		 mov	 DWORD PTR [rax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

  000ab	83 63 70 fe	 and	 DWORD PTR [rbx+112], -2
  000af	48 89 4b 68	 mov	 QWORD PTR [rbx+104], rcx

; 77   : 		}

  000b3	48 8b cb	 mov	 rcx, rbx
  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5b		 pop	 rbx
  000bb	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
$_Invalid_parameter$51:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000c8	cc		 int	 3
$LN49@basic_stri:
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
  00000	c2 00 00	 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d b9 48 ff
	ff ff		 lea	 rdi, QWORD PTR [rcx-184]
  00011	8b da		 mov	 ebx, edx
  00013	48 8b cf	 mov	 rcx, rdi
  00016	e8 00 00 00 00	 call	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	f6 c3 01	 test	 bl, 1
  0001e	74 0d		 je	 SHORT $LN4@scalar
  00020	ba 18 01 00 00	 mov	 edx, 280		; 00000118H
  00025	48 8b cf	 mov	 rcx, rdi
  00028	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  0002d	48 8b c7	 mov	 rax, rdi
  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d b9 58 ff
	ff ff		 lea	 rdi, QWORD PTR [rcx-168]
  00011	8b da		 mov	 ebx, edx
  00013	48 8b cf	 mov	 rcx, rdi
  00016	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	f6 c3 01	 test	 bl, 1
  0001e	74 0d		 je	 SHORT $LN4@scalar
  00020	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  00025	48 8b cf	 mov	 rcx, rdi
  00028	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  0002d	48 8b c7	 mov	 rax, rdi
  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d b9 50 ff
	ff ff		 lea	 rdi, QWORD PTR [rcx-176]
  00011	8b da		 mov	 ebx, edx
  00013	48 8b cf	 mov	 rcx, rdi
  00016	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	f6 c3 01	 test	 bl, 1
  0001e	74 0d		 je	 SHORT $LN4@scalar
  00020	ba 10 01 00 00	 mov	 edx, 272		; 00000110H
  00025	48 8b cf	 mov	 rcx, rdi
  00028	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  0002d	48 8b c7	 mov	 rax, rdi
  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
$T2 = 32
this$ = 64
__flags$ = 72
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN18:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	8b fa		 mov	 edi, edx
  00016	48 8b d9	 mov	 rbx, rcx

; 161  : 		{	// destroy the object

  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00020	48 89 01	 mov	 QWORD PTR [rcx], rax

; 162  : 		if (_Myfile != 0)

  00023	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0002b	74 2d		 je	 SHORT $LN10@scalar
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  0002d	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  00031	48 8d 41 70	 lea	 rax, QWORD PTR [rcx+112]
  00035	49 39 00	 cmp	 QWORD PTR [r8], rax
  00038	75 20		 jne	 SHORT $LN10@scalar

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0003a	48 8b 91 90 00
	00 00		 mov	 rdx, QWORD PTR [rcx+144]
  00041	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00048	49 89 08	 mov	 QWORD PTR [r8], rcx

; 253  : 		*_IGnext = _Next;

  0004b	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0004f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00052	2b d1		 sub	 edx, ecx
  00054	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00058	89 10		 mov	 DWORD PTR [rax], edx
$LN10@scalar:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 164  : 		if (_Closef)

  0005a	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  0005e	74 09		 je	 SHORT $LN6@scalar

; 165  : 			close();

  00060	48 8b cb	 mov	 rcx, rbx
  00063	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00068	90		 npad	 1
$LN6@scalar:

; 166  : 		}

  00069	48 8b cb	 mov	 rcx, rbx
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00072	90		 npad	 1
  00073	40 f6 c7 01	 test	 dil, 1
  00077	74 0e		 je	 SHORT $LN16@scalar
  00079	ba 98 00 00 00	 mov	 edx, 152		; 00000098H
  0007e	48 8b cb	 mov	 rcx, rbx
  00081	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00086	90		 npad	 1
$LN16@scalar:
  00087	48 8b c3	 mov	 rax, rbx
  0008a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00093	5f		 pop	 rdi
  00094	c3		 ret	 0
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 634  : 		{	// destroy the object

  0000f	48 8b 81 68 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-152]
  00016	48 8b d9	 mov	 rbx, rcx
  00019	8b fa		 mov	 edi, edx
  0001b	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00026	49 89 84 08 68
	ff ff ff	 mov	 QWORD PTR [r8+rcx-152], rax
  0002e	48 8b 81 68 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-152]
  00035	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  00039	45 8d 88 68 ff
	ff ff		 lea	 r9d, DWORD PTR [r8-152]
  00040	45 89 8c 08 64
	ff ff ff	 mov	 DWORD PTR [r8+rcx-156], r9d

; 635  : 		}

  00048	48 83 c1 80	 add	 rcx, -128		; ffffffffffffff80H
  0004c	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00051	48 8d 4b 88	 lea	 rcx, QWORD PTR [rbx-120]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00064	40 f6 c7 01	 test	 dil, 1
  00068	74 11		 je	 SHORT $LN10@scalar
  0006a	ba f8 00 00 00	 mov	 edx, 248		; 000000f8H
  0006f	48 8d 8b 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rbx-152]
  00076	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN10@scalar:
  0007b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00080	48 8d 83 68 ff
	ff ff		 lea	 rax, QWORD PTR [rbx-152]
  00087	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b da		 mov	 ebx, edx
  0000c	48 8b f9	 mov	 rdi, rcx
  0000f	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00014	f6 c3 01	 test	 bl, 1
  00017	74 0d		 je	 SHORT $LN4@scalar
  00019	ba 78 00 00 00	 mov	 edx, 120		; 00000078H
  0001e	48 8b cf	 mov	 rcx, rdi
  00021	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  00026	48 8b c7	 mov	 rax, rdi
  00029	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
  00000	c2 00 00	 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
  00000	c2 00 00	 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z PROC ; std::pointer_traits<char * __ptr64>::pointer_to, COMDAT

; 379  : 		return (_STD addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 380  : 		}

  00003	c3		 ret	 0
?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ENDP ; std::pointer_traits<char * __ptr64>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0?$uniform_int@H@std@@QEAA@HH@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
??0?$uniform_int@H@std@@QEAA@HH@Z PROC			; std::uniform_int<int>::uniform_int<int>, COMDAT

; 2224 : 			_Min = _Min0;

  00000	89 11		 mov	 DWORD PTR [rcx], edx

; 2236 : 		}

  00002	48 8b c1	 mov	 rax, rcx

; 2225 : 			_Max = _Max0;

  00005	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d

; 2236 : 		}

  00009	c3		 ret	 0
??0?$uniform_int@H@std@@QEAA@HH@Z ENDP			; std::uniform_int<int>::uniform_int<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?_Refill_upper@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Refill_upper@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ PROC ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_upper, COMDAT

; 1402 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00000	48 8d 41 10	 lea	 rax, QWORD PTR [rcx+16]
  00004	41 b9 38 01 00
	00		 mov	 r9d, 312		; 00000138H
  0000a	49 ba e9 19 66
	a9 5a 6f 02 b5	 mov	 r10, -5403634167711393303 ; b5026f5aa96619e9H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@Refill_upp:

; 1397 : 		int _Ix;
; 1398 : 		for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix)
; 1399 : 			{	// fill in values
; 1400 : 			_Ty _Tmp = (this->_Ax[_Ix - _Nx] & _HMSK)
; 1401 : 				| (this->_Ax[_Ix - _Nx + 1] & _LMSK);

  00020	44 8b 40 f8	 mov	 r8d, DWORD PTR [rax-8]
  00024	44 33 00	 xor	 r8d, DWORD PTR [rax]
  00027	48 8d 40 08	 lea	 rax, QWORD PTR [rax+8]
  0002b	41 0f ba f0 1f	 btr	 r8d, 31
  00030	4c 33 40 f0	 xor	 r8, QWORD PTR [rax-16]

; 1402 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00034	41 0f b6 c8	 movzx	 ecx, r8b
  00038	80 e1 01	 and	 cl, 1
  0003b	f6 d9		 neg	 cl
  0003d	48 1b d2	 sbb	 rdx, rdx
  00040	49 d1 e8	 shr	 r8, 1
  00043	49 23 d2	 and	 rdx, r10
  00046	48 33 90 d0 04
	00 00		 xor	 rdx, QWORD PTR [rax+1232]
  0004d	49 33 d0	 xor	 rdx, r8
  00050	48 89 90 b0 09
	00 00		 mov	 QWORD PTR [rax+2480], rdx
  00057	49 83 e9 01	 sub	 r9, 1
  0005b	75 c3		 jne	 SHORT $LL4@Refill_upp

; 1403 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1404 : 			}
; 1405 : 		}

  0005d	c3		 ret	 0
?_Refill_upper@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ ENDP ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_upper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ PROC ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_lower, COMDAT

; 1371 : 		{	// compute values for the lower half of the history array

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi

; 1390 : 		this->_Ax[_Ix] = (_Tmp >> 1)

  0000a	4c 8d 91 c8 09
	00 00		 lea	 r10, QWORD PTR [rcx+2504]
  00011	4c 8b d9	 mov	 r11, rcx
  00014	49 8b 02	 mov	 rax, QWORD PTR [r10]
  00017	bb 9c 00 00 00	 mov	 ebx, 156		; 0000009cH
  0001c	48 bf e9 19 66
	a9 5a 6f 02 b5	 mov	 rdi, -5403634167711393303 ; b5026f5aa96619e9H
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@Refill_low:

; 1372 : 		int _Ix;
; 1373 : 		for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix)
; 1374 : 			{	// fill in lower region
; 1375 : 			_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK)
; 1376 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00030	49 8b 52 08	 mov	 rdx, QWORD PTR [r10+8]
  00034	4d 8d 42 08	 lea	 r8, QWORD PTR [r10+8]
  00038	48 33 d0	 xor	 rdx, rax
  0003b	0f ba f2 1f	 btr	 edx, 31
  0003f	48 33 d0	 xor	 rdx, rax

; 1377 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00042	0f b6 c2	 movzx	 eax, dl
  00045	24 01		 and	 al, 1
  00047	f6 d8		 neg	 al
  00049	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0004c	48 1b c9	 sbb	 rcx, rcx
  0004f	48 d1 ea	 shr	 rdx, 1
  00052	48 23 cf	 and	 rcx, rdi
  00055	49 33 8a e0 04
	00 00		 xor	 rcx, QWORD PTR [r10+1248]
  0005c	48 33 ca	 xor	 rcx, rdx
  0005f	49 89 8a 40 f6
	ff ff		 mov	 QWORD PTR [r10-2496], rcx
  00066	4d 8d 10	 lea	 r10, QWORD PTR [r8]
  00069	48 83 eb 01	 sub	 rbx, 1
  0006d	75 c1		 jne	 SHORT $LL4@Refill_low

; 1378 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];
; 1379 : 			}
; 1380 : 
; 1381 : 		for (; _Ix < _Nx - 1; ++_Ix)

  0006f	4d 8d 93 a8 0e
	00 00		 lea	 r10, QWORD PTR [r11+3752]
  00076	bb 9b 00 00 00	 mov	 ebx, 155		; 0000009bH
  0007b	49 8b 02	 mov	 rax, QWORD PTR [r10]
  0007e	66 90		 npad	 2
$LL7@Refill_low:

; 1382 : 			{	// fill in upper region (avoids modulus operation)
; 1383 : 			_Ty _Tmp = (this->_Ax[_Ix +_Nx] & _HMSK)
; 1384 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00080	49 8b 52 08	 mov	 rdx, QWORD PTR [r10+8]
  00084	4d 8d 42 08	 lea	 r8, QWORD PTR [r10+8]
  00088	48 33 d0	 xor	 rdx, rax
  0008b	0f ba f2 1f	 btr	 edx, 31
  0008f	48 33 d0	 xor	 rdx, rax

; 1385 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00092	0f b6 c2	 movzx	 eax, dl
  00095	24 01		 and	 al, 1
  00097	f6 d8		 neg	 al
  00099	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0009c	48 1b c9	 sbb	 rcx, rcx
  0009f	48 d1 ea	 shr	 rdx, 1
  000a2	48 23 cf	 and	 rcx, rdi
  000a5	49 33 8a 60 f1
	ff ff		 xor	 rcx, QWORD PTR [r10-3744]
  000ac	48 33 ca	 xor	 rcx, rdx
  000af	49 89 8a 40 f6
	ff ff		 mov	 QWORD PTR [r10-2496], rcx
  000b6	4d 8d 10	 lea	 r10, QWORD PTR [r8]
  000b9	48 83 eb 01	 sub	 rbx, 1
  000bd	75 c1		 jne	 SHORT $LL7@Refill_low

; 1386 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1387 : 			}
; 1388 : 
; 1389 : 		_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

  000bf	41 8b 93 80 13
	00 00		 mov	 edx, DWORD PTR [r11+4992]
  000c6	41 33 53 08	 xor	 edx, DWORD PTR [r11+8]

; 1391 : 			^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];
; 1392 : 		this->_Idx = 0;
; 1393 : 		}

  000ca	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000cf	0f ba f2 1f	 btr	 edx, 31
  000d3	49 33 93 80 13
	00 00		 xor	 rdx, QWORD PTR [r11+4992]
  000da	0f b6 c2	 movzx	 eax, dl
  000dd	24 01		 and	 al, 1
  000df	f6 d8		 neg	 al
  000e1	48 1b c9	 sbb	 rcx, rcx
  000e4	48 d1 ea	 shr	 rdx, 1
  000e7	48 23 cf	 and	 rcx, rdi
  000ea	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  000ef	49 33 8b e0 04
	00 00		 xor	 rcx, QWORD PTR [r11+1248]
  000f6	48 33 ca	 xor	 rcx, rdx
  000f9	49 89 8b c0 09
	00 00		 mov	 QWORD PTR [r11+2496], rcx
  00100	41 c7 03 00 00
	00 00		 mov	 DWORD PTR [r11], 0
  00107	c3		 ret	 0
?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ ENDP ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_lower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA@_K00@Z
_TEXT	SEGMENT
this$ = 8
_X0$ = 16
_Dxarg$dead$ = 24
_Fxarg$dead$ = 32
??0?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA@_K00@Z PROC ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>, COMDAT

; 1293 : 		: _Dxval(_Dxarg)

  00000	48 b8 55 55 55
	55 55 55 55 55	 mov	 rax, 6148914691236517205 ; 5555555555555555H
  0000a	4c 8d 49 10	 lea	 r9, QWORD PTR [rcx+16]
  0000e	48 89 81 88 13
	00 00		 mov	 QWORD PTR [rcx+5000], rax
  00015	41 b8 01 00 00
	00		 mov	 r8d, 1

; 1309 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  0001b	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 1293 : 		: _Dxval(_Dxarg)

  0001f	41 ba 37 01 00
	00		 mov	 r10d, 311		; 00000137H
  00025	49 bb 2d 7f 95
	4c 2d f4 51 58	 mov	 r11, 6364136223846793005 ; 5851f42d4c957f2dH
  0002f	90		 npad	 1
$LL6@mersenne_t:

; 1311 : 			_Prev = this->_Ax[_Ix] =

  00030	48 8b c2	 mov	 rax, rdx
  00033	4d 8d 49 08	 lea	 r9, QWORD PTR [r9+8]
  00037	48 c1 e8 3e	 shr	 rax, 62			; 0000003eH
  0003b	48 33 d0	 xor	 rdx, rax
  0003e	49 0f af d3	 imul	 rdx, r11
  00042	49 03 d0	 add	 rdx, r8
  00045	49 ff c0	 inc	 r8
  00048	49 89 51 f8	 mov	 QWORD PTR [r9-8], rdx
  0004c	49 83 ea 01	 sub	 r10, 1
  00050	75 de		 jne	 SHORT $LL6@mersenne_t

; 1312 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;
; 1313 : 		this->_Idx = _Nx;

  00052	c7 01 38 01 00
	00		 mov	 DWORD PTR [rcx], 312	; 00000138H

; 1295 : 		seed(_X0, _Fxarg);
; 1296 : 		}

  00058	48 8b c1	 mov	 rax, rcx
  0005b	c3		 ret	 0
??0?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA@_K00@Z ENDP ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 141  : 			return (_Ok);

  00000	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]

; 142  : 			}

  00004	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 128  : 			{	// destroy the object

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 129  :  #if _HAS_EXCEPTIONS
; 130  : 			if (_STD uncaught_exceptions() == 0)

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ
  00018	90		 npad	 1
  00019	85 c0		 test	 eax, eax
  0001b	75 0a		 jne	 SHORT $LN2@sentry

; 131  : 				{
; 132  : 				this->_Myostr._Osfx();

  0001d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00026	90		 npad	 1
$LN2@sentry:

; 106  : 			if (_Myostr.rdbuf() != 0)

  00027	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0002a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00031	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 106  : 			if (_Myostr.rdbuf() != 0)

  00036	48 85 c9	 test	 rcx, rcx
  00039	74 07		 je	 SHORT $LN12@sentry

; 107  : 				_Myostr.rdbuf()->_Unlock();

  0003b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0003e	ff 50 10	 call	 QWORD PTR [rax+16]
  00041	90		 npad	 1
$LN12@sentry:

; 133  : 				}
; 134  :  #else /* _HAS_EXCEPTIONS */
; 135  : 			this->_Myostr._Osfx();
; 136  :  #endif /* _HAS_EXCEPTIONS */
; 137  : 			}

  00042	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 121  : 			{	// construct locking and testing stream

$LN27:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T8[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx

; 98   : 			: _Myostr(_Ostr)

  0001e	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 100  : 			if (_Myostr.rdbuf() != 0)

  00021	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00024	48 63 42 04	 movsxd	 rax, DWORD PTR [rdx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00028	48 8b 4c 18 48	 mov	 rcx, QWORD PTR [rax+rbx+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

  0002d	48 85 c9	 test	 rcx, rcx
  00030	74 09		 je	 SHORT $LN6@sentry

; 101  : 				_Myostr.rdbuf()->_Lock();

  00032	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00035	ff 50 08	 call	 QWORD PTR [rax+8]
  00038	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
$LN6@sentry:

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0003b	48 63 4a 04	 movsxd	 rcx, DWORD PTR [rdx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  0003f	48 8b c2	 mov	 rax, rdx

; 338  : 		return (rdstate() == goodbit);

  00042	83 7c 19 10 00	 cmp	 DWORD PTR [rcx+rbx+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00047	75 18		 jne	 SHORT $LN2@sentry
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 79   : 		return (_Tiestr);

  00049	48 8b 4c 19 50	 mov	 rcx, QWORD PTR [rcx+rbx+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0004e	48 85 c9	 test	 rcx, rcx
  00051	74 0e		 je	 SHORT $LN2@sentry
  00053	48 3b cb	 cmp	 rcx, rbx
  00056	74 09		 je	 SHORT $LN2@sentry

; 123  : 				_Ostr.tie()->flush();

  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
  0005e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN2@sentry:

; 124  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00061	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 338  : 		return (rdstate() == goodbit);

  00065	83 7c 18 10 00	 cmp	 DWORD PTR [rax+rbx+16], 0
  0006a	0f 94 c0	 sete	 al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 124  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  0006d	88 47 08	 mov	 BYTE PTR [rdi+8], al

; 125  : 			}

  00070	48 8b c7	 mov	 rax, rdi
  00073	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00078	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ
_TEXT	SEGMENT
this$ = 8
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT

; 1421 : 		return ((reference)**(_Mybase *)this);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1422 : 		}

  00003	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 1641 : 			}

  00000	c2 00 00	 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
_Size$ = 24
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b c2	 sub	 rax, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00007	49 3b c0	 cmp	 rax, r8
  0000a	4c 0f 42 c0	 cmovb	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  0000e	49 8b c0	 mov	 rax, r8

; 1631 : 		}

  00011	c3		 ret	 0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 1608 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1609 : 		if (_Mysize < _Off)

  00004	48 39 51 10	 cmp	 QWORD PTR [rcx+16], rdx
  00008	72 05		 jb	 SHORT $LN5@Check_offs

; 1612 : 			}
; 1613 : 		}

  0000a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000e	c3		 ret	 0
$LN5@Check_offs:

; 1610 : 			{
; 1611 : 			_Xran();

  0000f	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00014	cc		 int	 3
$LN4@Check_offs:
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16
  00005	0f 93 c0	 setae	 al

; 1605 : 		}

  00008	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;
; 1594 : 		if (_Large_string_engaged())

  00005	72 04		 jb	 SHORT $LN8@Myptr

; 1595 : 			{
; 1596 : 			_Result = _Unfancy(_Bx._Ptr);
; 1597 : 			}
; 1598 : 
; 1599 : 		return (_Result);

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1600 : 		}

  0000a	c3		 ret	 0
$LN8@Myptr:

; 1595 : 			{
; 1596 : 			_Result = _Unfancy(_Bx._Ptr);
; 1597 : 			}
; 1598 : 
; 1599 : 		return (_Result);

  0000b	48 8b c1	 mov	 rax, rcx

; 1600 : 		}

  0000e	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1582 : 		value_type * _Result = _Bx._Buf;
; 1583 : 		if (_Large_string_engaged())

  00005	72 04		 jb	 SHORT $LN8@Myptr

; 1584 : 			{
; 1585 : 			_Result = _Unfancy(_Bx._Ptr);
; 1586 : 			}
; 1587 : 
; 1588 : 		return (_Result);

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1589 : 		}

  0000a	c3		 ret	 0
$LN8@Myptr:

; 1584 : 			{
; 1585 : 			_Result = _Unfancy(_Bx._Ptr);
; 1586 : 			}
; 1587 : 
; 1588 : 		return (_Result);

  0000b	48 8b c1	 mov	 rax, rcx

; 1589 : 		}

  0000e	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 961  : 		return (_Al);

  00000	48 8b c1	 mov	 rax, rcx

; 962  : 		}

  00003	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT

; 1827 : 		return (_Mypair._Get_second());

  00000	48 8b c1	 mov	 rax, rcx

; 1828 : 		}

  00003	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT

; 1822 : 		return (_Mypair._Get_second());

  00000	48 8b c1	 mov	 rax, rcx

; 1823 : 		}

  00003	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT

; 1817 : 		return (_Mypair._Get_first());

  00000	48 8b c1	 mov	 rax, rcx

; 1818 : 		}

  00003	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT

; 1812 : 		return (_Mypair._Get_first());

  00000	48 8b c1	 mov	 rax, rcx

; 1813 : 		}

  00003	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT

; 1802 : 		_Get_data()._Orphan_all();
; 1803 : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEAV?$allocator@D@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Al$dead$ = 16
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEAV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT

; 1707 : 		_Pocma(_Getal(), _Al);
; 1708 : 		}

  00000	c2 00 00	 ret	 0
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEAV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Al$dead$ = 16
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEBV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT

; 1702 : 		_Pocca(_Getal(), _Al);
; 1703 : 		}

  00000	c2 00 00	 ret	 0
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEBV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT

; 1563 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1564 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1690 : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3691 : 		{	// initialize buffer, deallocating any storage

$LN59:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00006	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]

; 3691 : 		{	// initialize buffer, deallocating any storage

  0000a	48 8b d9	 mov	 rbx, rcx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0000d	48 83 fa 10	 cmp	 rdx, 16

; 3692 : 		this->_Orphan_all();
; 3693 : 		auto& _My_data = this->_Get_data();
; 3694 : 		if (_My_data._Large_string_engaged())

  00011	72 3e		 jb	 SHORT $LN36@Tidy_deall
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00016	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00019	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00020	72 2a		 jb	 SHORT $LN39@Tidy_deall

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00022	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00026	48 3b c2	 cmp	 rax, rdx
  00029	76 3f		 jbe	 SHORT $_Invalid_parameter$60

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0002b	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0002e	f6 c1 1f	 test	 cl, 31
  00031	75 37		 jne	 SHORT $_Invalid_parameter$60

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00033	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00037	48 3b c1	 cmp	 rax, rcx
  0003a	73 2e		 jae	 SHORT $_Invalid_parameter$60

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0003c	48 2b c8	 sub	 rcx, rax
  0003f	48 83 e9 08	 sub	 rcx, 8
  00043	48 83 f9 1f	 cmp	 rcx, 31
  00047	77 21		 ja	 SHORT $_Invalid_parameter$60

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00049	48 8b c8	 mov	 rcx, rax
$LN39@Tidy_deall:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0004c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN36@Tidy_deall:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3702 : 		_My_data._Mysize = 0;

  00051	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0

; 3703 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00059	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00061	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3707 : 		}

  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
$_Invalid_parameter$60:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00070	cc		 int	 3
$LN58@Tidy_deall:
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT

; 3682 : 		auto& _My_data = this->_Get_data();
; 3683 : 		_My_data._Mysize = 0;

  00000	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00008	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00010	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3688 : 		}

  00013	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$dead$ = 16
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 3676 : 		auto& _My_data = this->_Get_data();
; 3677 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00005	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1583 : 		if (_Large_string_engaged())

  0000d	72 07		 jb	 SHORT $LN19@Eos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000f	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00012	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3678 : 		}

  00015	c3		 ret	 0
$LN19@Eos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00016	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3678 : 		}

  00019	c3		 ret	 0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small, COMDAT

; 3661 : 		{	// release any held storage and return to small string mode

$LN50:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3662 : 			// pre: *this is in large string mode
; 3663 : 			// pre: this is small enough to return to small string mode
; 3664 : 		auto& _My_data = this->_Get_data();
; 3665 : 		_My_data._Orphan_all();
; 3666 : 		const pointer _Ptr = _My_data._Bx._Ptr;

  0000a	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  0000d	48 8b f9	 mov	 rdi, rcx

; 3669 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00010	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00014	48 8b d3	 mov	 rdx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3669 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00017	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0001a	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3670 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0001f	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00023	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00026	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0002d	72 2a		 jb	 SHORT $LN33@Become_sma

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0002f	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00033	48 3b c2	 cmp	 rax, rdx
  00036	76 3c		 jbe	 SHORT $_Invalid_parameter$51

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00038	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0003b	f6 c3 1f	 test	 bl, 31
  0003e	75 34		 jne	 SHORT $_Invalid_parameter$51

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00040	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00044	48 3b c3	 cmp	 rax, rbx
  00047	73 2b		 jae	 SHORT $_Invalid_parameter$51

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00049	48 2b d8	 sub	 rbx, rax
  0004c	48 83 eb 08	 sub	 rbx, 8
  00050	48 83 fb 1f	 cmp	 rbx, 31
  00054	77 1e		 ja	 SHORT $_Invalid_parameter$51

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00056	48 8b d8	 mov	 rbx, rax
$LN33@Become_sma:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00059	48 8b cb	 mov	 rcx, rbx
  0005c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3672 : 		}

  00061	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00066	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15
  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
$_Invalid_parameter$51:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0007a	cc		 int	 3
$LN49@Become_sma:
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT

; 3569 : 		return (static_cast<allocator_type>(this->_Getal()));

  00000	48 8b c2	 mov	 rax, rdx

; 3570 : 		}

  00003	c3		 ret	 0
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 3052 : 		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
; 3053 : 		const size_type _Storage_max = // can always store small string
; 3054 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));
; 3055 : 		return (_Min_value(

  00000	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH

; 3056 : 			static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3057 : 			_Storage_max - 1 // -1 is for null terminator and/or npos
; 3058 : 			));
; 3059 : 
; 3060 : 		}

  0000a	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
;	COMDAT ??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z PROC		; std::_Max_value<unsigned __int64>, COMDAT

; 32   : 	return (_Left < _Right ? _Right : _Left);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00006	48 0f 42 ca	 cmovb	 rcx, rdx
  0000a	48 8b c1	 mov	 rax, rcx

; 33   : 	}

  0000d	c3		 ret	 0
??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z ENDP		; std::_Max_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
_TEXT	SEGMENT
this$ = 8
_Ch$ = 16
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT

; 2975 : 		auto& _My_data = this->_Get_data();
; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  00000	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2977 : 		if (_Old_size < _My_data._Myres)

  00004	4c 8b 49 18	 mov	 r9, QWORD PTR [rcx+24]
  00008	4d 3b c1	 cmp	 r8, r9
  0000b	73 1c		 jae	 SHORT $LN2@push_back

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  0000d	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  00011	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00015	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  00019	72 03		 jb	 SHORT $LN11@push_back
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0001b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN11@push_back:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0001e	42 88 14 01	 mov	 BYTE PTR [rcx+r8], dl
  00022	42 c6 44 01 01
	00		 mov	 BYTE PTR [rcx+r8+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2993 : 		}

  00028	c3		 ret	 0
$LN2@push_back:

; 2980 : 			_Elem * const _Ptr = _My_data._Myptr();
; 2981 : 			_Traits::assign(_Ptr[_Old_size], _Ch);
; 2982 : 			_Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 2983 : 			return;
; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  00029	44 0f b6 ca	 movzx	 r9d, dl
  0002d	e9 00 00 00 00	 jmp	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ch$ = 80
??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z PROC ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator(), COMDAT

; 2988 : 				const _Elem _Ch) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00010	48 8b d0	 mov	 rdx, rax
  00013	48 8b cb	 mov	 rcx, rbx
  00016	4d 8b c1	 mov	 r8, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2988 : 				const _Elem _Ch) {

  00019	49 8b f9	 mov	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0001c	e8 00 00 00 00	 call	 memcpy

; 442  : 		_Left = _Right;

  00021	0f b6 44 24 50	 movzx	 eax, BYTE PTR _Ch$[rsp]
  00026	88 04 1f	 mov	 BYTE PTR [rdi+rbx], al
  00029	c6 44 1f 01 00	 mov	 BYTE PTR [rdi+rbx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2992 : 			}, _Ch);

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z ENDP ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1583 : 		if (_Large_string_engaged())

  00005	72 0a		 jb	 SHORT $LN28@begin
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1202 : 		: _Ptr(_Parg)

  0000a	48 89 02	 mov	 QWORD PTR [rdx], rax

; 2826 : 		auto _My_data = _STD addressof(this->_Get_data());
; 2827 : 		return (iterator(_Refancy<pointer>(_My_data->_Myptr()), _My_data));

  0000d	48 8b c2	 mov	 rax, rdx

; 2828 : 		}

  00010	c3		 ret	 0
$LN28@begin:

; 1202 : 		: _Ptr(_Parg)

  00011	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 2826 : 		auto _My_data = _STD addressof(this->_Get_data());
; 2827 : 		return (iterator(_Refancy<pointer>(_My_data->_Myptr()), _My_data));

  00014	48 8b c2	 mov	 rax, rdx

; 2828 : 		}

  00017	c3		 ret	 0
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
_Ch$dead$ = 64
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2441 : 		{	// assign _Count * _Ch

$LN159:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2442 : 		auto& _My_data = this->_Get_data();
; 2443 : 		if (_Count <= _My_data._Myres)

  0000a	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	48 83 ff 08	 cmp	 rdi, 8
  00015	72 2a		 jb	 SHORT $LN2@assign

; 1582 : 		value_type * _Result = _Bx._Buf;

  00017	48 8b c1	 mov	 rax, rcx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0001a	48 83 ff 10	 cmp	 rdi, 16

; 1583 : 		if (_Large_string_engaged())

  0001e	72 03		 jb	 SHORT $LN11@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00020	48 8b 01	 mov	 rax, QWORD PTR [rcx]
$LN11@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2446 : 			_My_data._Mysize = _Count;

  00023	48 c7 41 10 08
	00 00 00	 mov	 QWORD PTR [rcx+16], 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  0002b	33 c9		 xor	 ecx, ecx
  0002d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 442  : 		_Left = _Right;

  00030	88 48 08	 mov	 BYTE PTR [rax+8], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2452 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

  00033	48 8b c3	 mov	 rax, rbx

; 2456 : 		}

  00036	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
$LN2@assign:
  00041	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp

; 3583 : 		if (_Old > _Max - _Old / 2)

  00046	48 8b cf	 mov	 rcx, rdi
  00049	48 d1 e9	 shr	 rcx, 1
  0004c	48 bd ff ff ff
	ff ff ff ff 7f	 mov	 rbp, 9223372036854775807 ; 7fffffffffffffffH
  00056	48 8b c5	 mov	 rax, rbp
  00059	48 2b c1	 sub	 rax, rcx
  0005c	48 3b f8	 cmp	 rdi, rax
  0005f	77 10		 ja	 SHORT $LN55@assign

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);
; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00061	48 8d 04 39	 lea	 rax, QWORD PTR [rcx+rdi]
  00065	bd 0f 00 00 00	 mov	 ebp, 15
  0006a	48 3b c5	 cmp	 rax, rbp
  0006d	48 0f 47 e8	 cmova	 rbp, rax
$LN55@assign:

; 3605 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00071	48 8b cd	 mov	 rcx, rbp
  00074	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00079	48 83 c1 01	 add	 rcx, 1
  0007d	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00084	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  00088	48 85 c9	 test	 rcx, rcx
  0008b	75 04		 jne	 SHORT $LN99@assign

; 79   : 		{
; 80   : 		return (nullptr);

  0008d	33 f6		 xor	 esi, esi
  0008f	eb 34		 jmp	 SHORT $LN97@assign
$LN99@assign:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00091	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00098	72 23		 jb	 SHORT $LN100@assign

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  0009a	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  0009e	48 3b c1	 cmp	 rax, rcx
  000a1	0f 86 99 00 00
	00		 jbe	 $LN157@assign

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000a7	48 8b c8	 mov	 rcx, rax
  000aa	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  000af	48 8d 70 27	 lea	 rsi, QWORD PTR [rax+39]
  000b3	48 83 e6 e0	 and	 rsi, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000b7	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  000bb	eb 08		 jmp	 SHORT $LN97@assign
$LN100@assign:

; 67   : 			_Ptr = ::operator new(_Bytes);

  000bd	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000c2	48 8b f0	 mov	 rsi, rax
$LN97@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  000c5	33 c0		 xor	 eax, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3607 : 		_My_data._Mysize = _New_size;

  000c7	48 c7 43 10 08
	00 00 00	 mov	 QWORD PTR [rbx+16], 8

; 3608 : 		_My_data._Myres = _New_capacity;

  000cf	48 89 6b 18	 mov	 QWORD PTR [rbx+24], rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  000d3	48 89 06	 mov	 QWORD PTR [rsi], rax

; 442  : 		_Left = _Right;

  000d6	88 46 08	 mov	 BYTE PTR [rsi+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3610 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000d9	48 83 ff 10	 cmp	 rdi, 16
  000dd	72 3f		 jb	 SHORT $LN25@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  000df	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3612 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000e2	48 8d 57 01	 lea	 rdx, QWORD PTR [rdi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000e6	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  000ed	72 2a		 jb	 SHORT $LN128@assign

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000ef	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  000f3	48 3b c2	 cmp	 rax, rdx
  000f6	76 41		 jbe	 SHORT $_Invalid_parameter$160

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000f8	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000fb	f6 c1 1f	 test	 cl, 31
  000fe	75 39		 jne	 SHORT $_Invalid_parameter$160

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00100	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00104	48 3b c1	 cmp	 rax, rcx
  00107	73 30		 jae	 SHORT $_Invalid_parameter$160

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00109	48 2b c8	 sub	 rcx, rax
  0010c	48 83 e9 08	 sub	 rcx, 8
  00110	48 83 f9 1f	 cmp	 rcx, 31
  00114	77 23		 ja	 SHORT $_Invalid_parameter$160

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00116	48 8b c8	 mov	 rcx, rax
$LN128@assign:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00119	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN25@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2452 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

  0011e	48 89 33	 mov	 QWORD PTR [rbx], rsi
  00121	48 8b c3	 mov	 rax, rbx
  00124	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00129	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 2456 : 		}

  0012e	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00133	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00137	5f		 pop	 rdi
  00138	c3		 ret	 0
$_Invalid_parameter$160:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0013f	cc		 int	 3
$LN157@assign:

; 119  : 				_Traits::_Fail();	// report no memory

  00140	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  00145	cc		 int	 3
$LN155@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBA@QEAD_KD@Z
_TEXT	SEGMENT
this$dead$ = 8
_New_ptr$ = 16
_Count$dead$ = 24
_Ch$dead$ = 32
??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBA@QEAD_KD@Z PROC ; <lambda_138c3d7c38c85abb84c7fc7bfe5747b7>::operator(), COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00000	33 c0		 xor	 eax, eax
  00002	48 89 02	 mov	 QWORD PTR [rdx], rax

; 442  : 		_Left = _Right;

  00005	88 42 08	 mov	 BYTE PTR [rdx+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2455 : 			}, _Ch));

  00008	c3		 ret	 0
??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBA@QEAD_KD@Z ENDP ; <lambda_138c3d7c38c85abb84c7fc7bfe5747b7>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2436 : 		{	// assign [_Ptr, <null>)

$LN32:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0000d	48 83 cb ff	 or	 rbx, -1
$LL30@assign:
  00011	48 ff c3	 inc	 rbx
  00014	80 3c 1a 00	 cmp	 BYTE PTR [rdx+rbx], 0
  00018	75 f7		 jne	 SHORT $LL30@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2420 : 		if (_Count <= _My_data._Myres)

  0001a	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  0001e	48 3b d8	 cmp	 rbx, rax
  00021	77 38		 ja	 SHORT $LN9@assign

; 1582 : 		value_type * _Result = _Bx._Buf;

  00023	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00028	48 8b f7	 mov	 rsi, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0002b	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  0002f	72 03		 jb	 SHORT $LN18@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00031	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN18@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  00034	48 89 59 10	 mov	 QWORD PTR [rcx+16], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00038	4c 8b c3	 mov	 r8, rbx
  0003b	48 8b ce	 mov	 rcx, rsi
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00044	c6 04 1e 00	 mov	 BYTE PTR [rsi+rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2437 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00048	48 8b c7	 mov	 rax, rdi
  0004b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 2438 : 		}

  00050	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
$LN9@assign:

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0005b	4c 8b ca	 mov	 r9, rdx
  0005e	48 8b d3	 mov	 rdx, rbx

; 2438 : 		}

  00061	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00066	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006a	5f		 pop	 rdi

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0006b	e9 00 00 00 00	 jmp	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2418 : 		{	// assign [_Ptr, _Ptr + _Count)

$LN24:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2419 : 		auto& _My_data = this->_Get_data();
; 2420 : 		if (_Count <= _My_data._Myres)

  0000a	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  0000e	49 8b f8	 mov	 rdi, r8
  00011	48 8b d9	 mov	 rbx, rcx
  00014	4c 3b c0	 cmp	 r8, rax
  00017	77 35		 ja	 SHORT $LN2@assign

; 1582 : 		value_type * _Result = _Bx._Buf;

  00019	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0001e	48 8b f1	 mov	 rsi, rcx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00021	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00025	72 03		 jb	 SHORT $LN11@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00027	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN11@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  0002a	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0002e	48 8b ce	 mov	 rcx, rsi
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00037	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2426 : 			return (*this);

  0003b	48 8b c3	 mov	 rax, rbx
  0003e	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 2430 : 			_Traits::copy(_New_ptr, _Ptr, _Count);
; 2431 : 			_Traits::assign(_New_ptr[_Count], _Elem());
; 2432 : 			}, _Ptr));
; 2433 : 		}

  00043	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
$LN2@assign:

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0004e	4c 8b ca	 mov	 r9, rdx
  00051	48 8b d7	 mov	 rdx, rdi

; 2430 : 			_Traits::copy(_New_ptr, _Ptr, _Count);
; 2431 : 			_Traits::assign(_New_ptr[_Count], _Elem());
; 2432 : 			}, _Ptr));
; 2433 : 		}

  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi

; 2427 : 			}
; 2428 : 
; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0005e	e9 00 00 00 00	 jmp	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Count$ = 64
_Ptr$ = 72
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z PROC ; <lambda_66f57f934f28d61049862f64df852ff0>::operator(), COMDAT

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00010	48 8b cb	 mov	 rcx, rbx
  00013	49 8b d1	 mov	 rdx, r9
  00016	e8 00 00 00 00	 call	 memcpy

; 442  : 		_Left = _Right;

  0001b	c6 04 3b 00	 mov	 BYTE PTR [rbx+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2432 : 			}, _Ptr));

  0001f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5f		 pop	 rdi
  00029	c3		 ret	 0
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z ENDP ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Ch$ = 80
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 2360 : 		{	// append _Count * _Ch

$LN24:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b f2	 mov	 rsi, rdx

; 2361 : 		auto& _My_data = this->_Get_data();
; 2362 : 		const size_type _Old_size = _My_data._Mysize;

  00010	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]

; 2363 : 		if (_Count <= _My_data._Myres - _Old_size)

  00014	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00018	48 8b c2	 mov	 rax, rdx
  0001b	48 2b c1	 sub	 rax, rcx
  0001e	48 3b f0	 cmp	 rsi, rax
  00021	77 43		 ja	 SHORT $LN2@append

; 2364 : 			{
; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  00023	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00028	48 8d 04 31	 lea	 rax, QWORD PTR [rcx+rsi]
  0002c	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00030	48 8b c7	 mov	 rax, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00033	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  00037	72 03		 jb	 SHORT $LN11@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00039	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN11@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2367 : 			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  0003c	48 8d 1c 08	 lea	 rbx, QWORD PTR [rax+rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00040	41 0f be d0	 movsx	 edx, r8b
  00044	48 8b cb	 mov	 rcx, rbx
  00047	4c 8b c6	 mov	 r8, rsi
  0004a	e8 00 00 00 00	 call	 memset

; 442  : 		_Left = _Right;

  0004f	c6 04 33 00	 mov	 BYTE PTR [rbx+rsi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2369 : 			return (*this);

  00053	48 8b c7	 mov	 rax, rdi
  00056	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2373 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2374 : 				const size_type _Count, const _Elem _Ch) {
; 2375 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2376 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2377 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2378 : 			}, _Count, _Ch));
; 2379 : 		}

  0005b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
$LN2@append:

; 2370 : 			}
; 2371 : 
; 2372 : 		return (_Reallocate_grow_by(_Count,

  00066	4c 8b ce	 mov	 r9, rsi
  00069	44 88 44 24 20	 mov	 BYTE PTR [rsp+32], r8b
  0006e	48 8b d6	 mov	 rdx, rsi
  00071	48 8b cf	 mov	 rcx, rdi
  00074	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>

; 2373 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2374 : 				const size_type _Count, const _Elem _Ch) {
; 2375 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2376 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2377 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2378 : 			}, _Count, _Ch));
; 2379 : 		}

  00079	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0007e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Count$ = 80
_Ch$ = 88
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z PROC ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator(), COMDAT

; 2374 : 				const size_type _Count, const _Elem _Ch) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00010	48 8b d0	 mov	 rdx, rax
  00013	48 8b cb	 mov	 rcx, rbx
  00016	4d 8b c1	 mov	 r8, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2374 : 				const size_type _Count, const _Elem _Ch) {

  00019	49 8b f9	 mov	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0001c	e8 00 00 00 00	 call	 memcpy

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00021	0f be 54 24 58	 movsx	 edx, BYTE PTR _Ch$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2376 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  00026	48 03 fb	 add	 rdi, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00029	48 8b 5c 24 50	 mov	 rbx, QWORD PTR _Count$[rsp]
  0002e	48 8b cf	 mov	 rcx, rdi
  00031	4c 8b c3	 mov	 r8, rbx
  00034	e8 00 00 00 00	 call	 memset

; 442  : 		_Left = _Right;

  00039	c6 04 1f 00	 mov	 BYTE PTR [rdi+rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2378 : 			}, _Count, _Ch));

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ENDP ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 2333 : 		{	// append [_Ptr, _Ptr + _Count)

$LN24:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	49 8b f0	 mov	 rsi, r8

; 2334 : 		auto& _My_data = this->_Get_data();
; 2335 : 		const size_type _Old_size = _My_data._Mysize;

  00010	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]

; 2336 : 		if (_Count <= _My_data._Myres - _Old_size)

  00014	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  00018	49 8b c0	 mov	 rax, r8
  0001b	48 2b c1	 sub	 rax, rcx
  0001e	48 3b f0	 cmp	 rsi, rax
  00021	77 40		 ja	 SHORT $LN2@append

; 2337 : 			{
; 2338 : 			_My_data._Mysize = _Old_size + _Count;

  00023	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00028	48 8d 04 31	 lea	 rax, QWORD PTR [rcx+rsi]
  0002c	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00030	48 8b c7	 mov	 rax, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00033	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  00037	72 03		 jb	 SHORT $LN11@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00039	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN11@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2340 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0003c	48 8d 1c 08	 lea	 rbx, QWORD PTR [rax+rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00040	4c 8b c6	 mov	 r8, rsi
  00043	48 8b cb	 mov	 rcx, rbx
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  0004c	c6 04 33 00	 mov	 BYTE PTR [rbx+rsi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2342 : 			return (*this);

  00050	48 8b c7	 mov	 rax, rdi
  00053	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2346 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2347 : 				const _Elem * const _Ptr, const size_type _Count) {
; 2348 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2349 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2350 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2351 : 			}, _Ptr, _Count));
; 2352 : 		}

  00058	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN2@append:

; 2343 : 			}
; 2344 : 
; 2345 : 		return (_Reallocate_grow_by(_Count,

  00063	4c 8b ca	 mov	 r9, rdx
  00066	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0006b	48 8b d6	 mov	 rdx, rsi
  0006e	48 8b cf	 mov	 rcx, rdi
  00071	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const * __ptr64,unsigned __int64>

; 2346 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2347 : 				const _Elem * const _Ptr, const size_type _Count) {
; 2348 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2349 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2350 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2351 : 			}, _Ptr, _Count));
; 2352 : 		}

  00076	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0007b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ptr$ = 80
_Count$ = 88
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z PROC ; <lambda_65e615be2a453ca0576c979606f46740>::operator(), COMDAT

; 2347 : 				const _Elem * const _Ptr, const size_type _Count) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00010	48 8b d0	 mov	 rdx, rax
  00013	48 8b cb	 mov	 rcx, rbx
  00016	4d 8b c1	 mov	 r8, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2347 : 				const _Elem * const _Ptr, const size_type _Count) {

  00019	49 8b f9	 mov	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0001c	e8 00 00 00 00	 call	 memcpy
  00021	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Ptr$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2349 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00026	48 03 fb	 add	 rdi, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00029	48 8b 5c 24 58	 mov	 rbx, QWORD PTR _Count$[rsp]
  0002e	48 8b cf	 mov	 rcx, rdi
  00031	4c 8b c3	 mov	 r8, rbx
  00034	e8 00 00 00 00	 call	 memcpy

; 442  : 		_Left = _Right;

  00039	c6 04 1f 00	 mov	 BYTE PTR [rdi+rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2351 : 			}, _Ptr, _Count));

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ENDP ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00005	48 8b c2	 mov	 rax, rdx

; 1594 : 		if (_Large_string_engaged())

  00008	72 03		 jb	 SHORT $LN12@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN12@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0000d	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]
  00011	48 8b d0	 mov	 rdx, rax
  00014	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT

; 2166 : 		{	// assign by copying data stored in _Right

$LN90:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00008	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 2166 : 		{	// assign by copying data stored in _Right

  0000d	48 8b da	 mov	 rbx, rdx

; 2167 : 			// pre: this != &_Right
; 2168 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2169 : 		auto& _My_data = this->_Get_data();
; 2170 : 		auto& _Right_data = _Right._Get_data();
; 2171 : 		const size_type _Right_size = _Right_data._Mysize;

  00010	48 8b 72 10	 mov	 rsi, QWORD PTR [rdx+16]
  00014	48 8b f9	 mov	 rdi, rcx

; 1594 : 		if (_Large_string_engaged())

  00017	72 03		 jb	 SHORT $LN17@Construct_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00019	48 8b 1a	 mov	 rbx, QWORD PTR [rdx]
$LN17@Construct_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2173 : 		if (_Right_size < this->_BUF_SIZE)

  0001c	48 83 fe 10	 cmp	 rsi, 16
  00020	73 1a		 jae	 SHORT $LN2@Construct_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00022	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]
  00025	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2176 : 			_My_data._Mysize = _Right_size;

  00028	48 89 71 10	 mov	 QWORD PTR [rcx+16], rsi

; 2177 : 			_My_data._Myres = this->_BUF_SIZE - 1;

  0002c	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15

; 2188 : 		}

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	5e		 pop	 rsi
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
$LN2@Construct_:
  0003c	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp

; 2178 : 			return;
; 2179 : 			}
; 2180 : 
; 2181 : 		auto& _Al = this->_Getal();
; 2182 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  00041	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0004b	48 8b ee	 mov	 rbp, rsi
  0004e	48 83 cd 0f	 or	 rbp, 15
  00052	48 3b e8	 cmp	 rbp, rax
  00055	48 0f 47 e8	 cmova	 rbp, rax

; 2183 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  00059	48 8d 4d 01	 lea	 rcx, QWORD PTR [rbp+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0005d	48 85 c9	 test	 rcx, rcx
  00060	74 30		 je	 SHORT $LN58@Construct_

; 79   : 		{
; 80   : 		return (nullptr);
; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00062	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00069	72 1f		 jb	 SHORT $LN61@Construct_

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  0006b	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  0006f	48 3b c1	 cmp	 rax, rcx
  00072	76 42		 jbe	 SHORT $LN88@Construct_

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00074	48 8b c8	 mov	 rcx, rax
  00077	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  0007c	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  00080	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00084	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00088	eb 08		 jmp	 SHORT $LN58@Construct_
$LN61@Construct_:

; 67   : 			_Ptr = ::operator new(_Bytes);

  0008a	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0008f	48 8b c8	 mov	 rcx, rax
$LN58@Construct_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2185 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  00092	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 944  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00096	48 89 0f	 mov	 QWORD PTR [rdi], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00099	48 8b d3	 mov	 rdx, rbx
  0009c	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2187 : 		_My_data._Myres = _New_capacity;

  000a1	48 89 6f 18	 mov	 QWORD PTR [rdi+24], rbp
  000a5	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000aa	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 2188 : 		}

  000ae	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b2	5f		 pop	 rdi
  000b3	5e		 pop	 rsi
  000b4	5b		 pop	 rbx
  000b5	c3		 ret	 0
$LN88@Construct_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  000b6	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  000bb	cc		 int	 3
$LN87@Construct_:
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT

; 2117 : 			// pre: this != &_Right
; 2118 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2119 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2120 : 		auto& _Right_data = _Right._Get_data();
; 2121 : 
; 2122 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2123 : 		if (_Right_data._Large_string_engaged())
; 2124 : 			{	// take ownership of _Right's iterators along with its buffer
; 2125 : 			this->_Swap_all(_Right);
; 2126 : 			}
; 2127 : 		else
; 2128 : 			{
; 2129 : 			_Right._Orphan_all();
; 2130 : 			}
; 2131 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2132 : 
; 2133 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2134 : 			+ _Memcpy_move_offset;
; 2135 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2136 : 			+ _Memcpy_move_offset;
; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00000	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00003	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00006	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  0000a	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  0000e	48 c7 42 10 00
	00 00 00	 mov	 QWORD PTR [rdx+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00016	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0001e	c6 02 00	 mov	 BYTE PTR [rdx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2139 : 		}

  00021	c3		 ret	 0
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents, COMDAT

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00000	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00003	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00006	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  0000a	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  0000e	48 c7 42 10 00
	00 00 00	 mov	 QWORD PTR [rdx+16], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00016	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0001e	c6 02 00	 mov	 BYTE PTR [rdx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2098 : 		}

  00021	c3		 ret	 0
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
_Right$dead$ = 56
_Roff$dead$ = 64
_Count$dead$ = 72
_Al$dead$ = 80
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1940 : 		{	// construct from _Right [_Roff, _Roff + _Count)

$LN77:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3683 : 		_My_data._Mysize = 0;

  00006	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1940 : 		{	// construct from _Right [_Roff, _Roff + _Count)

  0000e	48 8b d9	 mov	 rbx, rcx

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00011	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00019	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1609 : 		if (_Mysize < _Off)

  0001c	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00023	48 83 f8 05	 cmp	 rax, 5
  00027	0f 82 89 00 00
	00		 jb	 $LN75@basic_stri

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  0002d	48 83 c0 fb	 add	 rax, -5
  00031	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00036	48 83 cf ff	 or	 rdi, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00041	48 3b c7	 cmp	 rax, rdi
  00044	48 0f 42 f8	 cmovb	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00048	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 2420 : 		if (_Count <= _My_data._Myres)

  00050	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]

; 1594 : 		if (_Large_string_engaged())

  00054	4c 0f 43 0d 00
	00 00 00	 cmovae	 r9, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0005c	49 83 c1 05	 add	 r9, 5

; 2420 : 		if (_Count <= _My_data._Myres)

  00060	48 3b f8	 cmp	 rdi, rax
  00063	77 3b		 ja	 SHORT $LN52@basic_stri

; 1582 : 		value_type * _Result = _Bx._Buf;

  00065	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0006a	48 8b f1	 mov	 rsi, rcx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0006d	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  00071	72 03		 jb	 SHORT $LN61@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00073	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN61@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  00076	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0007a	4c 8b c7	 mov	 r8, rdi
  0007d	48 8b ce	 mov	 rcx, rsi
  00080	49 8b d1	 mov	 rdx, r9
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00089	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1943 : 		}

  0008d	48 8b c3	 mov	 rax, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00090	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1943 : 		}

  00095	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5b		 pop	 rbx
  0009f	c3		 ret	 0
$LN52@basic_stri:

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  000a0	48 8b d7	 mov	 rdx, rdi
  000a3	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 1943 : 		}

  000a8	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000ad	48 8b c3	 mov	 rax, rbx
  000b0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b4	5b		 pop	 rbx
  000b5	c3		 ret	 0
$LN75@basic_stri:

; 1611 : 			_Xran();

  000b6	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  000bb	cc		 int	 3
$LN74@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT

; 736  : 		{	// set up putback area

  00000	4c 8b c1	 mov	 r8, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00003	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 737  : 		if (_Mysb::eback() != &_Mychar)

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000a	4d 8d 48 70	 lea	 r9, QWORD PTR [r8+112]
  0000e	49 3b c1	 cmp	 rax, r9
  00011	74 1c		 je	 SHORT $LN13@Set_back

; 738  : 			{	// save current get buffer
; 739  : 			_Set_eback = _Mysb::eback();

  00013	49 89 80 88 00
	00 00		 mov	 QWORD PTR [r8+136], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0001a	49 8b 40 50	 mov	 rax, QWORD PTR [r8+80]
  0001e	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  00021	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  00025	48 03 10	 add	 rdx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 740  : 			_Set_egptr = _Mysb::egptr();

  00028	49 89 90 90 00
	00 00		 mov	 QWORD PTR [r8+144], rdx
$LN13@Set_back:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  0002f	4c 89 09	 mov	 QWORD PTR [rcx], r9

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  00032	41 8b c8	 mov	 ecx, r8d
  00035	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  00039	41 2b c9	 sub	 ecx, r9d
  0003c	83 c1 71	 add	 ecx, 113		; 00000071H
  0003f	4c 89 08	 mov	 QWORD PTR [rax], r9
  00042	49 8b 40 50	 mov	 rax, QWORD PTR [r8+80]
  00046	89 08		 mov	 DWORD PTR [rax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 743  : 		}

  00048	c3		 ret	 0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  00000	4c 8b 49 18	 mov	 r9, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 731  : 		if (_Mysb::eback() == &_Mychar)

  00004	48 8d 41 70	 lea	 rax, QWORD PTR [rcx+112]
  00008	49 39 01	 cmp	 QWORD PTR [r9], rax
  0000b	75 22		 jne	 SHORT $LN2@Reset_back

; 732  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0000d	48 8b 91 88 00
	00 00		 mov	 rdx, QWORD PTR [rcx+136]
  00014	4c 8b 81 90 00
	00 00		 mov	 r8, QWORD PTR [rcx+144]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  0001b	49 89 11	 mov	 QWORD PTR [r9], rdx

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  0001e	44 2b c2	 sub	 r8d, edx
  00021	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00025	48 89 10	 mov	 QWORD PTR [rax], rdx
  00028	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
  0002c	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN2@Reset_back:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 733  : 		}

  0002f	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Newpcvt$ = 56
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT

; 711  : 		{	// initialize codecvt pointer

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 8b fa	 mov	 rdi, rdx

; 712  : 		if (_Newpcvt->always_noconv())

  00010	48 8b ca	 mov	 rcx, rdx
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  00019	84 c0		 test	 al, al
  0001b	74 13		 je	 SHORT $LN2@Initcvt

; 713  : 			_Pcvt = 0;	// nothing to do

  0001d	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 718  : 			}
; 719  : 		}

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
$LN2@Initcvt:

; 714  : 		else
; 715  : 			{	// set up for nontrivial codecvt facet
; 716  : 			_Pcvt = _Newpcvt;
; 717  : 			_Mysb::_Init();	// reset any buffering

  00030	48 8b cb	 mov	 rcx, rbx
  00033	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 718  : 			}
; 719  : 		}

  00037	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi

; 714  : 		else
; 715  : 			{	// set up for nontrivial codecvt facet
; 716  : 			_Pcvt = _Newpcvt;
; 717  : 			_Mysb::_Init();	// reset any buffering

  00041	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
_TEXT	SEGMENT
$T67 = 48
_Dest$68 = 56
_Str$69 = 64
__$ArrayPad$ = 96
this$ = 128
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT

; 668  : 		{	// put shift to initial conversion state, as needed

$LN580:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	48 8b ec	 mov	 rbp, rsp
  00007	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000b	48 c7 45 c0 fe
	ff ff ff	 mov	 QWORD PTR $T67[rbp-112], -2
  00013	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00017	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0001b	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c4	 xor	 rax, rsp
  00029	48 89 45 f0	 mov	 QWORD PTR __$ArrayPad$[rbp-112], rax
  0002d	48 8b f9	 mov	 rdi, rcx

; 669  : 		if (_Pcvt == 0 || !_Wrotesome)

  00030	48 83 79 68 00	 cmp	 QWORD PTR [rcx+104], 0
  00035	0f 84 96 01 00
	00		 je	 $LN9@Endwrite
  0003b	80 79 71 00	 cmp	 BYTE PTR [rcx+113], 0
  0003f	0f 84 8c 01 00
	00		 je	 $LN9@Endwrite

; 671  : 		else
; 672  : 			{	// may have to put
; 673  : 			const int _STRING_INC = 8;
; 674  : 			char *_Dest;
; 675  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

  00045	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00048	83 ca ff	 or	 edx, -1
  0004b	ff 50 18	 call	 QWORD PTR [rax+24]
  0004e	83 f8 ff	 cmp	 eax, -1
  00051	75 07		 jne	 SHORT $LN10@Endwrite

; 676  : 				return (false);

  00053	32 c0		 xor	 al, al
  00055	e9 79 01 00 00	 jmp	 $LN554@Endwrite
$LN10@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0005a	48 c7 45 e0 00
	00 00 00	 mov	 QWORD PTR _Str$69[rbp-96], 0

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00062	48 c7 45 e8 0f
	00 00 00	 mov	 QWORD PTR _Str$69[rbp-88], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0006a	c6 45 d0 00	 mov	 BYTE PTR _Str$69[rbp-112], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1978 : 		assign(_Count, _Ch);

  0006e	48 8d 4d d0	 lea	 rcx, QWORD PTR _Str$69[rbp-112]
  00072	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00077	90		 npad	 1
$LN577@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 678  : 			string _Str(_STRING_INC, '\0');

  00078	4c 8b 4d e8	 mov	 r9, QWORD PTR _Str$69[rbp-88]
  0007c	48 8b 4d d0	 mov	 rcx, QWORD PTR _Str$69[rbp-112]
$LL2@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  00080	48 8d 55 d0	 lea	 rdx, QWORD PTR _Str$69[rbp-112]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00084	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  00088	48 0f 43 d1	 cmovae	 rdx, rcx

; 1582 : 		value_type * _Result = _Bx._Buf;

  0008c	4c 8d 45 d0	 lea	 r8, QWORD PTR _Str$69[rbp-112]

; 1583 : 		if (_Large_string_engaged())

  00090	4c 0f 43 c1	 cmovae	 r8, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 681  : 				switch (_Pcvt->unshift(_State,

  00094	4c 8b 4d e0	 mov	 r9, QWORD PTR _Str$69[rbp-96]
  00098	4c 03 ca	 add	 r9, rdx
  0009b	48 8d 45 c8	 lea	 rax, QWORD PTR _Dest$68[rbp-112]
  0009f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a4	48 8d 57 74	 lea	 rdx, QWORD PTR [rdi+116]
  000a8	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z
  000b2	85 c0		 test	 eax, eax
  000b4	74 1d		 je	 SHORT $LN11@Endwrite
  000b6	83 e8 01	 sub	 eax, 1
  000b9	74 1c		 je	 SHORT $LN12@Endwrite
  000bb	83 e8 02	 sub	 eax, 2

; 704  : 						return (false);	// conversion failed

  000be	4c 8b 4d e8	 mov	 r9, QWORD PTR _Str$69[rbp-88]
  000c2	48 8b 4d d0	 mov	 rcx, QWORD PTR _Str$69[rbp-112]

; 681  : 				switch (_Pcvt->unshift(_State,

  000c6	0f 84 b6 00 00
	00		 je	 $LN571@Endwrite
$_Invalid_parameter$581:
$LN570@Endwrite:
  000cc	32 db		 xor	 bl, bl
  000ce	e9 b1 00 00 00	 jmp	 $LN22@Endwrite
$LN11@Endwrite:

; 682  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 683  : 					{	// test result of homing conversion
; 684  : 					case codecvt_base::ok:
; 685  : 						_Wrotesome = false;	// homed successfully

  000d3	c6 47 71 00	 mov	 BYTE PTR [rdi+113], 0
$LN12@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  000d7	48 8d 45 d0	 lea	 rax, QWORD PTR _Str$69[rbp-112]

; 1583 : 		if (_Large_string_engaged())

  000db	48 8b 4d d0	 mov	 rcx, QWORD PTR _Str$69[rbp-112]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000df	4c 8b 4d e8	 mov	 r9, QWORD PTR _Str$69[rbp-88]
  000e3	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  000e7	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 689  : 						size_t _Count = _Dest - &*_Str.begin();

  000eb	48 8b 5d c8	 mov	 rbx, QWORD PTR _Dest$68[rbp-112]
  000ef	48 2b d8	 sub	 rbx, rax

; 690  : 						if (0 < _Count && _Count !=

  000f2	74 31		 je	 SHORT $LN13@Endwrite
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1582 : 		value_type * _Result = _Bx._Buf;

  000f4	48 8d 45 d0	 lea	 rax, QWORD PTR _Str$69[rbp-112]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000f8	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  000fc	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 690  : 						if (0 < _Count && _Count !=

  00100	4c 8b 8f 80 00
	00 00		 mov	 r9, QWORD PTR [rdi+128]
  00107	4c 8b c3	 mov	 r8, rbx
  0010a	ba 01 00 00 00	 mov	 edx, 1
  0010f	48 8b c8	 mov	 rcx, rax
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  00118	4c 8b 4d e8	 mov	 r9, QWORD PTR _Str$69[rbp-88]
  0011c	48 8b 4d d0	 mov	 rcx, QWORD PTR _Str$69[rbp-112]
  00120	48 3b d8	 cmp	 rbx, rax
  00123	75 a7		 jne	 SHORT $LN570@Endwrite
$LN13@Endwrite:
$_Invalid_parameter$582:

; 691  : 							fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 692  : 							return (false);	// write failed
; 693  : 						if (!_Wrotesome)

  00125	80 7f 71 00	 cmp	 BYTE PTR [rdi+113], 0
  00129	74 57		 je	 SHORT $LN571@Endwrite
$_Invalid_parameter$583:

; 695  : 						if (_Count == 0)

  0012b	48 85 db	 test	 rbx, rbx
  0012e	0f 85 4c ff ff
	ff		 jne	 $LL2@Endwrite
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2362 : 		const size_type _Old_size = _My_data._Mysize;

  00134	48 8b 55 e0	 mov	 rdx, QWORD PTR _Str$69[rbp-96]
  00138	49 8b c1	 mov	 rax, r9
  0013b	48 2b c2	 sub	 rax, rdx

; 2363 : 		if (_Count <= _My_data._Myres - _Old_size)

  0013e	48 83 f8 08	 cmp	 rax, 8
  00142	72 23		 jb	 SHORT $LN335@Endwrite

; 2364 : 			{
; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  00144	48 8d 42 08	 lea	 rax, QWORD PTR [rdx+8]
  00148	48 89 45 e0	 mov	 QWORD PTR _Str$69[rbp-96], rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0014c	48 8d 45 d0	 lea	 rax, QWORD PTR _Str$69[rbp-112]

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00150	49 83 f9 10	 cmp	 r9, 16

; 1583 : 		if (_Large_string_engaged())

  00154	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00158	33 c9		 xor	 ecx, ecx
  0015a	48 89 0c 10	 mov	 QWORD PTR [rax+rdx], rcx

; 442  : 		_Left = _Right;

  0015e	88 4c 10 08	 mov	 BYTE PTR [rax+rdx+8], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2369 : 			return (*this);

  00162	e9 11 ff ff ff	 jmp	 $LN577@Endwrite
$LN335@Endwrite:

; 2370 : 			}
; 2371 : 
; 2372 : 		return (_Reallocate_grow_by(_Count,

  00167	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0016c	ba 08 00 00 00	 mov	 edx, 8
  00171	44 8b ca	 mov	 r9d, edx
  00174	48 8d 4d d0	 lea	 rcx, QWORD PTR _Str$69[rbp-112]
  00178	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 706  : 				}

  0017d	e9 f6 fe ff ff	 jmp	 $LN577@Endwrite
$LN571@Endwrite:

; 694  : 							return (true);

  00182	b3 01		 mov	 bl, 1
$LN22@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00184	49 83 f9 10	 cmp	 r9, 16

; 3694 : 		if (_My_data._Large_string_engaged())

  00188	72 42		 jb	 SHORT $LN465@Endwrite
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  0018a	48 8b c1	 mov	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3699 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0018d	49 8d 51 01	 lea	 rdx, QWORD PTR [r9+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00191	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00198	72 2d		 jb	 SHORT $LN468@Endwrite

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0019a	4c 8d 42 27	 lea	 r8, QWORD PTR [rdx+39]
  0019e	4c 3b c2	 cmp	 r8, rdx
  001a1	76 1d		 jbe	 SHORT $_Invalid_parameter$584

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  001a3	49 8b d0	 mov	 rdx, r8
  001a6	a8 1f		 test	 al, 31

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  001a8	75 16		 jne	 SHORT $_Invalid_parameter$584

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001aa	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  001ae	48 3b c8	 cmp	 rcx, rax

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  001b1	73 0d		 jae	 SHORT $_Invalid_parameter$584

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  001b3	48 2b c1	 sub	 rax, rcx
  001b6	48 83 e8 08	 sub	 rax, 8
  001ba	48 83 f8 1f	 cmp	 rax, 31
  001be	76 07		 jbe	 SHORT $LN468@Endwrite
$_Invalid_parameter$584:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001c6	cc		 int	 3
$LN468@Endwrite:

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  001c7	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN465@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 704  : 						return (false);	// conversion failed

  001cc	0f b6 c3	 movzx	 eax, bl
  001cf	eb 02		 jmp	 SHORT $LN554@Endwrite
$LN9@Endwrite:

; 670  : 			return (true);

  001d1	b0 01		 mov	 al, 1
$LN554@Endwrite:

; 707  : 			}
; 708  : 		}

  001d3	48 8b 4d f0	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-112]
  001d7	48 33 cc	 xor	 rcx, rsp
  001da	e8 00 00 00 00	 call	 __security_check_cookie
  001df	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  001e4	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  001e8	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  001ec	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  001f0	49 8b e3	 mov	 rsp, r11
  001f3	5d		 pop	 rbp
  001f4	c3		 ret	 0
$LN576@Endwrite:
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T67 = 48
_Dest$68 = 56
_Str$69 = 64
__$ArrayPad$ = 96
this$ = 128
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
  00000	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Str$69[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T67 = 48
_Dest$68 = 56
_Str$69 = 64
__$ArrayPad$ = 96
this$ = 128
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
  00000	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Str$69[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
_Pb$1 = 32
_Pn$2 = 40
_Nr$3 = 48
__$ArrayPad$ = 56
this$ = 80
_File$ = 88
_Which$ = 96
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT

; 633  : 		{	// initialize to C stream _File after {new, open, close}

$LN13:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 634  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 635  : 
; 636  : 		_Closef = _Which == _Openfl;

  0001e	41 83 f8 01	 cmp	 r8d, 1

; 637  : 		_Wrotesome = false;

  00022	c6 41 71 00	 mov	 BYTE PTR [rcx+113], 0
  00026	48 8b fa	 mov	 rdi, rdx
  00029	48 8b d9	 mov	 rbx, rcx
  0002c	0f 94 c0	 sete	 al
  0002f	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)

  00038	33 f6		 xor	 esi, esi
  0003a	48 85 ff	 test	 rdi, rdi
  0003d	74 4e		 je	 SHORT $LN2@Init

; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(

  0003f	4c 8d 4c 24 30	 lea	 r9, QWORD PTR _Nr$3[rsp]
  00044	48 89 74 24 20	 mov	 QWORD PTR _Pb$1[rsp], rsi
  00049	4c 8d 44 24 28	 lea	 r8, QWORD PTR _Pn$2[rsp]
  0004e	48 89 74 24 28	 mov	 QWORD PTR _Pn$2[rsp], rsi
  00053	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Pb$1[rsp]
  00058	48 89 74 24 30	 mov	 QWORD PTR _Nr$3[rsp], rsi
  0005d	48 8b cf	 mov	 rcx, rdi
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_stream_buffer_pointers
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 331  : 		_IGfirst = _Gf;

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR _Pb$1[rsp]
  0006b	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 332  : 		_IPfirst = _Pf;

  0006f	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 333  : 		_IGnext = _Gn;

  00073	48 8b 44 24 28	 mov	 rax, QWORD PTR _Pn$2[rsp]
  00078	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 334  : 		_IPnext = _Pn;

  0007c	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax

; 335  : 		_IGcount = _Gc;

  00080	48 8b 44 24 30	 mov	 rax, QWORD PTR _Nr$3[rsp]
  00085	48 89 43 50	 mov	 QWORD PTR [rbx+80], rax

; 336  : 		_IPcount = _Pc;

  00089	48 89 43 58	 mov	 QWORD PTR [rbx+88], rax
$LN2@Init:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 663  : 		_State = _Stinit;

  0008d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  00094	48 89 43 74	 mov	 QWORD PTR [rbx+116], rax
  00098	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  0009f	48 89 73 68	 mov	 QWORD PTR [rbx+104], rsi

; 665  : 		}

  000a3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a8	48 33 cc	 xor	 rcx, rsp
  000ab	e8 00 00 00 00	 call	 __security_check_cookie
  000b0	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000b5	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000ba	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
_TEXT	SEGMENT
this$ = 48
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT

; 359  : 		{	// close the C stream

$LN19:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 360  : 		_Myt *_Ans = this;
; 361  : 		if (_Myfile == 0)

  0000f	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	75 06		 jne	 SHORT $LN2@close

; 362  : 			_Ans = 0;

  0001c	33 ff		 xor	 edi, edi
  0001e	8b f7		 mov	 esi, edi

; 363  : 		else

  00020	eb 23		 jmp	 SHORT $LN5@close
$LN2@close:

; 364  : 			{	// put any homing sequence and close file
; 365  : 			if (!_Endwrite())

  00022	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 366  : 				_Ans = 0;
; 367  : 			if (fclose(_Myfile) != 0)

  00027	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0002e	33 ff		 xor	 edi, edi
  00030	84 c0		 test	 al, al
  00032	48 8b f3	 mov	 rsi, rbx
  00035	48 0f 44 f7	 cmove	 rsi, rdi
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  0003f	85 c0		 test	 eax, eax
  00041	48 0f 45 f7	 cmovne	 rsi, rdi
$LN5@close:

; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00045	48 8b cb	 mov	 rcx, rbx
  00048	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0
  0004c	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;
; 663  : 		_State = _Stinit;

  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit

; 368  : 				_Ans = 0;
; 369  : 			}
; 370  : 		_Init(0, _Closefl);
; 371  : 		return (_Ans);

  0005d	48 8b c6	 mov	 rax, rsi

; 372  : 		}

  00060	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 663  : 		_State = _Stinit;

  00065	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx
  00069	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  00070	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 372  : 		}

  00074	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
_TEXT	SEGMENT
$T4 = 32
$T1 = 40
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$dead$ = 104
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT

; 275  : 		{	// open a C stream with specified mode

$LN23:
  00000	40 57		 push	 rdi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T4[rsp], -2
  0000f	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00014	41 8b c0	 mov	 eax, r8d
  00017	4c 8b ca	 mov	 r9, rdx
  0001a	48 8b d9	 mov	 rbx, rcx

; 276  : 		_Filet *_File;
; 277  : 		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)

  0001d	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00025	0f 85 9c 00 00
	00		 jne	 $LN3@open
  0002b	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00031	8b d0		 mov	 edx, eax
  00033	49 8b c9	 mov	 rcx, r9
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z
  0003c	48 85 c0	 test	 rax, rax
  0003f	0f 84 82 00 00
	00		 je	 $LN3@open

; 279  : 
; 280  : 		_Init(_File, _Openfl);

  00045	41 b8 01 00 00
	00		 mov	 r8d, 1
  0004b	48 8b d0	 mov	 rdx, rax
  0004e	48 8b cb	 mov	 rcx, rbx
  00051	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 281  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

  00056	48 8d 54 24 28	 lea	 rdx, QWORD PTR $T1[rsp]
  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ
  00064	90		 npad	 1
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  0006d	48 8b f8	 mov	 rdi, rax

; 712  : 		if (_Newpcvt->always_noconv())

  00070	48 8b c8	 mov	 rcx, rax
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  00079	84 c0		 test	 al, al
  0007b	74 0a		 je	 SHORT $LN7@open

; 713  : 			_Pcvt = 0;	// nothing to do

  0007d	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 714  : 		else

  00085	eb 0e		 jmp	 SHORT $LN8@open
$LN7@open:

; 715  : 			{	// set up for nontrivial codecvt facet
; 716  : 			_Pcvt = _Newpcvt;

  00087	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 717  : 			_Mysb::_Init();	// reset any buffering

  0008b	48 8b cb	 mov	 rcx, rbx
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
  00094	90		 npad	 1
$LN8@open:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale

; 403  : 		if (_Ptr != 0)

  00095	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp+8]
  0009a	48 85 c9	 test	 rcx, rcx
  0009d	74 1a		 je	 SHORT $LN19@open

; 404  : 			delete _Ptr->_Decref();

  0009f	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  000a2	ff 50 10	 call	 QWORD PTR [rax+16]
  000a5	48 85 c0	 test	 rax, rax
  000a8	74 0f		 je	 SHORT $LN19@open
  000aa	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  000ad	ba 01 00 00 00	 mov	 edx, 1
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	41 ff 10	 call	 QWORD PTR [r8]
  000b8	90		 npad	 1
$LN19@open:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream

; 282  : 		return (this);	// open succeeded

  000b9	48 8b c3	 mov	 rax, rbx

; 283  : 		}

  000bc	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000c1	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
$LN3@open:

; 278  : 			return (0);	// open failed

  000c7	33 c0		 xor	 eax, eax

; 283  : 		}

  000c9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000ce	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T1 = 40
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$dead$ = 104
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T1 = 40
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$dead$ = 104
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\fstream
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
_TEXT	SEGMENT
$T1 = 32
this$GSCopy$ = 40
this$ = 64
_File$dead$ = 72
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT

; 156  : 		{	// construct from pointer to C stream

$LN16:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	48 89 4c 24 28	 mov	 QWORD PTR this$GSCopy$[rsp], rcx

; 155  : 		: _Mysb()

  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0001d	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  0001e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00025	48 89 03	 mov	 QWORD PTR [rbx], rax

; 636  : 		_Closef = _Which == _Openfl;

  00028	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0

; 637  : 		_Wrotesome = false;

  0002c	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 638  : 
; 639  : 		_Mysb::_Init();	// initialize stream buffer base object

  00030	48 8b cb	 mov	 rcx, rbx
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 640  : 
; 641  :  #ifndef _IORCNT
; 642  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 643  :   #define _IOWCNT _IOCNT
; 644  :  #endif /* _IORCNT */
; 645  : 
; 646  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 647  : 			{	// point inside C stream with [first, first + count) buffer
; 648  : 			_Elem **_Pb = 0;
; 649  : 			_Elem **_Pn = 0;
; 650  : 			int *_Nr = 0;
; 651  : 
; 652  : 			::_get_stream_buffer_pointers(
; 653  : 				_File,
; 654  : 				reinterpret_cast<char***>(&_Pb),
; 655  : 				reinterpret_cast<char***>(&_Pn),
; 656  : 				&_Nr);
; 657  : 			int *_Nw = _Nr;
; 658  : 
; 659  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 660  : 			}
; 661  : 
; 662  : 		_Myfile = _File;

  00039	33 c0		 xor	 eax, eax
  0003b	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 663  : 		_State = _Stinit;

  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  00049	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx

; 664  : 		_Pcvt = 0;	// pointer to codecvt facet

  0004d	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 157  : 		_Init(_File, _Newfl);
; 158  : 		}

  00051	48 8b c3	 mov	 rax, rbx
  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
this$ = 64
_File$dead$ = 72
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
  00000	48 8b 8a 28 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
this$ = 64
_File$dead$ = 72
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
  00000	48 8b 8a 28 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT

; 337  : 		{	// discard any allocated buffer and clear pointers

$LN47:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 338  : 		if (_Mystate & _Allocated)

  00006	f6 41 70 01	 test	 BYTE PTR [rcx+112], 1
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	74 68		 je	 SHORT $LN23@Tidy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  0000f	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00013	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00016	48 85 c9	 test	 rcx, rcx
  00019	74 0c		 je	 SHORT $LN4@Tidy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  0001b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0001f	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  00022	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00025	eb 0e		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00027	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0002b	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  0002e	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00032	48 03 10	 add	 rdx, QWORD PTR [rax]
$LN5@Tidy:

; 221  : 		return (*_IGfirst);

  00035	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00039	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003c	48 2b d1	 sub	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0003f	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00046	72 2a		 jb	 SHORT $LN26@Tidy

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00048	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  0004c	48 3b c2	 cmp	 rax, rdx
  0004f	76 5e		 jbe	 SHORT $_Invalid_parameter$48

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00051	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00054	f6 c1 1f	 test	 cl, 31
  00057	75 56		 jne	 SHORT $_Invalid_parameter$48

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00059	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0005d	48 3b c1	 cmp	 rax, rcx
  00060	73 4d		 jae	 SHORT $_Invalid_parameter$48

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00062	48 2b c8	 sub	 rcx, rax
  00065	48 83 e9 08	 sub	 rcx, 8
  00069	48 83 f9 1f	 cmp	 rcx, 31
  0006d	77 40		 ja	 SHORT $_Invalid_parameter$48

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0006f	48 8b c8	 mov	 rcx, rax
$LN26@Tidy:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00072	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN23@Tidy:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 252  : 		*_IGfirst = _First;

  00077	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0007b	33 c9		 xor	 ecx, ecx
  0007d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 253  : 		*_IGnext = _Next;

  00080	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00084	48 89 08	 mov	 QWORD PTR [rax], rcx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00087	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0008b	89 08		 mov	 DWORD PTR [rax], ecx

; 293  : 		*_IPfirst = _First;

  0008d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00091	48 89 08	 mov	 QWORD PTR [rax], rcx

; 294  : 		*_IPnext = _First;

  00094	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00098	48 89 08	 mov	 QWORD PTR [rax], rcx

; 295  : 		*_IPcount = (int)(_Last - _First);

  0009b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0009f	89 08		 mov	 DWORD PTR [rax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

  000a1	83 63 70 fe	 and	 DWORD PTR [rbx+112], -2
  000a5	48 89 4b 68	 mov	 QWORD PTR [rbx+104], rcx

; 346  : 		}

  000a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ad	5b		 pop	 rbx
  000ae	c3		 ret	 0
$_Invalid_parameter$48:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000b5	cc		 int	 3
$LN46@Tidy:
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_Nul$74 = 32
_Str$75 = 32
_Str$76 = 32
__$ArrayPad$ = 64
this$ = 96
__$ReturnUdt$ = 104
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT

; 93   : 		{	// return string copy of character array

$LN533:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  00019	44 8b 41 70	 mov	 r8d, DWORD PTR [rcx+112]
  0001d	48 8b da	 mov	 rbx, rdx
  00020	41 f6 c0 02	 test	 r8b, 2
  00024	75 6b		 jne	 SHORT $LN2@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 236  : 		return (*_IPnext);

  00026	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0002a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002d	48 85 d2	 test	 rdx, rdx
  00030	74 5f		 je	 SHORT $LN2@str

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00032	48 8b 79 68	 mov	 rdi, QWORD PTR [rcx+104]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 231  : 		return (*_IPfirst);

  00036	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  0003a	48 3b fa	 cmp	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  0003d	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00045	48 8d 4c 24 20	 lea	 rcx, QWORD PTR _Str$76[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  0004a	48 0f 42 fa	 cmovb	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 231  : 		return (*_IPfirst);

  0004e	4c 8b 08	 mov	 r9, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00051	49 2b f9	 sub	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00054	c6 44 24 20 00	 mov	 BYTE PTR _Str$76[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  00059	f3 0f 7f 44 24
	30		 movdqu	 XMMWORD PTR _Str$76[rsp+16], xmm0

; 2420 : 		if (_Count <= _My_data._Myres)

  0005f	48 83 ff 0f	 cmp	 rdi, 15
  00063	77 1d		 ja	 SHORT $LN47@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00065	4c 8b c7	 mov	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  00068	48 89 7c 24 30	 mov	 QWORD PTR _Str$76[rsp+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0006d	49 8b d1	 mov	 rdx, r9
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00076	c6 44 3c 20 00	 mov	 BYTE PTR _Str$76[rsp+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0007b	0f 10 4c 24 30	 movups	 xmm1, XMMWORD PTR _Str$76[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 98   : 			return (_Str);

  00080	eb 7c		 jmp	 SHORT $LN531@str
$LN47@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00082	48 8b d7	 mov	 rdx, rdi
  00085	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0008a	0f 10 4c 24 30	 movups	 xmm1, XMMWORD PTR _Str$76[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 98   : 			return (_Str);

  0008f	eb 6d		 jmp	 SHORT $LN531@str
$LN2@str:

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  00091	41 f6 c0 04	 test	 r8b, 4
  00095	75 5b		 jne	 SHORT $LN4@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 226  : 		return (*_IGnext);

  00097	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  0009b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0009e	48 85 d2	 test	 rdx, rdx
  000a1	74 4f		 je	 SHORT $LN4@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  000a3	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  000a7	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  000af	4c 8b 08	 mov	 r9, QWORD PTR [rax]

; 241  : 		return (*_IGnext + *_IGcount);

  000b2	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000b6	48 8d 4c 24 20	 lea	 rcx, QWORD PTR _Str$75[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\streambuf

; 221  : 		return (*_IGfirst);

  000bb	48 63 38	 movsxd	 rdi, DWORD PTR [rax]

; 241  : 		return (*_IGnext + *_IGcount);

  000be	49 2b f9	 sub	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000c1	c6 44 24 20 00	 mov	 BYTE PTR _Str$75[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

  000c6	48 03 fa	 add	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3683 : 		_My_data._Mysize = 0;

  000c9	f3 0f 7f 44 24
	30		 movdqu	 XMMWORD PTR _Str$75[rsp+16], xmm0

; 2420 : 		if (_Count <= _My_data._Myres)

  000cf	48 83 ff 0f	 cmp	 rdi, 15
  000d3	77 ad		 ja	 SHORT $LN47@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000d5	4c 8b c7	 mov	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  000d8	48 89 7c 24 30	 mov	 QWORD PTR _Str$75[rsp+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  000dd	49 8b d1	 mov	 rdx, r9
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  000e6	c6 44 3c 20 00	 mov	 BYTE PTR _Str$75[rsp+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000eb	0f 10 4c 24 30	 movups	 xmm1, XMMWORD PTR _Str$76[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 98   : 			return (_Str);

  000f0	eb 0c		 jmp	 SHORT $LN531@str
$LN4@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000f2	0f 10 0d 00 00
	00 00		 movups	 xmm1, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000f9	c6 44 24 20 00	 mov	 BYTE PTR _Nul$74[rsp], 0
$LN531@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000fe	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR _Nul$74[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 108  : 			return (_Nul);

  00103	48 8b c3	 mov	 rax, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00106	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00109	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream

; 110  : 		}

  0010d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00112	48 33 cc	 xor	 rcx, rsp
  00115	e8 00 00 00 00	 call	 __security_check_cookie
  0011a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0011f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00123	5f		 pop	 rdi
  00124	c3		 ret	 0
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
_TEXT	SEGMENT
$T6 = 32
this$ = 64
_Mode$dead$ = 72
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

$LN51:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T6[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00018	90		 npad	 1
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00020	48 89 03	 mov	 QWORD PTR [rbx], rax

; 311  : 		_Seekhigh = 0;

  00023	33 c0		 xor	 eax, eax
  00025	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 312  : 		_Mystate = _State;

  00029	89 43 70	 mov	 DWORD PTR [rbx+112], eax

; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}

  0002c	48 8b c3	 mov	 rax, rbx
  0002f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00033	5b		 pop	 rbx
  00034	c3		 ret	 0
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
this$ = 64
_Mode$dead$ = 72
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
this$ = 64
_Mode$dead$ = 72
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 1054 : 		{	// allocate array of _Count elements

$LN18:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 78   : 	if (_Count == 0)

  00004	48 85 d2	 test	 rdx, rdx
  00007	75 09		 jne	 SHORT $LN5@allocate

; 79   : 		{
; 80   : 		return (nullptr);

  00009	33 c9		 xor	 ecx, ecx

; 1055 : 		return (static_cast<_Ty *>(_Allocate(_Count, sizeof(_Ty), alignof(_Ty))));

  0000b	8b c1		 mov	 eax, ecx

; 1056 : 		}

  0000d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00011	c3		 ret	 0
$LN5@allocate:

; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00012	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00019	72 22		 jb	 SHORT $LN6@allocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  0001b	48 8d 4a 27	 lea	 rcx, QWORD PTR [rdx+39]

; 117  : 			if (_Block_size <= _User_size)

  0001f	48 3b ca	 cmp	 rcx, rdx
  00022	76 29		 jbe	 SHORT $LN16@allocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00024	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00029	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  0002d	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00031	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 1055 : 		return (static_cast<_Ty *>(_Allocate(_Count, sizeof(_Ty), alignof(_Ty))));

  00035	48 8b c1	 mov	 rax, rcx

; 1056 : 		}

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	c3		 ret	 0
$LN6@allocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  0003d	48 8b ca	 mov	 rcx, rdx
  00040	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00045	48 8b c8	 mov	 rcx, rax

; 1056 : 		}

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
$LN16@allocate:

; 119  : 				_Traits::_Fail();	// report no memory

  0004d	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  00052	cc		 int	 3
$LN15@allocate:
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 1049 : 		{	// deallocate object at _Ptr

$LN22:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c2	 mov	 rax, rdx

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00007	49 81 f8 00 10
	00 00		 cmp	 r8, 4096		; 00001000H
  0000e	72 29		 jb	 SHORT $LN6@deallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00010	49 8d 48 27	 lea	 rcx, QWORD PTR [r8+39]
  00014	49 3b c8	 cmp	 rcx, r8
  00017	76 2f		 jbe	 SHORT $_Invalid_parameter$23

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00019	4c 8b c1	 mov	 r8, rcx

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0001c	a8 1f		 test	 al, 31
  0001e	75 28		 jne	 SHORT $_Invalid_parameter$23

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00020	48 8b 4a f8	 mov	 rcx, QWORD PTR [rdx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00024	48 3b ca	 cmp	 rcx, rdx
  00027	73 1f		 jae	 SHORT $_Invalid_parameter$23

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00029	48 2b c1	 sub	 rax, rcx
  0002c	48 83 e8 08	 sub	 rax, 8
  00030	48 83 f8 1f	 cmp	 rax, 31
  00034	77 12		 ja	 SHORT $_Invalid_parameter$23

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00036	48 8b c1	 mov	 rax, rcx
$LN6@deallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00039	49 8b d0	 mov	 rdx, r8
  0003c	48 8b c8	 mov	 rcx, rax

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));
; 1051 : 		}

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00043	e9 00 00 00 00	 jmp	 ??3@YAXPEAX_K@Z		; operator delete
$_Invalid_parameter$23:

; 239  : 			}
; 240  : 		return;
; 241  : 		}
; 242  : 
; 243  : _Invalid_parameter:
; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0004e	cc		 int	 3
$LN21@deallocate:
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT

; 63   : 		return (_Myoff + _Fpos);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 03 01	 add	 rax, QWORD PTR [rcx]

; 64   : 		}

  00007	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?seekpos@?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?seekpos@?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::seekpos, COMDAT

; 58   : 		return (_Fpos);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 59   : 		}

  00004	c3		 ret	 0
?seekpos@?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT

; 48   : 		return (_Mystate);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 89 02	 mov	 QWORD PTR [rdx], rax
  00007	48 8b c2	 mov	 rax, rdx

; 49   : 		}

  0000a	c3		 ret	 0
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
this$ = 8
_State$ = 16
_Fileposition$ = 24
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 42   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  00000	48 c7 01 00 00
	00 00		 mov	 QWORD PTR [rcx], 0

; 44   : 		}

  00007	48 8b c1	 mov	 rax, rcx
  0000a	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8
  0000e	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
  00012	c3		 ret	 0
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 37   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  00000	33 c0		 xor	 eax, eax
  00002	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00005	48 c7 41 08 00
	00 00 00	 mov	 QWORD PTR [rcx+8], 0
  0000d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 39   : 		}

  00011	48 8b c1	 mov	 rax, rcx
  00014	c3		 ret	 0
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??0param_type@?$uniform_int@H@std@@QEAA@HH@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
??0param_type@?$uniform_int@H@std@@QEAA@HH@Z PROC	; std::uniform_int<int>::param_type::param_type, COMDAT

; 2224 : 			_Min = _Min0;

  00000	89 11		 mov	 DWORD PTR [rcx], edx

; 2196 : 			{	// construct from parameters
; 2197 : 			_Init(_Min0, _Max0);
; 2198 : 			}

  00002	48 8b c1	 mov	 rax, rcx

; 2225 : 			_Max = _Max0;

  00005	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d

; 2196 : 			{	// construct from parameters
; 2197 : 			_Init(_Min0, _Max0);
; 2198 : 			}

  00009	c3		 ret	 0
??0param_type@?$uniform_int@H@std@@QEAA@HH@Z ENDP	; std::uniform_int<int>::param_type::param_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?seed@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAAX_K0@Z
_TEXT	SEGMENT
this$ = 8
_X0$ = 16
_Fx$dead$ = 24
?seed@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAAX_K0@Z PROC ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::seed, COMDAT

; 1309 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00000	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  00004	4c 8d 49 10	 lea	 r9, QWORD PTR [rcx+16]
  00008	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000e	41 ba 37 01 00
	00		 mov	 r10d, 311		; 00000137H
  00014	49 bb 2d 7f 95
	4c 2d f4 51 58	 mov	 r11, 6364136223846793005 ; 5851f42d4c957f2dH
  0001e	66 90		 npad	 2
$LL4@seed:

; 1310 : 		for (int _Ix = 1; _Ix < _Nx; ++_Ix)
; 1311 : 			_Prev = this->_Ax[_Ix] =

  00020	48 8b c2	 mov	 rax, rdx
  00023	4d 8d 49 08	 lea	 r9, QWORD PTR [r9+8]
  00027	48 c1 e8 3e	 shr	 rax, 62			; 0000003eH
  0002b	48 33 d0	 xor	 rdx, rax
  0002e	49 0f af d3	 imul	 rdx, r11
  00032	49 03 d0	 add	 rdx, r8
  00035	49 ff c0	 inc	 r8
  00038	49 89 51 f8	 mov	 QWORD PTR [r9-8], rdx
  0003c	49 83 ea 01	 sub	 r10, 1
  00040	75 de		 jne	 SHORT $LL4@seed

; 1312 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;
; 1313 : 		this->_Idx = _Nx;

  00042	c7 01 38 01 00
	00		 mov	 DWORD PTR [rcx], 312	; 00000138H

; 1314 : 		}

  00048	c3		 ret	 0
?seed@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAAX_K0@Z ENDP ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::seed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 105  : 			{	// destroy after unlocking

$LN9:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2

; 106  : 			if (_Myostr.rdbuf() != 0)

  0000d	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00017	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
  0001c	48 85 c9	 test	 rcx, rcx
  0001f	74 07		 je	 SHORT $LN2@Sentry_bas

; 107  : 				_Myostr.rdbuf()->_Unlock();

  00021	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00024	ff 50 10	 call	 QWORD PTR [rax+16]
  00027	90		 npad	 1
$LN2@Sentry_bas:

; 108  : 			}

  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 99   : 			{	// lock the stream buffer, if there

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 98   : 			: _Myostr(_Ostr)

  00006	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 99   : 			{	// lock the stream buffer, if there

  00009	48 8b d9	 mov	 rbx, rcx

; 100  : 			if (_Myostr.rdbuf() != 0)

  0000c	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000f	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  00013	49 8b 4c 10 48	 mov	 rcx, QWORD PTR [r8+rdx+72]
  00018	48 85 c9	 test	 rcx, rcx
  0001b	74 06		 je	 SHORT $LN8@Sentry_bas

; 101  : 				_Myostr.rdbuf()->_Lock();

  0001d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00020	ff 50 08	 call	 QWORD PTR [rax+8]
$LN8@Sentry_bas:

; 102  : 			}

  00023	48 8b c3	 mov	 rax, rbx
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT

; 352  : 		return (_Myval2);

  00000	48 8b c1	 mov	 rax, rcx

; 353  : 		}

  00003	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT

; 347  : 		return (_Myval2);

  00000	48 8b c1	 mov	 rax, rcx

; 348  : 		}

  00003	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 332  : 		return (*this);

  00000	48 8b c1	 mov	 rax, rcx

; 333  : 		}

  00003	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 327  : 		return (*this);

  00000	48 8b c1	 mov	 rax, rcx

; 328  : 		}

  00003	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ
_TEXT	SEGMENT
this$ = 8
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT

; 1211 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1212 : 		_IDL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1213 : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 1214 : 		_IDL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1215 : 			" invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1216 : 		const auto _Contptr = _Mycont->_Myptr();
; 1217 : 		const auto _Rawptr = _Unfancy(_Ptr);
; 1218 : 		_IDL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1219 : 			"cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1220 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 1221 : 
; 1222 : 		_Analysis_assume_(_Ptr);
; 1223 : 		return (*_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1224 : 		}

  00003	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pstring$dead$ = 24
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1202 : 		: _Ptr(_Parg)

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 1415 : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 1624 : 		{	// report an out_of_range error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1625 : 		_Xout_of_range("invalid string position");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
  00011	cc		 int	 3
$LN3@Xran:
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 956  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	48 83 c8 ff	 or	 rax, -1

; 957  : 		}

  00004	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
_TEXT	SEGMENT
this$ = 48
_Right$dead$ = 56
_Roff$dead$ = 64
_Count$dead$ = 72
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2395 : 		{	// assign _Right [_Roff, _Roff + _Count)

$LN51:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1609 : 		if (_Mysize < _Off)

  00006	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 2395 : 		{	// assign _Right [_Roff, _Roff + _Count)

  0000d	48 8b d9	 mov	 rbx, rcx

; 1609 : 		if (_Mysize < _Off)

  00010	48 83 f8 05	 cmp	 rax, 5
  00014	0f 82 89 00 00
	00		 jb	 $LN49@assign

; 1630 : 		return (_Min_value(_Size, _Mysize - _Off));

  0001a	48 83 c0 fb	 add	 rax, -5
  0001e	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00023	48 83 cf ff	 or	 rdi, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00027	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0002e	48 3b c7	 cmp	 rax, rdi
  00031	48 0f 42 f8	 cmovb	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00035	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 2420 : 		if (_Count <= _My_data._Myres)

  0003d	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]

; 1594 : 		if (_Large_string_engaged())

  00041	4c 0f 43 0d 00
	00 00 00	 cmovae	 r9, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00049	49 83 c1 05	 add	 r9, 5

; 2420 : 		if (_Count <= _My_data._Myres)

  0004d	48 3b f8	 cmp	 rdi, rax
  00050	77 3b		 ja	 SHORT $LN27@assign

; 1582 : 		value_type * _Result = _Bx._Buf;

  00052	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00057	48 8b f1	 mov	 rsi, rcx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0005a	48 83 f8 10	 cmp	 rax, 16

; 1583 : 		if (_Large_string_engaged())

  0005e	72 03		 jb	 SHORT $LN36@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00060	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN36@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2423 : 			_My_data._Mysize = _Count;

  00063	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00067	4c 8b c7	 mov	 r8, rdi
  0006a	48 8b ce	 mov	 rcx, rsi
  0006d	49 8b d1	 mov	 rdx, r9
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 442  : 		_Left = _Right;

  00076	c6 04 37 00	 mov	 BYTE PTR [rdi+rsi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0007a	48 8b c3	 mov	 rax, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0007d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00082	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2400 : 		}

  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5b		 pop	 rbx
  0008c	c3		 ret	 0
$LN27@assign:

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0008d	48 8b d7	 mov	 rdx, rdi
  00090	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 2399 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00095	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2429 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0009a	48 8b d8	 mov	 rbx, rax

; 2400 : 		}

  0009d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a1	5b		 pop	 rbx
  000a2	c3		 ret	 0
$LN49@assign:

; 1611 : 			_Xran();

  000a3	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  000a8	cc		 int	 3
$LN48@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAHH@Z
_TEXT	SEGMENT
this$dead$ = 8
_Mode$dead$ = 16
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT

; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);

  00000	33 c0		 xor	 eax, eax

; 367  : 		}

  00002	c3		 ret	 0
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$dead$ = 16
_Count$dead$ = 24
_State$ = 32
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init, COMDAT

; 311  : 		_Seekhigh = 0;

  00000	48 c7 41 68 00
	00 00 00	 mov	 QWORD PTR [rcx+104], 0

; 312  : 		_Mystate = _State;

  00008	44 89 49 70	 mov	 DWORD PTR [rcx+112], r9d

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}

  0000c	c3		 ret	 0
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 1039 : 		{	// construct default allocator (do nothing)
; 1040 : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?_Init@param_type@?$uniform_int@H@std@@QEAAXHH@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
?_Init@param_type@?$uniform_int@H@std@@QEAAXHH@Z PROC	; std::uniform_int<int>::param_type::_Init, COMDAT

; 2222 : 			_RNG_ASSERT(_Min0 <= _Max0,
; 2223 : 				"invalid min and max arguments for uniform_int");
; 2224 : 			_Min = _Min0;

  00000	89 11		 mov	 DWORD PTR [rcx], edx

; 2225 : 			_Max = _Max0;

  00002	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d

; 2226 : 			}

  00006	c3		 ret	 0
?_Init@param_type@?$uniform_int@H@std@@QEAAXHH@Z ENDP	; std::uniform_int<int>::param_type::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pstring$dead$ = 24
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1202 : 		: _Ptr(_Parg)

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 1204 : 		this->_Adopt(_Pstring);
; 1205 : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 504  : 	{	// get facet reference from locale

$LN25:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	57		 push	 rdi
  00004	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00008	49 c7 43 b8 fe
	ff ff ff	 mov	 QWORD PTR [r11-72], -2
  00010	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00014	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00027	48 8b f1	 mov	 rsi, rcx

; 505  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  0002a	33 d2		 xor	 edx, edx
  0002c	49 8d 4b e0	 lea	 rcx, QWORD PTR [r11-32]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00036	90		 npad	 1

; 506  : 		const locale::facet *_Psave =
; 507  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  00037	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::ctype<char> >::_Psave
  0003e	48 89 44 24 40	 mov	 QWORD PTR _Psave$3[rsp], rax

; 508  : 
; 509  : 		size_t _Id = _Facet::id;

  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??Bid@locale@std@@QEAA_KXZ
  00050	48 8b f8	 mov	 rdi, rax

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00053	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00057	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  0005b	73 0f		 jae	 SHORT $LN15@use_facet
  0005d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00061	48 8b 1c f9	 mov	 rbx, QWORD PTR [rcx+rdi*8]

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00065	48 85 db	 test	 rbx, rbx
  00068	75 5f		 jne	 SHORT $LN7@use_facet
  0006a	eb 02		 jmp	 SHORT $LN19@use_facet
$LN15@use_facet:

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0006c	33 db		 xor	 ebx, ebx
$LN19@use_facet:

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0006e	80 78 24 00	 cmp	 BYTE PTR [rax+36], 0
  00072	74 14		 je	 SHORT $LN12@use_facet

; 433  : 			return (_Facptr);	// found facet or not transparent
; 434  : 		else
; 435  : 			{	// look in current locale
; 436  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ

; 437  : 			return (_Id < _Ptr0->_Facetcount

  0007a	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  0007e	73 0d		 jae	 SHORT $LN20@use_facet
  00080	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00084	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]
$LN12@use_facet:

; 510  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 511  : 
; 512  : 		if (_Pf != 0)

  00088	48 85 db	 test	 rbx, rbx
  0008b	75 3c		 jne	 SHORT $LN7@use_facet
$LN20@use_facet:

; 513  : 			;	// got facet from locale
; 514  : 		else if (_Psave != 0)

  0008d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR _Psave$3[rsp]
  00092	48 85 db	 test	 rbx, rbx
  00095	75 32		 jne	 SHORT $LN7@use_facet

; 515  : 			_Pf = _Psave;	// lazy facet already allocated
; 516  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  00097	48 8b d6	 mov	 rdx, rsi
  0009a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Psave$3[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
  000a5	48 83 f8 ff	 cmp	 rax, -1
  000a9	74 4c		 je	 SHORT $LN24@use_facet

; 521  : 
; 522  :  #else /* _HAS_EXCEPTIONS */
; 523  : 			abort();	// lazy disallowed
; 524  :  #endif /* _HAS_EXCEPTIONS */
; 525  : 
; 526  : 		else
; 527  : 			{	// queue up lazy facet for destruction
; 528  : 			_Pf = _Psave;

  000ab	48 8b 5c 24 40	 mov	 rbx, QWORD PTR _Psave$3[rsp]

; 529  : 			_Facetptr<_Facet>::_Psave = _Psave;

  000b0	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB, rbx ; std::_Facetptr<std::ctype<char> >::_Psave

; 530  : 
; 531  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 532  : 			_Pfmod->_Incref();

  000b7	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  000ba	48 8b cb	 mov	 rcx, rbx
  000bd	ff 52 08	 call	 QWORD PTR [rdx+8]

; 533  : 
; 534  :  #if defined(_M_CEE)
; 535  : 			_Facet_Register_m(_Pfmod);
; 536  : 
; 537  :  #else /* defined(_M_CEE) */
; 538  : 			_Facet_Register(_Pfmod);

  000c0	48 8b cb	 mov	 rcx, rbx
  000c3	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register
  000c8	90		 npad	 1
$LN7@use_facet:

; 539  :  #endif /* defined(_M_CEE) */
; 540  : 			}
; 541  : 
; 542  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000c9	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$4[rsp]
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000d4	48 8b c3	 mov	 rax, rbx

; 543  : 	_END_LOCK()
; 544  : 	}	// end of use_facet body

  000d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000dc	48 33 cc	 xor	 rcx, rsp
  000df	e8 00 00 00 00	 call	 __security_check_cookie
  000e4	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  000e9	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  000f1	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000f5	5f		 pop	 rdi
  000f6	c3		 ret	 0
$LN24@use_facet:

; 517  : 
; 518  :  #if _HAS_EXCEPTIONS
; 519  : 
; 520  : 			_THROW(bad_cast{});	// lazy disallowed

  000f7	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  000fc	e8 00 00 00 00	 call	 ??0bad_cast@std@@QEAA@XZ ; std::bad_cast::bad_cast
  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
  00108	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  0010d	e8 00 00 00 00	 call	 _CxxThrowException
  00112	cc		 int	 3
$LN21@use_facet:
??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$4[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$4[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
_TEXT	SEGMENT
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Ch$ = 120
_State$ = 128
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 816  : 	{	// insert a char into char stream

$LN114:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00011	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T29[rsp], -2
  0001a	48 89 5c 24 78	 mov	 QWORD PTR [rsp+120], rbx
  0001f	44 0f b6 e2	 movzx	 r12d, dl
  00023	48 8b f1	 mov	 rsi, rcx

; 817  : 	typedef char _Elem;
; 818  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 819  : 	ios_base::iostate _State = ios_base::goodbit;

  00026	33 db		 xor	 ebx, ebx
  00028	89 9c 24 80 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx

; 98   : 			: _Myostr(_Ostr)

  0002f	4c 8b f9	 mov	 r15, rcx
  00032	48 89 4c 24 28	 mov	 QWORD PTR _Ok$[rsp], rcx

; 100  : 			if (_Myostr.rdbuf() != 0)

  00037	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  0003a	49 63 40 04	 movsxd	 rax, DWORD PTR [r8+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0003e	48 8b 4c 08 48	 mov	 rcx, QWORD PTR [rax+rcx+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

  00043	48 85 c9	 test	 rcx, rcx
  00046	74 09		 je	 SHORT $LN27@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

  00048	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0004b	ff 50 08	 call	 QWORD PTR [rax+8]
  0004e	4d 8b 07	 mov	 r8, QWORD PTR [r15]
$LN27@operator:

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00051	49 63 48 04	 movsxd	 rcx, DWORD PTR [r8+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  00055	49 8b c0	 mov	 rax, r8
  00058	49 8b d0	 mov	 rdx, r8

; 338  : 		return (rdstate() == goodbit);

  0005b	83 7c 31 10 00	 cmp	 DWORD PTR [rcx+rsi+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00060	75 1b		 jne	 SHORT $LN23@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 79   : 		return (_Tiestr);

  00062	48 8b 4c 31 50	 mov	 rcx, QWORD PTR [rcx+rsi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00067	48 85 c9	 test	 rcx, rcx
  0006a	74 11		 je	 SHORT $LN23@operator
  0006c	48 3b ce	 cmp	 rcx, rsi
  0006f	74 0c		 je	 SHORT $LN23@operator

; 123  : 				_Ostr.tie()->flush();

  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
  00077	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0007a	48 8b d0	 mov	 rdx, rax
$LN23@operator:

; 124  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  0007d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  00081	8b 44 31 10	 mov	 eax, DWORD PTR [rcx+rsi+16]

; 338  : 		return (rdstate() == goodbit);

  00085	85 c0		 test	 eax, eax
  00087	0f 94 44 24 30	 sete	 BYTE PTR _Ok$[rsp+8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 820  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	85 c0		 test	 eax, eax

; 821  : 
; 822  : 	if (_Ok)

  0008e	0f 85 bf 00 00
	00		 jne	 $LN20@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 422  : 		return (_Wide);

  00094	4c 8b 44 31 28	 mov	 r8, QWORD PTR [rcx+rsi+40]

; 377  : 		return (_Fmtfl);

  00099	8b 4c 31 18	 mov	 ecx, DWORD PTR [rcx+rsi+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 826  : 		_TRY_IO_BEGIN

  0009d	49 8d 40 ff	 lea	 rax, QWORD PTR [r8-1]
  000a1	33 ff		 xor	 edi, edi
  000a3	49 83 f8 01	 cmp	 r8, 1
  000a7	48 0f 4f f8	 cmovg	 rdi, rax

; 827  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000ab	81 e1 c0 01 00
	00		 and	 ecx, 448		; 000001c0H
  000b1	41 be 04 00 00
	00		 mov	 r14d, 4
  000b7	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000ba	74 37		 je	 SHORT $LN106@operator
  000bc	0f 1f 40 00	 npad	 4
$LL4@operator:

; 828  : 			for (; _State == ios_base::goodbit && 0 < _Pad;

  000c0	85 db		 test	 ebx, ebx
  000c2	75 7c		 jne	 SHORT $LN6@operator
  000c4	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000c7	48 85 ff	 test	 rdi, rdi
  000ca	7e 27		 jle	 SHORT $LN106@operator

; 830  : 				if (_Traits::eq_int_type(_Traits::eof(),

  000cc	48 63 42 04	 movsxd	 rax, DWORD PTR [rdx+4]
  000d0	0f b6 54 30 58	 movzx	 edx, BYTE PTR [rax+rsi+88]
  000d5	48 8b 4c 30 48	 mov	 rcx, QWORD PTR [rax+rsi+72]
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  000e0	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 830  : 				if (_Traits::eq_int_type(_Traits::eof(),

  000e3	41 0f 44 de	 cmove	 ebx, r14d
  000e7	89 9c 24 80 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx

; 829  : 				--_Pad)	// pad on left

  000ee	48 ff cf	 dec	 rdi
  000f1	eb cd		 jmp	 SHORT $LL4@operator
$LN106@operator:

; 831  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 832  : 					_State |= ios_base::badbit;
; 833  : 
; 834  : 		if (_State == ios_base::goodbit
; 835  : 			&& _Traits::eq_int_type(_Traits::eof(),

  000f3	48 63 42 04	 movsxd	 rax, DWORD PTR [rdx+4]
  000f7	41 0f b6 d4	 movzx	 edx, r12b
  000fb	48 8b 4c 30 48	 mov	 rcx, QWORD PTR [rax+rsi+72]
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  00106	83 f8 ff	 cmp	 eax, -1
  00109	41 0f 44 de	 cmove	 ebx, r14d
$LN111@operator:
  0010d	89 9c 24 80 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx

; 836  : 				_Ostr.rdbuf()->sputc(_Ch)))
; 837  : 			_State |= ios_base::badbit;
; 838  : 
; 839  : 		for (; _State == ios_base::goodbit && 0 < _Pad;

  00114	85 db		 test	 ebx, ebx
  00116	75 28		 jne	 SHORT $LN6@operator
  00118	48 85 ff	 test	 rdi, rdi
  0011b	7e 23		 jle	 SHORT $LN6@operator

; 841  : 			if (_Traits::eq_int_type(_Traits::eof(),

  0011d	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00120	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00124	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00129	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 467  : 		return (_Left == _Right);

  00134	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 841  : 			if (_Traits::eq_int_type(_Traits::eof(),

  00137	41 0f 44 de	 cmove	 ebx, r14d

; 840  : 			--_Pad)	// pad on right

  0013b	48 ff cf	 dec	 rdi
  0013e	eb cd		 jmp	 SHORT $LN111@operator
$LN6@operator:
  00140	eb 11		 jmp	 SHORT $LN20@operator
$LN21@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
  00142	48 8b 74 24 70	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  00147	8b 9c 24 80 00
	00 00		 mov	 ebx, DWORD PTR _State$[rsp]
  0014e	4c 8b 7c 24 28	 mov	 r15, QWORD PTR _Ok$[rsp]
$LN20@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 842  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 843  : 				_State |= ios_base::badbit;
; 844  : 		_CATCH_IO_(_Ostr)
; 845  : 		}
; 846  : 
; 847  : 	_Ostr.width(0);

  00153	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00156	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  0015a	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 848  : 	_Ostr.setstate(_State);

  00163	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00166	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0016a	48 03 ce	 add	 rcx, rsi
  0016d	45 33 c0	 xor	 r8d, r8d
  00170	8b d3		 mov	 edx, ebx
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00178	90		 npad	 1

; 130  : 			if (_STD uncaught_exceptions() == 0)

  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ
  0017f	85 c0		 test	 eax, eax
  00181	75 0a		 jne	 SHORT $LN86@operator

; 131  : 				{
; 132  : 				this->_Myostr._Osfx();

  00183	49 8b cf	 mov	 rcx, r15
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0018c	90		 npad	 1
$LN86@operator:

; 106  : 			if (_Myostr.rdbuf() != 0)

  0018d	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00190	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00194	4a 8b 4c 39 48	 mov	 rcx, QWORD PTR [rcx+r15+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 106  : 			if (_Myostr.rdbuf() != 0)

  00199	48 85 c9	 test	 rcx, rcx
  0019c	74 07		 je	 SHORT $LN90@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

  0019e	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001a1	ff 50 10	 call	 QWORD PTR [rax+16]
  001a4	90		 npad	 1
$LN90@operator:

; 849  : 	return (_Ostr);

  001a5	48 8b c6	 mov	 rax, rsi

; 850  : 	}

  001a8	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  001ad	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001b1	41 5f		 pop	 r15
  001b3	41 5e		 pop	 r14
  001b5	41 5c		 pop	 r12
  001b7	5f		 pop	 rdi
  001b8	5e		 pop	 rsi
  001b9	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Ch$ = 120
_State$ = 128
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Ch$ = 120
_State$ = 128
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Ch$ = 120
_State$ = 128
?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$10

; 842  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 843  : 				_State |= ios_base::badbit;
; 844  : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN21@catch$10
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Ch$ = 120
_State$ = 128
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Ch$ = 120
_State$ = 128
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Ch$ = 120
_State$ = 128
?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$10

; 844  : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN21@catch$10
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$10@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$10
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 770  : 	{	// insert NTBS into char stream

$LN114:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00011	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T28[rsp], -2
  0001a	48 89 5c 24 78	 mov	 QWORD PTR [rsp+120], rbx
  0001f	4c 8b fa	 mov	 r15, rdx
  00022	48 8b f1	 mov	 rsi, rcx

; 771  : 	typedef char _Elem;
; 772  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 773  : 	ios_base::iostate _State = ios_base::goodbit;

  00025	33 db		 xor	 ebx, ebx
  00027	89 9c 24 80 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0002e	49 83 ce ff	 or	 r14, -1
$LL108@operator:
  00032	49 ff c6	 inc	 r14
  00035	42 38 1c 32	 cmp	 BYTE PTR [rdx+r14], bl
  00039	75 f7		 jne	 SHORT $LL108@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 775  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  0003b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003e	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 422  : 		return (_Wide);

  00042	48 8b 7c 30 28	 mov	 rdi, QWORD PTR [rax+rsi+40]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 775  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  00047	48 85 ff	 test	 rdi, rdi
  0004a	7e 0a		 jle	 SHORT $LN17@operator
  0004c	49 3b fe	 cmp	 rdi, r14
  0004f	7e 05		 jle	 SHORT $LN17@operator
  00051	49 2b fe	 sub	 rdi, r14
  00054	eb 02		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00056	33 ff		 xor	 edi, edi
$LN18@operator:

; 98   : 			: _Myostr(_Ostr)

  00058	4c 8b e6	 mov	 r12, rsi
  0005b	48 89 74 24 28	 mov	 QWORD PTR _Ok$[rsp], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00060	48 8b 54 30 48	 mov	 rdx, QWORD PTR [rax+rsi+72]
  00065	4c 8b c1	 mov	 r8, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

  00068	48 85 d2	 test	 rdx, rdx
  0006b	74 0f		 je	 SHORT $LN38@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

  0006d	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00070	48 8b ca	 mov	 rcx, rdx
  00073	ff 50 08	 call	 QWORD PTR [rax+8]
  00076	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00079	4c 8b c1	 mov	 r8, rcx
$LN38@operator:

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0007c	4c 63 49 04	 movsxd	 r9, DWORD PTR [rcx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  00080	48 8b c1	 mov	 rax, rcx
  00083	49 8b d0	 mov	 rdx, r8

; 338  : 		return (rdstate() == goodbit);

  00086	41 83 7c 31 10
	00		 cmp	 DWORD PTR [r9+rsi+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0008c	75 1e		 jne	 SHORT $LN34@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 79   : 		return (_Tiestr);

  0008e	4d 8b 4c 31 50	 mov	 r9, QWORD PTR [r9+rsi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00093	4d 85 c9	 test	 r9, r9
  00096	74 14		 je	 SHORT $LN34@operator
  00098	4c 3b ce	 cmp	 r9, rsi
  0009b	74 0f		 je	 SHORT $LN34@operator

; 123  : 				_Ostr.tie()->flush();

  0009d	49 8b c9	 mov	 rcx, r9
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
  000a6	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000a9	48 8b d0	 mov	 rdx, rax
$LN34@operator:

; 124  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  000ac	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  000b0	8b 44 31 10	 mov	 eax, DWORD PTR [rcx+rsi+16]

; 338  : 		return (rdstate() == goodbit);

  000b4	85 c0		 test	 eax, eax
  000b6	0f 94 44 24 30	 sete	 BYTE PTR _Ok$[rsp+8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 777  : 	const typename _Myos::sentry _Ok(_Ostr);

  000bb	85 c0		 test	 eax, eax

; 778  : 
; 779  : 	if (!_Ok)

  000bd	74 0a		 je	 SHORT $LN8@operator

; 780  : 		_State |= ios_base::badbit;

  000bf	bb 04 00 00 00	 mov	 ebx, 4

; 781  : 	else

  000c4	e9 ac 00 00 00	 jmp	 $LN22@operator
$LN8@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 377  : 		return (_Fmtfl);

  000c9	8b 44 31 18	 mov	 eax, DWORD PTR [rcx+rsi+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 784  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000cd	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000d2	83 f8 40	 cmp	 eax, 64			; 00000040H
  000d5	74 29		 je	 SHORT $LN104@operator
$LL4@operator:

; 785  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000d7	48 85 ff	 test	 rdi, rdi
  000da	7e 21		 jle	 SHORT $LN3@operator

; 786  : 				if (_Traits::eq_int_type(_Traits::eof(),

  000dc	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000df	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000e3	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  000e8	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  000f3	83 f8 ff	 cmp	 eax, -1
  000f6	74 4e		 je	 SHORT $LN111@operator

; 785  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000f8	48 ff cf	 dec	 rdi
  000fb	eb da		 jmp	 SHORT $LL4@operator
$LN3@operator:

; 790  : 					break;
; 791  : 					}
; 792  : 
; 793  : 		if (_State == ios_base::goodbit
; 794  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  000fd	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
$LN104@operator:
  00100	48 63 42 04	 movsxd	 rax, DWORD PTR [rdx+4]
  00104	4d 8b c6	 mov	 r8, r14
  00107	49 8b d7	 mov	 rdx, r15
  0010a	48 8b 4c 30 48	 mov	 rcx, QWORD PTR [rax+rsi+72]
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  00115	49 3b c6	 cmp	 rax, r14
  00118	75 2c		 jne	 SHORT $LN111@operator
  0011a	66 0f 1f 44 00
	00		 npad	 6
$LL109@operator:

; 795  : 			_State |= ios_base::badbit;
; 796  : 
; 797  : 		if (_State == ios_base::goodbit)
; 798  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00120	48 85 ff	 test	 rdi, rdi
  00123	7e 2d		 jle	 SHORT $LN6@operator

; 799  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00125	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00128	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0012c	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00131	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  0013c	83 f8 ff	 cmp	 eax, -1
  0013f	74 05		 je	 SHORT $LN111@operator

; 795  : 			_State |= ios_base::badbit;
; 796  : 
; 797  : 		if (_State == ios_base::goodbit)
; 798  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00141	48 ff cf	 dec	 rdi
  00144	eb da		 jmp	 SHORT $LL109@operator
$LN111@operator:

; 787  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 788  : 					{	// insertion failed, quit
; 789  : 					_State |= ios_base::badbit;

  00146	bb 04 00 00 00	 mov	 ebx, 4
  0014b	89 9c 24 80 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx
$LN6@operator:

; 800  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 801  : 					{	// insertion failed, quit
; 802  : 					_State |= ios_base::badbit;
; 803  : 					break;
; 804  : 					}
; 805  : 		_Ostr.width(0);

  00152	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00155	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  00159	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
  00162	eb 11		 jmp	 SHORT $LN22@operator
$LN23@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
  00164	48 8b 74 24 70	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  00169	8b 9c 24 80 00
	00 00		 mov	 ebx, DWORD PTR _State$[rsp]
  00170	4c 8b 64 24 28	 mov	 r12, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 809  : 	_Ostr.setstate(_State);

  00175	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00178	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0017c	48 03 ce	 add	 rcx, rsi
  0017f	45 33 c0	 xor	 r8d, r8d
  00182	8b d3		 mov	 edx, ebx
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0018a	90		 npad	 1

; 130  : 			if (_STD uncaught_exceptions() == 0)

  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ
  00191	85 c0		 test	 eax, eax
  00193	75 0a		 jne	 SHORT $LN87@operator

; 131  : 				{
; 132  : 				this->_Myostr._Osfx();

  00195	49 8b cc	 mov	 rcx, r12
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0019e	90		 npad	 1
$LN87@operator:

; 106  : 			if (_Myostr.rdbuf() != 0)

  0019f	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  001a3	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  001a7	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 106  : 			if (_Myostr.rdbuf() != 0)

  001ac	48 85 c9	 test	 rcx, rcx
  001af	74 07		 je	 SHORT $LN91@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

  001b1	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001b4	ff 50 10	 call	 QWORD PTR [rax+16]
  001b7	90		 npad	 1
$LN91@operator:

; 810  : 	return (_Ostr);

  001b8	48 8b c6	 mov	 rax, rsi

; 811  : 	}

  001bb	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  001c0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001c4	41 5f		 pop	 r15
  001c6	41 5e		 pop	 r14
  001c8	41 5c		 pop	 r12
  001ca	5f		 pop	 rdi
  001cb	5e		 pop	 rsi
  001cc	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$2@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$2
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$2@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$2
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$9

; 806  : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$9
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$2@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$2
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$2@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$9

; 806  : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$9
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$9
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 981  : 	{	// insert newline and flush stream

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 982  : 	_Ostr.put(_Ostr.widen('\n'));

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	b2 0a		 mov	 dl, 10
  0000e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00012	48 03 cb	 add	 rcx, rbx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  0001b	0f b6 d0	 movzx	 edx, al
  0001e	48 8b cb	 mov	 rcx, rbx
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z

; 983  : 	_Ostr.flush();

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 984  : 	return (_Ostr);

  00030	48 8b c3	 mov	 rax, rbx

; 985  : 	}

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Istr$ = 8
_Str$ = 16
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 138  : 	return (_STD move(_Istr) >> _Str);

  00000	e9 00 00 00 00	 jmp	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z PROC ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3930 : 	{	// test for string vs. NTCTS inequality

$LN34:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00004	48 83 c8 ff	 or	 rax, -1
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL32@operator:
  00010	48 ff c0	 inc	 rax
  00013	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  00017	75 f7		 jne	 SHORT $LL32@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00019	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0001e	4c 8b c9	 mov	 r9, rcx

; 1594 : 		if (_Large_string_engaged())

  00021	72 03		 jb	 SHORT $LN18@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00023	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
$LN18@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00026	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0002a	4c 3b c0	 cmp	 r8, rax
  0002d	75 11		 jne	 SHORT $LN26@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0002f	49 8b c9	 mov	 rcx, r9
  00032	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00037	85 c0		 test	 eax, eax
  00039	75 05		 jne	 SHORT $LN26@operator

; 3932 : 	}

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
$LN26@operator:

; 3931 : 	return (!(_Left == _Right));

  00040	b0 01		 mov	 al, 1

; 3932 : 	}

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3900 : 	{	// test for string vs. NTCTS equality

$LN32:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00004	48 83 c8 ff	 or	 rax, -1
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL30@operator:
  00010	48 ff c0	 inc	 rax
  00013	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  00017	75 f7		 jne	 SHORT $LL30@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00019	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0001e	4c 8b c9	 mov	 r9, rcx

; 1594 : 		if (_Large_string_engaged())

  00021	72 03		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00023	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
$LN16@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00026	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0002a	4c 3b c0	 cmp	 r8, rax
  0002d	75 13		 jne	 SHORT $LN24@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0002f	49 8b c9	 mov	 rcx, r9
  00032	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00037	85 c0		 test	 eax, eax
  00039	75 07		 jne	 SHORT $LN24@operator

; 3901 : 	return (_Left._Equal(_Right));

  0003b	b0 01		 mov	 al, 1

; 3902 : 	}

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
$LN24@operator:

; 3901 : 	return (_Left._Equal(_Right));

  00042	32 c0		 xor	 al, al

; 3902 : 	}

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z
_TEXT	SEGMENT
this$ = 48
_Eng$dead$ = 56
??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z PROC ; std::uniform_int<int>::operator()<std::random_device>, COMDAT

; 2279 : 		{	// return next value

$LN93:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2328 : 		if (_Umax - _Umin == _Uty(-1))

  0000a	8b 59 04	 mov	 ebx, DWORD PTR [rcx+4]

; 2280 : 		return (_Eval(_Eng, _Par._Min, _Par._Max));

  0000d	8b 31		 mov	 esi, DWORD PTR [rcx]

; 2328 : 		if (_Umax - _Umin == _Uty(-1))

  0000f	2b de		 sub	 ebx, esi
  00011	83 fb ff	 cmp	 ebx, -1			; ffffffffH
  00014	75 13		 jne	 SHORT $LN4@operator

; 6410 : 		return (_Random_device());

  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  0001c	03 c6		 add	 eax, esi

; 2281 : 		}

  0001e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5e		 pop	 rsi
  00028	c3		 ret	 0
$LN4@operator:
  00029	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 2331 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  0002e	8d 7b 01	 lea	 edi, DWORD PTR [rbx+1]
$LL44@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3944 : 			_Udiff _Ret = 0;	// random bits

  00031	45 33 c0	 xor	 r8d, r8d

; 3945 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00034	33 c0		 xor	 eax, eax

; 3946 : 
; 3947 : 			while (_Mask < _Udiff(_Index - 1))

  00036	85 db		 test	 ebx, ebx
  00038	74 0c		 je	 SHORT $LN48@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  00040	44 8b c0	 mov	 r8d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3954 : 				_Mask |= _Bmask;

  00043	83 c8 ff	 or	 eax, -1			; ffffffffH
$LN48@operator:

; 3955 : 				}
; 3956 : 
; 3957 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3958 : 			if (_Ret / _Index < _Mask / _Index
; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00046	33 d2		 xor	 edx, edx
  00048	f7 f7		 div	 edi
  0004a	8b c8		 mov	 ecx, eax
  0004c	44 8b ca	 mov	 r9d, edx
  0004f	33 d2		 xor	 edx, edx
  00051	41 8b c0	 mov	 eax, r8d
  00054	f7 f7		 div	 edi
  00056	3b c1		 cmp	 eax, ecx
  00058	72 05		 jb	 SHORT $LN78@operator
  0005a	44 3b cb	 cmp	 r9d, ebx
  0005d	75 d2		 jne	 SHORT $LL44@operator
$LN78@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2281 : 		}

  0005f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3960 : 				return (_Ret % _Index);

  00064	33 d2		 xor	 edx, edx
  00066	41 8b c0	 mov	 eax, r8d
  00069	f7 f7		 div	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2280 : 		return (_Eval(_Eng, _Par._Min, _Par._Max));

  0006b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  00070	8d 04 16	 lea	 eax, DWORD PTR [rsi+rdx]

; 2281 : 		}

  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5e		 pop	 rsi
  00078	c3		 ret	 0
??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z ENDP ; std::uniform_int<int>::operator()<std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Left$ = 56
_Right$ = 64
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3824 : 	{	// return string + string

$LN203:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3825 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 3826 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  00006	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]
  00011	4d 8b c8	 mov	 r9, r8
  00014	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  00018	48 2b c1	 sub	 rax, rcx
  0001b	4c 8b d2	 mov	 r10, rdx
  0001e	4c 3b c0	 cmp	 r8, rax
  00021	76 19		 jbe	 SHORT $LN200@operator
  00023	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  00027	49 2b c0	 sub	 rax, r8
  0002a	48 3b c1	 cmp	 rax, rcx
  0002d	72 0d		 jb	 SHORT $LN200@operator

; 3828 : 	else
; 3829 : 		return (_STD move(_Right.insert(0, _Left)));

  0002f	4c 8b c2	 mov	 r8, rdx
  00032	49 8b c9	 mov	 rcx, r9
  00035	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  0003a	eb 15		 jmp	 SHORT $LN201@operator
$LN200@operator:

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0003c	49 83 79 18 10	 cmp	 QWORD PTR [r9+24], 16

; 1594 : 		if (_Large_string_engaged())

  00041	72 03		 jb	 SHORT $LN71@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00043	4d 8b 09	 mov	 r9, QWORD PTR [r9]
$LN71@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00046	49 8b d1	 mov	 rdx, r9
  00049	49 8b ca	 mov	 rcx, r10
  0004c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN201@operator:

; 1563 : 		_Mysize(0),

  00051	33 c9		 xor	 ecx, ecx
  00053	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 1564 : 		_Myres(0)

  00057	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0005b	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0005e	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00061	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00065	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00069	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0006d	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00075	88 08		 mov	 BYTE PTR [rax], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3827 : 		return (_STD move(_Left.append(_Right)));

  00077	48 8b c3	 mov	 rax, rbx

; 3830 : 	}

  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5b		 pop	 rbx
  0007f	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Left$dead$ = 56
_Right$ = 64
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3804 : 	{	// return string + string

$LN67:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b c0	 mov	 rax, r8
  00009	48 8b d9	 mov	 rbx, rcx

; 3805 : 	return (_STD move(_Right.insert(0, _Left)));

  0000c	48 8b c8	 mov	 rcx, rax
  0000f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00016	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1563 : 		_Mysize(0),

  0001b	33 c9		 xor	 ecx, ecx
  0001d	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 1564 : 		_Myres(0)

  00021	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00025	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00028	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  0002b	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0002f	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00033	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00037	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0003f	88 08		 mov	 BYTE PTR [rax], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3805 : 	return (_STD move(_Right.insert(0, _Left)));

  00041	48 8b c3	 mov	 rax, rbx

; 3806 : 	}

  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
_TEXT	SEGMENT
$T1 = 32
$T12 = 40
__$ReturnUdt$ = 80
_Left$ = 88
_Right$ = 96
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3730 : 	{	// return string + string

$LN81:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T12[rsp], -2
  00017	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  0001c	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00021	49 8b f8	 mov	 rdi, r8
  00024	48 8b f2	 mov	 rsi, rdx
  00027	48 8b d9	 mov	 rbx, rcx
  0002a	33 c0		 xor	 eax, eax
  0002c	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax

; 3683 : 		_My_data._Mysize = 0;

  00030	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00034	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0003c	88 01		 mov	 BYTE PTR [rcx], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3735 : 	return (_Ans);

  0003e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 3047 : 		return (this->_Get_data()._Mysize);

  00046	4c 8d 7a 10	 lea	 r15, QWORD PTR [rdx+16]
  0004a	4d 8d 70 10	 lea	 r14, QWORD PTR [r8+16]

; 3731 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3732 : 	_Ans.reserve(_Left.size() + _Right.size());

  0004e	49 8b 16	 mov	 rdx, QWORD PTR [r14]
  00051	49 03 17	 add	 rdx, QWORD PTR [r15]
  00054	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00059	48 83 7e 18 10	 cmp	 QWORD PTR [rsi+24], 16

; 1594 : 		if (_Large_string_engaged())

  0005e	72 03		 jb	 SHORT $LN57@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00060	48 8b 36	 mov	 rsi, QWORD PTR [rsi]
$LN57@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00063	4d 8b 07	 mov	 r8, QWORD PTR [r15]
  00066	48 8b d6	 mov	 rdx, rsi
  00069	48 8b cb	 mov	 rcx, rbx
  0006c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00071	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 1594 : 		if (_Large_string_engaged())

  00076	72 03		 jb	 SHORT $LN74@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00078	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
$LN74@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0007b	4d 8b 06	 mov	 r8, QWORD PTR [r14]
  0007e	48 8b d7	 mov	 rdx, rdi
  00081	48 8b cb	 mov	 rcx, rbx
  00084	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3735 : 	return (_Ans);

  00089	48 8b c3	 mov	 rax, rbx

; 3736 : 	}

  0008c	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00091	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00096	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009a	41 5f		 pop	 r15
  0009c	41 5e		 pop	 r14
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
  000a0	cc		 int	 3
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T12 = 40
__$ReturnUdt$ = 80
_Left$ = 88
_Right$ = 96
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T12 = 40
__$ReturnUdt$ = 80
_Left$ = 88
_Right$ = 96
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Left$ = 56
_Right$ = 64
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3859 : 	{	// return string + NTCTS

$LN75:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b c0	 mov	 rax, r8
  00009	4c 8b ca	 mov	 r9, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0000c	49 83 c8 ff	 or	 r8, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3859 : 	{	// return string + NTCTS

  00010	48 8b d9	 mov	 rbx, rcx
$LL73@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00013	49 ff c0	 inc	 r8
  00016	42 80 3c 00 00	 cmp	 BYTE PTR [rax+r8], 0
  0001b	75 f6		 jne	 SHORT $LL73@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0001d	48 8b d0	 mov	 rdx, rax
  00020	49 8b c9	 mov	 rcx, r9
  00023	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1563 : 		_Mysize(0),

  00028	33 c9		 xor	 ecx, ecx
  0002a	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 1564 : 		_Myres(0)

  0002e	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00032	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00035	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00038	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0003c	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00040	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00044	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0004c	88 08		 mov	 BYTE PTR [rax], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3860 : 	return (_STD move(_Left.append(_Right)));

  0004e	48 8b c3	 mov	 rax, rbx

; 3861 : 	}

  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
$T10 = 40
__$ReturnUdt$ = 64
_Left$dead$ = 72
_Right$ = 80
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3774 : 	{	// return string + NTCTS

$LN71:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T10[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0001d	49 8b f8	 mov	 rdi, r8
  00020	48 8b f1	 mov	 rsi, rcx
  00023	33 c0		 xor	 eax, eax
  00025	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax

; 3683 : 		_My_data._Mysize = 0;

  00029	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0002d	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00035	88 01		 mov	 BYTE PTR [rcx], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3781 : 	return (_Ans);

  00037	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  0003f	48 83 cb ff	 or	 rbx, -1
  00043	48 8b d3	 mov	 rdx, rbx
$LL69@operator:
  00046	48 ff c2	 inc	 rdx
  00049	41 80 3c 10 00	 cmp	 BYTE PTR [r8+rdx], 0
  0004e	75 f6		 jne	 SHORT $LL69@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3778 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00050	48 03 15 10 00
	00 00		 add	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00057	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00063	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1594 : 		if (_Large_string_engaged())

  0006b	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00073	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0007a	48 8b ce	 mov	 rcx, rsi
  0007d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LL68@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00082	48 ff c3	 inc	 rbx
  00085	80 3c 1f 00	 cmp	 BYTE PTR [rdi+rbx], 0
  00089	75 f7		 jne	 SHORT $LL68@operator
  0008b	4c 8b c3	 mov	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0008e	48 8b d7	 mov	 rdx, rdi
  00091	48 8b ce	 mov	 rcx, rsi
  00094	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3781 : 	return (_Ans);

  00099	48 8b c6	 mov	 rax, rsi

; 3782 : 	}

  0009c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000a1	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000a6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
  000ac	cc		 int	 3
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T10 = 40
__$ReturnUdt$ = 64
_Left$dead$ = 72
_Right$ = 80
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T10 = 40
__$ReturnUdt$ = 64
_Left$dead$ = 72
_Right$ = 80
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Left$ = 56
_Right$ = 64
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3869 : 	{	// return string + character

$LN89:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b da	 mov	 rbx, rdx

; 2976 : 		const size_type _Old_size = _My_data._Mysize;

  00010	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]

; 2977 : 		if (_Old_size < _My_data._Myres)

  00014	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00018	48 3b ca	 cmp	 rcx, rdx
  0001b	73 1f		 jae	 SHORT $LN6@operator

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  0001d	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00021	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00025	48 8b c3	 mov	 rax, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00028	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  0002c	72 03		 jb	 SHORT $LN15@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN15@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00031	44 88 04 08	 mov	 BYTE PTR [rax+rcx], r8b
  00035	c6 44 08 01 00	 mov	 BYTE PTR [rax+rcx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  0003a	eb 0c		 jmp	 SHORT $LN5@operator
$LN6@operator:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  0003c	45 0f b6 c8	 movzx	 r9d, r8b
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN5@operator:

; 1563 : 		_Mysize(0),

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 1564 : 		_Myres(0)

  0004e	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 2137 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00052	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]
  00055	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0
  00058	0f 10 4b 10	 movups	 xmm1, XMMWORD PTR [rbx+16]
  0005c	0f 11 4f 10	 movups	 XMMWORD PTR [rdi+16], xmm1

; 3683 : 		_My_data._Mysize = 0;

  00060	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00064	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0006c	88 03		 mov	 BYTE PTR [rbx], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3871 : 	return (_STD move(_Left));

  0006e	48 8b c7	 mov	 rax, rdi

; 3872 : 	}

  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Istr$ = 48
_Str$ = 56
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 158  : 	{	// get characters into string, discard newline

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  0000a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	48 8b da	 mov	 rbx, rdx
  00013	b2 0a		 mov	 dl, 10
  00015	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00019	48 03 cf	 add	 rcx, rdi
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  00022	48 8b d3	 mov	 rdx, rbx
  00025	48 8b cf	 mov	 rcx, rdi
  00028	44 0f b6 c0	 movzx	 r8d, al

; 160  : 	}

  0002c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00036	e9 00 00 00 00	 jmp	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
_TEXT	SEGMENT
$T1 = 32
$T10 = 40
__$ReturnUdt$ = 64
_Left$dead$ = 72
_Right$ = 80
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3744 : 	{	// return NTCTS + string

$LN69:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T10[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0001d	49 8b d8	 mov	 rbx, r8
  00020	48 8b f9	 mov	 rdi, rcx
  00023	33 c0		 xor	 eax, eax
  00025	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax

; 3683 : 		_My_data._Mysize = 0;

  00029	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3684 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0002d	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00035	88 01		 mov	 BYTE PTR [rcx], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3751 : 	return (_Ans);

  00037	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 3047 : 		return (this->_Get_data()._Mysize);

  0003f	49 8d 70 10	 lea	 rsi, QWORD PTR [r8+16]

; 3745 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3746 : 	using _Size_type = typename _String_type::size_type;
; 3747 : 	_String_type _Ans;
; 3748 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  00043	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00046	48 83 c2 05	 add	 rdx, 5
  0004a	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2356 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0004f	41 b8 05 00 00
	00		 mov	 r8d, 5
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  0005c	48 8b cf	 mov	 rcx, rdi
  0005f	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00064	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1594 : 		if (_Large_string_engaged())

  00069	72 03		 jb	 SHORT $LN62@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0006b	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN62@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2306 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0006e	4c 8b 06	 mov	 r8, QWORD PTR [rsi]
  00071	48 8b d3	 mov	 rdx, rbx
  00074	48 8b cf	 mov	 rcx, rdi
  00077	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3751 : 	return (_Ans);

  0007c	48 8b c7	 mov	 rax, rdi

; 3752 : 	}

  0007f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00084	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00089	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
  0008f	cc		 int	 3
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T10 = 40
__$ReturnUdt$ = 64
_Left$dead$ = 72
_Right$ = 80
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T10 = 40
__$ReturnUdt$ = 64
_Left$dead$ = 72
_Right$ = 80
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Ostr$ = 8
_Str$ = 16
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 3047 : 		return (this->_Get_data()._Mysize);

  00005	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]

; 1594 : 		if (_Large_string_engaged())

  00009	72 03		 jb	 SHORT $LN22@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000b	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN22@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  0000e	e9 00 00 00 00	 jmp	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0CA@@std@@YA_KAEAY0CA@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0CA@@std@@YA_KAEAY0CA@$$CBD@Z PROC		; std::size<char,32>, COMDAT

; 1611 : 	return (_Size);

  00000	b8 20 00 00 00	 mov	 eax, 32			; 00000020H

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0CA@@std@@YA_KAEAY0CA@$$CBD@Z ENDP		; std::size<char,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0CG@@std@@YA_KAEAY0CG@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0CG@@std@@YA_KAEAY0CG@$$CBD@Z PROC		; std::size<char,38>, COMDAT

; 1611 : 	return (_Size);

  00000	b8 26 00 00 00	 mov	 eax, 38			; 00000026H

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0CG@@std@@YA_KAEAY0CG@$$CBD@Z ENDP		; std::size<char,38>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BM@@std@@YA_KAEAY0BM@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BM@@std@@YA_KAEAY0BM@$$CBD@Z PROC		; std::size<char,28>, COMDAT

; 1611 : 	return (_Size);

  00000	b8 1c 00 00 00	 mov	 eax, 28

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BM@@std@@YA_KAEAY0BM@$$CBD@Z ENDP		; std::size<char,28>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BL@@std@@YA_KAEAY0BL@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BL@@std@@YA_KAEAY0BL@$$CBD@Z PROC		; std::size<char,27>, COMDAT

; 1611 : 	return (_Size);

  00000	b8 1b 00 00 00	 mov	 eax, 27

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BL@@std@@YA_KAEAY0BL@$$CBD@Z ENDP		; std::size<char,27>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BH@@std@@YA_KAEAY0BH@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BH@@std@@YA_KAEAY0BH@$$CBD@Z PROC		; std::size<char,23>, COMDAT

; 1611 : 	return (_Size);

  00000	b8 17 00 00 00	 mov	 eax, 23

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BH@@std@@YA_KAEAY0BH@$$CBD@Z ENDP		; std::size<char,23>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BB@@std@@YA_KAEAY0BB@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BB@@std@@YA_KAEAY0BB@$$CBD@Z PROC		; std::size<char,17>, COMDAT

; 1611 : 	return (_Size);

  00000	b8 11 00 00 00	 mov	 eax, 17

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BB@@std@@YA_KAEAY0BB@$$CBD@Z ENDP		; std::size<char,17>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0O@@std@@YA_KAEAY0O@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0O@@std@@YA_KAEAY0O@$$CBD@Z PROC		; std::size<char,14>, COMDAT

; 1611 : 	return (_Size);

  00000	b8 0e 00 00 00	 mov	 eax, 14

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0O@@std@@YA_KAEAY0O@$$CBD@Z ENDP		; std::size<char,14>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BE@@std@@YA_KAEAY0BE@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BE@@std@@YA_KAEAY0BE@$$CBD@Z PROC		; std::size<char,20>, COMDAT

; 1611 : 	return (_Size);

  00000	b8 14 00 00 00	 mov	 eax, 20

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BE@@std@@YA_KAEAY0BE@$$CBD@Z ENDP		; std::size<char,20>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$size@D$0BN@@std@@YA_KAEAY0BN@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BN@@std@@YA_KAEAY0BN@$$CBD@Z PROC		; std::size<char,29>, COMDAT

; 1611 : 	return (_Size);

  00000	b8 1d 00 00 00	 mov	 eax, 29

; 1612 : 	}

  00005	c3		 ret	 0
??$size@D$0BN@@std@@YA_KAEAY0BN@$$CBD@Z ENDP		; std::size<char,29>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
_TEXT	SEGMENT
_Haystack$ = 48
_Hay_size$ = 56
_Start_at$dead$ = 64
_Needle$ = 72
_Needle_size$ = 80
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 56   : 	{	// search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at

$LN26:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 56		 push	 r14
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00010	48 8b 74 24 50	 mov	 rsi, QWORD PTR _Needle_size$[rsp]
  00015	49 8b f9	 mov	 rdi, r9
  00018	4c 8b f1	 mov	 r14, rcx
  0001b	48 3b f2	 cmp	 rsi, rdx
  0001e	0f 87 a3 00 00
	00		 ja	 $LN6@Traits_fin

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)

  00024	48 85 f6	 test	 rsi, rsi
  00027	75 13		 jne	 SHORT $LN7@Traits_fin

; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);

  00029	33 c0		 xor	 eax, eax

; 86   : 			}
; 87   : 		}
; 88   : 	}

  0002b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00030	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	41 5e		 pop	 r14
  0003b	c3		 ret	 0
$LN7@Traits_fin:
  0003c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00041	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp

; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00046	49 8b ee	 mov	 rbp, r14
  00049	48 2b ee	 sub	 rbp, rsi
  0004c	48 03 ea	 add	 rbp, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  0004f	41 0f be 11	 movsx	 edx, BYTE PTR [r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00053	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
  00057	4d 2b c6	 sub	 r8, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00060	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  00063	48 85 c0	 test	 rax, rax
  00066	74 38		 je	 SHORT $LN18@Traits_fin
  00068	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@Traits_fin:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00070	4c 8b c6	 mov	 r8, rsi
  00073	48 8b d7	 mov	 rdx, rdi
  00076	48 8b cb	 mov	 rcx, rbx
  00079	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  0007e	85 c0		 test	 eax, eax
  00080	74 3d		 je	 SHORT $LN19@Traits_fin
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  00082	0f be 17	 movsx	 edx, BYTE PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00085	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
  00089	48 ff c3	 inc	 rbx
  0008c	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 425  : 		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));

  0008f	48 8b cb	 mov	 rcx, rbx
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00098	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 78   : 		if (!_Match_try)

  0009b	48 85 c0	 test	 rax, rax
  0009e	75 d0		 jne	 SHORT $LL4@Traits_fin
$LN18@Traits_fin:

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  000a0	48 83 c8 ff	 or	 rax, -1
$LN24@Traits_fin:
  000a4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a9	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 86   : 			}
; 87   : 		}
; 88   : 	}

  000ae	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000b3	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	41 5e		 pop	 r14
  000be	c3		 ret	 0
$LN19@Traits_fin:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  000bf	49 2b de	 sub	 rbx, r14
  000c2	48 8b c3	 mov	 rax, rbx
  000c5	eb dd		 jmp	 SHORT $LN24@Traits_fin
$LN6@Traits_fin:

; 86   : 			}
; 87   : 		}
; 88   : 	}

  000c7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000cc	48 83 c8 ff	 or	 rax, -1
  000d0	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	41 5e		 pop	 r14
  000db	c3		 ret	 0
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
;	COMDAT ??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z PROC		; std::_Min_value<unsigned __int64>, COMDAT

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 39 02	 cmp	 QWORD PTR [rdx], rax
  00006	48 0f 42 ca	 cmovb	 rcx, rdx
  0000a	48 8b c1	 mov	 rax, rcx

; 24   : 	}

  0000d	c3		 ret	 0
??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z ENDP		; std::_Min_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 265  : 	return (_Ptr);

  00000	48 8b c1	 mov	 rax, rcx

; 266  : 	}

  00003	c3		 ret	 0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 249  : 	return (__builtin_addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 250  : 	}

  00003	c3		 ret	 0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 249  : 	return (__builtin_addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 250  : 	}

  00003	c3		 ret	 0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > & __ptr64>, COMDAT

; 1553 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1554 : 	}

  00003	c3		 ret	 0
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> & __ptr64>, COMDAT

; 1553 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1554 : 	}

  00003	c3		 ret	 0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>, COMDAT

; 1563 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1564 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1698 : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT

; 504  : 	{	// get facet reference from locale

$LN25:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	57		 push	 rdi
  00004	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00008	49 c7 43 b8 fe
	ff ff ff	 mov	 QWORD PTR [r11-72], -2
  00010	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00014	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00027	48 8b f1	 mov	 rsi, rcx

; 505  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  0002a	33 d2		 xor	 edx, edx
  0002c	49 8d 4b e0	 lea	 rcx, QWORD PTR [r11-32]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00036	90		 npad	 1

; 506  : 		const locale::facet *_Psave =
; 507  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  00037	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
  0003e	48 89 44 24 40	 mov	 QWORD PTR _Psave$3[rsp], rax

; 508  : 
; 509  : 		size_t _Id = _Facet::id;

  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??Bid@locale@std@@QEAA_KXZ
  00050	48 8b f8	 mov	 rdi, rax

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00053	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00057	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  0005b	73 0f		 jae	 SHORT $LN15@use_facet
  0005d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00061	48 8b 1c f9	 mov	 rbx, QWORD PTR [rcx+rdi*8]

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00065	48 85 db	 test	 rbx, rbx
  00068	75 5f		 jne	 SHORT $LN7@use_facet
  0006a	eb 02		 jmp	 SHORT $LN19@use_facet
$LN15@use_facet:

; 430  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0006c	33 db		 xor	 ebx, ebx
$LN19@use_facet:

; 431  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 432  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0006e	80 78 24 00	 cmp	 BYTE PTR [rax+36], 0
  00072	74 14		 je	 SHORT $LN12@use_facet

; 433  : 			return (_Facptr);	// found facet or not transparent
; 434  : 		else
; 435  : 			{	// look in current locale
; 436  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ

; 437  : 			return (_Id < _Ptr0->_Facetcount

  0007a	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  0007e	73 0d		 jae	 SHORT $LN20@use_facet
  00080	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00084	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]
$LN12@use_facet:

; 510  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 511  : 
; 512  : 		if (_Pf != 0)

  00088	48 85 db	 test	 rbx, rbx
  0008b	75 3c		 jne	 SHORT $LN7@use_facet
$LN20@use_facet:

; 513  : 			;	// got facet from locale
; 514  : 		else if (_Psave != 0)

  0008d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR _Psave$3[rsp]
  00092	48 85 db	 test	 rbx, rbx
  00095	75 32		 jne	 SHORT $LN7@use_facet

; 515  : 			_Pf = _Psave;	// lazy facet already allocated
; 516  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  00097	48 8b d6	 mov	 rdx, rsi
  0009a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Psave$3[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
  000a5	48 83 f8 ff	 cmp	 rax, -1
  000a9	74 4c		 je	 SHORT $LN24@use_facet

; 521  : 
; 522  :  #else /* _HAS_EXCEPTIONS */
; 523  : 			abort();	// lazy disallowed
; 524  :  #endif /* _HAS_EXCEPTIONS */
; 525  : 
; 526  : 		else
; 527  : 			{	// queue up lazy facet for destruction
; 528  : 			_Pf = _Psave;

  000ab	48 8b 5c 24 40	 mov	 rbx, QWORD PTR _Psave$3[rsp]

; 529  : 			_Facetptr<_Facet>::_Psave = _Psave;

  000b0	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB, rbx ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave

; 530  : 
; 531  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 532  : 			_Pfmod->_Incref();

  000b7	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  000ba	48 8b cb	 mov	 rcx, rbx
  000bd	ff 52 08	 call	 QWORD PTR [rdx+8]

; 533  : 
; 534  :  #if defined(_M_CEE)
; 535  : 			_Facet_Register_m(_Pfmod);
; 536  : 
; 537  :  #else /* defined(_M_CEE) */
; 538  : 			_Facet_Register(_Pfmod);

  000c0	48 8b cb	 mov	 rcx, rbx
  000c3	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register
  000c8	90		 npad	 1
$LN7@use_facet:

; 539  :  #endif /* defined(_M_CEE) */
; 540  : 			}
; 541  : 
; 542  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000c9	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$4[rsp]
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000d4	48 8b c3	 mov	 rax, rbx

; 543  : 	_END_LOCK()
; 544  : 	}	// end of use_facet body

  000d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000dc	48 33 cc	 xor	 rcx, rsp
  000df	e8 00 00 00 00	 call	 __security_check_cookie
  000e4	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  000e9	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  000f1	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000f5	5f		 pop	 rdi
  000f6	c3		 ret	 0
$LN24@use_facet:

; 517  : 
; 518  :  #if _HAS_EXCEPTIONS
; 519  : 
; 520  : 			_THROW(bad_cast{});	// lazy disallowed

  000f7	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  000fc	e8 00 00 00 00	 call	 ??0bad_cast@std@@QEAA@XZ ; std::bad_cast::bad_cast
  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
  00108	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  0010d	e8 00 00 00 00	 call	 _CxxThrowException
  00112	cc		 int	 3
$LN21@use_facet:
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$4[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$4[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 249  : 	return (__builtin_addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 250  : 	}

  00003	c3		 ret	 0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1150 : 	typename allocator_traits<_Alloc>::propagate_on_container_move_assignment _Tag;
; 1151 : 	_Pocma(_Left, _Right, _Tag);
; 1152 : 	}

  00000	c2 00 00	 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 1131 : 	typename allocator_traits<_Alloc>::propagate_on_container_copy_assignment _Tag;
; 1132 : 	_Pocca(_Left, _Right, _Tag);
; 1133 : 	}

  00000	c2 00 00	 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1563 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1564 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 313  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char * __ptr64>, COMDAT

; 249  : 	return (__builtin_addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 250  : 	}

  00003	c3		 ret	 0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$destroy@PEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEAD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char * __ptr64>, COMDAT

; 951  : 		_Ptr->~_Uty();
; 952  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
_TEXT	SEGMENT
this$ = 80
_Size_increase$dead$ = 88
_Fn$dead$ = 96
<_Args_0>$ = 104
??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>, COMDAT

; 3626 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3627 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3628 : 		auto& _My_data = this->_Get_data();
; 3629 : 		const size_type _Old_size = _My_data._Mysize;

  0000a	48 8b 69 10	 mov	 rbp, QWORD PTR [rcx+16]

; 3630 : 		if (max_size() - _Old_size < _Size_increase)

  0000e	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00018	48 8b c3	 mov	 rax, rbx
  0001b	45 0f b6 e1	 movzx	 r12d, r9b
  0001f	48 2b c5	 sub	 rax, rbp
  00022	48 8b f9	 mov	 rdi, rcx
  00025	48 83 f8 01	 cmp	 rax, 1
  00029	0f 82 31 01 00
	00		 jb	 $LN150@Reallocate

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  0002f	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  00034	4c 8b 71 18	 mov	 r14, QWORD PTR [rcx+24]
  00038	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0003d	4c 8d 7d 01	 lea	 r15, QWORD PTR [rbp+1]

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00041	49 8b cf	 mov	 rcx, r15
  00044	48 83 c9 0f	 or	 rcx, 15
  00048	48 3b cb	 cmp	 rcx, rbx

; 3577 : 		if (_Masked > _Max)

  0004b	77 1f		 ja	 SHORT $LN33@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);
; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  0004d	49 8b d6	 mov	 rdx, r14
  00050	48 8b c3	 mov	 rax, rbx
  00053	48 d1 ea	 shr	 rdx, 1
  00056	48 2b c2	 sub	 rax, rdx
  00059	4c 3b f0	 cmp	 r14, rax
  0005c	77 0e		 ja	 SHORT $LN33@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);
; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0005e	4a 8d 04 32	 lea	 rax, QWORD PTR [rdx+r14]
  00062	48 8b d9	 mov	 rbx, rcx
  00065	48 3b c8	 cmp	 rcx, rax
  00068	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3637 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3638 : 		auto& _Al = this->_Getal();
; 3639 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00074	48 83 c1 01	 add	 rcx, 1
  00078	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0007f	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  00083	48 85 c9	 test	 rcx, rcx
  00086	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  00088	33 f6		 xor	 esi, esi
  0008a	eb 34		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  0008c	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00093	72 23		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00095	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  00099	48 3b c1	 cmp	 rax, rcx
  0009c	0f 86 c4 00 00
	00		 jbe	 $LN152@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000a2	48 8b c8	 mov	 rcx, rax
  000a5	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  000aa	48 8d 70 27	 lea	 rsi, QWORD PTR [rax+39]
  000ae	48 83 e6 e0	 and	 rsi, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000b2	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  000b6	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  000b8	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000bd	48 8b f0	 mov	 rsi, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3641 : 		_My_data._Mysize = _New_size;

  000c0	4c 89 7f 10	 mov	 QWORD PTR [rdi+16], r15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000c4	4c 8b c5	 mov	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3642 : 		_My_data._Myres = _New_capacity;

  000c7	48 89 5f 18	 mov	 QWORD PTR [rdi+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000cb	48 8b ce	 mov	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000ce	49 83 fe 10	 cmp	 r14, 16
  000d2	72 5c		 jb	 SHORT $LN3@Reallocate

; 3645 : 			{
; 3646 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000d4	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000d7	48 8b d3	 mov	 rdx, rbx
  000da	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000df	49 8d 56 01	 lea	 rdx, QWORD PTR [r14+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000e3	44 88 24 2e	 mov	 BYTE PTR [rsi+rbp], r12b
  000e7	c6 44 2e 01 00	 mov	 BYTE PTR [rsi+rbp+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000ec	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  000f3	72 2a		 jb	 SHORT $LN111@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000f5	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  000f9	48 3b c2	 cmp	 rax, rdx
  000fc	76 2b		 jbe	 SHORT $_Invalid_parameter$153

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000fe	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00101	f6 c3 1f	 test	 bl, 31
  00104	75 23		 jne	 SHORT $_Invalid_parameter$153

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00106	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  0010a	48 3b c3	 cmp	 rax, rbx
  0010d	73 1a		 jae	 SHORT $_Invalid_parameter$153

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0010f	48 2b d8	 sub	 rbx, rax
  00112	48 83 eb 08	 sub	 rbx, 8
  00116	48 83 fb 1f	 cmp	 rbx, 31
  0011a	77 0d		 ja	 SHORT $_Invalid_parameter$153

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0011c	48 8b d8	 mov	 rbx, rax
$LN111@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0011f	48 8b cb	 mov	 rcx, rbx
  00122	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3651 : 		else

  00127	eb 18		 jmp	 SHORT $LN4@Reallocate
$_Invalid_parameter$153:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0012f	cc		 int	 3
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00130	48 8b d7	 mov	 rdx, rdi
  00133	e8 00 00 00 00	 call	 memcpy

; 442  : 		_Left = _Right;

  00138	44 88 24 2e	 mov	 BYTE PTR [rsi+rbp], r12b
  0013c	c6 44 2e 01 00	 mov	 BYTE PTR [rsi+rbp+1], 0
$LN4@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  00141	48 89 37	 mov	 QWORD PTR [rdi], rsi
  00144	48 8b c7	 mov	 rax, rdi
  00147	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0014c	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]
  00151	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 3658 : 		}

  00156	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0015a	41 5c		 pop	 r12
  0015c	5f		 pop	 rdi
  0015d	5d		 pop	 rbp
  0015e	5b		 pop	 rbx
  0015f	c3		 ret	 0
$LN150@Reallocate:

; 3631 : 			{
; 3632 : 			_Xlen();	// result too long

  00160	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  00165	cc		 int	 3
$LN152@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  00166	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  0016b	cc		 int	 3
$LN149@Reallocate:
??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 249  : 	return (__builtin_addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 250  : 	}

  00003	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z PROC		; std::_Refancy<char * __ptr64,0>, COMDAT

; 400  : 	return (_Ptr);

  00000	48 8b c1	 mov	 rax, rcx

; 401  : 	}

  00003	c3		 ret	 0
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z ENDP		; std::_Refancy<char * __ptr64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z
_TEXT	SEGMENT
this$ = 48
_New_size$dead$ = 56
_Fn$dead$ = 64
<_Args_0>$dead$ = 72
??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>,char>, COMDAT

; 3594 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3595 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3596 : 		if (_New_size > max_size())
; 3597 : 			{
; 3598 : 			_Xlen();	// result too long
; 3599 : 			}
; 3600 : 
; 3601 : 		auto& _My_data = this->_Get_data();
; 3602 : 		const size_type _Old_capacity = _My_data._Myres;

  0000f	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  00013	48 8b f9	 mov	 rdi, rcx

; 3583 : 		if (_Old > _Max - _Old / 2)

  00016	48 8b cd	 mov	 rcx, rbp
  00019	48 be ff ff ff
	ff ff ff ff 7f	 mov	 rsi, 9223372036854775807 ; 7fffffffffffffffH
  00023	48 d1 e9	 shr	 rcx, 1
  00026	48 8b c6	 mov	 rax, rsi
  00029	48 2b c1	 sub	 rax, rcx
  0002c	48 3b e8	 cmp	 rbp, rax
  0002f	77 10		 ja	 SHORT $LN33@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);
; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00031	48 8d 04 29	 lea	 rax, QWORD PTR [rcx+rbp]
  00035	be 0f 00 00 00	 mov	 esi, 15
  0003a	48 3b c6	 cmp	 rax, rsi
  0003d	48 0f 47 f0	 cmova	 rsi, rax
$LN33@Reallocate:

; 3603 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3604 : 		auto& _Al = this->_Getal();
; 3605 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00041	48 8b ce	 mov	 rcx, rsi
  00044	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00049	48 83 c1 01	 add	 rcx, 1
  0004d	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00054	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  00058	48 85 c9	 test	 rcx, rcx
  0005b	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  0005d	33 db		 xor	 ebx, ebx
  0005f	eb 34		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00061	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00068	72 23		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  0006a	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  0006e	48 3b c1	 cmp	 rax, rcx
  00071	0f 86 99 00 00
	00		 jbe	 $LN131@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00077	48 8b c8	 mov	 rcx, rax
  0007a	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  0007f	48 8d 58 27	 lea	 rbx, QWORD PTR [rax+39]
  00083	48 83 e3 e0	 and	 rbx, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00087	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  0008b	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  0008d	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00092	48 8b d8	 mov	 rbx, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00095	33 c0		 xor	 eax, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3607 : 		_My_data._Mysize = _New_size;

  00097	48 c7 47 10 08
	00 00 00	 mov	 QWORD PTR [rdi+16], 8

; 3608 : 		_My_data._Myres = _New_capacity;

  0009f	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  000a3	48 89 03	 mov	 QWORD PTR [rbx], rax

; 442  : 		_Left = _Right;

  000a6	88 43 08	 mov	 BYTE PTR [rbx+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3610 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000a9	48 83 fd 10	 cmp	 rbp, 16
  000ad	72 3f		 jb	 SHORT $LN3@Reallocate
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  000af	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3612 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000b2	48 8d 55 01	 lea	 rdx, QWORD PTR [rbp+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000b6	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  000bd	72 2a		 jb	 SHORT $LN106@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000bf	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  000c3	48 3b c2	 cmp	 rax, rdx
  000c6	76 41		 jbe	 SHORT $_Invalid_parameter$133

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000c8	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000cb	f6 c1 1f	 test	 cl, 31
  000ce	75 39		 jne	 SHORT $_Invalid_parameter$133

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000d0	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  000d4	48 3b c1	 cmp	 rax, rcx
  000d7	73 30		 jae	 SHORT $_Invalid_parameter$133

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000d9	48 2b c8	 sub	 rcx, rax
  000dc	48 83 e9 08	 sub	 rcx, 8
  000e0	48 83 f9 1f	 cmp	 rcx, 31
  000e4	77 23		 ja	 SHORT $_Invalid_parameter$133

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000e6	48 8b c8	 mov	 rcx, rax
$LN106@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  000e9	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3620 : 		return (*this);

  000ee	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  000f1	48 8b c7	 mov	 rax, rdi
  000f4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]

; 3621 : 		}

  000f9	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000fe	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00103	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00107	5f		 pop	 rdi
  00108	c3		 ret	 0
$_Invalid_parameter$133:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0010f	cc		 int	 3
$LN131@Reallocate:

; 119  : 				_Traits::_Fail();	// report no memory

  00110	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  00115	cc		 int	 3
$LN130@Reallocate:
??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
_TEXT	SEGMENT
this$ = 80
_New_size$ = 88
_Fn$dead$ = 96
<_Args_0>$ = 104
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>, COMDAT

; 3594 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 56		 push	 r14
  00005	41 57		 push	 r15
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3595 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3596 : 		if (_New_size > max_size())

  0000b	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00015	4d 8b f9	 mov	 r15, r9
  00018	4c 8b f2	 mov	 r14, rdx
  0001b	48 8b f1	 mov	 rsi, rcx
  0001e	48 3b d3	 cmp	 rdx, rbx
  00021	0f 87 0a 01 00
	00		 ja	 $LN133@Reallocate

; 3599 : 			}
; 3600 : 
; 3601 : 		auto& _My_data = this->_Get_data();
; 3602 : 		const size_type _Old_capacity = _My_data._Myres;

  00027	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  0002c	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00030	48 8b ca	 mov	 rcx, rdx
  00033	48 83 c9 0f	 or	 rcx, 15
  00037	48 3b cb	 cmp	 rcx, rbx

; 3577 : 		if (_Masked > _Max)

  0003a	77 1f		 ja	 SHORT $LN33@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);
; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  0003c	48 8b d5	 mov	 rdx, rbp
  0003f	48 8b c3	 mov	 rax, rbx
  00042	48 d1 ea	 shr	 rdx, 1
  00045	48 2b c2	 sub	 rax, rdx
  00048	48 3b e8	 cmp	 rbp, rax
  0004b	77 0e		 ja	 SHORT $LN33@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);
; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0004d	48 8d 04 2a	 lea	 rax, QWORD PTR [rdx+rbp]
  00051	48 8b d9	 mov	 rbx, rcx
  00054	48 3b c8	 cmp	 rcx, rax
  00057	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3603 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3604 : 		auto& _Al = this->_Getal();
; 3605 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00063	48 83 c1 01	 add	 rcx, 1
  00067	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0006e	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  00072	48 85 c9	 test	 rcx, rcx
  00075	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  00077	33 ff		 xor	 edi, edi
  00079	eb 34		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  0007b	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00082	72 23		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00084	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  00088	48 3b c1	 cmp	 rax, rcx
  0008b	0f 86 a6 00 00
	00		 jbe	 $LN135@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00091	48 8b c8	 mov	 rcx, rax
  00094	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  00099	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  0009d	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000a1	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  000a5	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  000a7	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000ac	48 8b f8	 mov	 rdi, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000af	4d 8b c6	 mov	 r8, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3607 : 		_My_data._Mysize = _New_size;

  000b2	4c 89 76 10	 mov	 QWORD PTR [rsi+16], r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000b6	49 8b d7	 mov	 rdx, r15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3608 : 		_My_data._Myres = _New_capacity;

  000b9	48 89 5e 18	 mov	 QWORD PTR [rsi+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000bd	48 8b cf	 mov	 rcx, rdi
  000c0	e8 00 00 00 00	 call	 memcpy

; 442  : 		_Left = _Right;

  000c5	41 c6 04 3e 00	 mov	 BYTE PTR [r14+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3610 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000ca	48 83 fd 10	 cmp	 rbp, 16
  000ce	72 3f		 jb	 SHORT $LN3@Reallocate
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 1050 : 		_Deallocate(_Ptr, _Count, sizeof(_Ty), alignof(_Ty));

  000d0	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3612 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000d3	48 8d 55 01	 lea	 rdx, QWORD PTR [rbp+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000d7	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  000de	72 2a		 jb	 SHORT $LN106@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000e0	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  000e4	48 3b c2	 cmp	 rax, rdx
  000e7	76 41		 jbe	 SHORT $_Invalid_parameter$136

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000e9	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000ec	f6 c1 1f	 test	 cl, 31
  000ef	75 39		 jne	 SHORT $_Invalid_parameter$136

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000f1	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  000f5	48 3b c1	 cmp	 rax, rcx
  000f8	73 30		 jae	 SHORT $_Invalid_parameter$136

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  000fa	48 2b c8	 sub	 rcx, rax
  000fd	48 83 e9 08	 sub	 rcx, 8
  00101	48 83 f9 1f	 cmp	 rcx, 31
  00105	77 23		 ja	 SHORT $_Invalid_parameter$136

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00107	48 8b c8	 mov	 rcx, rax
$LN106@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0010a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3620 : 		return (*this);

  0010f	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  00112	48 8b c6	 mov	 rax, rsi
  00115	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  0011a	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 3621 : 		}

  0011f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00123	41 5f		 pop	 r15
  00125	41 5e		 pop	 r14
  00127	5e		 pop	 rsi
  00128	5b		 pop	 rbx
  00129	c3		 ret	 0
$_Invalid_parameter$136:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00130	cc		 int	 3
$LN133@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3598 : 			_Xlen();	// result too long

  00131	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  00136	cc		 int	 3
$LN135@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  00137	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  0013c	cc		 int	 3
$LN132@Reallocate:
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
_TEXT	SEGMENT
<_Args_0>$GSCopy$1$ = 32
this$ = 112
_Size_increase$ = 120
_Fn$dead$ = 128
<_Args_0>$ = 136
<_Args_1>$ = 144
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>, COMDAT

; 3626 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 57		 push	 r15
  00005	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 3627 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3628 : 		auto& _My_data = this->_Get_data();
; 3629 : 		const size_type _Old_size = _My_data._Mysize;

  00009	4c 8b 79 10	 mov	 r15, QWORD PTR [rcx+16]

; 3630 : 		if (max_size() - _Old_size < _Size_increase)

  0000d	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00017	48 8b c3	 mov	 rax, rbx
  0001a	4c 89 4c 24 20	 mov	 QWORD PTR <_Args_0>$GSCopy$1$[rsp], r9
  0001f	49 2b c7	 sub	 rax, r15
  00022	48 8b f1	 mov	 rsi, rcx
  00025	48 3b c2	 cmp	 rax, rdx
  00028	0f 82 74 01 00
	00		 jb	 $LN152@Reallocate

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;

  0002e	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp
  00036	4a 8d 2c 3a	 lea	 rbp, QWORD PTR [rdx+r15]
  0003a	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13

; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  0003f	4c 8b 69 18	 mov	 r13, QWORD PTR [rcx+24]

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00043	48 8b cd	 mov	 rcx, rbp
  00046	48 83 c9 0f	 or	 rcx, 15
  0004a	48 3b cb	 cmp	 rcx, rbx

; 3577 : 		if (_Masked > _Max)

  0004d	77 1f		 ja	 SHORT $LN33@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);
; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  0004f	49 8b d5	 mov	 rdx, r13
  00052	48 8b c3	 mov	 rax, rbx
  00055	48 d1 ea	 shr	 rdx, 1
  00058	48 2b c2	 sub	 rax, rdx
  0005b	4c 3b e8	 cmp	 r13, rax
  0005e	77 0e		 ja	 SHORT $LN33@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);
; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00060	4a 8d 04 2a	 lea	 rax, QWORD PTR [rdx+r13]
  00064	48 8b d9	 mov	 rbx, rcx
  00067	48 3b c8	 cmp	 rcx, rax
  0006a	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3637 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3638 : 		auto& _Al = this->_Getal();
; 3639 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0006e	48 8b cb	 mov	 rcx, rbx
  00071	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00076	48 83 c1 01	 add	 rcx, 1
  0007a	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00081	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  00085	48 85 c9	 test	 rcx, rcx
  00088	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  0008a	33 ff		 xor	 edi, edi
  0008c	eb 34		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  0008e	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00095	72 23		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00097	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  0009b	48 3b c1	 cmp	 rax, rcx
  0009e	0f 86 04 01 00
	00		 jbe	 $LN154@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  000ac	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000b0	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000b4	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  000b8	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  000ba	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000bf	48 8b f8	 mov	 rdi, rax
$LN75@Reallocate:
  000c2	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000c7	4d 8b c7	 mov	 r8, r15
  000ca	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3642 : 		_My_data._Myres = _New_capacity;

  000cf	4e 8d 24 3f	 lea	 r12, QWORD PTR [rdi+r15]
  000d3	48 89 5e 18	 mov	 QWORD PTR [rsi+24], rbx
  000d7	4d 8d 34 3f	 lea	 r14, QWORD PTR [r15+rdi]
  000db	48 8b 5c 24 20	 mov	 rbx, QWORD PTR <_Args_0>$GSCopy$1$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000e0	48 8b cf	 mov	 rcx, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3642 : 		_My_data._Myres = _New_capacity;

  000e3	4c 03 f3	 add	 r14, rbx
  000e6	48 89 6e 10	 mov	 QWORD PTR [rsi+16], rbp
  000ea	0f be ac 24 90
	00 00 00	 movsx	 ebp, BYTE PTR <_Args_1>$[rsp]

; 3643 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);
; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000f2	49 83 fd 10	 cmp	 r13, 16
  000f6	72 66		 jb	 SHORT $LN3@Reallocate

; 3645 : 			{
; 3646 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000f8	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000fb	48 8b d3	 mov	 rdx, rbx
  000fe	e8 00 00 00 00	 call	 memcpy

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00103	4c 8b 44 24 20	 mov	 r8, QWORD PTR <_Args_0>$GSCopy$1$[rsp]
  00108	8b d5		 mov	 edx, ebp
  0010a	49 8b cc	 mov	 rcx, r12
  0010d	e8 00 00 00 00	 call	 memset
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00112	49 8d 55 01	 lea	 rdx, QWORD PTR [r13+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00116	41 c6 06 00	 mov	 BYTE PTR [r14], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  0011a	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00121	72 2a		 jb	 SHORT $LN111@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00123	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00127	48 3b c2	 cmp	 rax, rdx
  0012a	76 2b		 jbe	 SHORT $_Invalid_parameter$155

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  0012c	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0012f	f6 c3 1f	 test	 bl, 31
  00132	75 23		 jne	 SHORT $_Invalid_parameter$155

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00134	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00138	48 3b c3	 cmp	 rax, rbx
  0013b	73 1a		 jae	 SHORT $_Invalid_parameter$155

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0013d	48 2b d8	 sub	 rbx, rax
  00140	48 83 eb 08	 sub	 rbx, 8
  00144	48 83 fb 1f	 cmp	 rbx, 31
  00148	77 0d		 ja	 SHORT $_Invalid_parameter$155

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0014a	48 8b d8	 mov	 rbx, rax
$LN111@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0014d	48 8b cb	 mov	 rcx, rbx
  00150	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3651 : 		else

  00155	eb 20		 jmp	 SHORT $LN4@Reallocate
$_Invalid_parameter$155:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0015d	cc		 int	 3
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0015e	48 8b d6	 mov	 rdx, rsi
  00161	e8 00 00 00 00	 call	 memcpy

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  00166	4c 8b c3	 mov	 r8, rbx
  00169	8b d5		 mov	 edx, ebp
  0016b	49 8b cc	 mov	 rcx, r12
  0016e	e8 00 00 00 00	 call	 memset

; 442  : 		_Left = _Right;

  00173	41 c6 06 00	 mov	 BYTE PTR [r14], 0
$LN4@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  00177	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  0017a	48 8b c6	 mov	 rax, rsi
  0017d	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
  00182	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
  00187	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0018c	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  00194	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]

; 3658 : 		}

  00199	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0019d	41 5f		 pop	 r15
  0019f	5e		 pop	 rsi
  001a0	5b		 pop	 rbx
  001a1	c3		 ret	 0
$LN152@Reallocate:

; 3631 : 			{
; 3632 : 			_Xlen();	// result too long

  001a2	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  001a7	cc		 int	 3
$LN154@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  001a8	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  001ad	cc		 int	 3
$LN151@Reallocate:
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
<_Args_1>$ = 128
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const * __ptr64,unsigned __int64>, COMDAT

; 3626 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 57		 push	 r15
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3627 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3628 : 		auto& _My_data = this->_Get_data();
; 3629 : 		const size_type _Old_size = _My_data._Mysize;

  0000d	4c 8b 79 10	 mov	 r15, QWORD PTR [rcx+16]

; 3630 : 		if (max_size() - _Old_size < _Size_increase)

  00011	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  0001b	4c 8b a4 24 80
	00 00 00	 mov	 r12, QWORD PTR <_Args_1>$[rsp]
  00023	48 8b c3	 mov	 rax, rbx
  00026	49 2b c7	 sub	 rax, r15
  00029	4d 8b e9	 mov	 r13, r9
  0002c	48 8b f1	 mov	 rsi, rcx
  0002f	48 3b c2	 cmp	 rax, rdx
  00032	0f 82 4c 01 00
	00		 jb	 $LN150@Reallocate

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  00038	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  0003d	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  00041	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00046	4e 8d 34 3a	 lea	 r14, QWORD PTR [rdx+r15]

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0004a	49 8b ce	 mov	 rcx, r14
  0004d	48 83 c9 0f	 or	 rcx, 15
  00051	48 3b cb	 cmp	 rcx, rbx

; 3577 : 		if (_Masked > _Max)

  00054	77 1f		 ja	 SHORT $LN33@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);
; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  00056	48 8b d5	 mov	 rdx, rbp
  00059	48 8b c3	 mov	 rax, rbx
  0005c	48 d1 ea	 shr	 rdx, 1
  0005f	48 2b c2	 sub	 rax, rdx
  00062	48 3b e8	 cmp	 rbp, rax
  00065	77 0e		 ja	 SHORT $LN33@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);
; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00067	48 8d 04 2a	 lea	 rax, QWORD PTR [rdx+rbp]
  0006b	48 8b d9	 mov	 rbx, rcx
  0006e	48 3b c8	 cmp	 rcx, rax
  00071	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3637 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3638 : 		auto& _Al = this->_Getal();
; 3639 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00075	48 8b cb	 mov	 rcx, rbx
  00078	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  0007d	48 83 c1 01	 add	 rcx, 1
  00081	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00088	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0008c	48 85 c9	 test	 rcx, rcx
  0008f	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  00091	33 ff		 xor	 edi, edi
  00093	eb 34		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00095	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0009c	72 23		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  0009e	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  000a2	48 3b c1	 cmp	 rax, rcx
  000a5	0f 86 df 00 00
	00		 jbe	 $LN152@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000ab	48 8b c8	 mov	 rcx, rax
  000ae	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  000b3	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000b7	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000bb	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  000bf	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  000c1	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000c6	48 8b f8	 mov	 rdi, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3641 : 		_My_data._Mysize = _New_size;

  000c9	4c 89 76 10	 mov	 QWORD PTR [rsi+16], r14

; 3642 : 		_My_data._Myres = _New_capacity;

  000cd	4e 8d 34 3f	 lea	 r14, QWORD PTR [rdi+r15]
  000d1	48 89 5e 18	 mov	 QWORD PTR [rsi+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000d5	4d 8b c7	 mov	 r8, r15
  000d8	48 8b cf	 mov	 rcx, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000db	48 83 fd 10	 cmp	 rbp, 16
  000df	72 66		 jb	 SHORT $LN3@Reallocate

; 3645 : 			{
; 3646 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000e1	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000e4	48 8b d3	 mov	 rdx, rbx
  000e7	e8 00 00 00 00	 call	 memcpy
  000ec	4d 8b c4	 mov	 r8, r12
  000ef	49 8b d5	 mov	 rdx, r13
  000f2	49 8b ce	 mov	 rcx, r14
  000f5	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000fa	48 8d 55 01	 lea	 rdx, QWORD PTR [rbp+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000fe	43 c6 04 26 00	 mov	 BYTE PTR [r14+r12], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00103	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0010a	72 2a		 jb	 SHORT $LN111@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0010c	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00110	48 3b c2	 cmp	 rax, rdx
  00113	76 2b		 jbe	 SHORT $_Invalid_parameter$153

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00115	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00118	f6 c3 1f	 test	 bl, 31
  0011b	75 23		 jne	 SHORT $_Invalid_parameter$153

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0011d	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00121	48 3b c3	 cmp	 rax, rbx
  00124	73 1a		 jae	 SHORT $_Invalid_parameter$153

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00126	48 2b d8	 sub	 rbx, rax
  00129	48 83 eb 08	 sub	 rbx, 8
  0012d	48 83 fb 1f	 cmp	 rbx, 31
  00131	77 0d		 ja	 SHORT $_Invalid_parameter$153

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00133	48 8b d8	 mov	 rbx, rax
$LN111@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00136	48 8b cb	 mov	 rcx, rbx
  00139	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3651 : 		else

  0013e	eb 22		 jmp	 SHORT $LN4@Reallocate
$_Invalid_parameter$153:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00146	cc		 int	 3
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00147	48 8b d6	 mov	 rdx, rsi
  0014a	e8 00 00 00 00	 call	 memcpy
  0014f	4d 8b c4	 mov	 r8, r12
  00152	49 8b d5	 mov	 rdx, r13
  00155	49 8b ce	 mov	 rcx, r14
  00158	e8 00 00 00 00	 call	 memcpy

; 442  : 		_Left = _Right;

  0015d	43 c6 04 26 00	 mov	 BYTE PTR [r14+r12], 0
$LN4@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  00162	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  00165	48 8b c6	 mov	 rax, rsi
  00168	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]
  0016d	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00172	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]

; 3658 : 		}

  00177	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0017b	41 5f		 pop	 r15
  0017d	41 5d		 pop	 r13
  0017f	41 5c		 pop	 r12
  00181	5e		 pop	 rsi
  00182	5b		 pop	 rbx
  00183	c3		 ret	 0
$LN150@Reallocate:

; 3631 : 			{
; 3632 : 			_Xlen();	// result too long

  00184	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  00189	cc		 int	 3
$LN152@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  0018a	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  0018f	cc		 int	 3
$LN149@Reallocate:
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const * __ptr64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$construct@PEADAEBQEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEADAEBQEAD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEADAEBQEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEADAEBQEAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 const & __ptr64>, COMDAT

; 944  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00000	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax

; 945  : 			_Objty(_STD forward<_Types>(_Args)...);
; 946  : 		}

  00006	c3		 ret	 0
??$construct@PEADAEBQEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEADAEBQEAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$?0AEBV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??$?0AEBV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const & __ptr64,void>, COMDAT

; 1563 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1564 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1698 : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??$?0AEBV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const & __ptr64,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPEAX_K0_K@Z
_TEXT	SEGMENT
_Count$ = 48
_Sz$dead$ = 56
_Align$dead$ = 64
??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPEAX_K0_K@Z PROC ; std::_Allocate<std::_Default_allocate_traits<1> >, COMDAT

; 77   : 	{	// allocate storage for _Count elements of size _Sz with alignment _Align

$LN15:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 78   : 	if (_Count == 0)

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 07		 jne	 SHORT $LN3@Allocate

; 79   : 		{
; 80   : 		return (nullptr);

  00009	33 c0		 xor	 eax, eax

; 133  : 			}
; 134  : 		}
; 135  :  #pragma warning(pop)
; 136  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));
; 139  : 	}

  0000b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000f	c3		 ret	 0
$LN3@Allocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00010	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00017	72 25		 jb	 SHORT $LN4@Allocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  00019	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  0001d	48 3b c1	 cmp	 rax, rcx
  00020	76 25		 jbe	 SHORT $LN13@Allocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  0002a	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  0002e	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00032	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  00036	48 8b c1	 mov	 rax, rcx

; 133  : 			}
; 134  : 		}
; 135  :  #pragma warning(pop)
; 136  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	return (_Traits::_Get_bytes(_User_size, _Align));
; 139  : 	}

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
$LN4@Allocate:
  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 67   : 			_Ptr = ::operator new(_Bytes);

  00042	e9 00 00 00 00	 jmp	 ??2@YAPEAX_K@Z		; operator new
$LN13@Allocate:

; 118  : 				{
; 119  : 				_Traits::_Fail();	// report no memory

  00047	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  0004c	cc		 int	 3
$LN12@Allocate:
??$_Allocate@U?$_Default_allocate_traits@$00@std@@@std@@YAPEAX_K0_K@Z ENDP ; std::_Allocate<std::_Default_allocate_traits<1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_cast@std@@QEAA@AEBV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 65   :         : _Data()

  0000c	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 66   :     {

  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00017	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  0001a	33 c9		 xor	 ecx, ecx
  0001c	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0001f	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  00023	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_copy
  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_cast@std@@6B@
  00034	48 89 03	 mov	 QWORD PTR [rbx], rax
  00037	48 8b c3	 mov	 rax, rbx
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
??0bad_cast@std@@QEAA@AEBV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?_Get_bytes@?$_Default_allocate_traits@$00@std@@SAPEAX_K0@Z
_TEXT	SEGMENT
_Bytes$ = 8
_Align$dead$ = 16
?_Get_bytes@?$_Default_allocate_traits@$00@std@@SAPEAX_K0@Z PROC ; std::_Default_allocate_traits<1>::_Get_bytes, COMDAT

; 56   : 		(void)_Align;
; 57   : 
; 58   : 		void * _Ptr = nullptr;
; 59   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 60   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 61   : 			{
; 62   : 			_Ptr = ::operator new(_Bytes, align_val_t{_Align});
; 63   : 			}
; 64   : 		else
; 65   :  #endif /* _HAS_ALIGNED_NEW */
; 66   : 			{
; 67   : 			_Ptr = ::operator new(_Bytes);

  00000	e9 00 00 00 00	 jmp	 ??2@YAPEAX_K@Z		; operator new
?_Get_bytes@?$_Default_allocate_traits@$00@std@@SAPEAX_K0@Z ENDP ; std::_Default_allocate_traits<1>::_Get_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ
_TEXT	SEGMENT
?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ PROC	; std::_Default_allocate_traits<1>::_Fail, COMDAT

; 50   : 		{

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 51   : 		_Xbad_alloc();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0000a	cc		 int	 3
$LN3@Fail:
?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ENDP	; std::_Default_allocate_traits<1>::_Fail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 1563 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1564 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1566 : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 3710 : 		{	// report a length_error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3711 : 		_Xlength_error("string too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  00011	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Requested$ = 16
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 3574 : 		const size_type _Max = max_size();
; 3575 : 		auto& _My_data = this->_Get_data();
; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00000	49 b9 ff ff ff
	ff ff ff ff 7f	 mov	 r9, 9223372036854775807	; 7fffffffffffffffH
  0000a	48 83 ca 0f	 or	 rdx, 15

; 3577 : 		if (_Masked > _Max)
; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);

  0000e	49 8b c1	 mov	 rax, r9
  00011	49 3b d1	 cmp	 rdx, r9
  00014	77 24		 ja	 SHORT $LN1@Calculate_

; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;

  00016	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]

; 3583 : 		if (_Old > _Max - _Old / 2)

  0001a	49 8b c8	 mov	 rcx, r8
  0001d	48 d1 e9	 shr	 rcx, 1
  00020	48 2b c1	 sub	 rax, rcx
  00023	4c 3b c0	 cmp	 r8, rax
  00026	76 04		 jbe	 SHORT $LN3@Calculate_

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);

  00028	49 8b c1	 mov	 rax, r9

; 3589 : 		}

  0002b	c3		 ret	 0
$LN3@Calculate_:

; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0002c	4a 8d 04 01	 lea	 rax, QWORD PTR [rcx+r8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\utility

; 32   : 	return (_Left < _Right ? _Right : _Left);

  00030	48 3b d0	 cmp	 rdx, rax
  00033	48 0f 42 d0	 cmovb	 rdx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00037	48 8b c2	 mov	 rax, rdx
$LN1@Calculate_:

; 3589 : 		}

  0003a	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT

; 3479 : 		{	// compare [0, size()) with _Ptr for equality

$LN29:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 405  : 		return (_CSTD strlen(_First));

  00004	48 83 c8 ff	 or	 rax, -1
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL27@Equal:
  00010	48 ff c0	 inc	 rax
  00013	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  00017	75 f7		 jne	 SHORT $LL27@Equal
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00019	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1593 : 		const value_type * _Result = _Bx._Buf;

  0001e	4c 8b c9	 mov	 r9, rcx

; 1594 : 		if (_Large_string_engaged())

  00021	72 03		 jb	 SHORT $LN13@Equal
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00023	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
$LN13@Equal:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00026	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0002a	4c 3b c0	 cmp	 r8, rax
  0002d	75 13		 jne	 SHORT $LN21@Equal
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0002f	49 8b c9	 mov	 rcx, r9
  00032	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00037	85 c0		 test	 eax, eax
  00039	75 07		 jne	 SHORT $LN21@Equal

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  0003b	b0 01		 mov	 al, 1

; 3482 : 		}

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
$LN21@Equal:

; 3481 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00042	32 c0		 xor	 al, al

; 3482 : 		}

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcap$ = 56
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT

; 3081 : 		{	// determine new minimum length of allocated storage

$LN66:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3082 : 		auto& _My_data = this->_Get_data();
; 3083 : 		if (_My_data._Mysize > _Newcap)

  0000a	48 8b 71 10	 mov	 rsi, QWORD PTR [rcx+16]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 3b f2	 cmp	 rsi, rdx
  00014	0f 87 95 00 00
	00		 ja	 $LN5@reserve

; 3084 : 			{	// requested capacity is not large enough for current size, ignore
; 3085 : 			return;	// nothing to do
; 3086 : 			}
; 3087 : 
; 3088 : 		if (_My_data._Myres == _Newcap)

  0001a	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  0001e	48 3b c2	 cmp	 rax, rdx
  00021	0f 84 88 00 00
	00		 je	 $LN5@reserve

; 3089 : 			{	// we're already at the requested capacity
; 3090 : 			return;	// nothing to do
; 3091 : 			}
; 3092 : 
; 3093 : 		if (_My_data._Myres < _Newcap)

  00027	73 17		 jae	 SHORT $LN4@reserve

; 3094 : 			{	// reallocate to grow
; 3095 : 			const size_type _Old_size = _My_data._Mysize;
; 3096 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  00029	48 2b d6	 sub	 rdx, rsi
  0002c	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3097 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3098 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3099 : 				});
; 3100 : 
; 3101 : 			_My_data._Mysize = _Old_size;

  00031	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 3112 : 		}

  00035	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
$LN4@reserve:

; 3102 : 			return;
; 3103 : 			}
; 3104 : 
; 3105 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  00040	48 83 fa 10	 cmp	 rdx, 16
  00044	73 69		 jae	 SHORT $LN5@reserve

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00046	48 83 f8 10	 cmp	 rax, 16

; 3102 : 			return;
; 3103 : 			}
; 3104 : 
; 3105 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  0004a	72 63		 jb	 SHORT $LN5@reserve

; 3666 : 		const pointer _Ptr = _My_data._Bx._Ptr;

  0004c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 3667 : 		auto& _Al = this->_Getal();
; 3668 : 		_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3669 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00051	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
  00055	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00058	48 8b d3	 mov	 rdx, rbx
  0005b	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3670 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00060	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00064	48 ff c2	 inc	 rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00067	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0006e	72 2a		 jb	 SHORT $LN47@reserve

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  00070	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00074	48 3b c2	 cmp	 rax, rdx
  00077	76 41		 jbe	 SHORT $_Invalid_parameter$67

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00079	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  0007c	f6 c3 1f	 test	 bl, 31
  0007f	75 39		 jne	 SHORT $_Invalid_parameter$67

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00081	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00085	48 3b c3	 cmp	 rax, rbx
  00088	73 30		 jae	 SHORT $_Invalid_parameter$67

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  0008a	48 2b d8	 sub	 rbx, rax
  0008d	48 83 eb 08	 sub	 rbx, 8
  00091	48 83 fb 1f	 cmp	 rbx, 31
  00095	77 23		 ja	 SHORT $_Invalid_parameter$67

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00097	48 8b d8	 mov	 rbx, rax
$LN47@reserve:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  0009a	48 8b cb	 mov	 rcx, rbx
  0009d	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000a2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3671 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000a7	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15
$LN5@reserve:

; 3112 : 		}

  000af	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
$_Invalid_parameter$67:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000c0	cc		 int	 3
$LN65@reserve:
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@QEBA@QEADQEBD_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_New_ptr$ = 16
_Old_ptr$ = 24
_Old_size$ = 32
??R<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@QEBA@QEADQEBD_K@Z PROC ; <lambda_9013ee9e23efe4882b67eff5b0ecf103>::operator(), COMDAT

; 3097 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00006	48 8b d0	 mov	 rdx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3098 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  00009	4d 8d 41 01	 lea	 r8, QWORD PTR [r9+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0000d	e9 00 00 00 00	 jmp	 memcpy
??R<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@QEBA@QEADQEBD_K@Z ENDP ; <lambda_9013ee9e23efe4882b67eff5b0ecf103>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity, COMDAT

; 3077 : 		return (this->_Get_data()._Myres);

  00000	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]

; 3078 : 		}

  00004	c3		 ret	 0
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1594 : 		if (_Large_string_engaged())

  00005	72 04		 jb	 SHORT $LN16@data

; 3030 : 		return (this->_Get_data()._Myptr());

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 3031 : 		}

  0000a	c3		 ret	 0
$LN16@data:

; 3030 : 		return (this->_Get_data()._Myptr());

  0000b	48 8b c1	 mov	 rax, rcx

; 3031 : 		}

  0000e	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
_TEXT	SEGMENT
this$ = 64
_Off$dead$ = 72
_Right$ = 80
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 2466 : 		{	// insert _Right at _Off

$LN52:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 56		 push	 r14
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00010	49 83 78 18 10	 cmp	 QWORD PTR [r8+24], 16

; 2466 : 		{	// insert _Right at _Off

  00015	4c 8b f1	 mov	 r14, rcx

; 1593 : 		const value_type * _Result = _Bx._Buf;

  00018	49 8b d8	 mov	 rbx, r8

; 1594 : 		if (_Large_string_engaged())

  0001b	72 03		 jb	 SHORT $LN10@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0001d	49 8b 18	 mov	 rbx, QWORD PTR [r8]
$LN10@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2468 : 		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));

  00020	49 8b 78 10	 mov	 rdi, QWORD PTR [r8+16]

; 1609 : 		if (_Mysize < _Off)

  00024	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2501 : 		if (_Count <= _My_data._Myres - _Old_size)

  00028	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0002c	48 8b c1	 mov	 rax, rcx
  0002f	49 2b c0	 sub	 rax, r8
  00032	48 3b f8	 cmp	 rdi, rax
  00035	0f 87 97 00 00
	00		 ja	 $LN17@insert

; 2502 : 			{
; 2503 : 			_My_data._Mysize = _Old_size + _Count;

  0003b	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00040	49 8d 04 38	 lea	 rax, QWORD PTR [r8+rdi]
  00044	49 89 46 10	 mov	 QWORD PTR [r14+16], rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00048	49 8b f6	 mov	 rsi, r14

; 2503 : 			_My_data._Mysize = _Old_size + _Count;

  0004b	4c 89 7c 24 48	 mov	 QWORD PTR [rsp+72], r15

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00050	48 83 f9 10	 cmp	 rcx, 16

; 1583 : 		if (_Large_string_engaged())

  00054	72 03		 jb	 SHORT $LN35@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00056	49 8b 36	 mov	 rsi, QWORD PTR [r14]
$LN35@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2509 : 			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)

  00059	48 8d 04 1f	 lea	 rax, QWORD PTR [rdi+rbx]
  0005d	48 3b c6	 cmp	 rax, rsi
  00060	76 1b		 jbe	 SHORT $LN20@insert
  00062	4a 8d 04 06	 lea	 rax, QWORD PTR [rsi+r8]
  00066	48 3b d8	 cmp	 rbx, rax
  00069	77 12		 ja	 SHORT $LN20@insert

; 2512 : 				}
; 2513 : 			else if (_Insert_at <= _Ptr)

  0006b	48 3b f3	 cmp	 rsi, rbx
  0006e	77 05		 ja	 SHORT $LN21@insert

; 2514 : 				{	// all of [_Ptr, _Ptr + _Count) shifts
; 2515 : 				_Ptr_shifted_after = 0;

  00070	45 33 ff	 xor	 r15d, r15d

; 2516 : 				}
; 2517 : 			else

  00073	eb 0b		 jmp	 SHORT $LN22@insert
$LN21@insert:

; 2518 : 				{	// [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
; 2519 : 				_Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  00075	4c 8b fe	 mov	 r15, rsi
  00078	4c 2b fb	 sub	 r15, rbx
  0007b	eb 03		 jmp	 SHORT $LN22@insert
$LN20@insert:

; 2510 : 				{	// inserted content is before the shifted region, or does not alias
; 2511 : 				_Ptr_shifted_after = _Count; // none of _Ptr's data shifts

  0007d	4c 8b ff	 mov	 r15, rdi
$LN22@insert:

; 2520 : 				}
; 2521 : 
; 2522 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00080	49 ff c0	 inc	 r8
  00083	48 8d 0c 3e	 lea	 rcx, QWORD PTR [rsi+rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00087	48 8b d6	 mov	 rdx, rsi
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00090	4d 8b c7	 mov	 r8, r15
  00093	48 8b d3	 mov	 rdx, rbx
  00096	48 8b ce	 mov	 rcx, rsi
  00099	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2524 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  0009e	4c 8b c7	 mov	 r8, rdi
  000a1	49 8d 14 3f	 lea	 rdx, QWORD PTR [r15+rdi]
  000a5	4d 2b c7	 sub	 r8, r15
  000a8	4a 8d 0c 3e	 lea	 rcx, QWORD PTR [rsi+r15]
  000ac	48 03 d3	 add	 rdx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000af	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2468 : 		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));

  000b4	4c 8b 7c 24 48	 mov	 r15, QWORD PTR [rsp+72]
  000b9	49 8b c6	 mov	 rax, r14
  000bc	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 2469 : 		}

  000c1	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000c6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cf	41 5e		 pop	 r14
  000d1	c3		 ret	 0
$LN17@insert:

; 2529 : 		return (_Reallocate_grow_by(_Count,

  000d2	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  000d7	48 8b d7	 mov	 rdx, rdi
  000da	49 8b ce	 mov	 rcx, r14
  000dd	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  000e2	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const * __ptr64,unsigned __int64>

; 2469 : 		}

  000e7	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000ec	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000f1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f5	41 5e		 pop	 r14
  000f7	c3		 ret	 0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 1636 : 			{	// user-provided, for fancy pointers
; 1637 : 			}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
_TEXT	SEGMENT
this$ = 64
_Off$dead$ = 72
_Ptr$ = 80
_Count$ = 88
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 2497 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

$LN36:
  00000	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  00005	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0000a	41 57		 push	 r15
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00010	4d 8b f0	 mov	 r14, r8
  00013	4c 8b f9	 mov	 r15, rcx

; 1609 : 		if (_Mysize < _Off)

  00016	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2497 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  0001a	49 8b f9	 mov	 rdi, r9

; 2498 : 		auto& _My_data = this->_Get_data();
; 2499 : 		_My_data._Check_offset(_Off);
; 2500 : 		const size_type _Old_size = _My_data._Mysize;
; 2501 : 		if (_Count <= _My_data._Myres - _Old_size)

  0001d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00021	48 8b c1	 mov	 rax, rcx
  00024	49 2b c0	 sub	 rax, r8
  00027	4c 3b c8	 cmp	 r9, rax
  0002a	0f 87 96 00 00
	00		 ja	 $LN2@insert

; 2502 : 			{
; 2503 : 			_My_data._Mysize = _Old_size + _Count;

  00030	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00035	4b 8d 04 08	 lea	 rax, QWORD PTR [r8+r9]
  00039	49 89 47 10	 mov	 QWORD PTR [r15+16], rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  0003d	49 8b df	 mov	 rbx, r15

; 2502 : 			{
; 2503 : 			_My_data._Mysize = _Old_size + _Count;

  00040	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00045	48 83 f9 10	 cmp	 rcx, 16

; 1583 : 		if (_Large_string_engaged())

  00049	72 03		 jb	 SHORT $LN20@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0004b	49 8b 1f	 mov	 rbx, QWORD PTR [r15]
$LN20@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2509 : 			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)

  0004e	4b 8d 04 0e	 lea	 rax, QWORD PTR [r14+r9]
  00052	48 3b c3	 cmp	 rax, rbx
  00055	76 1a		 jbe	 SHORT $LN5@insert
  00057	4a 8d 04 03	 lea	 rax, QWORD PTR [rbx+r8]
  0005b	4c 3b f0	 cmp	 r14, rax
  0005e	77 11		 ja	 SHORT $LN5@insert

; 2512 : 				}
; 2513 : 			else if (_Insert_at <= _Ptr)

  00060	49 3b de	 cmp	 rbx, r14
  00063	77 04		 ja	 SHORT $LN6@insert

; 2514 : 				{	// all of [_Ptr, _Ptr + _Count) shifts
; 2515 : 				_Ptr_shifted_after = 0;

  00065	33 f6		 xor	 esi, esi

; 2516 : 				}
; 2517 : 			else

  00067	eb 0b		 jmp	 SHORT $LN7@insert
$LN6@insert:

; 2518 : 				{	// [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
; 2519 : 				_Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  00069	48 8b f3	 mov	 rsi, rbx
  0006c	49 2b f6	 sub	 rsi, r14
  0006f	eb 03		 jmp	 SHORT $LN7@insert
$LN5@insert:

; 2510 : 				{	// inserted content is before the shifted region, or does not alias
; 2511 : 				_Ptr_shifted_after = _Count; // none of _Ptr's data shifts

  00071	48 8b f7	 mov	 rsi, rdi
$LN7@insert:

; 2520 : 				}
; 2521 : 
; 2522 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00074	49 ff c0	 inc	 r8
  00077	4a 8d 0c 0b	 lea	 rcx, QWORD PTR [rbx+r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 431  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0007b	48 8b d3	 mov	 rdx, rbx
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00084	4c 8b c6	 mov	 r8, rsi
  00087	49 8b d6	 mov	 rdx, r14
  0008a	48 8b cb	 mov	 rcx, rbx
  0008d	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2524 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00092	4c 8b c7	 mov	 r8, rdi
  00095	4a 8d 14 36	 lea	 rdx, QWORD PTR [rsi+r14]
  00099	4c 2b c6	 sub	 r8, rsi
  0009c	48 8d 0c 33	 lea	 rcx, QWORD PTR [rbx+rsi]
  000a0	48 03 d7	 add	 rdx, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000a3	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2526 : 			return (*this);

  000a8	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ad	49 8b c7	 mov	 rax, r15
  000b0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2530 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2531 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {
; 2532 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2533 : 			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 2534 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2535 : 			}, _Off, _Ptr, _Count));
; 2536 : 		}

  000b5	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000ba	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  000bf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c3	41 5f		 pop	 r15
  000c5	c3		 ret	 0
$LN2@insert:

; 2527 : 			}
; 2528 : 
; 2529 : 		return (_Reallocate_grow_by(_Count,

  000c6	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  000cb	48 8b d7	 mov	 rdx, rdi
  000ce	49 8b cf	 mov	 rcx, r15
  000d1	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  000d6	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const * __ptr64,unsigned __int64>

; 2530 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2531 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {
; 2532 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2533 : 			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 2534 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2535 : 			}, _Off, _Ptr, _Count));
; 2536 : 		}

  000db	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000e0	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  000e5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e9	41 5f		 pop	 r15
  000eb	c3		 ret	 0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Off$dead$ = 80
_Ptr$ = 88
_Count$ = 96
??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z PROC ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator(), COMDAT

; 2531 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00014	48 8b 5c 24 60	 mov	 rbx, QWORD PTR _Count$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2531 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {

  00019	48 8b fa	 mov	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0001c	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Ptr$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2531 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {

  00021	49 8b e8	 mov	 rbp, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00024	4c 8b c3	 mov	 r8, rbx
  00027	48 8b cf	 mov	 rcx, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2531 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {

  0002a	49 8b f1	 mov	 rsi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0002d	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2534 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00032	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00036	48 8b d5	 mov	 rdx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2534 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00039	48 8d 0c 1f	 lea	 rcx, QWORD PTR [rdi+rbx]

; 2535 : 			}, _Off, _Ptr, _Count));

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00047	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5f		 pop	 rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00051	e9 00 00 00 00	 jmp	 memcpy
??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z ENDP ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 23   : 	{	// extract a string

$LN180:
  00000	48 8b c4	 mov	 rax, rsp
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00010	48 c7 40 b8 fe
	ff ff ff	 mov	 QWORD PTR [rax-72], -2
  00018	48 89 58 18	 mov	 QWORD PTR [rax+24], rbx
  0001c	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  00020	48 8b da	 mov	 rbx, rdx
  00023	48 8b f9	 mov	 rdi, rcx
  00026	48 89 4c 24 38	 mov	 QWORD PTR _Istr$GSCopy$[rsp], rcx

; 24   : 	typedef ctype<_Elem> _Ctype;
; 25   : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 26   : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 27   : 	typedef typename _Mystr::size_type _Mysizt;
; 28   : 
; 29   : 	ios_base::iostate _State = ios_base::goodbit;

  0002b	33 f6		 xor	 esi, esi
  0002d	89 74 24 34	 mov	 DWORD PTR _State$[rsp], esi

; 30   : 	bool _Changed = false;

  00031	45 32 ff	 xor	 r15b, r15b
  00034	44 88 7c 24 30	 mov	 BYTE PTR _Changed$[rsp], r15b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 92   : 			: _Myistr(_Istr)

  00039	4c 8b e1	 mov	 r12, rcx
  0003c	48 89 48 a8	 mov	 QWORD PTR [rax-88], rcx

; 94   : 			if (_Myistr.rdbuf() != 0)

  00040	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00043	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00047	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  0004c	48 85 c9	 test	 rcx, rcx
  0004f	74 07		 je	 SHORT $LN25@operator

; 95   : 				_Myistr.rdbuf()->_Lock();

  00051	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00054	ff 50 08	 call	 QWORD PTR [rax+8]
  00057	90		 npad	 1
$LN25@operator:

; 116  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00058	33 d2		 xor	 edx, edx
  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
  00063	88 44 24 48	 mov	 BYTE PTR _Ok$[rsp+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 33   : 	if (_Ok)

  00067	84 c0		 test	 al, al
  00069	0f 84 3e 01 00
	00		 je	 $LN19@operator

; 34   : 		{	// state okay, extract characters
; 35   : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  0006f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00072	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00076	48 03 cf	 add	 rcx, rdi
  00079	48 8d 54 24 58	 lea	 rdx, QWORD PTR $T4[rsp]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?getloc@ios_base@std@@QEBA?AVlocale@2@XZ
  00084	90		 npad	 1
  00085	48 8b c8	 mov	 rcx, rax
  00088	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0008d	4c 8b e8	 mov	 r13, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale

; 403  : 		if (_Ptr != 0)

  00090	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T4[rsp+8]
  00095	48 85 c9	 test	 rcx, rcx
  00098	74 19		 je	 SHORT $LN36@operator

; 404  : 			delete _Ptr->_Decref();

  0009a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0009d	ff 50 10	 call	 QWORD PTR [rax+16]
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	48 85 c0	 test	 rax, rax
  000a6	74 0b		 je	 SHORT $LN36@operator
  000a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ab	ba 01 00 00 00	 mov	 edx, 1
  000b0	ff 10		 call	 QWORD PTR [rax]
  000b2	90		 npad	 1
$LN36@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3677 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  000b3	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0

; 1582 : 		value_type * _Result = _Bx._Buf;

  000bb	48 8b c3	 mov	 rax, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  000be	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1583 : 		if (_Large_string_engaged())

  000c3	72 03		 jb	 SHORT $LN60@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  000c5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN60@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  000c8	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 40   : 			&& (_Mysizt)_Istr.width() < _Str.max_size()

  000cb	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000ce	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 422  : 		return (_Wide);

  000d2	4c 8b 74 39 28	 mov	 r14, QWORD PTR [rcx+rdi+40]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 40   : 			&& (_Mysizt)_Istr.width() < _Str.max_size()

  000d7	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000e1	4d 85 f6	 test	 r14, r14
  000e4	7e 05		 jle	 SHORT $LN174@operator
  000e6	4c 3b f0	 cmp	 r14, rax
  000e9	72 03		 jb	 SHORT $LN98@operator
$LN174@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3055 : 		return (_Min_value(

  000eb	4c 8b f0	 mov	 r14, rax
$LN98@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 42   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  000ee	48 8b 4c 39 48	 mov	 rcx, QWORD PTR [rcx+rdi+72]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@operator:

; 43   : 
; 44   : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  00100	4d 85 f6	 test	 r14, r14
  00103	74 0e		 je	 SHORT $LN3@operator

; 45   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00105	83 f8 ff	 cmp	 eax, -1
  00108	75 0e		 jne	 SHORT $LN7@operator

; 46   : 				{	// end of file, quit
; 47   : 				_State |= ios_base::eofbit;

  0010a	be 01 00 00 00	 mov	 esi, 1
  0010f	89 74 24 34	 mov	 DWORD PTR _State$[rsp], esi
$LN3@operator:
  00113	e9 95 00 00 00	 jmp	 $LN19@operator
$LN7@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xlocale

; 2343 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

  00118	44 0f b6 c8	 movzx	 r9d, al
  0011c	49 8b 45 18	 mov	 rax, QWORD PTR [r13+24]
  00120	42 f6 04 48 48	 test	 BYTE PTR [rax+r9*2], 72	; 00000048H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 50   : 			else if (_Ctype_fac.is(_Ctype::space,

  00125	75 ec		 jne	 SHORT $LN3@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2362 : 		const size_type _Old_size = _My_data._Mysize;

  00127	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]

; 2363 : 		if (_Count <= _My_data._Myres - _Old_size)

  0012b	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  0012f	48 8b c2	 mov	 rax, rdx
  00132	48 2b c1	 sub	 rax, rcx
  00135	48 83 f8 01	 cmp	 rax, 1
  00139	72 27		 jb	 SHORT $LN137@operator

; 2364 : 			{
; 2365 : 			_My_data._Mysize = _Old_size + _Count;

  0013b	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  0013f	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00143	4c 8b c3	 mov	 r8, rbx

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00146	48 83 fa 10	 cmp	 rdx, 16

; 1583 : 		if (_Large_string_engaged())

  0014a	72 03		 jb	 SHORT $LN146@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0014c	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
$LN146@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 437  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

  0014f	41 0f be c1	 movsx	 eax, r9b
  00153	0f b6 c0	 movzx	 al, al
  00156	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 442  : 		_Left = _Right;

  0015a	41 c6 44 08 01
	00		 mov	 BYTE PTR [r8+rcx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2369 : 			return (*this);

  00160	eb 15		 jmp	 SHORT $LN136@operator
$LN137@operator:

; 2370 : 			}
; 2371 : 
; 2372 : 		return (_Reallocate_grow_by(_Count,

  00162	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00167	ba 01 00 00 00	 mov	 edx, 1
  0016c	44 8b ca	 mov	 r9d, edx
  0016f	48 8b cb	 mov	 rcx, rbx
  00172	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
$LN136@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 56   : 				_Changed = true;

  00177	41 b7 01	 mov	 r15b, 1
  0017a	44 88 7c 24 30	 mov	 BYTE PTR _Changed$[rsp], r15b

; 43   : 
; 44   : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  0017f	49 ff ce	 dec	 r14
  00182	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00185	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00189	48 8b 4c 39 48	 mov	 rcx, QWORD PTR [rcx+rdi+72]
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  00194	e9 67 ff ff ff	 jmp	 $LL4@operator
$LN20@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
  00199	8b 74 24 34	 mov	 esi, DWORD PTR _State$[rsp]
  0019d	44 0f b6 7c 24
	30		 movzx	 r15d, BYTE PTR _Changed$[rsp]
  001a3	4c 8b 64 24 40	 mov	 r12, QWORD PTR _Ok$[rsp]
  001a8	48 8b 7c 24 38	 mov	 rdi, QWORD PTR _Istr$GSCopy$[rsp]
$LN19@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 57   : 				}
; 58   : 		_CATCH_IO_(_Istr)
; 59   : 		}
; 60   : 
; 61   : 	_Istr.width(0);

  001ad	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  001b0	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  001b4	48 c7 44 39 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rdi+40], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 62   : 	if (!_Changed)

  001bd	45 84 ff	 test	 r15b, r15b
  001c0	75 03		 jne	 SHORT $LN11@operator

; 63   : 		_State |= ios_base::failbit;

  001c2	83 ce 02	 or	 esi, 2
$LN11@operator:

; 64   : 	_Istr.setstate(_State);

  001c5	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  001c8	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  001cc	48 03 cf	 add	 rcx, rdi
  001cf	45 33 c0	 xor	 r8d, r8d
  001d2	8b d6		 mov	 edx, esi
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  001da	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 100  : 			if (_Myistr.rdbuf() != 0)

  001db	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  001df	48 63 51 04	 movsxd	 rdx, DWORD PTR [rcx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  001e3	4a 8b 4c 22 48	 mov	 rcx, QWORD PTR [rdx+r12+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 100  : 			if (_Myistr.rdbuf() != 0)

  001e8	48 85 c9	 test	 rcx, rcx
  001eb	74 07		 je	 SHORT $LN175@operator

; 101  : 				_Myistr.rdbuf()->_Unlock();

  001ed	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  001f0	ff 52 10	 call	 QWORD PTR [rdx+16]
  001f3	90		 npad	 1
$LN175@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 65   : 	return (_Istr);

  001f4	48 8b c7	 mov	 rax, rdi

; 66   : 	}

  001f7	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  001fc	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  00200	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  00204	49 8b e3	 mov	 rsp, r11
  00207	41 5f		 pop	 r15
  00209	41 5e		 pop	 r14
  0020b	41 5d		 pop	 r13
  0020d	41 5c		 pop	 r12
  0020f	5f		 pop	 rdi
  00210	c3		 ret	 0
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$2@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
  00000	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$2@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$0@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  0000c	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
?dtor$0@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$1@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00018	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T4[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$1@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$33

; 57   : 				}
; 58   : 		_CATCH_IO_(_Istr)

  00024	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00029	55		 push	 rbp
  0002a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0002e	48 8b ea	 mov	 rbp, rdx
__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:
  00031	48 8b 55 38	 mov	 rdx, QWORD PTR _Istr$GSCopy$[rbp]
  00035	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00038	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0003c	48 03 ca	 add	 rcx, rdx
  0003f	41 b0 01	 mov	 r8b, 1
  00042	ba 04 00 00 00	 mov	 edx, 4
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0004d	90		 npad	 1
  0004e	48 8d 05 00 00
	00 00		 lea	 rax, $LN20@catch$33
  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
  0005b	cc		 int	 3
?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$33
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$2@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
  00000	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$2@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$0@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  0000c	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
?dtor$0@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$1@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00018	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T4[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$1@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$33

; 58   : 		_CATCH_IO_(_Istr)

  00024	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00029	55		 push	 rbp
  0002a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0002e	48 8b ea	 mov	 rbp, rdx
__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:
  00031	48 8b 55 38	 mov	 rdx, QWORD PTR _Istr$GSCopy$[rbp]
  00035	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00038	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0003c	48 03 ca	 add	 rcx, rdx
  0003f	41 b0 01	 mov	 r8b, 1
  00042	ba 04 00 00 00	 mov	 edx, 4
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0004d	90		 npad	 1
  0004e	48 8d 05 00 00
	00 00		 lea	 rax, $LN20@catch$33
  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
  0005b	cc		 int	 3
?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$33
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > & __ptr64>, COMDAT

; 1553 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1554 : 	}

  00003	c3		 ret	 0
??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z
_TEXT	SEGMENT
this$dead$ = 48
_Eng$dead$ = 56
_Min$ = 64
_Max$ = 72
??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z PROC ; std::uniform_int<int>::_Eval<std::random_device>, COMDAT

; 2320 : 		{	// compute next value in range [_Min, _Max]

$LN91:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2345 : 		if (_Uval < _Adjuster)

  0000a	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  0000f	41 8d 34 00	 lea	 esi, DWORD PTR [r8+rax]

; 2321 : 		_Rng_from_urng<_Uty, _Engine> _Rng(_Eng);
; 2322 : 
; 2323 : 		const _Uty _Umin = _Adjust(_Uty(_Min));
; 2324 : 		const _Uty _Umax = _Adjust(_Uty(_Max));
; 2325 : 
; 2326 : 		_Uty _Uret = 0;
; 2327 : 
; 2328 : 		if (_Umax - _Umin == _Uty(-1))

  00013	44 2b ce	 sub	 r9d, esi
  00016	41 8d 1c 01	 lea	 ebx, DWORD PTR [r9+rax]
  0001a	83 fb ff	 cmp	 ebx, -1			; ffffffffH
  0001d	75 18		 jne	 SHORT $LN2@Eval

; 6410 : 		return (_Random_device());

  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  00025	05 00 00 00 80	 add	 eax, -2147483648	; ffffffff80000000H
  0002a	03 c6		 add	 eax, esi

; 2334 : 		}

  0002c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5e		 pop	 rsi
  00036	c3		 ret	 0
$LN2@Eval:
  00037	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 2329 : 			_Uret = static_cast<_Uty>(_Rng._Get_all_bits());
; 2330 : 		else
; 2331 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  0003c	8d 7b 01	 lea	 edi, DWORD PTR [rbx+1]
  0003f	90		 npad	 1
$LL42@Eval:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3944 : 			_Udiff _Ret = 0;	// random bits

  00040	45 33 c0	 xor	 r8d, r8d

; 3945 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00043	33 c0		 xor	 eax, eax

; 3946 : 
; 3947 : 			while (_Mask < _Udiff(_Index - 1))

  00045	85 db		 test	 ebx, ebx
  00047	74 0c		 je	 SHORT $LN46@Eval
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  0004f	44 8b c0	 mov	 r8d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3954 : 				_Mask |= _Bmask;

  00052	83 c8 ff	 or	 eax, -1			; ffffffffH
$LN46@Eval:

; 3955 : 				}
; 3956 : 
; 3957 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3958 : 			if (_Ret / _Index < _Mask / _Index
; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00055	33 d2		 xor	 edx, edx
  00057	f7 f7		 div	 edi
  00059	8b c8		 mov	 ecx, eax
  0005b	44 8b ca	 mov	 r9d, edx
  0005e	33 d2		 xor	 edx, edx
  00060	41 8b c0	 mov	 eax, r8d
  00063	f7 f7		 div	 edi
  00065	3b c1		 cmp	 eax, ecx
  00067	72 05		 jb	 SHORT $LN76@Eval
  00069	44 3b cb	 cmp	 r9d, ebx
  0006c	75 d2		 jne	 SHORT $LL42@Eval
$LN76@Eval:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2334 : 		}

  0006e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3960 : 				return (_Ret % _Index);

  00073	33 d2		 xor	 edx, edx
  00075	41 8b c0	 mov	 eax, r8d
  00078	f7 f7		 div	 edi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 2333 : 		return (_Ty(_Adjust(_Uret + _Umin)));

  0007a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  0007f	8d 86 00 00 00
	80		 lea	 eax, DWORD PTR [rsi-2147483648]
  00085	03 c2		 add	 eax, edx

; 2334 : 		}

  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5e		 pop	 rsi
  0008c	c3		 ret	 0
??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z ENDP ; std::uniform_int<int>::_Eval<std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 75   : 	{	// get characters into string, discard delimiter

$LN159:
  00000	48 8b c4	 mov	 rax, rsp
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00010	48 c7 40 c8 fe
	ff ff ff	 mov	 QWORD PTR [rax-56], -2
  00018	48 89 58 18	 mov	 QWORD PTR [rax+24], rbx
  0001c	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  00020	45 0f b6 f8	 movzx	 r15d, r8b
  00024	48 8b fa	 mov	 rdi, rdx
  00027	48 8b f1	 mov	 rsi, rcx
  0002a	48 89 4c 24 28	 mov	 QWORD PTR _Istr$GSCopy$[rsp], rcx

; 76   : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 77   : 
; 78   : 	ios_base::iostate _State = ios_base::goodbit;

  0002f	33 db		 xor	 ebx, ebx
  00031	89 5c 24 24	 mov	 DWORD PTR _State$[rsp], ebx

; 79   : 	bool _Changed = false;

  00035	45 32 f6	 xor	 r14b, r14b
  00038	44 88 74 24 20	 mov	 BYTE PTR _Changed$[rsp], r14b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 92   : 			: _Myistr(_Istr)

  0003d	4c 8b e1	 mov	 r12, rcx
  00040	48 89 48 b8	 mov	 QWORD PTR [rax-72], rcx

; 94   : 			if (_Myistr.rdbuf() != 0)

  00044	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00047	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0004b	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  00050	48 85 c9	 test	 rcx, rcx
  00053	74 07		 je	 SHORT $LN24@getline

; 95   : 				_Myistr.rdbuf()->_Lock();

  00055	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00058	ff 50 08	 call	 QWORD PTR [rax+8]
  0005b	90		 npad	 1
$LN24@getline:

; 116  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0005c	b2 01		 mov	 dl, 1
  0005e	48 8b ce	 mov	 rcx, rsi
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
  00067	88 44 24 38	 mov	 BYTE PTR _Ok$[rsp+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 82   : 	if (_Ok)

  0006b	84 c0		 test	 al, al
  0006d	0f 84 e9 00 00
	00		 je	 $LN153@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3677 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00073	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx

; 1582 : 		value_type * _Result = _Bx._Buf;

  00077	48 8b c7	 mov	 rax, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  0007a	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 1583 : 		if (_Large_string_engaged())

  0007f	72 03		 jb	 SHORT $LN154@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00081	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN154@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00084	c6 00 00	 mov	 BYTE PTR [rax], 0

; 462  : 		return (static_cast<unsigned char>(_Ch));

  00087	45 0f b6 ff	 movzx	 r15d, r15b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 88   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  0008b	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0008e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00092	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  0009d	8b d0		 mov	 edx, eax
  0009f	49 bd ff ff ff
	ff ff ff ff 7f	 mov	 r13, 9223372036854775807 ; 7fffffffffffffffH
  000a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@getline:

; 91   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000b0	83 fa ff	 cmp	 edx, -1
  000b3	75 05		 jne	 SHORT $LN7@getline

; 92   : 				{	// end of file, quit
; 93   : 				_State |= ios_base::eofbit;

  000b5	8d 5a 02	 lea	 ebx, QWORD PTR [rdx+2]

; 94   : 				break;

  000b8	eb 2f		 jmp	 SHORT $LN156@getline
$LN7@getline:

; 95   : 				}
; 96   : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  000ba	41 3b d7	 cmp	 edx, r15d
  000bd	75 1c		 jne	 SHORT $LN9@getline

; 97   : 				{	// got a delimiter, discard it and quit
; 98   : 				_Changed = true;

  000bf	41 b6 01	 mov	 r14b, 1
  000c2	44 88 74 24 20	 mov	 BYTE PTR _Changed$[rsp], r14b

; 99   : 				_Istr.rdbuf()->sbumpc();

  000c7	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000ca	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000ce	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ

; 100  : 				break;

  000d9	eb 12		 jmp	 SHORT $LN3@getline
$LN9@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3047 : 		return (this->_Get_data()._Mysize);

  000db	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 102  : 			else if (_Str.max_size() <= _Str.size())

  000df	49 3b cd	 cmp	 rcx, r13
  000e2	72 0b		 jb	 SHORT $LN11@getline

; 103  : 				{	// string too large, quit
; 104  : 				_State |= ios_base::failbit;

  000e4	bb 02 00 00 00	 mov	 ebx, 2
$LN156@getline:
  000e9	89 5c 24 24	 mov	 DWORD PTR _State$[rsp], ebx
$LN3@getline:
  000ed	eb 68		 jmp	 SHORT $LN18@getline
$LN11@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2977 : 		if (_Old_size < _My_data._Myres)

  000ef	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  000f3	49 3b c8	 cmp	 rcx, r8
  000f6	73 1e		 jae	 SHORT $LN117@getline

; 2978 : 			{
; 2979 : 			_My_data._Mysize = _Old_size + 1;

  000f8	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  000fc	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 1582 : 		value_type * _Result = _Bx._Buf;

  00100	48 8b c7	 mov	 rax, rdi

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00103	49 83 f8 10	 cmp	 r8, 16

; 1583 : 		if (_Large_string_engaged())

  00107	72 03		 jb	 SHORT $LN126@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  00109	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN126@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  0010c	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  0010f	c6 44 08 01 00	 mov	 BYTE PTR [rax+rcx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2983 : 			return;

  00114	eb 0c		 jmp	 SHORT $LN116@getline
$LN117@getline:

; 2984 : 			}
; 2985 : 
; 2986 : 		_Reallocate_grow_by(1,

  00116	44 0f b6 ca	 movzx	 r9d, dl
  0011a	48 8b cf	 mov	 rcx, rdi
  0011d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN116@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 110  : 				_Changed = true;

  00122	41 b6 01	 mov	 r14b, 1
  00125	44 88 74 24 20	 mov	 BYTE PTR _Changed$[rsp], r14b

; 89   : 
; 90   : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  0012a	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0012d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00131	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  0013c	8b d0		 mov	 edx, eax
  0013e	e9 6d ff ff ff	 jmp	 $LL4@getline
$LN19@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
  00143	8b 5c 24 24	 mov	 ebx, DWORD PTR _State$[rsp]
  00147	44 0f b6 74 24
	20		 movzx	 r14d, BYTE PTR _Changed$[rsp]
  0014d	4c 8b 64 24 30	 mov	 r12, QWORD PTR _Ok$[rsp]
  00152	48 8b 74 24 28	 mov	 rsi, QWORD PTR _Istr$GSCopy$[rsp]
$LN18@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 111  : 				}
; 112  : 		_CATCH_IO_(_Istr)
; 113  : 		}
; 114  : 
; 115  : 	if (!_Changed)

  00157	45 84 f6	 test	 r14b, r14b
  0015a	75 03		 jne	 SHORT $LN13@getline
$LN153@getline:

; 116  : 		_State |= ios_base::failbit;

  0015c	83 cb 02	 or	 ebx, 2
$LN13@getline:

; 117  : 	_Istr.setstate(_State);

  0015f	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00162	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00166	48 03 ce	 add	 rcx, rsi
  00169	45 33 c0	 xor	 r8d, r8d
  0016c	8b d3		 mov	 edx, ebx
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00174	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 100  : 			if (_Myistr.rdbuf() != 0)

  00175	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  00179	48 63 51 04	 movsxd	 rdx, DWORD PTR [rcx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  0017d	4a 8b 4c 22 48	 mov	 rcx, QWORD PTR [rdx+r12+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 100  : 			if (_Myistr.rdbuf() != 0)

  00182	48 85 c9	 test	 rcx, rcx
  00185	74 07		 je	 SHORT $LN155@getline

; 101  : 				_Myistr.rdbuf()->_Unlock();

  00187	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0018a	ff 52 10	 call	 QWORD PTR [rdx+16]
  0018d	90		 npad	 1
$LN155@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\string

; 118  : 	return (_Istr);

  0018e	48 8b c6	 mov	 rax, rsi

; 119  : 	}

  00191	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  00196	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  0019a	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  0019e	49 8b e3	 mov	 rsp, r11
  001a1	41 5f		 pop	 r15
  001a3	41 5e		 pop	 r14
  001a5	41 5d		 pop	 r13
  001a7	41 5c		 pop	 r12
  001a9	5f		 pop	 rdi
  001aa	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  0000c	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$28

; 111  : 				}
; 112  : 		_CATCH_IO_(_Istr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:
  00025	48 8b 55 28	 mov	 rdx, QWORD PTR _Istr$GSCopy$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN19@catch$28
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$28
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  0000c	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$28

; 112  : 		_CATCH_IO_(_Istr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:
  00025	48 8b 55 28	 mov	 rdx, QWORD PTR _Istr$GSCopy$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN19@catch$28
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$28
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
_TEXT	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>, COMDAT

; 24   : 	{	// insert a character-type sequence into _Ostr as if through a basic_string copy

$LN112:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00011	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T27[rsp], -2
  0001a	48 89 5c 24 78	 mov	 QWORD PTR [rsp+120], rbx
  0001f	4d 8b f8	 mov	 r15, r8
  00022	4c 8b e2	 mov	 r12, rdx
  00025	48 8b f1	 mov	 rsi, rcx

; 25   : 	ios_base::iostate _State = ios_base::goodbit;

  00028	33 db		 xor	 ebx, ebx
  0002a	89 9c 24 88 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx

; 26   : 	_SizeT _Pad = _Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size

  00031	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00034	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 422  : 		return (_Wide);

  00038	48 8b 7c 30 28	 mov	 rdi, QWORD PTR [rax+rsi+40]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 26   : 	_SizeT _Pad = _Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size

  0003d	48 85 ff	 test	 rdi, rdi
  00040	7e 0a		 jle	 SHORT $LN17@Insert_str
  00042	49 3b f8	 cmp	 rdi, r8
  00045	76 05		 jbe	 SHORT $LN17@Insert_str
  00047	49 2b f8	 sub	 rdi, r8
  0004a	eb 02		 jmp	 SHORT $LN18@Insert_str
$LN17@Insert_str:
  0004c	33 ff		 xor	 edi, edi
$LN18@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 98   : 			: _Myostr(_Ostr)

  0004e	4c 8b f6	 mov	 r14, rsi
  00051	48 89 74 24 28	 mov	 QWORD PTR _Ok$[rsp], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00056	48 8b 54 30 48	 mov	 rdx, QWORD PTR [rax+rsi+72]
  0005b	4c 8b c1	 mov	 r8, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

  0005e	48 85 d2	 test	 rdx, rdx
  00061	74 0f		 je	 SHORT $LN35@Insert_str

; 101  : 				_Myostr.rdbuf()->_Lock();

  00063	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00066	48 8b ca	 mov	 rcx, rdx
  00069	ff 50 08	 call	 QWORD PTR [rax+8]
  0006c	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0006f	4c 8b c1	 mov	 r8, rcx
$LN35@Insert_str:

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00072	4c 63 49 04	 movsxd	 r9, DWORD PTR [rcx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  00076	48 8b c1	 mov	 rax, rcx
  00079	49 8b d0	 mov	 rdx, r8

; 338  : 		return (rdstate() == goodbit);

  0007c	41 83 7c 31 10
	00		 cmp	 DWORD PTR [r9+rsi+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00082	75 1e		 jne	 SHORT $LN31@Insert_str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 79   : 		return (_Tiestr);

  00084	4d 8b 4c 31 50	 mov	 r9, QWORD PTR [r9+rsi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00089	4d 85 c9	 test	 r9, r9
  0008c	74 14		 je	 SHORT $LN31@Insert_str
  0008e	4c 3b ce	 cmp	 r9, rsi
  00091	74 0f		 je	 SHORT $LN31@Insert_str

; 123  : 				_Ostr.tie()->flush();

  00093	49 8b c9	 mov	 rcx, r9
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
  0009c	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0009f	48 8b d0	 mov	 rdx, rax
$LN31@Insert_str:

; 124  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  000a2	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 314  : 		return (_Mystate);

  000a6	8b 44 31 10	 mov	 eax, DWORD PTR [rcx+rsi+16]

; 338  : 		return (rdstate() == goodbit);

  000aa	85 c0		 test	 eax, eax
  000ac	0f 94 44 24 30	 sete	 BYTE PTR _Ok$[rsp+8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 28   : 	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

  000b1	85 c0		 test	 eax, eax

; 29   : 
; 30   : 	if (!_Ok)

  000b3	74 0a		 je	 SHORT $LN8@Insert_str

; 31   : 		_State |= ios_base::badbit;

  000b5	bb 04 00 00 00	 mov	 ebx, 4

; 32   : 	else

  000ba	e9 bd 00 00 00	 jmp	 $LN22@Insert_str
$LN8@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 377  : 		return (_Fmtfl);

  000bf	8b 44 31 18	 mov	 eax, DWORD PTR [rcx+rsi+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 35   : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c3	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000c8	83 f8 40	 cmp	 eax, 64			; 00000040H
  000cb	74 78		 je	 SHORT $LN103@Insert_str
  000cd	0f 1f 00	 npad	 3
$LL4@Insert_str:

; 36   : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000d0	48 85 ff	 test	 rdi, rdi
  000d3	74 6d		 je	 SHORT $LN3@Insert_str

; 37   : 				if (_Traits::eq_int_type(_Traits::eof(),

  000d5	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000d8	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000dc	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  000e1	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  000ec	83 f8 ff	 cmp	 eax, -1
  000ef	75 4c		 jne	 SHORT $LN2@Insert_str

; 38   : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 39   : 					{	// insertion failed, quit
; 40   : 					_State |= ios_base::badbit;

  000f1	bb 04 00 00 00	 mov	 ebx, 4
  000f6	89 9c 24 88 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx
  000fd	0f 1f 00	 npad	 3
$LL107@Insert_str:

; 49   : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00100	48 85 ff	 test	 rdi, rdi
  00103	74 26		 je	 SHORT $LN6@Insert_str

; 50   : 				if (_Traits::eq_int_type(_Traits::eof(),

  00105	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00108	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0010c	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00111	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  0011c	83 f8 ff	 cmp	 eax, -1
  0011f	75 45		 jne	 SHORT $LN5@Insert_str

; 51   : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 52   : 					{	// insertion failed, quit
; 53   : 					_State |= ios_base::badbit;

  00121	83 cb 04	 or	 ebx, 4
$LN109@Insert_str:

; 46   : 				!= (streamsize)_Size)
; 47   : 				_State |= ios_base::badbit;

  00124	89 9c 24 88 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx
$LN6@Insert_str:

; 54   : 					break;
; 55   : 					}
; 56   : 		_Ostr.width(0);

  0012b	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0012e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  00132	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h
  0013b	eb 3f		 jmp	 SHORT $LN22@Insert_str
$LN2@Insert_str:

; 36   : 			for (; 0 < _Pad; --_Pad)	// pad on left

  0013d	48 ff cf	 dec	 rdi
  00140	eb 8e		 jmp	 SHORT $LL4@Insert_str
$LN3@Insert_str:

; 41   : 					break;
; 42   : 					}
; 43   : 
; 44   : 		if (_State == ios_base::goodbit
; 45   : 			&& _Ostr.rdbuf()->sputn(_Data, (streamsize)_Size)

  00142	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
$LN103@Insert_str:
  00145	48 63 42 04	 movsxd	 rax, DWORD PTR [rdx+4]
  00149	4d 8b c7	 mov	 r8, r15
  0014c	49 8b d4	 mov	 rdx, r12
  0014f	48 8b 4c 30 48	 mov	 rcx, QWORD PTR [rax+rsi+72]
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  0015a	49 3b c7	 cmp	 rax, r15
  0015d	74 a1		 je	 SHORT $LL107@Insert_str

; 46   : 				!= (streamsize)_Size)
; 47   : 				_State |= ios_base::badbit;

  0015f	bb 04 00 00 00	 mov	 ebx, 4

; 48   : 		else

  00164	eb be		 jmp	 SHORT $LN109@Insert_str
$LN5@Insert_str:

; 49   : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00166	48 ff cf	 dec	 rdi
  00169	eb 95		 jmp	 SHORT $LL107@Insert_str
$LN23@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
  0016b	48 8b 74 24 70	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  00170	8b 9c 24 88 00
	00 00		 mov	 ebx, DWORD PTR _State$[rsp]
  00177	4c 8b 74 24 28	 mov	 r14, QWORD PTR _Ok$[rsp]
$LN22@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 57   : 		_CATCH_IO_(_Ostr)
; 58   : 		}
; 59   : 
; 60   : 	_Ostr.setstate(_State);

  0017c	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0017f	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00183	48 03 ce	 add	 rcx, rsi
  00186	45 33 c0	 xor	 r8d, r8d
  00189	8b d3		 mov	 edx, ebx
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00191	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 130  : 			if (_STD uncaught_exceptions() == 0)

  00192	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ
  00198	85 c0		 test	 eax, eax
  0019a	75 0a		 jne	 SHORT $LN84@Insert_str

; 131  : 				{
; 132  : 				this->_Myostr._Osfx();

  0019c	49 8b ce	 mov	 rcx, r14
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  001a5	90		 npad	 1
$LN84@Insert_str:

; 106  : 			if (_Myostr.rdbuf() != 0)

  001a6	49 8b 06	 mov	 rax, QWORD PTR [r14]
  001a9	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  001ad	4a 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+r14+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ostream

; 106  : 			if (_Myostr.rdbuf() != 0)

  001b2	48 85 c9	 test	 rcx, rcx
  001b5	74 07		 je	 SHORT $LN88@Insert_str

; 107  : 				_Myostr.rdbuf()->_Unlock();

  001b7	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001ba	ff 50 10	 call	 QWORD PTR [rax+16]
  001bd	90		 npad	 1
$LN88@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring_insert.h

; 61   : 	return (_Ostr);

  001be	48 8b c6	 mov	 rax, rsi

; 62   : 	}

  001c1	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  001c6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001ca	41 5f		 pop	 r15
  001cc	41 5e		 pop	 r14
  001ce	41 5c		 pop	 r12
  001d0	5f		 pop	 rdi
  001d1	5e		 pop	 rsi
  001d2	c3		 ret	 0
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$8

; 57   : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$8
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$8

; 57   : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$8
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$8
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1538 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1539 : 	}

  00003	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1563 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1564 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 322  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
__formal$dead$ = 24
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1139 : 	_Left = _STD move(_Right);
; 1140 : 	}

  00000	c2 00 00	 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 1126 : 	}

  00000	c2 00 00	 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * __ptr64 const & __ptr64>, COMDAT

; 1538 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1539 : 	}

  00003	c3		 ret	 0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z PROC ; std::forward<std::allocator<char> const & __ptr64>, COMDAT

; 1538 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1539 : 	}

  00003	c3		 ret	 0
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const & __ptr64>, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 1563 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1564 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 322  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z
_TEXT	SEGMENT
_Left$ = 48
_Left_size$ = 56
_Right$ = 64
_Right_size$ = 72
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z PROC ; std::_Traits_equal<std::char_traits<char> >, COMDAT

; 24   : 	{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	49 8b c0	 mov	 rax, r8

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00007	49 3b d1	 cmp	 rdx, r9
  0000a	75 16		 jne	 SHORT $LN3@Traits_equ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 400  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0000c	4c 8b c2	 mov	 r8, rdx
  0000f	48 8b d0	 mov	 rdx, rax
  00012	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00017	85 c0		 test	 eax, eax
  00019	75 07		 jne	 SHORT $LN3@Traits_equ
  0001b	b0 01		 mov	 al, 1

; 26   : 	}

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
$LN3@Traits_equ:

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00022	32 c0		 xor	 al, al

; 26   : 	}

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ENDP ; std::_Traits_equal<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
_TEXT	SEGMENT
this$ = 80
_Size_increase$ = 88
_Fn$dead$ = 96
??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >, COMDAT

; 3626 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3627 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3628 : 		auto& _My_data = this->_Get_data();
; 3629 : 		const size_type _Old_size = _My_data._Mysize;

  00009	4c 8b 71 10	 mov	 r14, QWORD PTR [rcx+16]

; 3630 : 		if (max_size() - _Old_size < _Size_increase)

  0000d	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00017	48 8b c3	 mov	 rax, rbx
  0001a	48 8b f9	 mov	 rdi, rcx
  0001d	49 2b c6	 sub	 rax, r14
  00020	48 3b c2	 cmp	 rax, rdx
  00023	0f 82 1f 01 00
	00		 jb	 $LN138@Reallocate

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  00029	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  0002e	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  00032	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00037	4e 8d 3c 32	 lea	 r15, QWORD PTR [rdx+r14]

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0003b	49 8b cf	 mov	 rcx, r15
  0003e	48 83 c9 0f	 or	 rcx, 15
  00042	48 3b cb	 cmp	 rcx, rbx

; 3577 : 		if (_Masked > _Max)

  00045	77 1f		 ja	 SHORT $LN33@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);
; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  00047	48 8b d5	 mov	 rdx, rbp
  0004a	48 8b c3	 mov	 rax, rbx
  0004d	48 d1 ea	 shr	 rdx, 1
  00050	48 2b c2	 sub	 rax, rdx
  00053	48 3b e8	 cmp	 rbp, rax
  00056	77 0e		 ja	 SHORT $LN33@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);
; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00058	48 8d 04 2a	 lea	 rax, QWORD PTR [rdx+rbp]
  0005c	48 8b d9	 mov	 rbx, rcx
  0005f	48 3b c8	 cmp	 rcx, rax
  00062	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3637 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3638 : 		auto& _Al = this->_Getal();
; 3639 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00066	48 8b cb	 mov	 rcx, rbx
  00069	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  0006e	48 83 c1 01	 add	 rcx, 1
  00072	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00079	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  0007d	48 85 c9	 test	 rcx, rcx
  00080	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  00082	33 f6		 xor	 esi, esi
  00084	eb 34		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  00086	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0008d	72 23		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  0008f	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  00093	48 3b c1	 cmp	 rax, rcx
  00096	0f 86 b2 00 00
	00		 jbe	 $LN140@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0009c	48 8b c8	 mov	 rcx, rax
  0009f	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  000a4	48 8d 70 27	 lea	 rsi, QWORD PTR [rax+39]
  000a8	48 83 e6 e0	 and	 rsi, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000ac	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  000b0	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  000b2	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000b7	48 8b f0	 mov	 rsi, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3641 : 		_My_data._Mysize = _New_size;

  000ba	4c 89 7f 10	 mov	 QWORD PTR [rdi+16], r15

; 3642 : 		_My_data._Myres = _New_capacity;

  000be	4d 8d 46 01	 lea	 r8, QWORD PTR [r14+1]
  000c2	48 89 5f 18	 mov	 QWORD PTR [rdi+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000c6	48 8b ce	 mov	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000c9	48 83 fd 10	 cmp	 rbp, 16
  000cd	72 53		 jb	 SHORT $LN3@Reallocate

; 3645 : 			{
; 3646 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000cf	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000d2	48 8b d3	 mov	 rdx, rbx
  000d5	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000da	48 8d 55 01	 lea	 rdx, QWORD PTR [rbp+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  000de	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  000e5	72 2a		 jb	 SHORT $LN105@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  000e7	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  000eb	48 3b c2	 cmp	 rax, rdx
  000ee	76 2b		 jbe	 SHORT $_Invalid_parameter$141

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  000f0	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  000f3	f6 c3 1f	 test	 bl, 31
  000f6	75 23		 jne	 SHORT $_Invalid_parameter$141

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000f8	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  000fc	48 3b c3	 cmp	 rax, rbx
  000ff	73 1a		 jae	 SHORT $_Invalid_parameter$141

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00101	48 2b d8	 sub	 rbx, rax
  00104	48 83 eb 08	 sub	 rbx, 8
  00108	48 83 fb 1f	 cmp	 rbx, 31
  0010c	77 0d		 ja	 SHORT $_Invalid_parameter$141

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0010e	48 8b d8	 mov	 rbx, rax
$LN105@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00111	48 8b cb	 mov	 rcx, rbx
  00114	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3651 : 		else

  00119	eb 0f		 jmp	 SHORT $LN4@Reallocate
$_Invalid_parameter$141:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00121	cc		 int	 3
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00122	48 8b d7	 mov	 rdx, rdi
  00125	e8 00 00 00 00	 call	 memcpy
$LN4@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  0012a	48 89 37	 mov	 QWORD PTR [rdi], rsi
  0012d	48 8b c7	 mov	 rax, rdi
  00130	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  00135	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0013a	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 3658 : 		}

  0013f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00143	41 5e		 pop	 r14
  00145	5f		 pop	 rdi
  00146	5b		 pop	 rbx
  00147	c3		 ret	 0
$LN138@Reallocate:

; 3631 : 			{
; 3632 : 			_Xlen();	// result too long

  00148	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  0014d	cc		 int	 3
$LN140@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  0014e	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  00153	cc		 int	 3
$LN137@Reallocate:
??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$dead$ = 120
<_Args_1>$ = 128
<_Args_2>$ = 136
??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const * __ptr64,unsigned __int64>, COMDAT

; 3626 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3627 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3628 : 		auto& _My_data = this->_Get_data();
; 3629 : 		const size_type _Old_size = _My_data._Mysize;

  0000d	4c 8b 71 10	 mov	 r14, QWORD PTR [rcx+16]

; 3630 : 		if (max_size() - _Old_size < _Size_increase)

  00011	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  0001b	4c 8b a4 24 88
	00 00 00	 mov	 r12, QWORD PTR <_Args_2>$[rsp]
  00023	48 8b c3	 mov	 rax, rbx
  00026	4c 8b ac 24 80
	00 00 00	 mov	 r13, QWORD PTR <_Args_1>$[rsp]
  0002e	49 2b c6	 sub	 rax, r14
  00031	48 8b f1	 mov	 rsi, rcx
  00034	48 3b c2	 cmp	 rax, rdx
  00037	0f 82 41 01 00
	00		 jb	 $LN150@Reallocate

; 3633 : 			}
; 3634 : 
; 3635 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3636 : 		const size_type _Old_capacity = _My_data._Myres;

  0003d	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00042	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  00046	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0004b	4e 8d 3c 32	 lea	 r15, QWORD PTR [rdx+r14]

; 3576 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0004f	49 8b cf	 mov	 rcx, r15
  00052	48 83 c9 0f	 or	 rcx, 15
  00056	48 3b cb	 cmp	 rcx, rbx

; 3577 : 		if (_Masked > _Max)

  00059	77 1f		 ja	 SHORT $LN33@Reallocate

; 3578 : 			{	// the mask overflows, settle for max_size()
; 3579 : 			return (_Max);
; 3580 : 			}
; 3581 : 
; 3582 : 		const size_type _Old = _My_data._Myres;
; 3583 : 		if (_Old > _Max - _Old / 2)

  0005b	48 8b d5	 mov	 rdx, rbp
  0005e	48 8b c3	 mov	 rax, rbx
  00061	48 d1 ea	 shr	 rdx, 1
  00064	48 2b c2	 sub	 rax, rdx
  00067	48 3b e8	 cmp	 rbp, rax
  0006a	77 0e		 ja	 SHORT $LN33@Reallocate

; 3584 : 			{	// similarly, geometric overflows
; 3585 : 			return (_Max);
; 3586 : 			}
; 3587 : 
; 3588 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0006c	48 8d 04 2a	 lea	 rax, QWORD PTR [rdx+rbp]
  00070	48 8b d9	 mov	 rbx, rcx
  00073	48 3b c8	 cmp	 rcx, rax
  00076	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3637 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3638 : 		auto& _Al = this->_Getal();
; 3639 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0007a	48 8b cb	 mov	 rcx, rbx
  0007d	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  00082	48 83 c1 01	 add	 rcx, 1
  00086	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0008d	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 78   : 	if (_Count == 0)

  00091	48 85 c9	 test	 rcx, rcx
  00094	75 04		 jne	 SHORT $LN77@Reallocate

; 79   : 		{
; 80   : 		return (nullptr);

  00096	33 ff		 xor	 edi, edi
  00098	eb 34		 jmp	 SHORT $LN75@Reallocate
$LN77@Reallocate:

; 81   : 		}
; 82   : 
; 83   : 	// check overflow of multiply
; 84   : 	if (static_cast<size_t>(-1) / _Sz < _Count)
; 85   : 		{
; 86   : 		_Traits::_Fail();	// report no memory
; 87   : 		}
; 88   : 
; 89   : 	const size_t _User_size = _Count * _Sz;
; 90   : 
; 91   : #if defined(_M_IX86) || defined(_M_X64)
; 92   : 	// Boost the alignment of big allocations to help autovectorization.
; 93   :  #pragma warning(push)
; 94   :  #pragma warning(disable: 4127) // conditional expression is constant
; 95   :  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
; 96   : 	if (_Traits::_Try_aligned_allocation && _User_size >= _Big_allocation_threshold)

  0009a	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000a1	72 23		 jb	 SHORT $LN78@Reallocate

; 97   : 		{
; 98   :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 99   : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 100  : 			{	// allocation will use aligned new
; 101  : 			if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 102  : 				{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 103  : 					// and _Big_allocation_alignment; the below conditional is dead.
; 104  : 				}
; 105  : 			else
; 106  : 				{
; 107  : 				if (_Align < _Big_allocation_alignment)
; 108  : 					{	// boost alignment
; 109  : 					_Align = _Big_allocation_alignment;
; 110  : 					}
; 111  : 				}
; 112  : 			}
; 113  : 		else
; 114  :  #endif /* _HAS_ALIGNED_NEW */
; 115  : 			{	// allocation will use unaligned new; boost alignment manually
; 116  : 			const size_t _Block_size = _Non_user_size + _User_size;

  000a3	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 117  : 			if (_Block_size <= _User_size)

  000a7	48 3b c1	 cmp	 rax, rcx
  000aa	0f 86 d4 00 00
	00		 jbe	 $LN152@Reallocate

; 120  : 				}
; 121  : 
; 122  : 			const uintptr_t _Ptr_container =
; 123  : 				reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000b0	48 8b c8	 mov	 rcx, rax
  000b3	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 124  : 			_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 125  : 			void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 126  : 				& ~(_Big_allocation_alignment - 1));

  000b8	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000bc	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 127  : 			static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000c0	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 128  : 
; 129  :  #ifdef _DEBUG
; 130  : 			static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 131  :  #endif /* _DEBUG */
; 132  : 			return (_Ptr);

  000c4	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 67   : 			_Ptr = ::operator new(_Bytes);

  000c6	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000cb	48 8b f8	 mov	 rdi, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3641 : 		_My_data._Mysize = _New_size;

  000ce	4c 89 7e 10	 mov	 QWORD PTR [rsi+16], r15

; 3642 : 		_My_data._Myres = _New_capacity;

  000d2	4d 8d 3c 3c	 lea	 r15, QWORD PTR [r12+rdi]
  000d6	48 89 5e 18	 mov	 QWORD PTR [rsi+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000da	4d 8b c4	 mov	 r8, r12
  000dd	49 8b d5	 mov	 rdx, r13
  000e0	48 8b cf	 mov	 rcx, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3644 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000e3	48 83 fd 10	 cmp	 rbp, 16
  000e7	72 5f		 jb	 SHORT $LN3@Reallocate

; 3645 : 			{
; 3646 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000e9	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000ec	e8 00 00 00 00	 call	 memcpy
  000f1	4d 8d 46 01	 lea	 r8, QWORD PTR [r14+1]
  000f5	48 8b d3	 mov	 rdx, rbx
  000f8	49 8b cf	 mov	 rcx, r15
  000fb	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3648 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00100	48 8d 55 01	 lea	 rdx, QWORD PTR [rbp+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 159  : 		if (_Allocated_size >= _Big_allocation_threshold)

  00104	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0010b	72 2a		 jb	 SHORT $LN111@Reallocate

; 160  : 			{
; 161  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 162  : 			if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 163  : 				{	// allocation will use aligned new
; 164  : 				if /* constexpr */ (__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 2 >= _Big_allocation_alignment)
; 165  : 					{	// There are no valid alignments between __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 166  : 						// and _Big_allocation_alignment; the below conditional is dead.
; 167  : 					}
; 168  : 				else
; 169  : 					{
; 170  : 					if (_Align < _Big_allocation_alignment)
; 171  : 						{	// boost alignment
; 172  : 						_Align = _Big_allocation_alignment;
; 173  : 						}
; 174  : 					}
; 175  : 				}
; 176  : 			else
; 177  :  #endif /* _HAS_ALIGNED_NEW */
; 178  : 				{	// allocation will use unaligned new; boost alignment manually
; 179  : 				if (_Allocated_size + _Non_user_size <= _Allocated_size)

  0010d	48 8d 42 27	 lea	 rax, QWORD PTR [rdx+39]
  00111	48 3b c2	 cmp	 rax, rdx
  00114	76 2b		 jbe	 SHORT $_Invalid_parameter$153

; 180  : 					{
; 181  : 					goto _Invalid_parameter;
; 182  : 					}
; 183  : 				_Allocated_size += _Non_user_size;

  00116	48 8b d0	 mov	 rdx, rax

; 184  : 
; 185  : 				const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 186  : 				if ((_Ptr_user & (_Big_allocation_alignment - 1)) != 0)

  00119	f6 c3 1f	 test	 bl, 31
  0011c	75 23		 jne	 SHORT $_Invalid_parameter$153

; 187  : 					{
; 188  : 					goto _Invalid_parameter;
; 189  : 					}
; 190  : 
; 191  : 				const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 192  : 				const uintptr_t _Ptr_container =
; 193  : 					*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0011e	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 194  : 
; 195  :   #ifdef _DEBUG
; 196  : 				// If the following asserts, it likely means that we are performing
; 197  : 				// an aligned delete on memory coming from an unaligned allocation.
; 198  : 				if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _Big_allocation_sentinel)
; 199  : 					{
; 200  : 					goto _Invalid_parameter;
; 201  : 					}
; 202  :   #endif /* _DEBUG */
; 203  : 
; 204  : 				// Extra paranoia on aligned allocation/deallocation
; 205  : 				if (_Ptr_container >= _Ptr_user)

  00122	48 3b c3	 cmp	 rax, rbx
  00125	73 1a		 jae	 SHORT $_Invalid_parameter$153

; 206  : 					{
; 207  : 					goto _Invalid_parameter;
; 208  : 					}
; 209  : 
; 210  :   #ifdef _DEBUG
; 211  : 				if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 212  :   #else /* _DEBUG */
; 213  : 				if (sizeof(void *) > _Ptr_user - _Ptr_container)

  00127	48 2b d8	 sub	 rbx, rax
  0012a	48 83 eb 08	 sub	 rbx, 8
  0012e	48 83 fb 1f	 cmp	 rbx, 31
  00132	77 0d		 ja	 SHORT $_Invalid_parameter$153

; 214  :   #endif /* _DEBUG */
; 215  : 					{
; 216  : 					goto _Invalid_parameter;
; 217  : 					}
; 218  : 
; 219  : 				if (_Ptr_user - _Ptr_container > _Non_user_size)
; 220  : 					{
; 221  : 					goto _Invalid_parameter;
; 222  : 					}
; 223  : 
; 224  : 				_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00134	48 8b d8	 mov	 rbx, rax
$LN111@Reallocate:

; 225  : 				}
; 226  : 			}
; 227  :  #pragma warning(pop)
; 228  : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 229  : 
; 230  :  #if _HAS_ALIGNED_NEW // TRANSITION, if constexpr
; 231  : 		if (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
; 232  : 			{
; 233  : 			::operator delete(_Ptr, _Allocated_size, align_val_t{_Align});
; 234  : 			}
; 235  : 		else
; 236  :  #endif /* _HAS_ALIGNED_NEW */
; 237  : 			{
; 238  : 			::operator delete(_Ptr, _Allocated_size);

  00137	48 8b cb	 mov	 rcx, rbx
  0013a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3651 : 		else

  0013f	eb 1b		 jmp	 SHORT $LN4@Reallocate
$_Invalid_parameter$153:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 244  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00147	cc		 int	 3
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 411  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00148	e8 00 00 00 00	 call	 memcpy
  0014d	4d 8d 46 01	 lea	 r8, QWORD PTR [r14+1]
  00151	48 8b d6	 mov	 rdx, rsi
  00154	49 8b cf	 mov	 rcx, r15
  00157	e8 00 00 00 00	 call	 memcpy
$LN4@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 3657 : 		return (*this);

  0015c	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  0015f	48 8b c6	 mov	 rax, rsi
  00162	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]
  00167	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0016c	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 3658 : 		}

  00171	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00175	41 5e		 pop	 r14
  00177	41 5d		 pop	 r13
  00179	41 5c		 pop	 r12
  0017b	5e		 pop	 rsi
  0017c	5b		 pop	 rbx
  0017d	c3		 ret	 0
$LN150@Reallocate:

; 3631 : 			{
; 3632 : 			_Xlen();	// result too long

  0017e	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  00183	cc		 int	 3
$LN152@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xmemory0

; 119  : 				_Traits::_Fail();	// report no memory

  00184	e8 00 00 00 00	 call	 ?_Fail@?$_Default_allocate_traits@$00@std@@SAXXZ ; std::_Default_allocate_traits<1>::_Fail
  00189	cc		 int	 3
$LN149@Reallocate:
??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const * __ptr64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
$LN13:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2

; 100  : 			if (_Myistr.rdbuf() != 0)

  0000d	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00017	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 100  : 			if (_Myistr.rdbuf() != 0)

  0001c	48 85 c9	 test	 rcx, rcx
  0001f	74 07		 je	 SHORT $LN11@sentry

; 101  : 				_Myistr.rdbuf()->_Unlock();

  00021	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00024	ff 50 10	 call	 QWORD PTR [rax+16]
  00027	90		 npad	 1
$LN11@sentry:
  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ
_TEXT	SEGMENT
this$ = 48
?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits, COMDAT

; 3965 : 		{	// return a random value

$LN25:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3966 : 		_Udiff _Ret = 0;
; 3967 : 
; 3968 : 		for (size_t _Num = 0; _Num < CHAR_BIT * sizeof (_Udiff);
; 3969 : 			_Num += _Bits)

  0000f	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00013	33 db		 xor	 ebx, ebx
  00015	8b f3		 mov	 esi, ebx
  00017	48 8b f9	 mov	 rdi, rcx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Get_all_bi:

; 3970 : 			{	// don't mask away any bits
; 3971 : 			_Ret <<= _Bits - 1;	// avoid full shift

  00020	8d 88 ff 00 00
	00		 lea	 ecx, DWORD PTR [rax+255]
  00026	d3 e3		 shl	 ebx, cl

; 3972 : 			_Ret <<= 1;

  00028	03 db		 add	 ebx, ebx
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL7@Get_all_bi:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3989 : 			if (_Val <= _Bmask)

  00036	3b 47 10	 cmp	 eax, DWORD PTR [rdi+16]
  00039	77 f5		 ja	 SHORT $LL7@Get_all_bi

; 3966 : 		_Udiff _Ret = 0;
; 3967 : 
; 3968 : 		for (size_t _Num = 0; _Num < CHAR_BIT * sizeof (_Udiff);
; 3969 : 			_Num += _Bits)

  0003b	0b d8		 or	 ebx, eax
  0003d	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00041	48 03 f0	 add	 rsi, rax
  00044	48 83 fe 20	 cmp	 rsi, 32			; 00000020H
  00048	72 d6		 jb	 SHORT $LL4@Get_all_bi

; 3973 : 			_Ret |= _Get_bits();
; 3974 : 			}
; 3975 : 
; 3976 : 		return (_Ret);
; 3977 : 		}

  0004a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004f	8b c3		 mov	 eax, ebx
  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z
_TEXT	SEGMENT
this$ = 48
_Index$ = 56
??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::operator(), COMDAT

; 3941 : 		{	// adapt _Urng closed range to [0, _Index)

$LN33:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	44 8b f2	 mov	 r14d, edx
  0001d	8d 6a ff	 lea	 ebp, DWORD PTR [rdx-1]
  00020	48 8b f9	 mov	 rdi, rcx
$LL2@operator:

; 3942 : 		for (;;)
; 3943 : 			{	// try a sample random value
; 3944 : 			_Udiff _Ret = 0;	// random bits

  00023	33 db		 xor	 ebx, ebx

; 3945 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00025	33 f6		 xor	 esi, esi

; 3946 : 
; 3947 : 			while (_Mask < _Udiff(_Index - 1))

  00027	85 ed		 test	 ebp, ebp
  00029	74 3b		 je	 SHORT $LN6@operator

; 3954 : 				_Mask |= _Bmask;

  0002b	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  0002f	90		 npad	 1
$LL5@operator:

; 3948 : 				{	// need more random bits
; 3949 : 				_Ret <<= _Bits - 1;	// avoid full shift

  00030	41 8d 88 ff 00
	00 00		 lea	 ecx, DWORD PTR [r8+255]
  00037	d3 e3		 shl	 ebx, cl

; 3950 : 				_Ret <<= 1;

  00039	03 db		 add	 ebx, ebx
  0003b	0f 1f 44 00 00	 npad	 5
$LL11@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  00046	8b c8		 mov	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3989 : 			if (_Val <= _Bmask)

  00048	8b 47 10	 mov	 eax, DWORD PTR [rdi+16]
  0004b	3b c8		 cmp	 ecx, eax
  0004d	77 f1		 ja	 SHORT $LL11@operator

; 3951 : 				_Ret |= _Get_bits();

  0004f	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  00053	0b d9		 or	 ebx, ecx

; 3952 : 				_Mask <<= _Bits - 1;	// avoid full shift

  00055	41 8d 88 ff 00
	00 00		 lea	 ecx, DWORD PTR [r8+255]
  0005c	d3 e6		 shl	 esi, cl

; 3953 : 				_Mask <<= 1;

  0005e	03 f6		 add	 esi, esi

; 3954 : 				_Mask |= _Bmask;

  00060	0b f0		 or	 esi, eax
  00062	3b f5		 cmp	 esi, ebp
  00064	72 ca		 jb	 SHORT $LL5@operator
$LN6@operator:

; 3955 : 				}
; 3956 : 
; 3957 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3958 : 			if (_Ret / _Index < _Mask / _Index
; 3959 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00066	33 d2		 xor	 edx, edx
  00068	8b c6		 mov	 eax, esi
  0006a	41 f7 f6	 div	 r14d
  0006d	8b c8		 mov	 ecx, eax
  0006f	44 8b c2	 mov	 r8d, edx
  00072	33 d2		 xor	 edx, edx
  00074	8b c3		 mov	 eax, ebx
  00076	41 f7 f6	 div	 r14d
  00079	3b c1		 cmp	 eax, ecx
  0007b	72 05		 jb	 SHORT $LN25@operator
  0007d	44 3b c5	 cmp	 r8d, ebp
  00080	75 a1		 jne	 SHORT $LL2@operator
$LN25@operator:

; 3960 : 				return (_Ret % _Index);
; 3961 : 			}
; 3962 : 		}

  00082	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00087	8b c3		 mov	 eax, ebx
  00089	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008e	33 d2		 xor	 edx, edx
  00090	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00095	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0009a	41 f7 f6	 div	 r14d
  0009d	8b c2		 mov	 eax, edx
  0009f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a3	41 5e		 pop	 r14
  000a5	c3		 ret	 0
??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAA@AEAVrandom_device@1@@Z
_TEXT	SEGMENT
this$ = 8
_Func$ = 16
??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAA@AEAVrandom_device@1@@Z PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>, COMDAT

; 3934 : 		: _Ref(_Func), _Bits(CHAR_BIT * sizeof (_Udiff)), _Bmask(_Udiff(-1))

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 3936 : 		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
; 3937 : 			--_Bits;
; 3938 : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	48 c7 41 08 20
	00 00 00	 mov	 QWORD PTR [rcx+8], 32	; 00000020H
  0000e	c7 41 10 ff ff
	ff ff		 mov	 DWORD PTR [rcx+16], -1	; ffffffffH
  00015	c3		 ret	 0
??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAA@AEAVrandom_device@1@@Z ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAII@Z
_TEXT	SEGMENT
_Uval$ = 8
?_Adjust@?$uniform_int@H@std@@CAII@Z PROC		; std::uniform_int<int>::_Adjust, COMDAT

; 2337 : 		{	// convert signed ranges to unsigned ranges and vice versa

  00000	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  00005	03 c1		 add	 eax, ecx

; 2338 : 		return (_Adjust(_Uval, is_signed<_Ty>()));
; 2339 : 		}

  00007	c3		 ret	 0
?_Adjust@?$uniform_int@H@std@@CAII@Z ENDP		; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 121  : 			return (_Ok);

  00000	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]

; 122  : 			}

  00004	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
_TEXT	SEGMENT
$T3 = 32
this$ = 64
_Istr$ = 72
_Noskip$ = 80
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 115  : 			{	// construct locking and calling _Ipfx

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	41 0f b6 f8	 movzx	 edi, r8b
  0001c	48 8b d9	 mov	 rbx, rcx

; 92   : 			: _Myistr(_Istr)

  0001f	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 94   : 			if (_Myistr.rdbuf() != 0)

  00022	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00025	4c 63 48 04	 movsxd	 r9, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\ios

; 91   : 		return (_Mystrbuf);

  00029	49 8b 4c 11 48	 mov	 rcx, QWORD PTR [r9+rdx+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  0002e	48 85 c9	 test	 rcx, rcx
  00031	74 07		 je	 SHORT $LN5@sentry

; 95   : 				_Myistr.rdbuf()->_Lock();

  00033	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00036	ff 50 08	 call	 QWORD PTR [rax+8]
  00039	90		 npad	 1
$LN5@sentry:

; 116  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0003a	40 0f b6 d7	 movzx	 edx, dil
  0003e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
  00047	88 43 08	 mov	 BYTE PTR [rbx+8], al

; 117  : 			}

  0004a	48 8b c3	 mov	 rax, rbx
  0004d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
this$ = 64
_Istr$ = 72
_Noskip$ = 80
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
this$ = 64
_Istr$ = 72
_Noskip$ = 80
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 99   : 			{	// destroy after unlocking

$LN9:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2

; 100  : 			if (_Myistr.rdbuf() != 0)

  0000d	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00017	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
  0001c	48 85 c9	 test	 rcx, rcx
  0001f	74 07		 je	 SHORT $LN2@Sentry_bas

; 101  : 				_Myistr.rdbuf()->_Unlock();

  00021	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00024	ff 50 10	 call	 QWORD PTR [rax+16]
  00027	90		 npad	 1
$LN2@Sentry_bas:

; 102  : 			}

  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 1604 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 3677 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00005	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1583 : 		if (_Large_string_engaged())

  0000d	72 0a		 jb	 SHORT $LN31@erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstddef

; 265  : 	return (_Ptr);

  0000f	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00012	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2595 : 		return (*this);

  00015	48 8b c1	 mov	 rax, rcx

; 2596 : 		}

  00018	c3		 ret	 0
$LN31@erase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\iosfwd

; 442  : 		_Left = _Right;

  00019	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xstring

; 2595 : 		return (*this);

  0001c	48 8b c1	 mov	 rax, rcx

; 2596 : 		}

  0001f	c3		 ret	 0
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility
;	COMDAT ?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ
_TEXT	SEGMENT
this$ = 48
?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits, COMDAT

; 3984 : 		{	// return a random value within [0, _Bmask]

$LN17:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Get_bits:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random

; 6410 : 		return (_Random_device());

  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\xutility

; 3989 : 			if (_Val <= _Bmask)

  00016	3b 43 10	 cmp	 eax, DWORD PTR [rbx+16]
  00019	77 f5		 ja	 SHORT $LL2@Get_bits

; 3990 : 				return (_Val);
; 3991 : 			}
; 3992 : 		}

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_Uval$ = 8
__formal$dead$ = 16
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z PROC ; std::uniform_int<int>::_Adjust, COMDAT

; 2342 : 		{	// convert signed ranges to unsigned ranges and vice versa

  00000	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  00005	03 c1		 add	 eax, ecx

; 2343 : 		const _Uty _Adjuster = (_Uty(-1) >> 1) + 1;	// 2^(N-1)
; 2344 : 
; 2345 : 		if (_Uval < _Adjuster)
; 2346 : 			return (_Uval + _Adjuster);
; 2347 : 		else
; 2348 : 			return (_Uval - _Adjuster);
; 2349 : 		}

  00007	c3		 ret	 0
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ENDP ; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.12.25827\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Istr$ = 56
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 93   : 			{	// lock the stream buffer, if there

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 92   : 			: _Myistr(_Istr)

  00006	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 93   : 			{	// lock the stream buffer, if there

  00009	48 8b d9	 mov	 rbx, rcx

; 94   : 			if (_Myistr.rdbuf() != 0)

  0000c	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000f	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  00013	49 8b 4c 10 48	 mov	 rcx, QWORD PTR [r8+rdx+72]
  00018	48 85 c9	 test	 rcx, rcx
  0001b	74 06		 je	 SHORT $LN8@Sentry_bas

; 95   : 				_Myistr.rdbuf()->_Lock();

  0001d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00020	ff 50 08	 call	 QWORD PTR [rax+8]
$LN8@Sentry_bas:

; 96   : 			}

  00023	48 8b c3	 mov	 rax, rbx
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
END
